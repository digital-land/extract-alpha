class $S extends HTMLElement {
  static get observedAttributes() {
    return ["color", "label"];
  }
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.render();
  }
  attributeChangedCallback() {
    this.render();
  }
  render() {
    const n = this.getAttribute("color") || "#0078d4", l = this.getAttribute("label") || "Coloured Box";
    this.shadowRoot && (this.shadowRoot.innerHTML = `
        <style>
          .box {
            width: 200px;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: 2px solid #333;
            font-size: 1.2rem;
            color: #fff;
            background: ${n};
          }
        </style>
        <div class="box">${l}</div>
      `);
  }
}
customElements.define("my-box", $S);
class ZS extends HTMLElement {
  #e = 5e3;
  #r = {
    awaiting_start: `
      <p class="govuk-body-l">The service is busier than usual. Your extraction is in the queue.</p>
    `,
    in_progress: `
      <p class="govuk-body-l">Your PDF is being processed. This may take a few minutes.</p>
    `,
    completed: `
      <p class="govuk-body-l">Your PDF has been processed. <span class="govuk-visually-hidden">Click the button below this message or reload the page to continue.</span></p>
      <a href="${window.location.href}" class="govuk-button">View extraction</a>
    `,
    failed: `
      <p class="govuk-body-l">Your PDF has failed to process. Please <a href="/upload">try uploading again</a>.</p>
    `
  };
  connectedCallback() {
    this.#i(), this.#a(), this.querySelector(".loading-spinner__pause-button")?.addEventListener(
      "click",
      this.#t
    );
  }
  disconnectedCallback() {
    this.querySelector(".loading-spinner__pause-button")?.removeEventListener(
      "click",
      this.#t
    );
  }
  #i() {
    this.classList.add("loading-spinner"), this.innerHTML = `
      <div class="loading-spinner__spinner loading-spinner__spinner--active">
        <div class="loading-spinner__spinner-inner"></div>
        <button class="loading-spinner__pause-button">Stop spinner animation</button>
        <span class="loading-spinner__pause-message" tabindex="-1">Animation stopped. This will not affect the extraction process.</span>
      </div>
      <div class="loading-spinner__message" aria-live="assertive"></div>
    `;
  }
  #t = () => this.#n();
  #n(n = !1) {
    const l = this.querySelector(".loading-spinner__spinner");
    l?.classList.remove("loading-spinner__spinner--active"), n ? l?.remove() : this.querySelector(
      ".loading-spinner__pause-message"
    )?.focus();
  }
  /**
   * Check the job status from the backend and update the message.
   */
  async #a() {
    const n = this.querySelector(".loading-spinner__message"), l = this.getAttribute("fetch-url");
    if (!(!this.isConnected || !n || !l))
      try {
        const p = await fetch(l);
        if (!p.ok)
          throw new Error("Error with extraction status response");
        const x = await p.json(), M = x.status, T = this.#r[x.status];
        T && (n.innerHTML = T), M === "completed" || M === "failed" ? this.#n(!0) : window.setTimeout(() => this.#a(), this.#e);
      } catch (p) {
        console.error(`Error fetching extraction status: ${p}`), window.setTimeout(() => this.#a(), this.#e);
      }
  }
}
customElements.define("loading-spinner", ZS);
function HS(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var hg = { exports: {} };
var YS = hg.exports, Fx;
function WS() {
  return Fx || (Fx = 1, (function(a, n) {
    (function(l, p) {
      a.exports = p();
    })(YS, (function() {
      var l = {}, p = {};
      function x(T, u, R) {
        if (p[T] = R, T === "index") {
          var z = "var sharedModule = {}; (" + p.shared + ")(sharedModule); (" + p.worker + ")(sharedModule);", U = {};
          return p.shared(U), p.index(l, U), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([z], { type: "text/javascript" }))), l;
        }
      }
      x("shared", ["exports"], (function(T) {
        function u(i, e, r, c) {
          return new (r || (r = Promise))((function(f, m) {
            function v(P) {
              try {
                k(c.next(P));
              } catch (L) {
                m(L);
              }
            }
            function E(P) {
              try {
                k(c.throw(P));
              } catch (L) {
                m(L);
              }
            }
            function k(P) {
              var L;
              P.done ? f(P.value) : (L = P.value, L instanceof r ? L : new r((function(N) {
                N(L);
              }))).then(v, E);
            }
            k((c = c.apply(i, e || [])).next());
          }));
        }
        function R(i, e) {
          this.x = i, this.y = e;
        }
        function z(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
        }
        var U, $;
        typeof SuppressedError == "function" && SuppressedError, R.prototype = { clone() {
          return new R(this.x, this.y);
        }, add(i) {
          return this.clone()._add(i);
        }, sub(i) {
          return this.clone()._sub(i);
        }, multByPoint(i) {
          return this.clone()._multByPoint(i);
        }, divByPoint(i) {
          return this.clone()._divByPoint(i);
        }, mult(i) {
          return this.clone()._mult(i);
        }, div(i) {
          return this.clone()._div(i);
        }, rotate(i) {
          return this.clone()._rotate(i);
        }, rotateAround(i, e) {
          return this.clone()._rotateAround(i, e);
        }, matMult(i) {
          return this.clone()._matMult(i);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(i) {
          return this.x === i.x && this.y === i.y;
        }, dist(i) {
          return Math.sqrt(this.distSqr(i));
        }, distSqr(i) {
          const e = i.x - this.x, r = i.y - this.y;
          return e * e + r * r;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(i) {
          return Math.atan2(this.y - i.y, this.x - i.x);
        }, angleWith(i) {
          return this.angleWithSep(i.x, i.y);
        }, angleWithSep(i, e) {
          return Math.atan2(this.x * e - this.y * i, this.x * i + this.y * e);
        }, _matMult(i) {
          const e = i[2] * this.x + i[3] * this.y;
          return this.x = i[0] * this.x + i[1] * this.y, this.y = e, this;
        }, _add(i) {
          return this.x += i.x, this.y += i.y, this;
        }, _sub(i) {
          return this.x -= i.x, this.y -= i.y, this;
        }, _mult(i) {
          return this.x *= i, this.y *= i, this;
        }, _div(i) {
          return this.x /= i, this.y /= i, this;
        }, _multByPoint(i) {
          return this.x *= i.x, this.y *= i.y, this;
        }, _divByPoint(i) {
          return this.x /= i.x, this.y /= i.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const i = this.y;
          return this.y = this.x, this.x = -i, this;
        }, _rotate(i) {
          const e = Math.cos(i), r = Math.sin(i), c = r * this.x + e * this.y;
          return this.x = e * this.x - r * this.y, this.y = c, this;
        }, _rotateAround(i, e) {
          const r = Math.cos(i), c = Math.sin(i), f = e.y + c * (this.x - e.x) + r * (this.y - e.y);
          return this.x = e.x + r * (this.x - e.x) - c * (this.y - e.y), this.y = f, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: R }, R.convert = function(i) {
          if (i instanceof R) return i;
          if (Array.isArray(i)) return new R(+i[0], +i[1]);
          if (i.x !== void 0 && i.y !== void 0) return new R(+i.x, +i.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var ee = (function() {
          if ($) return U;
          function i(e, r, c, f) {
            this.cx = 3 * e, this.bx = 3 * (c - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (f - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r, this.p2x = c, this.p2y = f;
          }
          return $ = 1, U = i, i.prototype = { sampleCurveX: function(e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          }, sampleCurveY: function(e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          }, sampleCurveDerivativeX: function(e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          }, solveCurveX: function(e, r) {
            if (r === void 0 && (r = 1e-6), e < 0) return 0;
            if (e > 1) return 1;
            for (var c = e, f = 0; f < 8; f++) {
              var m = this.sampleCurveX(c) - e;
              if (Math.abs(m) < r) return c;
              var v = this.sampleCurveDerivativeX(c);
              if (Math.abs(v) < 1e-6) break;
              c -= m / v;
            }
            var E = 0, k = 1;
            for (c = e, f = 0; f < 20 && (m = this.sampleCurveX(c), !(Math.abs(m - e) < r)); f++) e > m ? E = c : k = c, c = 0.5 * (k - E) + E;
            return c;
          }, solve: function(e, r) {
            return this.sampleCurveY(this.solveCurveX(e, r));
          } }, U;
        })(), oe = z(ee);
        let ce, me;
        function re() {
          return ce == null && (ce = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ce;
        }
        function Pe() {
          if (me == null && (me = !1, re())) {
            const e = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (e) {
              for (let c = 0; c < 25; c++) {
                const f = 4 * c;
                e.fillStyle = `rgb(${f},${f + 1},${f + 2})`, e.fillRect(c % 5, Math.floor(c / 5), 1, 1);
              }
              const r = e.getImageData(0, 0, 5, 5).data;
              for (let c = 0; c < 100; c++) if (c % 4 != 3 && r[c] !== c) {
                me = !0;
                break;
              }
            }
          }
          return me || !1;
        }
        var _e = 1e-6, je = typeof Float32Array < "u" ? Float32Array : Array;
        function Qe() {
          var i = new je(9);
          return je != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i;
        }
        function et(i) {
          return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
        }
        function Ye() {
          var i = new je(3);
          return je != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i;
        }
        function ot(i) {
          var e = i[0], r = i[1], c = i[2];
          return Math.sqrt(e * e + r * r + c * c);
        }
        function Q(i, e, r) {
          var c = new je(3);
          return c[0] = i, c[1] = e, c[2] = r, c;
        }
        function ie(i, e, r) {
          return i[0] = e[0] + r[0], i[1] = e[1] + r[1], i[2] = e[2] + r[2], i;
        }
        function ge(i, e, r) {
          return i[0] = e[0] * r, i[1] = e[1] * r, i[2] = e[2] * r, i;
        }
        function Se(i, e, r) {
          var c = e[0], f = e[1], m = e[2], v = r[0], E = r[1], k = r[2];
          return i[0] = f * k - m * E, i[1] = m * v - c * k, i[2] = c * E - f * v, i;
        }
        var Ie, Oe = ot;
        function Re(i, e, r) {
          var c = e[0], f = e[1], m = e[2], v = e[3];
          return i[0] = r[0] * c + r[4] * f + r[8] * m + r[12] * v, i[1] = r[1] * c + r[5] * f + r[9] * m + r[13] * v, i[2] = r[2] * c + r[6] * f + r[10] * m + r[14] * v, i[3] = r[3] * c + r[7] * f + r[11] * m + r[15] * v, i;
        }
        function De() {
          var i = new je(4);
          return je != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i;
        }
        function Fe(i, e, r, c) {
          var f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", m = Math.PI / 360;
          e *= m, c *= m, r *= m;
          var v = Math.sin(e), E = Math.cos(e), k = Math.sin(r), P = Math.cos(r), L = Math.sin(c), N = Math.cos(c);
          switch (f) {
            case "xyz":
              i[0] = v * P * N + E * k * L, i[1] = E * k * N - v * P * L, i[2] = E * P * L + v * k * N, i[3] = E * P * N - v * k * L;
              break;
            case "xzy":
              i[0] = v * P * N - E * k * L, i[1] = E * k * N - v * P * L, i[2] = E * P * L + v * k * N, i[3] = E * P * N + v * k * L;
              break;
            case "yxz":
              i[0] = v * P * N + E * k * L, i[1] = E * k * N - v * P * L, i[2] = E * P * L - v * k * N, i[3] = E * P * N + v * k * L;
              break;
            case "yzx":
              i[0] = v * P * N + E * k * L, i[1] = E * k * N + v * P * L, i[2] = E * P * L - v * k * N, i[3] = E * P * N - v * k * L;
              break;
            case "zxy":
              i[0] = v * P * N - E * k * L, i[1] = E * k * N + v * P * L, i[2] = E * P * L + v * k * N, i[3] = E * P * N - v * k * L;
              break;
            case "zyx":
              i[0] = v * P * N - E * k * L, i[1] = E * k * N + v * P * L, i[2] = E * P * L - v * k * N, i[3] = E * P * N + v * k * L;
              break;
            default:
              throw new Error("Unknown angle order " + f);
          }
          return i;
        }
        function Ue() {
          var i = new je(2);
          return je != Float32Array && (i[0] = 0, i[1] = 0), i;
        }
        function Ve(i, e) {
          var r = new je(2);
          return r[0] = i, r[1] = e, r;
        }
        Ye(), Ie = new je(4), je != Float32Array && (Ie[0] = 0, Ie[1] = 0, Ie[2] = 0, Ie[3] = 0), Ye(), Q(1, 0, 0), Q(0, 1, 0), De(), De(), Qe(), Ue();
        const We = 8192;
        function dt(i, e, r) {
          return e * (We / (i.tileSize * Math.pow(2, r - i.tileID.overscaledZ)));
        }
        function Tt(i, e) {
          return (i % e + e) % e;
        }
        function Ht(i, e, r) {
          return i * (1 - r) + e * r;
        }
        function Ot(i) {
          if (i <= 0) return 0;
          if (i >= 1) return 1;
          const e = i * i, r = e * i;
          return 4 * (i < 0.5 ? r : 3 * (i - e) + r - 0.75);
        }
        function Pt(i, e, r, c) {
          const f = new oe(i, e, r, c);
          return (m) => f.solve(m);
        }
        const Mt = Pt(0.25, 0.1, 0.25, 1);
        function Kt(i, e, r) {
          return Math.min(r, Math.max(e, i));
        }
        function gr(i, e, r) {
          const c = r - e, f = ((i - e) % c + c) % c + e;
          return f === e ? r : f;
        }
        function Ze(i, ...e) {
          for (const r of e) for (const c in r) i[c] = r[c];
          return i;
        }
        let ri = 1;
        function lr(i, e, r) {
          const c = {};
          for (const f in i) c[f] = e.call(this, i[f], f, i);
          return c;
        }
        function Ut(i, e, r) {
          const c = {};
          for (const f in i) e.call(this, i[f], f, i) && (c[f] = i[f]);
          return c;
        }
        function Me(i) {
          return Array.isArray(i) ? i.map(Me) : typeof i == "object" && i ? lr(i, Me) : i;
        }
        const br = {};
        function ur(i) {
          br[i] || (typeof console < "u" && console.warn(i), br[i] = !0);
        }
        function tr(i, e, r) {
          return (r.y - i.y) * (e.x - i.x) > (e.y - i.y) * (r.x - i.x);
        }
        function mi(i) {
          return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
        }
        let Nr = null;
        function _i(i) {
          return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
        }
        const St = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function $i(i, e, r, c, f) {
          return u(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const m = new VideoFrame(i, { timestamp: 0 });
            try {
              const v = m?.format;
              if (!v || !v.startsWith("BGR") && !v.startsWith("RGB")) throw new Error(`Unrecognized format ${v}`);
              const E = v.startsWith("BGR"), k = new Uint8ClampedArray(c * f * 4);
              if (yield m.copyTo(k, (function(P, L, N, G, j) {
                const Z = 4 * Math.max(-L, 0), Y = (Math.max(0, N) - N) * G * 4 + Z, X = 4 * G, ne = Math.max(0, L), xe = Math.max(0, N);
                return { rect: { x: ne, y: xe, width: Math.min(P.width, L + G) - ne, height: Math.min(P.height, N + j) - xe }, layout: [{ offset: Y, stride: X }] };
              })(i, e, r, c, f)), E) for (let P = 0; P < k.length; P += 4) {
                const L = k[P];
                k[P] = k[P + 2], k[P + 2] = L;
              }
              return k;
            } finally {
              m.close();
            }
          }));
        }
        let Zi, In;
        function Ks(i, e, r, c) {
          return i.addEventListener(e, r, c), { unsubscribe: () => {
            i.removeEventListener(e, r, c);
          } };
        }
        function er(i) {
          return i * Math.PI / 180;
        }
        function Kr(i) {
          return i / Math.PI * 180;
        }
        const He = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, K = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, J = "AbortError";
        class le extends Error {
          constructor(e = J) {
            super(e instanceof Error ? e.message : e), this.name = J, e instanceof Error && e.stack && (this.stack = e.stack);
          }
        }
        function be(i) {
          return i.name === J;
        }
        const ye = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function Je(i) {
          return ye.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
        }
        const qe = "global-dispatcher";
        class Be extends Error {
          constructor(e, r, c, f) {
            super(`AJAXError: ${r} (${e}): ${c}`), this.status = e, this.statusText = r, this.url = c, this.body = f;
          }
        }
        const ze = () => mi(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, ft = function(i, e) {
          if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
            const c = Je(i.url);
            if (c) return c(i, e);
            if (mi(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: qe }, e);
          }
          if (!(/^file:/.test(r = i.url) || /^file:/.test(ze()) && !/^\w+:/.test(r))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(c, f) {
              return u(this, void 0, void 0, (function* () {
                const m = new Request(c.url, { method: c.method || "GET", body: c.body, credentials: c.credentials, headers: c.headers, cache: c.cache, referrer: ze(), signal: f.signal });
                let v, E;
                c.type !== "json" || m.headers.has("Accept") || m.headers.set("Accept", "application/json");
                try {
                  v = yield fetch(m);
                } catch (P) {
                  throw be(P) ? P : new Be(0, P.message, c.url, new Blob());
                }
                if (!v.ok) {
                  const P = yield v.blob();
                  throw new Be(v.status, v.statusText, c.url, P);
                }
                E = c.type === "arrayBuffer" || c.type === "image" ? v.arrayBuffer() : c.type === "json" ? v.json() : v.text();
                const k = yield E;
                return f.signal.throwIfAborted(), { data: k, cacheControl: v.headers.get("Cache-Control"), expires: v.headers.get("Expires") };
              }));
            })(i, e);
            if (mi(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: qe }, e);
          }
          var r;
          return (function(c, f) {
            return new Promise(((m, v) => {
              var E;
              const k = new XMLHttpRequest();
              k.open(c.method || "GET", c.url, !0), c.type !== "arrayBuffer" && c.type !== "image" || (k.responseType = "arraybuffer");
              for (const P in c.headers) k.setRequestHeader(P, c.headers[P]);
              c.type === "json" && (k.responseType = "text", !((E = c.headers) === null || E === void 0) && E.Accept || k.setRequestHeader("Accept", "application/json")), k.withCredentials = c.credentials === "include", k.onerror = () => {
                v(new Error(k.statusText));
              }, k.onload = () => {
                if (!f.signal.aborted) if ((k.status >= 200 && k.status < 300 || k.status === 0) && k.response !== null) {
                  let P = k.response;
                  if (c.type === "json") try {
                    P = JSON.parse(k.response);
                  } catch (L) {
                    return void v(L);
                  }
                  m({ data: P, cacheControl: k.getResponseHeader("Cache-Control"), expires: k.getResponseHeader("Expires") });
                } else {
                  const P = new Blob([k.response], { type: k.getResponseHeader("Content-Type") });
                  v(new Be(k.status, k.statusText, c.url, P));
                }
              }, f.signal.addEventListener("abort", (() => {
                k.abort(), v(new le(f.signal.reason));
              })), k.send(c.body);
            }));
          })(i, e);
        };
        function ct(i) {
          if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
          const e = new URL(i), r = window.location;
          return e.protocol === r.protocol && e.host === r.host;
        }
        function Lt(i, e, r) {
          r[i] && r[i].indexOf(e) !== -1 || (r[i] = r[i] || [], r[i].push(e));
        }
        function Nt(i, e, r) {
          if (r && r[i]) {
            const c = r[i].indexOf(e);
            c !== -1 && r[i].splice(c, 1);
          }
        }
        class Wt {
          constructor(e, r = {}) {
            Ze(this, r), this.type = e;
          }
        }
        class cr extends Wt {
          constructor(e, r = {}) {
            super("error", Ze({ error: e }, r));
          }
        }
        class wr {
          on(e, r) {
            return this._listeners = this._listeners || {}, Lt(e, r, this._listeners), { unsubscribe: () => {
              this.off(e, r);
            } };
          }
          off(e, r) {
            return Nt(e, r, this._listeners), Nt(e, r, this._oneTimeListeners), this;
          }
          once(e, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, Lt(e, r, this._oneTimeListeners), this) : new Promise(((c) => this.once(e, c)));
          }
          fire(e, r) {
            typeof e == "string" && (e = new Wt(e, r || {}));
            const c = e.type;
            if (this.listens(c)) {
              e.target = this;
              const f = this._listeners && this._listeners[c] ? this._listeners[c].slice() : [];
              for (const E of f) E.call(this, e);
              const m = this._oneTimeListeners && this._oneTimeListeners[c] ? this._oneTimeListeners[c].slice() : [];
              for (const E of m) Nt(c, E, this._oneTimeListeners), E.call(this, e);
              const v = this._eventedParent;
              v && (Ze(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), v.fire(e));
            } else e instanceof cr && console.error(e.error);
            return this;
          }
          listens(e) {
            return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
          }
          setEventedParent(e, r) {
            return this._eventedParent = e, this._eventedParentData = r, this;
          }
        }
        var Xe = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number", length: 2 }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "fontFaces" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "filter" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, filter: { type: "boolean", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "expression_name", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } }, interpolation: { type: "array", value: "interpolation_name", minimum: 1 }, interpolation_name: { type: "enum", values: { linear: { syntax: { overloads: [{ parameters: [], "output-type": "interpolation" }], parameters: [] } }, exponential: { syntax: { overloads: [{ parameters: ["base"], "output-type": "interpolation" }], parameters: [{ name: "base", type: "number literal" }] } }, "cubic-bezier": { syntax: { overloads: [{ parameters: ["x1", "y1", "x2", "y2"], "output-type": "interpolation" }], parameters: [{ name: "x1", type: "number literal" }, { name: "y1", type: "number literal" }, { name: "x2", type: "number literal" }, { name: "y2", type: "number literal" }] } } } } };
        const Rr = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function Mn(i, e) {
          const r = {};
          for (const c in i) c !== "ref" && (r[c] = i[c]);
          return Rr.forEach(((c) => {
            c in e && (r[c] = e[c]);
          })), r;
        }
        function qt(i, e) {
          if (Array.isArray(i)) {
            if (!Array.isArray(e) || i.length !== e.length) return !1;
            for (let r = 0; r < i.length; r++) if (!qt(i[r], e[r])) return !1;
            return !0;
          }
          if (typeof i == "object" && i !== null && e !== null) {
            if (typeof e != "object" || Object.keys(i).length !== Object.keys(e).length) return !1;
            for (const r in i) if (!qt(i[r], e[r])) return !1;
            return !0;
          }
          return i === e;
        }
        function mt(i, e) {
          i.push(e);
        }
        function fn(i, e, r) {
          mt(r, { command: "addSource", args: [i, e[i]] });
        }
        function Ir(i, e, r) {
          mt(e, { command: "removeSource", args: [i] }), r[i] = !0;
        }
        function Pr(i, e, r, c) {
          Ir(i, r, c), fn(i, e, r);
        }
        function Mr(i, e, r) {
          let c;
          for (c in i[r]) if (Object.prototype.hasOwnProperty.call(i[r], c) && c !== "data" && !qt(i[r][c], e[r][c])) return !1;
          for (c in e[r]) if (Object.prototype.hasOwnProperty.call(e[r], c) && c !== "data" && !qt(i[r][c], e[r][c])) return !1;
          return !0;
        }
        function Yr(i, e, r, c, f, m) {
          i = i || {}, e = e || {};
          for (const v in i) Object.prototype.hasOwnProperty.call(i, v) && (qt(i[v], e[v]) || r.push({ command: m, args: [c, v, e[v], f] }));
          for (const v in e) Object.prototype.hasOwnProperty.call(e, v) && !Object.prototype.hasOwnProperty.call(i, v) && (qt(i[v], e[v]) || r.push({ command: m, args: [c, v, e[v], f] }));
        }
        function Qs(i) {
          return i.id;
        }
        function Rn(i, e) {
          return i[e.id] = e, i;
        }
        class yt {
          constructor(e, r, c, f) {
            this.message = (e ? `${e}: ` : "") + c, f && (this.identifier = f), r != null && r.__line__ && (this.line = r.__line__);
          }
        }
        function bn(i, ...e) {
          for (const r of e) for (const c in r) i[c] = r[c];
          return i;
        }
        class Un extends Error {
          constructor(e, r) {
            super(r), this.message = r, this.key = e;
          }
        }
        class Ps {
          constructor(e, r = []) {
            this.parent = e, this.bindings = {};
            for (const [c, f] of r) this.bindings[c] = f;
          }
          concat(e) {
            return new Ps(this, e);
          }
          get(e) {
            if (this.bindings[e]) return this.bindings[e];
            if (this.parent) return this.parent.get(e);
            throw new Error(`${e} not found in scope.`);
          }
          has(e) {
            return !!this.bindings[e] || !!this.parent && this.parent.has(e);
          }
        }
        const yi = { kind: "null" }, xt = { kind: "number" }, ir = { kind: "string" }, rr = { kind: "boolean" }, pn = { kind: "color" }, zi = { kind: "projectionDefinition" }, Bi = { kind: "object" }, Ee = { kind: "value" }, zt = { kind: "collator" }, bt = { kind: "formatted" }, Tr = { kind: "padding" }, Qr = { kind: "colorArray" }, Cr = { kind: "numberArray" }, Cn = { kind: "resolvedImage" }, Fn = { kind: "variableAnchorOffsetCollection" };
        function Or(i, e) {
          return { kind: "array", itemType: i, N: e };
        }
        function Er(i) {
          if (i.kind === "array") {
            const e = Er(i.itemType);
            return typeof i.N == "number" ? `array<${e}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${e}>`;
          }
          return i.kind;
        }
        const gn = [yi, xt, ir, rr, pn, zi, bt, Bi, Or(Ee), Tr, Cr, Qr, Cn, Fn];
        function Nn(i, e) {
          if (e.kind === "error") return null;
          if (i.kind === "array") {
            if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !Nn(i.itemType, e.itemType)) && (typeof i.N != "number" || i.N === e.N)) return null;
          } else {
            if (i.kind === e.kind) return null;
            if (i.kind === "value") {
              for (const r of gn) if (!Nn(r, e)) return null;
            }
          }
          return `Expected ${Er(i)} but found ${Er(e)} instead.`;
        }
        function Hi(i, e) {
          return e.some(((r) => r.kind === i.kind));
        }
        function As(i, e) {
          return e.some(((r) => r === "null" ? i === null : r === "array" ? Array.isArray(i) : r === "object" ? i && !Array.isArray(i) && typeof i == "object" : r === typeof i));
        }
        function ni(i, e) {
          return i.kind === "array" && e.kind === "array" ? i.itemType.kind === e.itemType.kind && typeof i.N == "number" : i.kind === e.kind;
        }
        const yl = 0.96422, ba = 0.82521, vl = 4 / 29, on = 6 / 29, su = 3 * on * on, au = on * on * on, ea = Math.PI / 180, vs = 180 / Math.PI;
        function Ls(i) {
          return (i %= 360) < 0 && (i += 360), i;
        }
        function ou([i, e, r, c]) {
          let f, m;
          const v = lu((0.2225045 * (i = Ds(i)) + 0.7168786 * (e = Ds(e)) + 0.0606169 * (r = Ds(r))) / 1);
          i === e && e === r ? f = m = v : (f = lu((0.4360747 * i + 0.3850649 * e + 0.1430804 * r) / yl), m = lu((0.0139322 * i + 0.0971045 * e + 0.7141733 * r) / ba));
          const E = 116 * v - 16;
          return [E < 0 ? 0 : E, 500 * (f - v), 200 * (v - m), c];
        }
        function Ds(i) {
          return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
        }
        function lu(i) {
          return i > au ? Math.pow(i, 1 / 3) : i / su + vl;
        }
        function uu([i, e, r, c]) {
          let f = (i + 16) / 116, m = isNaN(e) ? f : f + e / 500, v = isNaN(r) ? f : f - r / 200;
          return f = 1 * hu(f), m = yl * hu(m), v = ba * hu(v), [cu(3.1338561 * m - 1.6168667 * f - 0.4906146 * v), cu(-0.9787684 * m + 1.9161415 * f + 0.033454 * v), cu(0.0719453 * m - 0.2289914 * f + 1.4052427 * v), c];
        }
        function cu(i) {
          return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
        }
        function hu(i) {
          return i > on ? i * i * i : su * (i - vl);
        }
        const wc = Object.hasOwn || function(i, e) {
          return Object.prototype.hasOwnProperty.call(i, e);
        };
        function Rs(i, e) {
          return wc(i, e) ? i[e] : void 0;
        }
        function Ao(i) {
          return parseInt(i.padEnd(2, i), 16) / 255;
        }
        function Ec(i, e) {
          return wa(e ? i / 100 : i, 0, 1);
        }
        function wa(i, e, r) {
          return Math.min(Math.max(e, i), r);
        }
        function du(i) {
          return !i.some(Number.isNaN);
        }
        const Ea = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Ar(i, e, r) {
          return i + r * (e - i);
        }
        function Yi(i, e, r) {
          return i.map(((c, f) => Ar(c, e[f], r)));
        }
        class hr {
          constructor(e, r, c, f = 1, m = !0) {
            this.r = e, this.g = r, this.b = c, this.a = f, m || (this.r *= f, this.g *= f, this.b *= f, f || this.overwriteGetter("rgb", [e, r, c, f]));
          }
          static parse(e) {
            if (e instanceof hr) return e;
            if (typeof e != "string") return;
            const r = (function(c) {
              if ((c = c.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const f = Rs(Ea, c);
              if (f) {
                const [v, E, k] = f;
                return [v / 255, E / 255, k / 255, 1];
              }
              if (c.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(c)) {
                const v = c.length < 6 ? 1 : 2;
                let E = 1;
                return [Ao(c.slice(E, E += v)), Ao(c.slice(E, E += v)), Ao(c.slice(E, E += v)), Ao(c.slice(E, E + v) || "ff")];
              }
              if (c.startsWith("rgb")) {
                const v = c.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (v) {
                  const [E, k, P, L, N, G, j, Z, Y, X, ne, xe] = v, ae = [L || " ", j || " ", X].join("");
                  if (ae === "  " || ae === "  /" || ae === ",," || ae === ",,,") {
                    const ue = [P, G, Y].join(""), Te = ue === "%%%" ? 100 : ue === "" ? 255 : 0;
                    if (Te) {
                      const Ae = [wa(+k / Te, 0, 1), wa(+N / Te, 0, 1), wa(+Z / Te, 0, 1), ne ? Ec(+ne, xe) : 1];
                      if (du(Ae)) return Ae;
                    }
                  }
                  return;
                }
              }
              const m = c.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (m) {
                const [v, E, k, P, L, N, G, j, Z] = m, Y = [k || " ", L || " ", G].join("");
                if (Y === "  " || Y === "  /" || Y === ",," || Y === ",,,") {
                  const X = [+E, wa(+P, 0, 100), wa(+N, 0, 100), j ? Ec(+j, Z) : 1];
                  if (du(X)) return (function([ne, xe, ae, ue]) {
                    function Te(Ae) {
                      const Ke = (Ae + ne / 30) % 12, ht = xe * Math.min(ae, 1 - ae);
                      return ae - ht * Math.max(-1, Math.min(Ke - 3, 9 - Ke, 1));
                    }
                    return ne = Ls(ne), xe /= 100, ae /= 100, [Te(0), Te(8), Te(4), ue];
                  })(X);
                }
              }
            })(e);
            return r ? new hr(...r, !1) : void 0;
          }
          get rgb() {
            const { r: e, g: r, b: c, a: f } = this, m = f || 1 / 0;
            return this.overwriteGetter("rgb", [e / m, r / m, c / m, f]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(e) {
              const [r, c, f, m] = ou(e), v = Math.sqrt(c * c + f * f);
              return [Math.round(1e4 * v) ? Ls(Math.atan2(f, c) * vs) : NaN, v, r, m];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", ou(this.rgb));
          }
          overwriteGetter(e, r) {
            return Object.defineProperty(this, e, { value: r }), r;
          }
          toString() {
            const [e, r, c, f] = this.rgb;
            return `rgba(${[e, r, c].map(((m) => Math.round(255 * m))).join(",")},${f})`;
          }
          static interpolate(e, r, c, f = "rgb") {
            switch (f) {
              case "rgb": {
                const [m, v, E, k] = Yi(e.rgb, r.rgb, c);
                return new hr(m, v, E, k, !1);
              }
              case "hcl": {
                const [m, v, E, k] = e.hcl, [P, L, N, G] = r.hcl;
                let j, Z;
                if (isNaN(m) || isNaN(P)) isNaN(m) ? isNaN(P) ? j = NaN : (j = P, E !== 1 && E !== 0 || (Z = L)) : (j = m, N !== 1 && N !== 0 || (Z = v));
                else {
                  let ae = P - m;
                  P > m && ae > 180 ? ae -= 360 : P < m && m - P > 180 && (ae += 360), j = m + c * ae;
                }
                const [Y, X, ne, xe] = (function([ae, ue, Te, Ae]) {
                  return ae = isNaN(ae) ? 0 : ae * ea, uu([Te, Math.cos(ae) * ue, Math.sin(ae) * ue, Ae]);
                })([j, Z ?? Ar(v, L, c), Ar(E, N, c), Ar(k, G, c)]);
                return new hr(Y, X, ne, xe, !1);
              }
              case "lab": {
                const [m, v, E, k] = uu(Yi(e.lab, r.lab, c));
                return new hr(m, v, E, k, !1);
              }
            }
          }
        }
        hr.black = new hr(0, 0, 0, 1), hr.white = new hr(1, 1, 1, 1), hr.transparent = new hr(0, 0, 0, 0), hr.red = new hr(1, 0, 0, 1);
        class Lo {
          constructor(e, r, c) {
            this.sensitivity = e ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = c, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(e, r) {
            return this.collator.compare(e, r);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Wi = ["bottom", "center", "top"];
        class Si {
          constructor(e, r, c, f, m, v) {
            this.text = e, this.image = r, this.scale = c, this.fontStack = f, this.textColor = m, this.verticalAlign = v;
          }
        }
        class Wn {
          constructor(e) {
            this.sections = e;
          }
          static fromString(e) {
            return new Wn([new Si(e, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0));
          }
          static factory(e) {
            return e instanceof Wn ? e : Wn.fromString(e);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((e) => e.text)).join("");
          }
        }
        class ii {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof ii) return e;
            if (typeof e == "number") return new ii([e, e, e, e]);
            if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
              for (const r of e) if (typeof r != "number") return;
              switch (e.length) {
                case 1:
                  e = [e[0], e[0], e[0], e[0]];
                  break;
                case 2:
                  e = [e[0], e[1], e[0], e[1]];
                  break;
                case 3:
                  e = [e[0], e[1], e[2], e[1]];
              }
              return new ii(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, r, c) {
            return new ii(Yi(e.values, r.values, c));
          }
        }
        class en {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof en) return e;
            if (typeof e == "number") return new en([e]);
            if (Array.isArray(e)) {
              for (const r of e) if (typeof r != "number") return;
              return new en(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, r, c) {
            return new en(Yi(e.values, r.values, c));
          }
        }
        class Qt {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof Qt) return e;
            if (typeof e == "string") {
              const c = hr.parse(e);
              return c ? new Qt([c]) : void 0;
            }
            if (!Array.isArray(e)) return;
            const r = [];
            for (const c of e) {
              if (typeof c != "string") return;
              const f = hr.parse(c);
              if (!f) return;
              r.push(f);
            }
            return new Qt(r);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, r, c, f = "rgb") {
            const m = [];
            if (e.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${r.values.length}), cannot interpolate.`);
            for (let v = 0; v < e.values.length; v++) m.push(hr.interpolate(e.values[v], r.values[v], c, f));
            return new Qt(m);
          }
        }
        class Lr extends Error {
          constructor(e) {
            super(e), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const ta = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class si {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof si) return e;
            if (Array.isArray(e) && !(e.length < 1) && e.length % 2 == 0) {
              for (let r = 0; r < e.length; r += 2) {
                const c = e[r], f = e[r + 1];
                if (typeof c != "string" || !ta.has(c) || !Array.isArray(f) || f.length !== 2 || typeof f[0] != "number" || typeof f[1] != "number") return;
              }
              return new si(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, r, c) {
            const f = e.values, m = r.values;
            if (f.length !== m.length) throw new Lr(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${r.toString()}`);
            const v = [];
            for (let E = 0; E < f.length; E += 2) {
              if (f[E] !== m[E]) throw new Lr(`Cannot interpolate values containing mismatched anchors. from[${E}]: ${f[E]}, to[${E}]: ${m[E]}`);
              v.push(f[E]);
              const [k, P] = f[E + 1], [L, N] = m[E + 1];
              v.push([Ar(k, L, c), Ar(P, N, c)]);
            }
            return new si(v);
          }
        }
        class dr {
          constructor(e) {
            this.name = e.name, this.available = e.available;
          }
          toString() {
            return this.name;
          }
          static fromString(e) {
            return e ? new dr({ name: e, available: !1 }) : null;
          }
        }
        class tn {
          constructor(e, r, c) {
            this.from = e, this.to = r, this.transition = c;
          }
          static interpolate(e, r, c) {
            return new tn(e, r, c);
          }
          static parse(e) {
            return e instanceof tn ? e : Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number" ? new tn(e[0], e[1], e[2]) : typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number" ? new tn(e.from, e.to, e.transition) : typeof e == "string" ? new tn(e, e, 1) : void 0;
          }
        }
        function ra(i, e, r, c) {
          return typeof i == "number" && i >= 0 && i <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? c === void 0 || typeof c == "number" && c >= 0 && c <= 1 ? null : `Invalid rgba value [${[i, e, r, c].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof c == "number" ? [i, e, r, c] : [i, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Fs(i) {
          if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof tn || i instanceof hr || i instanceof Lo || i instanceof Wn || i instanceof ii || i instanceof en || i instanceof Qt || i instanceof si || i instanceof dr) return !0;
          if (Array.isArray(i)) {
            for (const e of i) if (!Fs(e)) return !1;
            return !0;
          }
          if (typeof i == "object") {
            for (const e in i) if (!Fs(i[e])) return !1;
            return !0;
          }
          return !1;
        }
        function Ur(i) {
          if (i === null) return yi;
          if (typeof i == "string") return ir;
          if (typeof i == "boolean") return rr;
          if (typeof i == "number") return xt;
          if (i instanceof hr) return pn;
          if (i instanceof tn) return zi;
          if (i instanceof Lo) return zt;
          if (i instanceof Wn) return bt;
          if (i instanceof ii) return Tr;
          if (i instanceof en) return Cr;
          if (i instanceof Qt) return Qr;
          if (i instanceof si) return Fn;
          if (i instanceof dr) return Cn;
          if (Array.isArray(i)) {
            const e = i.length;
            let r;
            for (const c of i) {
              const f = Ur(c);
              if (r) {
                if (r === f) continue;
                r = Ee;
                break;
              }
              r = f;
            }
            return Or(r || Ee, e);
          }
          return Bi;
        }
        function na(i) {
          const e = typeof i;
          return i === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(i) : i instanceof hr || i instanceof tn || i instanceof Wn || i instanceof ii || i instanceof en || i instanceof Qt || i instanceof si || i instanceof dr ? i.toString() : JSON.stringify(i);
        }
        class rn {
          constructor(e, r) {
            this.type = e, this.value = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (!Fs(e[1])) return r.error("invalid value");
            const c = e[1];
            let f = Ur(c);
            const m = r.expectedType;
            return f.kind !== "array" || f.N !== 0 || !m || m.kind !== "array" || typeof m.N == "number" && m.N !== 0 || (f = m), new rn(f, c);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const Do = { string: ir, number: xt, boolean: rr, object: Bi };
        class ai {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            let c, f = 1;
            const m = e[0];
            if (m === "array") {
              let E, k;
              if (e.length > 2) {
                const P = e[1];
                if (typeof P != "string" || !(P in Do) || P === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                E = Do[P], f++;
              } else E = Ee;
              if (e.length > 3) {
                if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                k = e[2], f++;
              }
              c = Or(E, k);
            } else {
              if (!Do[m]) throw new Error(`Types doesn't contain name = ${m}`);
              c = Do[m];
            }
            const v = [];
            for (; f < e.length; f++) {
              const E = r.parse(e[f], f, Ee);
              if (!E) return null;
              v.push(E);
            }
            return new ai(c, v);
          }
          evaluate(e) {
            for (let r = 0; r < this.args.length; r++) {
              const c = this.args[r].evaluate(e);
              if (!Nn(this.type, Ur(c))) return c;
              if (r === this.args.length - 1) throw new Lr(`Expected value to be of type ${Er(this.type)}, but found ${Er(Ur(c))} instead.`);
            }
            throw new Error();
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        const ia = { "to-boolean": rr, "to-color": pn, "to-number": xt, "to-string": ir };
        class xs {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            const c = e[0];
            if (!ia[c]) throw new Error(`Can't parse ${c} as it is not part of the known types`);
            if ((c === "to-boolean" || c === "to-string") && e.length !== 2) return r.error("Expected one argument.");
            const f = ia[c], m = [];
            for (let v = 1; v < e.length; v++) {
              const E = r.parse(e[v], v, Ee);
              if (!E) return null;
              m.push(E);
            }
            return new xs(f, m);
          }
          evaluate(e) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(e);
              case "color": {
                let r, c;
                for (const f of this.args) {
                  if (r = f.evaluate(e), c = null, r instanceof hr) return r;
                  if (typeof r == "string") {
                    const m = e.parseColor(r);
                    if (m) return m;
                  } else if (Array.isArray(r) && (c = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : ra(r[0], r[1], r[2], r[3]), !c)) return new hr(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
                }
                throw new Lr(c || `Could not parse color from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "padding": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(e);
                  const f = ii.parse(r);
                  if (f) return f;
                }
                throw new Lr(`Could not parse padding from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "numberArray": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(e);
                  const f = en.parse(r);
                  if (f) return f;
                }
                throw new Lr(`Could not parse numberArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "colorArray": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(e);
                  const f = Qt.parse(r);
                  if (f) return f;
                }
                throw new Lr(`Could not parse colorArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let r;
                for (const c of this.args) {
                  r = c.evaluate(e);
                  const f = si.parse(r);
                  if (f) return f;
                }
                throw new Lr(`Could not parse variableAnchorOffsetCollection from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
              }
              case "number": {
                let r = null;
                for (const c of this.args) {
                  if (r = c.evaluate(e), r === null) return 0;
                  const f = Number(r);
                  if (!isNaN(f)) return f;
                }
                throw new Lr(`Could not convert ${JSON.stringify(r)} to number.`);
              }
              case "formatted":
                return Wn.fromString(na(this.args[0].evaluate(e)));
              case "resolvedImage":
                return dr.fromString(na(this.args[0].evaluate(e)));
              case "projectionDefinition":
                return this.args[0].evaluate(e);
              default:
                return na(this.args[0].evaluate(e));
            }
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        const Tc = ["Unknown", "Point", "LineString", "Polygon"];
        class xl {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Tc[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(e) {
            let r = this._parseColorCache.get(e);
            return r || (r = hr.parse(e), this._parseColorCache.set(e, r)), r;
          }
        }
        class vi {
          constructor(e, r, c = [], f, m = new Ps(), v = []) {
            this.registry = e, this.path = c, this.key = c.map(((E) => `[${E}]`)).join(""), this.scope = m, this.errors = v, this.expectedType = f, this._isConstant = r;
          }
          parse(e, r, c, f, m = {}) {
            return r ? this.concat(r, c, f)._parse(e, m) : this._parse(e, m);
          }
          _parse(e, r) {
            function c(f, m, v) {
              return v === "assert" ? new ai(m, [f]) : v === "coerce" ? new xs(m, [f]) : f;
            }
            if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
              if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const f = e[0];
              if (typeof f != "string") return this.error(`Expression name must be a string, but found ${typeof f} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const m = this.registry[f];
              if (m) {
                let v = m.parse(e, this);
                if (!v) return null;
                if (this.expectedType) {
                  const E = this.expectedType, k = v.type;
                  if (E.kind !== "string" && E.kind !== "number" && E.kind !== "boolean" && E.kind !== "object" && E.kind !== "array" || k.kind !== "value") {
                    if (E.kind === "projectionDefinition" && ["string", "array"].includes(k.kind) || ["color", "formatted", "resolvedImage"].includes(E.kind) && ["value", "string"].includes(k.kind) || ["padding", "numberArray"].includes(E.kind) && ["value", "number", "array"].includes(k.kind) || E.kind === "colorArray" && ["value", "string", "array"].includes(k.kind) || E.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(k.kind)) v = c(v, E, r.typeAnnotation || "coerce");
                    else if (this.checkSubtype(E, k)) return null;
                  } else v = c(v, E, r.typeAnnotation || "assert");
                }
                if (!(v instanceof rn) && v.type.kind !== "resolvedImage" && this._isConstant(v)) {
                  const E = new xl();
                  try {
                    v = new rn(v.type, v.evaluate(E));
                  } catch (k) {
                    return this.error(k.message), null;
                  }
                }
                return v;
              }
              return this.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
          }
          concat(e, r, c) {
            const f = typeof e == "number" ? this.path.concat(e) : this.path, m = c ? this.scope.concat(c) : this.scope;
            return new vi(this.registry, this._isConstant, f, r || null, m, this.errors);
          }
          error(e, ...r) {
            const c = `${this.key}${r.map(((f) => `[${f}]`)).join("")}`;
            this.errors.push(new Un(c, e));
          }
          checkSubtype(e, r) {
            const c = Nn(e, r);
            return c && this.error(c), c;
          }
        }
        class Dr {
          constructor(e, r) {
            this.type = r.type, this.bindings = [].concat(e), this.result = r;
          }
          evaluate(e) {
            return this.result.evaluate(e);
          }
          eachChild(e) {
            for (const r of this.bindings) e(r[1]);
            e(this.result);
          }
          static parse(e, r) {
            if (e.length < 4) return r.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
            const c = [];
            for (let m = 1; m < e.length - 1; m += 2) {
              const v = e[m];
              if (typeof v != "string") return r.error(`Expected string, but found ${typeof v} instead.`, m);
              if (/[^a-zA-Z0-9_]/.test(v)) return r.error("Variable names must contain only alphanumeric characters or '_'.", m);
              const E = r.parse(e[m + 1], m + 1);
              if (!E) return null;
              c.push([v, E]);
            }
            const f = r.parse(e[e.length - 1], e.length - 1, r.expectedType, c);
            return f ? new Dr(c, f) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Qa {
          constructor(e, r) {
            this.type = r.type, this.name = e, this.boundExpression = r;
          }
          static parse(e, r) {
            if (e.length !== 2 || typeof e[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const c = e[1];
            return r.scope.has(c) ? new Qa(c, r.scope.get(c)) : r.error(`Unknown variable "${c}". Make sure "${c}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(e) {
            return this.boundExpression.evaluate(e);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class sr {
          constructor(e, r, c) {
            this.type = e, this.index = r, this.input = c;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1, xt), f = r.parse(e[2], 2, Or(r.expectedType || Ee));
            return c && f ? new sr(f.type.itemType, c, f) : null;
          }
          evaluate(e) {
            const r = this.index.evaluate(e), c = this.input.evaluate(e);
            if (r < 0) throw new Lr(`Array index out of bounds: ${r} < 0.`);
            if (r >= c.length) throw new Lr(`Array index out of bounds: ${r} > ${c.length - 1}.`);
            if (r !== Math.floor(r)) throw new Lr(`Array index must be an integer, but found ${r} instead.`);
            return c[r];
          }
          eachChild(e) {
            e(this.index), e(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class nr {
          constructor(e, r) {
            this.type = rr, this.needle = e, this.haystack = r;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1, Ee), f = r.parse(e[2], 2, Ee);
            return c && f ? Hi(c.type, [rr, ir, xt, yi, Ee]) ? new nr(c, f) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Er(c.type)} instead`) : null;
          }
          evaluate(e) {
            const r = this.needle.evaluate(e), c = this.haystack.evaluate(e);
            if (!c) return !1;
            if (!As(r, ["boolean", "string", "number", "null"])) throw new Lr(`Expected first argument to be of type boolean, string, number or null, but found ${Er(Ur(r))} instead.`);
            if (!As(c, ["string", "array"])) throw new Lr(`Expected second argument to be of type array or string, but found ${Er(Ur(c))} instead.`);
            return c.indexOf(r) >= 0;
          }
          eachChild(e) {
            e(this.needle), e(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class eo {
          constructor(e, r, c) {
            this.type = xt, this.needle = e, this.haystack = r, this.fromIndex = c;
          }
          static parse(e, r) {
            if (e.length <= 2 || e.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1, Ee), f = r.parse(e[2], 2, Ee);
            if (!c || !f) return null;
            if (!Hi(c.type, [rr, ir, xt, yi, Ee])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Er(c.type)} instead`);
            if (e.length === 4) {
              const m = r.parse(e[3], 3, xt);
              return m ? new eo(c, f, m) : null;
            }
            return new eo(c, f);
          }
          evaluate(e) {
            const r = this.needle.evaluate(e), c = this.haystack.evaluate(e);
            if (!As(r, ["boolean", "string", "number", "null"])) throw new Lr(`Expected first argument to be of type boolean, string, number or null, but found ${Er(Ur(r))} instead.`);
            let f;
            if (this.fromIndex && (f = this.fromIndex.evaluate(e)), As(c, ["string"])) {
              const m = c.indexOf(r, f);
              return m === -1 ? -1 : [...c.slice(0, m)].length;
            }
            if (As(c, ["array"])) return c.indexOf(r, f);
            throw new Lr(`Expected second argument to be of type array or string, but found ${Er(Ur(c))} instead.`);
          }
          eachChild(e) {
            e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class pr {
          constructor(e, r, c, f, m, v) {
            this.inputType = e, this.type = r, this.input = c, this.cases = f, this.outputs = m, this.otherwise = v;
          }
          static parse(e, r) {
            if (e.length < 5) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let c, f;
            r.expectedType && r.expectedType.kind !== "value" && (f = r.expectedType);
            const m = {}, v = [];
            for (let P = 2; P < e.length - 1; P += 2) {
              let L = e[P];
              const N = e[P + 1];
              Array.isArray(L) || (L = [L]);
              const G = r.concat(P);
              if (L.length === 0) return G.error("Expected at least one branch label.");
              for (const Z of L) {
                if (typeof Z != "number" && typeof Z != "string") return G.error("Branch labels must be numbers or strings.");
                if (typeof Z == "number" && Math.abs(Z) > Number.MAX_SAFE_INTEGER) return G.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof Z == "number" && Math.floor(Z) !== Z) return G.error("Numeric branch labels must be integer values.");
                if (c) {
                  if (G.checkSubtype(c, Ur(Z))) return null;
                } else c = Ur(Z);
                if (m[String(Z)] !== void 0) return G.error("Branch labels must be unique.");
                m[String(Z)] = v.length;
              }
              const j = r.parse(N, P, f);
              if (!j) return null;
              f = f || j.type, v.push(j);
            }
            const E = r.parse(e[1], 1, Ee);
            if (!E) return null;
            const k = r.parse(e[e.length - 1], e.length - 1, f);
            return k ? E.type.kind !== "value" && r.concat(1).checkSubtype(c, E.type) ? null : new pr(c, f, E, m, v, k) : null;
          }
          evaluate(e) {
            const r = this.input.evaluate(e);
            return (Ur(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(e);
          }
          eachChild(e) {
            e(this.input), this.outputs.forEach(e), e(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class to {
          constructor(e, r, c) {
            this.type = e, this.branches = r, this.otherwise = c;
          }
          static parse(e, r) {
            if (e.length < 4) return r.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let c;
            r.expectedType && r.expectedType.kind !== "value" && (c = r.expectedType);
            const f = [];
            for (let v = 1; v < e.length - 1; v += 2) {
              const E = r.parse(e[v], v, rr);
              if (!E) return null;
              const k = r.parse(e[v + 1], v + 1, c);
              if (!k) return null;
              f.push([E, k]), c = c || k.type;
            }
            const m = r.parse(e[e.length - 1], e.length - 1, c);
            if (!m) return null;
            if (!c) throw new Error("Can't infer output type");
            return new to(c, f, m);
          }
          evaluate(e) {
            for (const [r, c] of this.branches) if (r.evaluate(e)) return c.evaluate(e);
            return this.otherwise.evaluate(e);
          }
          eachChild(e) {
            for (const [r, c] of this.branches) e(r), e(c);
            e(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([e, r]) => r.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Xn {
          constructor(e, r, c, f) {
            this.type = e, this.input = r, this.beginIndex = c, this.endIndex = f;
          }
          static parse(e, r) {
            if (e.length <= 2 || e.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1, Ee), f = r.parse(e[2], 2, xt);
            if (!c || !f) return null;
            if (!Hi(c.type, [Or(Ee), ir, Ee])) return r.error(`Expected first argument to be of type array or string, but found ${Er(c.type)} instead`);
            if (e.length === 4) {
              const m = r.parse(e[3], 3, xt);
              return m ? new Xn(c.type, c, f, m) : null;
            }
            return new Xn(c.type, c, f);
          }
          evaluate(e) {
            const r = this.input.evaluate(e), c = this.beginIndex.evaluate(e);
            let f;
            if (this.endIndex && (f = this.endIndex.evaluate(e)), As(r, ["string"])) return [...r].slice(c, f).join("");
            if (As(r, ["array"])) return r.slice(c, f);
            throw new Lr(`Expected first argument to be of type array or string, but found ${Er(Ur(r))} instead.`);
          }
          eachChild(e) {
            e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function ro(i, e) {
          const r = i.length - 1;
          let c, f, m = 0, v = r, E = 0;
          for (; m <= v; ) if (E = Math.floor((m + v) / 2), c = i[E], f = i[E + 1], c <= e) {
            if (E === r || e < f) return E;
            m = E + 1;
          } else {
            if (!(c > e)) throw new Lr("Input is not a number.");
            v = E - 1;
          }
          return 0;
        }
        class Jn {
          constructor(e, r, c) {
            this.type = e, this.input = r, this.labels = [], this.outputs = [];
            for (const [f, m] of c) this.labels.push(f), this.outputs.push(m);
          }
          static parse(e, r) {
            if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const c = r.parse(e[1], 1, xt);
            if (!c) return null;
            const f = [];
            let m = null;
            r.expectedType && r.expectedType.kind !== "value" && (m = r.expectedType);
            for (let v = 1; v < e.length; v += 2) {
              const E = v === 1 ? -1 / 0 : e[v], k = e[v + 1], P = v, L = v + 1;
              if (typeof E != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', P);
              if (f.length && f[f.length - 1][0] >= E) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', P);
              const N = r.parse(k, L, m);
              if (!N) return null;
              m = m || N.type, f.push([E, N]);
            }
            return new Jn(m, c, f);
          }
          evaluate(e) {
            const r = this.labels, c = this.outputs;
            if (r.length === 1) return c[0].evaluate(e);
            const f = this.input.evaluate(e);
            if (f <= r[0]) return c[0].evaluate(e);
            const m = r.length;
            return f >= r[m - 1] ? c[m - 1].evaluate(e) : c[ro(r, f)].evaluate(e);
          }
          eachChild(e) {
            e(this.input);
            for (const r of this.outputs) e(r);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined()));
          }
        }
        function fu(i) {
          return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
        }
        var Ro, pu, Kh = (function() {
          if (pu) return Ro;
          function i(e, r, c, f) {
            this.cx = 3 * e, this.bx = 3 * (c - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (f - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r, this.p2x = c, this.p2y = f;
          }
          return pu = 1, Ro = i, i.prototype = { sampleCurveX: function(e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          }, sampleCurveY: function(e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          }, sampleCurveDerivativeX: function(e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          }, solveCurveX: function(e, r) {
            if (r === void 0 && (r = 1e-6), e < 0) return 0;
            if (e > 1) return 1;
            for (var c = e, f = 0; f < 8; f++) {
              var m = this.sampleCurveX(c) - e;
              if (Math.abs(m) < r) return c;
              var v = this.sampleCurveDerivativeX(c);
              if (Math.abs(v) < 1e-6) break;
              c -= m / v;
            }
            var E = 0, k = 1;
            for (c = e, f = 0; f < 20 && (m = this.sampleCurveX(c), !(Math.abs(m - e) < r)); f++) e > m ? E = c : k = c, c = 0.5 * (k - E) + E;
            return c;
          }, solve: function(e, r) {
            return this.sampleCurveY(this.solveCurveX(e, r));
          } }, Ro;
        })(), Sc = fu(Kh);
        class xi {
          constructor(e, r, c, f, m) {
            this.type = e, this.operator = r, this.interpolation = c, this.input = f, this.labels = [], this.outputs = [];
            for (const [v, E] of m) this.labels.push(v), this.outputs.push(E);
          }
          static interpolationFactor(e, r, c, f) {
            let m = 0;
            if (e.name === "exponential") m = bs(r, e.base, c, f);
            else if (e.name === "linear") m = bs(r, 1, c, f);
            else if (e.name === "cubic-bezier") {
              const v = e.controlPoints;
              m = new Sc(v[0], v[1], v[2], v[3]).solve(bs(r, 1, c, f));
            }
            return m;
          }
          static parse(e, r) {
            let [c, f, m, ...v] = e;
            if (!Array.isArray(f) || f.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (f[0] === "linear") f = { name: "linear" };
            else if (f[0] === "exponential") {
              const P = f[1];
              if (typeof P != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              f = { name: "exponential", base: P };
            } else {
              if (f[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(f[0])}`, 1, 0);
              {
                const P = f.slice(1);
                if (P.length !== 4 || P.some(((L) => typeof L != "number" || L < 0 || L > 1))) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                f = { name: "cubic-bezier", controlPoints: P };
              }
            }
            if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (m = r.parse(m, 2, xt), !m) return null;
            const E = [];
            let k = null;
            c !== "interpolate-hcl" && c !== "interpolate-lab" || r.expectedType == Qr ? r.expectedType && r.expectedType.kind !== "value" && (k = r.expectedType) : k = pn;
            for (let P = 0; P < v.length; P += 2) {
              const L = v[P], N = v[P + 1], G = P + 3, j = P + 4;
              if (typeof L != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', G);
              if (E.length && E[E.length - 1][0] >= L) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', G);
              const Z = r.parse(N, j, k);
              if (!Z) return null;
              k = k || Z.type, E.push([L, Z]);
            }
            return ni(k, xt) || ni(k, zi) || ni(k, pn) || ni(k, Tr) || ni(k, Cr) || ni(k, Qr) || ni(k, Fn) || ni(k, Or(xt)) ? new xi(k, c, f, m, E) : r.error(`Type ${Er(k)} is not interpolatable.`);
          }
          evaluate(e) {
            const r = this.labels, c = this.outputs;
            if (r.length === 1) return c[0].evaluate(e);
            const f = this.input.evaluate(e);
            if (f <= r[0]) return c[0].evaluate(e);
            const m = r.length;
            if (f >= r[m - 1]) return c[m - 1].evaluate(e);
            const v = ro(r, f), E = xi.interpolationFactor(this.interpolation, f, r[v], r[v + 1]), k = c[v].evaluate(e), P = c[v + 1].evaluate(e);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Ar(k, P, E);
                  case "color":
                    return hr.interpolate(k, P, E);
                  case "padding":
                    return ii.interpolate(k, P, E);
                  case "colorArray":
                    return Qt.interpolate(k, P, E);
                  case "numberArray":
                    return en.interpolate(k, P, E);
                  case "variableAnchorOffsetCollection":
                    return si.interpolate(k, P, E);
                  case "array":
                    return Yi(k, P, E);
                  case "projectionDefinition":
                    return tn.interpolate(k, P, E);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return hr.interpolate(k, P, E, "hcl");
                  case "colorArray":
                    return Qt.interpolate(k, P, E, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return hr.interpolate(k, P, E, "lab");
                  case "colorArray":
                    return Qt.interpolate(k, P, E, "lab");
                }
            }
          }
          eachChild(e) {
            e(this.input);
            for (const r of this.outputs) e(r);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined()));
          }
        }
        function bs(i, e, r, c) {
          const f = c - r, m = i - r;
          return f === 0 ? 0 : e === 1 ? m / f : (Math.pow(e, m) - 1) / (Math.pow(e, f) - 1);
        }
        const Wr = { color: hr.interpolate, number: Ar, padding: ii.interpolate, numberArray: en.interpolate, colorArray: Qt.interpolate, variableAnchorOffsetCollection: si.interpolate, array: Yi };
        class Gi {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            let c = null;
            const f = r.expectedType;
            f && f.kind !== "value" && (c = f);
            const m = [];
            for (const E of e.slice(1)) {
              const k = r.parse(E, 1 + m.length, c, void 0, { typeAnnotation: "omit" });
              if (!k) return null;
              c = c || k.type, m.push(k);
            }
            if (!c) throw new Error("No output type");
            const v = f && m.some(((E) => Nn(f, E.type)));
            return new Gi(v ? Ee : c, m);
          }
          evaluate(e) {
            let r, c = null, f = 0;
            for (const m of this.args) if (f++, c = m.evaluate(e), c && c instanceof dr && !c.available && (r || (r = c.name), c = null, f === this.args.length && (c = r)), c !== null) break;
            return c;
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        function bi(i, e) {
          return i === "==" || i === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
        }
        function Fo(i, e, r, c) {
          return c.compare(e, r) === 0;
        }
        function nn(i, e, r) {
          const c = i !== "==" && i !== "!=";
          return class Gb {
            constructor(m, v, E) {
              this.type = rr, this.lhs = m, this.rhs = v, this.collator = E, this.hasUntypedArgument = m.type.kind === "value" || v.type.kind === "value";
            }
            static parse(m, v) {
              if (m.length !== 3 && m.length !== 4) return v.error("Expected two or three arguments.");
              const E = m[0];
              let k = v.parse(m[1], 1, Ee);
              if (!k) return null;
              if (!bi(E, k.type)) return v.concat(1).error(`"${E}" comparisons are not supported for type '${Er(k.type)}'.`);
              let P = v.parse(m[2], 2, Ee);
              if (!P) return null;
              if (!bi(E, P.type)) return v.concat(2).error(`"${E}" comparisons are not supported for type '${Er(P.type)}'.`);
              if (k.type.kind !== P.type.kind && k.type.kind !== "value" && P.type.kind !== "value") return v.error(`Cannot compare types '${Er(k.type)}' and '${Er(P.type)}'.`);
              c && (k.type.kind === "value" && P.type.kind !== "value" ? k = new ai(P.type, [k]) : k.type.kind !== "value" && P.type.kind === "value" && (P = new ai(k.type, [P])));
              let L = null;
              if (m.length === 4) {
                if (k.type.kind !== "string" && P.type.kind !== "string" && k.type.kind !== "value" && P.type.kind !== "value") return v.error("Cannot use collator to compare non-string types.");
                if (L = v.parse(m[3], 3, zt), !L) return null;
              }
              return new Gb(k, P, L);
            }
            evaluate(m) {
              const v = this.lhs.evaluate(m), E = this.rhs.evaluate(m);
              if (c && this.hasUntypedArgument) {
                const k = Ur(v), P = Ur(E);
                if (k.kind !== P.kind || k.kind !== "string" && k.kind !== "number") throw new Lr(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${k.kind}, ${P.kind}) instead.`);
              }
              if (this.collator && !c && this.hasUntypedArgument) {
                const k = Ur(v), P = Ur(E);
                if (k.kind !== "string" || P.kind !== "string") return e(m, v, E);
              }
              return this.collator ? r(m, v, E, this.collator.evaluate(m)) : e(m, v, E);
            }
            eachChild(m) {
              m(this.lhs), m(this.rhs), this.collator && m(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const kc = nn("==", (function(i, e, r) {
          return e === r;
        }), Fo), No = nn("!=", (function(i, e, r) {
          return e !== r;
        }), (function(i, e, r, c) {
          return !Fo(0, e, r, c);
        })), gu = nn("<", (function(i, e, r) {
          return e < r;
        }), (function(i, e, r, c) {
          return c.compare(e, r) < 0;
        })), mu = nn(">", (function(i, e, r) {
          return e > r;
        }), (function(i, e, r, c) {
          return c.compare(e, r) > 0;
        })), Ta = nn("<=", (function(i, e, r) {
          return e <= r;
        }), (function(i, e, r, c) {
          return c.compare(e, r) <= 0;
        })), ki = nn(">=", (function(i, e, r) {
          return e >= r;
        }), (function(i, e, r, c) {
          return c.compare(e, r) >= 0;
        }));
        class Sa {
          constructor(e, r, c) {
            this.type = zt, this.locale = c, this.caseSensitive = e, this.diacriticSensitive = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error("Expected one argument.");
            const c = e[1];
            if (typeof c != "object" || Array.isArray(c)) return r.error("Collator options argument must be an object.");
            const f = r.parse(c["case-sensitive"] !== void 0 && c["case-sensitive"], 1, rr);
            if (!f) return null;
            const m = r.parse(c["diacritic-sensitive"] !== void 0 && c["diacritic-sensitive"], 1, rr);
            if (!m) return null;
            let v = null;
            return c.locale && (v = r.parse(c.locale, 1, ir), !v) ? null : new Sa(f, m, v);
          }
          evaluate(e) {
            return new Lo(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
          }
          eachChild(e) {
            e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class wi {
          constructor(e, r, c, f, m) {
            this.type = ir, this.number = e, this.locale = r, this.currency = c, this.minFractionDigits = f, this.maxFractionDigits = m;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error("Expected two arguments.");
            const c = r.parse(e[1], 1, xt);
            if (!c) return null;
            const f = e[2];
            if (typeof f != "object" || Array.isArray(f)) return r.error("NumberFormat options argument must be an object.");
            let m = null;
            if (f.locale && (m = r.parse(f.locale, 1, ir), !m)) return null;
            let v = null;
            if (f.currency && (v = r.parse(f.currency, 1, ir), !v)) return null;
            let E = null;
            if (f["min-fraction-digits"] && (E = r.parse(f["min-fraction-digits"], 1, xt), !E)) return null;
            let k = null;
            return f["max-fraction-digits"] && (k = r.parse(f["max-fraction-digits"], 1, xt), !k) ? null : new wi(c, m, v, E, k);
          }
          evaluate(e) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
          }
          eachChild(e) {
            e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class Ns {
          constructor(e) {
            this.type = bt, this.sections = e;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            const c = e[1];
            if (!Array.isArray(c) && typeof c == "object") return r.error("First argument must be an image or text section.");
            const f = [];
            let m = !1;
            for (let v = 1; v <= e.length - 1; ++v) {
              const E = e[v];
              if (m && typeof E == "object" && !Array.isArray(E)) {
                m = !1;
                let k = null;
                if (E["font-scale"] && (k = r.parse(E["font-scale"], 1, xt), !k)) return null;
                let P = null;
                if (E["text-font"] && (P = r.parse(E["text-font"], 1, Or(ir)), !P)) return null;
                let L = null;
                if (E["text-color"] && (L = r.parse(E["text-color"], 1, pn), !L)) return null;
                let N = null;
                if (E["vertical-align"]) {
                  if (typeof E["vertical-align"] == "string" && !Wi.includes(E["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${E["vertical-align"]}' instead.`);
                  if (N = r.parse(E["vertical-align"], 1, ir), !N) return null;
                }
                const G = f[f.length - 1];
                G.scale = k, G.font = P, G.textColor = L, G.verticalAlign = N;
              } else {
                const k = r.parse(e[v], 1, Ee);
                if (!k) return null;
                const P = k.type.kind;
                if (P !== "string" && P !== "value" && P !== "null" && P !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                m = !0, f.push({ content: k, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Ns(f);
          }
          evaluate(e) {
            return new Wn(this.sections.map(((r) => {
              const c = r.content.evaluate(e);
              return Ur(c) === Cn ? new Si("", c, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(e) : null) : new Si(na(c), null, r.scale ? r.scale.evaluate(e) : null, r.font ? r.font.evaluate(e).join(",") : null, r.textColor ? r.textColor.evaluate(e) : null, r.verticalAlign ? r.verticalAlign.evaluate(e) : null);
            })));
          }
          eachChild(e) {
            for (const r of this.sections) e(r.content), r.scale && e(r.scale), r.font && e(r.font), r.textColor && e(r.textColor), r.verticalAlign && e(r.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class no {
          constructor(e) {
            this.type = Cn, this.input = e;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error("Expected two arguments.");
            const c = r.parse(e[1], 1, ir);
            return c ? new no(c) : r.error("No image name provided.");
          }
          evaluate(e) {
            const r = this.input.evaluate(e), c = dr.fromString(r);
            return c && e.availableImages && (c.available = e.availableImages.indexOf(r) > -1), c;
          }
          eachChild(e) {
            e(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class ka {
          constructor(e) {
            this.type = xt, this.input = e;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
            const c = r.parse(e[1], 1);
            return c ? c.type.kind !== "array" && c.type.kind !== "string" && c.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Er(c.type)} instead.`) : new ka(c) : null;
          }
          evaluate(e) {
            const r = this.input.evaluate(e);
            if (typeof r == "string") return [...r].length;
            if (Array.isArray(r)) return r.length;
            throw new Lr(`Expected value to be of type string or array, but found ${Er(Ur(r))} instead.`);
          }
          eachChild(e) {
            e(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const wn = 8192;
        function _u(i, e) {
          const r = (180 + i[0]) / 360, c = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, f = Math.pow(2, e.z);
          return [Math.round(r * f * wn), Math.round(c * f * wn)];
        }
        function sa(i, e) {
          const r = Math.pow(2, e.z);
          return [(f = (i[0] / wn + e.x) / r, 360 * f - 180), (c = (i[1] / wn + e.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * c) * Math.PI / 180)) - 90)];
          var c, f;
        }
        function Oo(i, e) {
          i[0] = Math.min(i[0], e[0]), i[1] = Math.min(i[1], e[1]), i[2] = Math.max(i[2], e[0]), i[3] = Math.max(i[3], e[1]);
        }
        function Ia(i, e) {
          return !(i[0] <= e[0] || i[2] >= e[2] || i[1] <= e[1] || i[3] >= e[3]);
        }
        function Qh(i, e, r) {
          const c = i[0] - e[0], f = i[1] - e[1], m = i[0] - r[0], v = i[1] - r[1];
          return c * v - m * f == 0 && c * m <= 0 && f * v <= 0;
        }
        function bl(i, e, r, c) {
          return (f = [c[0] - r[0], c[1] - r[1]])[0] * (m = [e[0] - i[0], e[1] - i[1]])[1] - f[1] * m[0] != 0 && !(!vu(i, e, r, c) || !vu(r, c, i, e));
          var f, m;
        }
        function ed(i, e, r) {
          for (const c of r) for (let f = 0; f < c.length - 1; ++f) if (bl(i, e, c[f], c[f + 1])) return !0;
          return !1;
        }
        function io(i, e, r = !1) {
          let c = !1;
          for (const E of e) for (let k = 0; k < E.length - 1; k++) {
            if (Qh(i, E[k], E[k + 1])) return r;
            (m = E[k])[1] > (f = i)[1] != (v = E[k + 1])[1] > f[1] && f[0] < (v[0] - m[0]) * (f[1] - m[1]) / (v[1] - m[1]) + m[0] && (c = !c);
          }
          var f, m, v;
          return c;
        }
        function wl(i, e) {
          for (const r of e) if (io(i, r)) return !0;
          return !1;
        }
        function Ic(i, e) {
          for (const r of i) if (!io(r, e)) return !1;
          for (let r = 0; r < i.length - 1; ++r) if (ed(i[r], i[r + 1], e)) return !1;
          return !0;
        }
        function yu(i, e) {
          for (const r of e) if (Ic(i, r)) return !0;
          return !1;
        }
        function vu(i, e, r, c) {
          const f = c[0] - r[0], m = c[1] - r[1], v = (i[0] - r[0]) * m - f * (i[1] - r[1]), E = (e[0] - r[0]) * m - f * (e[1] - r[1]);
          return v > 0 && E < 0 || v < 0 && E > 0;
        }
        function El(i, e, r) {
          const c = [];
          for (let f = 0; f < i.length; f++) {
            const m = [];
            for (let v = 0; v < i[f].length; v++) {
              const E = _u(i[f][v], r);
              Oo(e, E), m.push(E);
            }
            c.push(m);
          }
          return c;
        }
        function xu(i, e, r) {
          const c = [];
          for (let f = 0; f < i.length; f++) {
            const m = El(i[f], e, r);
            c.push(m);
          }
          return c;
        }
        function Mc(i, e, r, c) {
          if (i[0] < r[0] || i[0] > r[2]) {
            const f = 0.5 * c;
            let m = i[0] - r[0] > f ? -c : r[0] - i[0] > f ? c : 0;
            m === 0 && (m = i[0] - r[2] > f ? -c : r[2] - i[0] > f ? c : 0), i[0] += m;
          }
          Oo(e, i);
        }
        function Cc(i, e, r, c) {
          const f = Math.pow(2, c.z) * wn, m = [c.x * wn, c.y * wn], v = [];
          for (const E of i) for (const k of E) {
            const P = [k.x + m[0], k.y + m[1]];
            Mc(P, e, r, f), v.push(P);
          }
          return v;
        }
        function Pc(i, e, r, c) {
          const f = Math.pow(2, c.z) * wn, m = [c.x * wn, c.y * wn], v = [];
          for (const k of i) {
            const P = [];
            for (const L of k) {
              const N = [L.x + m[0], L.y + m[1]];
              Oo(e, N), P.push(N);
            }
            v.push(P);
          }
          if (e[2] - e[0] <= f / 2) {
            (E = e)[0] = E[1] = 1 / 0, E[2] = E[3] = -1 / 0;
            for (const k of v) for (const P of k) Mc(P, e, r, f);
          }
          var E;
          return v;
        }
        class Ma {
          constructor(e, r) {
            this.type = rr, this.geojson = e, this.geometries = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (Fs(e[1])) {
              const c = e[1];
              if (c.type === "FeatureCollection") {
                const f = [];
                for (const m of c.features) {
                  const { type: v, coordinates: E } = m.geometry;
                  v === "Polygon" && f.push(E), v === "MultiPolygon" && f.push(...E);
                }
                if (f.length) return new Ma(c, { type: "MultiPolygon", coordinates: f });
              } else if (c.type === "Feature") {
                const f = c.geometry.type;
                if (f === "Polygon" || f === "MultiPolygon") return new Ma(c, c.geometry);
              } else if (c.type === "Polygon" || c.type === "MultiPolygon") return new Ma(c, c);
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (e.geometry() != null && e.canonicalID() != null) {
              if (e.geometryType() === "Point") return (function(r, c) {
                const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = r.canonicalID();
                if (c.type === "Polygon") {
                  const E = El(c.coordinates, m, v), k = Cc(r.geometry(), f, m, v);
                  if (!Ia(f, m)) return !1;
                  for (const P of k) if (!io(P, E)) return !1;
                }
                if (c.type === "MultiPolygon") {
                  const E = xu(c.coordinates, m, v), k = Cc(r.geometry(), f, m, v);
                  if (!Ia(f, m)) return !1;
                  for (const P of k) if (!wl(P, E)) return !1;
                }
                return !0;
              })(e, this.geometries);
              if (e.geometryType() === "LineString") return (function(r, c) {
                const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = r.canonicalID();
                if (c.type === "Polygon") {
                  const E = El(c.coordinates, m, v), k = Pc(r.geometry(), f, m, v);
                  if (!Ia(f, m)) return !1;
                  for (const P of k) if (!Ic(P, E)) return !1;
                }
                if (c.type === "MultiPolygon") {
                  const E = xu(c.coordinates, m, v), k = Pc(r.geometry(), f, m, v);
                  if (!Ia(f, m)) return !1;
                  for (const P of k) if (!yu(P, E)) return !1;
                }
                return !0;
              })(e, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let Ac = class {
          constructor(i = [], e = (r, c) => r < c ? -1 : r > c ? 1 : 0) {
            if (this.data = i, this.length = this.data.length, this.compare = e, this.length > 0) for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
          }
          push(i) {
            this.data.push(i), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const i = this.data[0], e = this.data.pop();
            return --this.length > 0 && (this.data[0] = e, this._down(0)), i;
          }
          peek() {
            return this.data[0];
          }
          _up(i) {
            const { data: e, compare: r } = this, c = e[i];
            for (; i > 0; ) {
              const f = i - 1 >> 1, m = e[f];
              if (r(c, m) >= 0) break;
              e[i] = m, i = f;
            }
            e[i] = c;
          }
          _down(i) {
            const { data: e, compare: r } = this, c = this.length >> 1, f = e[i];
            for (; i < c; ) {
              let m = 1 + (i << 1);
              const v = m + 1;
              if (v < this.length && r(e[v], e[m]) < 0 && (m = v), r(e[m], f) >= 0) break;
              e[i] = e[m], i = m;
            }
            e[i] = f;
          }
        };
        function bu(i, e, r = 0, c = i.length - 1, f = wu) {
          for (; c > r; ) {
            if (c - r > 600) {
              const k = c - r + 1, P = e - r + 1, L = Math.log(k), N = 0.5 * Math.exp(2 * L / 3), G = 0.5 * Math.sqrt(L * N * (k - N) / k) * (P - k / 2 < 0 ? -1 : 1);
              bu(i, e, Math.max(r, Math.floor(e - P * N / k + G)), Math.min(c, Math.floor(e + (k - P) * N / k + G)), f);
            }
            const m = i[e];
            let v = r, E = c;
            for (Ca(i, r, e), f(i[c], m) > 0 && Ca(i, r, c); v < E; ) {
              for (Ca(i, v, E), v++, E--; f(i[v], m) < 0; ) v++;
              for (; f(i[E], m) > 0; ) E--;
            }
            f(i[r], m) === 0 ? Ca(i, r, E) : (E++, Ca(i, E, c)), E <= e && (r = E + 1), e <= E && (c = E - 1);
          }
        }
        function Ca(i, e, r) {
          const c = i[e];
          i[e] = i[r], i[r] = c;
        }
        function wu(i, e) {
          return i < e ? -1 : i > e ? 1 : 0;
        }
        function zo(i, e) {
          if (i.length <= 1) return [i];
          const r = [];
          let c, f;
          for (const m of i) {
            const v = Lc(m);
            v !== 0 && (m.area = Math.abs(v), f === void 0 && (f = v < 0), f === v < 0 ? (c && r.push(c), c = [m]) : c.push(m));
          }
          if (c && r.push(c), e > 1) for (let m = 0; m < r.length; m++) r[m].length <= e || (bu(r[m], e, 1, r[m].length - 1, td), r[m] = r[m].slice(0, e));
          return r;
        }
        function td(i, e) {
          return e.area - i.area;
        }
        function Lc(i) {
          let e = 0;
          for (let r, c, f = 0, m = i.length, v = m - 1; f < m; v = f++) r = i[f], c = i[v], e += (c.x - r.x) * (r.y + c.y);
          return e;
        }
        const Tl = 1 / 298.257223563, Bo = Tl * (2 - Tl), Eu = Math.PI / 180;
        class Sl {
          constructor(e) {
            const r = 6378.137 * Eu * 1e3, c = Math.cos(e * Eu), f = 1 / (1 - Bo * (1 - c * c)), m = Math.sqrt(f);
            this.kx = r * m * c, this.ky = r * m * f * (1 - Bo);
          }
          distance(e, r) {
            const c = this.wrap(e[0] - r[0]) * this.kx, f = (e[1] - r[1]) * this.ky;
            return Math.sqrt(c * c + f * f);
          }
          pointOnLine(e, r) {
            let c, f, m, v, E = 1 / 0;
            for (let k = 0; k < e.length - 1; k++) {
              let P = e[k][0], L = e[k][1], N = this.wrap(e[k + 1][0] - P) * this.kx, G = (e[k + 1][1] - L) * this.ky, j = 0;
              N === 0 && G === 0 || (j = (this.wrap(r[0] - P) * this.kx * N + (r[1] - L) * this.ky * G) / (N * N + G * G), j > 1 ? (P = e[k + 1][0], L = e[k + 1][1]) : j > 0 && (P += N / this.kx * j, L += G / this.ky * j)), N = this.wrap(r[0] - P) * this.kx, G = (r[1] - L) * this.ky;
              const Z = N * N + G * G;
              Z < E && (E = Z, c = P, f = L, m = k, v = j);
            }
            return { point: [c, f], index: m, t: Math.max(0, Math.min(1, v)) };
          }
          wrap(e) {
            for (; e < -180; ) e += 360;
            for (; e > 180; ) e -= 360;
            return e;
          }
        }
        function Dc(i, e) {
          return e[0] - i[0];
        }
        function kl(i) {
          return i[1] - i[0] + 1;
        }
        function oi(i, e) {
          return i[1] >= i[0] && i[1] < e;
        }
        function Il(i, e) {
          if (i[0] > i[1]) return [null, null];
          const r = kl(i);
          if (e) {
            if (r === 2) return [i, null];
            const f = Math.floor(r / 2);
            return [[i[0], i[0] + f], [i[0] + f, i[1]]];
          }
          if (r === 1) return [i, null];
          const c = Math.floor(r / 2) - 1;
          return [[i[0], i[0] + c], [i[0] + c + 1, i[1]]];
        }
        function Ml(i, e) {
          if (!oi(e, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let c = e[0]; c <= e[1]; ++c) Oo(r, i[c]);
          return r;
        }
        function Ii(i) {
          const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r of i) for (const c of r) Oo(e, c);
          return e;
        }
        function Xi(i) {
          return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
        }
        function y(i, e, r) {
          if (!Xi(i) || !Xi(e)) return NaN;
          let c = 0, f = 0;
          return i[2] < e[0] && (c = e[0] - i[2]), i[0] > e[2] && (c = i[0] - e[2]), i[1] > e[3] && (f = i[1] - e[3]), i[3] < e[1] && (f = e[1] - i[3]), r.distance([0, 0], [c, f]);
        }
        function o(i, e, r) {
          const c = r.pointOnLine(e, i);
          return r.distance(i, c.point);
        }
        function h(i, e, r, c, f) {
          const m = Math.min(o(i, [r, c], f), o(e, [r, c], f)), v = Math.min(o(r, [i, e], f), o(c, [i, e], f));
          return Math.min(m, v);
        }
        function _(i, e, r, c, f) {
          if (!oi(e, i.length) || !oi(c, r.length)) return 1 / 0;
          let m = 1 / 0;
          for (let v = e[0]; v < e[1]; ++v) {
            const E = i[v], k = i[v + 1];
            for (let P = c[0]; P < c[1]; ++P) {
              const L = r[P], N = r[P + 1];
              if (bl(E, k, L, N)) return 0;
              m = Math.min(m, h(E, k, L, N, f));
            }
          }
          return m;
        }
        function I(i, e, r, c, f) {
          if (!oi(e, i.length) || !oi(c, r.length)) return NaN;
          let m = 1 / 0;
          for (let v = e[0]; v <= e[1]; ++v) for (let E = c[0]; E <= c[1]; ++E) if (m = Math.min(m, f.distance(i[v], r[E])), m === 0) return m;
          return m;
        }
        function D(i, e, r) {
          if (io(i, e, !0)) return 0;
          let c = 1 / 0;
          for (const f of e) {
            const m = f[0], v = f[f.length - 1];
            if (m !== v && (c = Math.min(c, o(i, [v, m], r)), c === 0)) return c;
            const E = r.pointOnLine(f, i);
            if (c = Math.min(c, r.distance(i, E.point)), c === 0) return c;
          }
          return c;
        }
        function B(i, e, r, c) {
          if (!oi(e, i.length)) return NaN;
          for (let m = e[0]; m <= e[1]; ++m) if (io(i[m], r, !0)) return 0;
          let f = 1 / 0;
          for (let m = e[0]; m < e[1]; ++m) {
            const v = i[m], E = i[m + 1];
            for (const k of r) for (let P = 0, L = k.length, N = L - 1; P < L; N = P++) {
              const G = k[N], j = k[P];
              if (bl(v, E, G, j)) return 0;
              f = Math.min(f, h(v, E, G, j, c));
            }
          }
          return f;
        }
        function H(i, e) {
          for (const r of i) for (const c of r) if (io(c, e, !0)) return !0;
          return !1;
        }
        function se(i, e, r, c = 1 / 0) {
          const f = Ii(i), m = Ii(e);
          if (c !== 1 / 0 && y(f, m, r) >= c) return c;
          if (Ia(f, m)) {
            if (H(i, e)) return 0;
          } else if (H(e, i)) return 0;
          let v = 1 / 0;
          for (const E of i) for (let k = 0, P = E.length, L = P - 1; k < P; L = k++) {
            const N = E[L], G = E[k];
            for (const j of e) for (let Z = 0, Y = j.length, X = Y - 1; Z < Y; X = Z++) {
              const ne = j[X], xe = j[Z];
              if (bl(N, G, ne, xe)) return 0;
              v = Math.min(v, h(N, G, ne, xe, r));
            }
          }
          return v;
        }
        function de(i, e, r, c, f, m) {
          if (!m) return;
          const v = y(Ml(c, m), f, r);
          v < e && i.push([v, m, [0, 0]]);
        }
        function $e(i, e, r, c, f, m, v) {
          if (!m || !v) return;
          const E = y(Ml(c, m), Ml(f, v), r);
          E < e && i.push([E, m, v]);
        }
        function rt(i, e, r, c, f = 1 / 0) {
          let m = Math.min(c.distance(i[0], r[0][0]), f);
          if (m === 0) return m;
          const v = new Ac([[0, [0, i.length - 1], [0, 0]]], Dc), E = Ii(r);
          for (; v.length > 0; ) {
            const k = v.pop();
            if (k[0] >= m) continue;
            const P = k[1], L = e ? 50 : 100;
            if (kl(P) <= L) {
              if (!oi(P, i.length)) return NaN;
              if (e) {
                const N = B(i, P, r, c);
                if (isNaN(N) || N === 0) return N;
                m = Math.min(m, N);
              } else for (let N = P[0]; N <= P[1]; ++N) {
                const G = D(i[N], r, c);
                if (m = Math.min(m, G), m === 0) return 0;
              }
            } else {
              const N = Il(P, e);
              de(v, m, c, i, E, N[0]), de(v, m, c, i, E, N[1]);
            }
          }
          return m;
        }
        function vt(i, e, r, c, f, m = 1 / 0) {
          let v = Math.min(m, f.distance(i[0], r[0]));
          if (v === 0) return v;
          const E = new Ac([[0, [0, i.length - 1], [0, r.length - 1]]], Dc);
          for (; E.length > 0; ) {
            const k = E.pop();
            if (k[0] >= v) continue;
            const P = k[1], L = k[2], N = e ? 50 : 100, G = c ? 50 : 100;
            if (kl(P) <= N && kl(L) <= G) {
              if (!oi(P, i.length) && oi(L, r.length)) return NaN;
              let j;
              if (e && c) j = _(i, P, r, L, f), v = Math.min(v, j);
              else if (e && !c) {
                const Z = i.slice(P[0], P[1] + 1);
                for (let Y = L[0]; Y <= L[1]; ++Y) if (j = o(r[Y], Z, f), v = Math.min(v, j), v === 0) return v;
              } else if (!e && c) {
                const Z = r.slice(L[0], L[1] + 1);
                for (let Y = P[0]; Y <= P[1]; ++Y) if (j = o(i[Y], Z, f), v = Math.min(v, j), v === 0) return v;
              } else j = I(i, P, r, L, f), v = Math.min(v, j);
            } else {
              const j = Il(P, e), Z = Il(L, c);
              $e(E, v, f, i, r, j[0], Z[0]), $e(E, v, f, i, r, j[0], Z[1]), $e(E, v, f, i, r, j[1], Z[0]), $e(E, v, f, i, r, j[1], Z[1]);
            }
          }
          return v;
        }
        function Gt(i) {
          return i.type === "MultiPolygon" ? i.coordinates.map(((e) => ({ type: "Polygon", coordinates: e }))) : i.type === "MultiLineString" ? i.coordinates.map(((e) => ({ type: "LineString", coordinates: e }))) : i.type === "MultiPoint" ? i.coordinates.map(((e) => ({ type: "Point", coordinates: e }))) : [i];
        }
        class $t {
          constructor(e, r) {
            this.type = xt, this.geojson = e, this.geometries = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (Fs(e[1])) {
              const c = e[1];
              if (c.type === "FeatureCollection") return new $t(c, c.features.map(((f) => Gt(f.geometry))).flat());
              if (c.type === "Feature") return new $t(c, Gt(c.geometry));
              if ("type" in c && "coordinates" in c) return new $t(c, Gt(c));
            }
            return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (e.geometry() != null && e.canonicalID() != null) {
              if (e.geometryType() === "Point") return (function(r, c) {
                const f = r.geometry(), m = f.flat().map(((k) => sa([k.x, k.y], r.canonical)));
                if (f.length === 0) return NaN;
                const v = new Sl(m[0][1]);
                let E = 1 / 0;
                for (const k of c) {
                  switch (k.type) {
                    case "Point":
                      E = Math.min(E, vt(m, !1, [k.coordinates], !1, v, E));
                      break;
                    case "LineString":
                      E = Math.min(E, vt(m, !1, k.coordinates, !0, v, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, rt(m, !1, k.coordinates, v, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              })(e, this.geometries);
              if (e.geometryType() === "LineString") return (function(r, c) {
                const f = r.geometry(), m = f.flat().map(((k) => sa([k.x, k.y], r.canonical)));
                if (f.length === 0) return NaN;
                const v = new Sl(m[0][1]);
                let E = 1 / 0;
                for (const k of c) {
                  switch (k.type) {
                    case "Point":
                      E = Math.min(E, vt(m, !0, [k.coordinates], !1, v, E));
                      break;
                    case "LineString":
                      E = Math.min(E, vt(m, !0, k.coordinates, !0, v, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, rt(m, !0, k.coordinates, v, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              })(e, this.geometries);
              if (e.geometryType() === "Polygon") return (function(r, c) {
                const f = r.geometry();
                if (f.length === 0 || f[0].length === 0) return NaN;
                const m = zo(f, 0).map(((k) => k.map(((P) => P.map(((L) => sa([L.x, L.y], r.canonical))))))), v = new Sl(m[0][0][0][1]);
                let E = 1 / 0;
                for (const k of c) for (const P of m) {
                  switch (k.type) {
                    case "Point":
                      E = Math.min(E, rt([k.coordinates], !1, P, v, E));
                      break;
                    case "LineString":
                      E = Math.min(E, rt(k.coordinates, !0, P, v, E));
                      break;
                    case "Polygon":
                      E = Math.min(E, se(P, k.coordinates, v, E));
                  }
                  if (E === 0) return E;
                }
                return E;
              })(e, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        class Xt {
          constructor(e) {
            this.type = Ee, this.key = e;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
            const c = e[1];
            return c == null ? r.error("Global state property must be defined.") : typeof c != "string" ? r.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new Xt(c);
          }
          evaluate(e) {
            var r;
            const c = (r = e.globals) === null || r === void 0 ? void 0 : r.globalState;
            return c && Object.keys(c).length !== 0 ? Rs(c, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        const _r = { "==": kc, "!=": No, ">": mu, "<": gu, ">=": ki, "<=": Ta, array: ai, at: sr, boolean: ai, case: to, coalesce: Gi, collator: Sa, format: Ns, image: no, in: nr, "index-of": eo, interpolate: xi, "interpolate-hcl": xi, "interpolate-lab": xi, length: ka, let: Dr, literal: rn, match: pr, number: ai, "number-format": wi, object: ai, slice: Xn, step: Jn, string: ai, "to-boolean": xs, "to-color": xs, "to-number": xs, "to-string": xs, var: Qa, within: Ma, distance: $t, "global-state": Xt };
        class or {
          constructor(e, r, c, f) {
            this.name = e, this.type = r, this._evaluate = c, this.args = f;
          }
          evaluate(e) {
            return this._evaluate(e, this.args);
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return !1;
          }
          static parse(e, r) {
            const c = e[0], f = or.definitions[c];
            if (!f) return r.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const m = Array.isArray(f) ? f[0] : f.type, v = Array.isArray(f) ? [[f[1], f[2]]] : f.overloads, E = v.filter((([P]) => !Array.isArray(P) || P.length === e.length - 1));
            let k = null;
            for (const [P, L] of E) {
              k = new vi(r.registry, aa, r.path, null, r.scope);
              const N = [];
              let G = !1;
              for (let j = 1; j < e.length; j++) {
                const Z = e[j], Y = Array.isArray(P) ? P[j - 1] : P.type, X = k.parse(Z, 1 + N.length, Y);
                if (!X) {
                  G = !0;
                  break;
                }
                N.push(X);
              }
              if (!G) if (Array.isArray(P) && P.length !== N.length) k.error(`Expected ${P.length} arguments, but found ${N.length} instead.`);
              else {
                for (let j = 0; j < N.length; j++) {
                  const Z = Array.isArray(P) ? P[j] : P.type, Y = N[j];
                  k.concat(j + 1).checkSubtype(Z, Y.type);
                }
                if (k.errors.length === 0) return new or(c, m, L, N);
              }
            }
            if (E.length === 1) r.errors.push(...k.errors);
            else {
              const P = (E.length ? E : v).map((([N]) => {
                return G = N, Array.isArray(G) ? `(${G.map(Er).join(", ")})` : `(${Er(G.type)}...)`;
                var G;
              })).join(" | "), L = [];
              for (let N = 1; N < e.length; N++) {
                const G = r.parse(e[N], 1 + L.length);
                if (!G) return null;
                L.push(Er(G.type));
              }
              r.error(`Expected arguments of type ${P}, but found (${L.join(", ")}) instead.`);
            }
            return null;
          }
          static register(e, r) {
            or.definitions = r;
            for (const c in r) e[c] = or;
          }
        }
        function Gr(i, [e, r, c, f]) {
          e = e.evaluate(i), r = r.evaluate(i), c = c.evaluate(i);
          const m = f ? f.evaluate(i) : 1, v = ra(e, r, c, m);
          if (v) throw new Lr(v);
          return new hr(e / 255, r / 255, c / 255, m, !1);
        }
        function qn(i, e) {
          return i in e;
        }
        function $n(i, e) {
          const r = e[i];
          return r === void 0 ? null : r;
        }
        function ji(i) {
          return { type: i };
        }
        function aa(i) {
          if (i instanceof Qa) return aa(i.boundExpression);
          if (i instanceof or && i.name === "error" || i instanceof Sa || i instanceof Ma || i instanceof $t || i instanceof Xt) return !1;
          const e = i instanceof xs || i instanceof ai;
          let r = !0;
          return i.eachChild(((c) => {
            r = e ? r && aa(c) : r && c instanceof rn;
          })), !!r && Go(i) && jo(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Go(i) {
          if (i instanceof or && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof Ma || i instanceof $t) return !1;
          let e = !0;
          return i.eachChild(((r) => {
            e && !Go(r) && (e = !1);
          })), e;
        }
        function so(i) {
          if (i instanceof or && i.name === "feature-state") return !1;
          let e = !0;
          return i.eachChild(((r) => {
            e && !so(r) && (e = !1);
          })), e;
        }
        function jo(i, e) {
          if (i instanceof or && e.indexOf(i.name) >= 0) return !1;
          let r = !0;
          return i.eachChild(((c) => {
            r && !jo(c, e) && (r = !1);
          })), r;
        }
        function Tu(i) {
          return { result: "success", value: i };
        }
        function Pa(i) {
          return { result: "error", value: i };
        }
        function Aa(i) {
          return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
        }
        function Cl(i) {
          return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
        }
        function Vo(i) {
          return !!i.expression && i.expression.interpolated;
        }
        function mr(i) {
          return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
        }
        function Rc(i) {
          return typeof i == "object" && i !== null && !Array.isArray(i) && Ur(i) === Bi;
        }
        function nm(i) {
          return i;
        }
        function Zf(i, e) {
          const r = i.stops && typeof i.stops[0][0] == "object", c = r || !(r || i.property !== void 0), f = i.type || (Vo(e) ? "exponential" : "interval"), m = (function(L) {
            switch (L.type) {
              case "color":
                return hr.parse;
              case "padding":
                return ii.parse;
              case "numberArray":
                return en.parse;
              case "colorArray":
                return Qt.parse;
              default:
                return null;
            }
          })(e);
          if (m && ((i = bn({}, i)).stops && (i.stops = i.stops.map(((L) => [L[0], m(L[1])]))), i.default = m(i.default ? i.default : e.default)), i.colorSpace && (v = i.colorSpace) !== "rgb" && v !== "hcl" && v !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
          var v;
          const E = (function(L) {
            switch (L) {
              case "exponential":
                return Hf;
              case "interval":
                return sm;
              case "categorical":
                return im;
              case "identity":
                return am;
              default:
                throw new Error(`Unknown function type "${L}"`);
            }
          })(f);
          let k, P;
          if (f === "categorical") {
            k = /* @__PURE__ */ Object.create(null);
            for (const L of i.stops) k[L[0]] = L[1];
            P = typeof i.stops[0][0];
          }
          if (r) {
            const L = {}, N = [];
            for (let Z = 0; Z < i.stops.length; Z++) {
              const Y = i.stops[Z], X = Y[0].zoom;
              L[X] === void 0 && (L[X] = { zoom: X, type: i.type, property: i.property, default: i.default, stops: [] }, N.push(X)), L[X].stops.push([Y[0].value, Y[1]]);
            }
            const G = [];
            for (const Z of N) G.push([L[Z].zoom, Zf(L[Z], e)]);
            const j = { name: "linear" };
            return { kind: "composite", interpolationType: j, interpolationFactor: xi.interpolationFactor.bind(void 0, j), zoomStops: G.map(((Z) => Z[0])), evaluate: ({ zoom: Z }, Y) => Hf({ stops: G, base: i.base }, e, Z).evaluate(Z, Y) };
          }
          if (c) {
            const L = f === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
            return { kind: "camera", interpolationType: L, interpolationFactor: xi.interpolationFactor.bind(void 0, L), zoomStops: i.stops.map(((N) => N[0])), evaluate: ({ zoom: N }) => E(i, e, N, k, P) };
          }
          return { kind: "source", evaluate(L, N) {
            const G = N && N.properties ? N.properties[i.property] : void 0;
            return G === void 0 ? Su(i.default, e.default) : E(i, e, G, k, P);
          } };
        }
        function Su(i, e, r) {
          return i !== void 0 ? i : e !== void 0 ? e : r !== void 0 ? r : void 0;
        }
        function im(i, e, r, c, f) {
          return Su(typeof r === f ? c[r] : void 0, i.default, e.default);
        }
        function sm(i, e, r) {
          if (mr(r) !== "number") return Su(i.default, e.default);
          const c = i.stops.length;
          if (c === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[c - 1][0]) return i.stops[c - 1][1];
          const f = ro(i.stops.map(((m) => m[0])), r);
          return i.stops[f][1];
        }
        function Hf(i, e, r) {
          const c = i.base !== void 0 ? i.base : 1;
          if (mr(r) !== "number") return Su(i.default, e.default);
          const f = i.stops.length;
          if (f === 1 || r <= i.stops[0][0]) return i.stops[0][1];
          if (r >= i.stops[f - 1][0]) return i.stops[f - 1][1];
          const m = ro(i.stops.map(((L) => L[0])), r), v = (function(L, N, G, j) {
            const Z = j - G, Y = L - G;
            return Z === 0 ? 0 : N === 1 ? Y / Z : (Math.pow(N, Y) - 1) / (Math.pow(N, Z) - 1);
          })(r, c, i.stops[m][0], i.stops[m + 1][0]), E = i.stops[m][1], k = i.stops[m + 1][1], P = Wr[e.type] || nm;
          return typeof E.evaluate == "function" ? { evaluate(...L) {
            const N = E.evaluate.apply(void 0, L), G = k.evaluate.apply(void 0, L);
            if (N !== void 0 && G !== void 0) return P(N, G, v, i.colorSpace);
          } } : P(E, k, v, i.colorSpace);
        }
        function am(i, e, r) {
          switch (e.type) {
            case "color":
              r = hr.parse(r);
              break;
            case "formatted":
              r = Wn.fromString(r.toString());
              break;
            case "resolvedImage":
              r = dr.fromString(r.toString());
              break;
            case "padding":
              r = ii.parse(r);
              break;
            case "colorArray":
              r = Qt.parse(r);
              break;
            case "numberArray":
              r = en.parse(r);
              break;
            default:
              mr(r) === e.type || e.type === "enum" && e.values[r] || (r = void 0);
          }
          return Su(r, i.default, e.default);
        }
        or.register(_r, { error: [{ kind: "error" }, [ir], (i, [e]) => {
          throw new Lr(e.evaluate(i));
        }], typeof: [ir, [Ee], (i, [e]) => Er(Ur(e.evaluate(i)))], "to-rgba": [Or(xt, 4), [pn], (i, [e]) => {
          const [r, c, f, m] = e.evaluate(i).rgb;
          return [255 * r, 255 * c, 255 * f, m];
        }], rgb: [pn, [xt, xt, xt], Gr], rgba: [pn, [xt, xt, xt, xt], Gr], has: { type: rr, overloads: [[[ir], (i, [e]) => qn(e.evaluate(i), i.properties())], [[ir, Bi], (i, [e, r]) => qn(e.evaluate(i), r.evaluate(i))]] }, get: { type: Ee, overloads: [[[ir], (i, [e]) => $n(e.evaluate(i), i.properties())], [[ir, Bi], (i, [e, r]) => $n(e.evaluate(i), r.evaluate(i))]] }, "feature-state": [Ee, [ir], (i, [e]) => $n(e.evaluate(i), i.featureState || {})], properties: [Bi, [], (i) => i.properties()], "geometry-type": [ir, [], (i) => i.geometryType()], id: [Ee, [], (i) => i.id()], zoom: [xt, [], (i) => i.globals.zoom], "heatmap-density": [xt, [], (i) => i.globals.heatmapDensity || 0], elevation: [xt, [], (i) => i.globals.elevation || 0], "line-progress": [xt, [], (i) => i.globals.lineProgress || 0], accumulated: [Ee, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [xt, ji(xt), (i, e) => {
          let r = 0;
          for (const c of e) r += c.evaluate(i);
          return r;
        }], "*": [xt, ji(xt), (i, e) => {
          let r = 1;
          for (const c of e) r *= c.evaluate(i);
          return r;
        }], "-": { type: xt, overloads: [[[xt, xt], (i, [e, r]) => e.evaluate(i) - r.evaluate(i)], [[xt], (i, [e]) => -e.evaluate(i)]] }, "/": [xt, [xt, xt], (i, [e, r]) => e.evaluate(i) / r.evaluate(i)], "%": [xt, [xt, xt], (i, [e, r]) => e.evaluate(i) % r.evaluate(i)], ln2: [xt, [], () => Math.LN2], pi: [xt, [], () => Math.PI], e: [xt, [], () => Math.E], "^": [xt, [xt, xt], (i, [e, r]) => Math.pow(e.evaluate(i), r.evaluate(i))], sqrt: [xt, [xt], (i, [e]) => Math.sqrt(e.evaluate(i))], log10: [xt, [xt], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN10], ln: [xt, [xt], (i, [e]) => Math.log(e.evaluate(i))], log2: [xt, [xt], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN2], sin: [xt, [xt], (i, [e]) => Math.sin(e.evaluate(i))], cos: [xt, [xt], (i, [e]) => Math.cos(e.evaluate(i))], tan: [xt, [xt], (i, [e]) => Math.tan(e.evaluate(i))], asin: [xt, [xt], (i, [e]) => Math.asin(e.evaluate(i))], acos: [xt, [xt], (i, [e]) => Math.acos(e.evaluate(i))], atan: [xt, [xt], (i, [e]) => Math.atan(e.evaluate(i))], min: [xt, ji(xt), (i, e) => Math.min(...e.map(((r) => r.evaluate(i))))], max: [xt, ji(xt), (i, e) => Math.max(...e.map(((r) => r.evaluate(i))))], abs: [xt, [xt], (i, [e]) => Math.abs(e.evaluate(i))], round: [xt, [xt], (i, [e]) => {
          const r = e.evaluate(i);
          return r < 0 ? -Math.round(-r) : Math.round(r);
        }], floor: [xt, [xt], (i, [e]) => Math.floor(e.evaluate(i))], ceil: [xt, [xt], (i, [e]) => Math.ceil(e.evaluate(i))], "filter-==": [rr, [ir, Ee], (i, [e, r]) => i.properties()[e.value] === r.value], "filter-id-==": [rr, [Ee], (i, [e]) => i.id() === e.value], "filter-type-==": [rr, [ir], (i, [e]) => i.geometryType() === e.value], "filter-<": [rr, [ir, Ee], (i, [e, r]) => {
          const c = i.properties()[e.value], f = r.value;
          return typeof c == typeof f && c < f;
        }], "filter-id-<": [rr, [Ee], (i, [e]) => {
          const r = i.id(), c = e.value;
          return typeof r == typeof c && r < c;
        }], "filter->": [rr, [ir, Ee], (i, [e, r]) => {
          const c = i.properties()[e.value], f = r.value;
          return typeof c == typeof f && c > f;
        }], "filter-id->": [rr, [Ee], (i, [e]) => {
          const r = i.id(), c = e.value;
          return typeof r == typeof c && r > c;
        }], "filter-<=": [rr, [ir, Ee], (i, [e, r]) => {
          const c = i.properties()[e.value], f = r.value;
          return typeof c == typeof f && c <= f;
        }], "filter-id-<=": [rr, [Ee], (i, [e]) => {
          const r = i.id(), c = e.value;
          return typeof r == typeof c && r <= c;
        }], "filter->=": [rr, [ir, Ee], (i, [e, r]) => {
          const c = i.properties()[e.value], f = r.value;
          return typeof c == typeof f && c >= f;
        }], "filter-id->=": [rr, [Ee], (i, [e]) => {
          const r = i.id(), c = e.value;
          return typeof r == typeof c && r >= c;
        }], "filter-has": [rr, [Ee], (i, [e]) => e.value in i.properties()], "filter-has-id": [rr, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [rr, [Or(ir)], (i, [e]) => e.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [rr, [Or(Ee)], (i, [e]) => e.value.indexOf(i.id()) >= 0], "filter-in-small": [rr, [ir, Or(Ee)], (i, [e, r]) => r.value.indexOf(i.properties()[e.value]) >= 0], "filter-in-large": [rr, [ir, Or(Ee)], (i, [e, r]) => (function(c, f, m, v) {
          for (; m <= v; ) {
            const E = m + v >> 1;
            if (f[E] === c) return !0;
            f[E] > c ? v = E - 1 : m = E + 1;
          }
          return !1;
        })(i.properties()[e.value], r.value, 0, r.value.length - 1)], all: { type: rr, overloads: [[[rr, rr], (i, [e, r]) => e.evaluate(i) && r.evaluate(i)], [ji(rr), (i, e) => {
          for (const r of e) if (!r.evaluate(i)) return !1;
          return !0;
        }]] }, any: { type: rr, overloads: [[[rr, rr], (i, [e, r]) => e.evaluate(i) || r.evaluate(i)], [ji(rr), (i, e) => {
          for (const r of e) if (r.evaluate(i)) return !0;
          return !1;
        }]] }, "!": [rr, [rr], (i, [e]) => !e.evaluate(i)], "is-supported-script": [rr, [ir], (i, [e]) => {
          const r = i.globals && i.globals.isSupportedScript;
          return !r || r(e.evaluate(i));
        }], upcase: [ir, [ir], (i, [e]) => e.evaluate(i).toUpperCase()], downcase: [ir, [ir], (i, [e]) => e.evaluate(i).toLowerCase()], concat: [ir, ji(Ee), (i, e) => e.map(((r) => na(r.evaluate(i)))).join("")], "resolved-locale": [ir, [zt], (i, [e]) => e.evaluate(i).resolvedLocale()] });
        class rd {
          constructor(e, r, c) {
            this.expression = e, this._warningHistory = {}, this._evaluator = new xl(), this._defaultValue = r ? (function(f) {
              if (f.type === "color" && Rc(f.default)) return new hr(0, 0, 0, 0);
              switch (f.type) {
                case "color":
                  return hr.parse(f.default) || null;
                case "padding":
                  return ii.parse(f.default) || null;
                case "numberArray":
                  return en.parse(f.default) || null;
                case "colorArray":
                  return Qt.parse(f.default) || null;
                case "variableAnchorOffsetCollection":
                  return si.parse(f.default) || null;
                case "projectionDefinition":
                  return tn.parse(f.default) || null;
                default:
                  return f.default === void 0 ? null : f.default;
              }
            })(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null, this._globalState = c;
          }
          evaluateWithoutErrorHandling(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = r, this._evaluator.featureState = c, this._evaluator.canonical = f, this._evaluator.availableImages = m || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
          }
          evaluate(e, r, c, f, m, v) {
            this._globalState && (e = Uo(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = r || null, this._evaluator.featureState = c || null, this._evaluator.canonical = f, this._evaluator.availableImages = m || null, this._evaluator.formattedSection = v || null;
            try {
              const E = this.expression.evaluate(this._evaluator);
              if (E == null || typeof E == "number" && E != E) return this._defaultValue;
              if (this._enumValues && !(E in this._enumValues)) throw new Lr(`Expected value to be one of ${Object.keys(this._enumValues).map(((k) => JSON.stringify(k))).join(", ")}, but found ${JSON.stringify(E)} instead.`);
              return E;
            } catch (E) {
              return this._warningHistory[E.message] || (this._warningHistory[E.message] = !0, typeof console < "u" && console.warn(E.message)), this._defaultValue;
            }
          }
        }
        function Pl(i) {
          return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in _r;
        }
        function ku(i, e, r) {
          const c = new vi(_r, aa, [], e ? (function(m) {
            const v = { color: pn, string: ir, number: xt, enum: ir, boolean: rr, formatted: bt, padding: Tr, numberArray: Cr, colorArray: Qr, projectionDefinition: zi, resolvedImage: Cn, variableAnchorOffsetCollection: Fn };
            return m.type === "array" ? Or(v[m.value] || Ee, m.length) : v[m.type];
          })(e) : void 0), f = c.parse(i, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return f ? Tu(new rd(f, e, r)) : Pa(c.errors);
        }
        class Fc {
          constructor(e, r, c) {
            this.kind = e, this._styleExpression = r, this.isStateDependent = e !== "constant" && !so(r.expression), this.globalStateRefs = ao(r.expression), this._globalState = c;
          }
          evaluateWithoutErrorHandling(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, r, c, f, m, v);
          }
          evaluate(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._styleExpression.evaluate(e, r, c, f, m, v);
          }
        }
        class nd {
          constructor(e, r, c, f, m) {
            this.kind = e, this.zoomStops = c, this._styleExpression = r, this.isStateDependent = e !== "camera" && !so(r.expression), this.globalStateRefs = ao(r.expression), this.interpolationType = f, this._globalState = m;
          }
          evaluateWithoutErrorHandling(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, r, c, f, m, v);
          }
          evaluate(e, r, c, f, m, v) {
            return this._globalState && (e = Uo(e, this._globalState)), this._styleExpression.evaluate(e, r, c, f, m, v);
          }
          interpolationFactor(e, r, c) {
            return this.interpolationType ? xi.interpolationFactor(this.interpolationType, e, r, c) : 0;
          }
        }
        function id(i, e, r) {
          const c = ku(i, e, r);
          if (c.result === "error") return c;
          const f = c.value.expression, m = Go(f);
          if (!m && !Aa(e)) return Pa([new Un("", "data expressions not supported")]);
          const v = jo(f, ["zoom"]);
          if (!v && !Cl(e)) return Pa([new Un("", "zoom expressions not supported")]);
          const E = Oc(f);
          return E || v ? E instanceof Un ? Pa([E]) : E instanceof xi && !Vo(e) ? Pa([new Un("", '"interpolate" expressions cannot be used with this property')]) : Tu(E ? new nd(m ? "camera" : "composite", c.value, E.labels, E instanceof xi ? E.interpolation : void 0, r) : new Fc(m ? "constant" : "source", c.value, r)) : Pa([new Un("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Nc {
          constructor(e, r) {
            this._parameters = e, this._specification = r, bn(this, Zf(this._parameters, this._specification));
          }
          static deserialize(e) {
            return new Nc(e._parameters, e._specification);
          }
          static serialize(e) {
            return { _parameters: e._parameters, _specification: e._specification };
          }
        }
        function Oc(i) {
          let e = null;
          if (i instanceof Dr) e = Oc(i.result);
          else if (i instanceof Gi) {
            for (const r of i.args) if (e = Oc(r), e) break;
          } else (i instanceof Jn || i instanceof xi) && i.input instanceof or && i.input.name === "zoom" && (e = i);
          return e instanceof Un || i.eachChild(((r) => {
            const c = Oc(r);
            c instanceof Un ? e = c : !e && c ? e = new Un("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && c && e !== c && (e = new Un("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), e;
        }
        function ao(i, e = /* @__PURE__ */ new Set()) {
          return i instanceof Xt && e.add(i.key), i.eachChild(((r) => {
            ao(r, e);
          })), e;
        }
        function Uo(i, e) {
          const { zoom: r, heatmapDensity: c, elevation: f, lineProgress: m, isSupportedScript: v, accumulated: E } = i ?? {};
          return { zoom: r, heatmapDensity: c, elevation: f, lineProgress: m, isSupportedScript: v, accumulated: E, globalState: e };
        }
        function sd(i) {
          if (i === !0 || i === !1) return !0;
          if (!Array.isArray(i) || i.length === 0) return !1;
          switch (i[0]) {
            case "has":
              return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
            case "in":
              return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
            case "any":
            case "all":
              for (const e of i.slice(1)) if (!sd(e) && typeof e != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const om = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function Iu(i, e) {
          if (i == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          sd(i) || (i = Mu(i));
          const r = ku(i, om, e);
          if (r.result === "error") throw new Error(r.value.map(((c) => `${c.key}: ${c.message}`)).join(", "));
          return { filter: (c, f, m) => r.value.evaluate(c, f, {}, m), needGeometry: Yf(i), getGlobalStateRefs: () => ao(r.value.expression) };
        }
        function lm(i, e) {
          return i < e ? -1 : i > e ? 1 : 0;
        }
        function Yf(i) {
          if (!Array.isArray(i)) return !1;
          if (i[0] === "within" || i[0] === "distance") return !0;
          for (let e = 1; e < i.length; e++) if (Yf(i[e])) return !0;
          return !1;
        }
        function Mu(i) {
          if (!i) return !0;
          const e = i[0];
          return i.length <= 1 ? e !== "any" : e === "==" ? zc(i[1], i[2], "==") : e === "!=" ? Cu(zc(i[1], i[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? zc(i[1], i[2], e) : e === "any" ? (r = i.slice(1), ["any"].concat(r.map(Mu))) : e === "all" ? ["all"].concat(i.slice(1).map(Mu)) : e === "none" ? ["all"].concat(i.slice(1).map(Mu).map(Cu)) : e === "in" ? Wf(i[1], i.slice(2)) : e === "!in" ? Cu(Wf(i[1], i.slice(2))) : e === "has" ? Xf(i[1]) : e !== "!has" || Cu(Xf(i[1]));
          var r;
        }
        function zc(i, e, r) {
          switch (i) {
            case "$type":
              return [`filter-type-${r}`, e];
            case "$id":
              return [`filter-id-${r}`, e];
            default:
              return [`filter-${r}`, i, e];
          }
        }
        function Wf(i, e) {
          if (e.length === 0) return !1;
          switch (i) {
            case "$type":
              return ["filter-type-in", ["literal", e]];
            case "$id":
              return ["filter-id-in", ["literal", e]];
            default:
              return e.length > 200 && !e.some(((r) => typeof r != typeof e[0])) ? ["filter-in-large", i, ["literal", e.sort(lm)]] : ["filter-in-small", i, ["literal", e]];
          }
        }
        function Xf(i) {
          switch (i) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", i];
          }
        }
        function Cu(i) {
          return ["!", i];
        }
        function Bc(i) {
          const e = typeof i;
          if (e === "number" || e === "boolean" || e === "string" || i == null) return JSON.stringify(i);
          if (Array.isArray(i)) {
            let f = "[";
            for (const m of i) f += `${Bc(m)},`;
            return `${f}]`;
          }
          const r = Object.keys(i).sort();
          let c = "{";
          for (let f = 0; f < r.length; f++) c += `${JSON.stringify(r[f])}:${Bc(i[r[f]])},`;
          return `${c}}`;
        }
        function Jf(i) {
          let e = "";
          for (const r of Rr) e += `/${Bc(i[r])}`;
          return e;
        }
        function Kf(i) {
          const e = i.value;
          return e ? [new yt(i.key, e, "constants have been deprecated as of v8")] : [];
        }
        function Pn(i) {
          return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
        }
        function qo(i) {
          if (Array.isArray(i)) return i.map(qo);
          if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
            const e = {};
            for (const r in i) e[r] = qo(i[r]);
            return e;
          }
          return Pn(i);
        }
        function as(i) {
          const e = i.key, r = i.value, c = i.valueSpec || {}, f = i.objectElementValidators || {}, m = i.style, v = i.styleSpec, E = i.validateSpec;
          let k = [];
          const P = mr(r);
          if (P !== "object") return [new yt(e, r, `object expected, ${P} found`)];
          for (const L in r) {
            const N = L.split(".")[0], G = Rs(c, N) || c["*"];
            let j;
            if (Rs(f, N)) j = f[N];
            else if (Rs(c, N)) {
              if (r[L] === void 0) continue;
              j = E;
            } else if (f["*"]) j = f["*"];
            else {
              if (!c["*"]) {
                k.push(new yt(e, r[L], `unknown property "${L}"`));
                continue;
              }
              j = E;
            }
            k = k.concat(j({ key: (e && `${e}.`) + L, value: r[L], valueSpec: G, style: m, styleSpec: v, object: r, objectKey: L, validateSpec: E }, r));
          }
          for (const L in c) f[L] || c[L].required && c[L].default === void 0 && r[L] === void 0 && k.push(new yt(e, r, `missing required property "${L}"`));
          return k;
        }
        function Gc(i) {
          const e = i.value, r = i.valueSpec, c = i.style, f = i.styleSpec, m = i.key, v = i.arrayElementValidator || i.validateSpec;
          if (mr(e) !== "array") return [new yt(m, e, `array expected, ${mr(e)} found`)];
          if (r.length && e.length !== r.length) return [new yt(m, e, `array length ${r.length} expected, length ${e.length} found`)];
          let E = { type: r.value, values: r.values };
          f.$version < 7 && (E.function = r.function), mr(r.value) === "object" && (E = r.value);
          let k = [];
          for (let P = 0; P < e.length; P++) k = k.concat(v({ array: e, arrayIndex: P, value: e[P], valueSpec: E, validateSpec: i.validateSpec, style: c, styleSpec: f, key: `${m}[${P}]` }));
          return k;
        }
        function Pu(i) {
          const e = i.key, r = i.value, c = i.valueSpec;
          let f = mr(r);
          return f === "number" && r != r && (f = "NaN"), f !== "number" ? [new yt(e, r, `number expected, ${f} found`)] : "minimum" in c && r < c.minimum ? [new yt(e, r, `${r} is less than the minimum value ${c.minimum}`)] : "maximum" in c && r > c.maximum ? [new yt(e, r, `${r} is greater than the maximum value ${c.maximum}`)] : [];
        }
        function jc(i) {
          const e = i.valueSpec, r = Pn(i.value.type);
          let c, f, m, v = {};
          const E = r !== "categorical" && i.value.property === void 0, k = !E, P = mr(i.value.stops) === "array" && mr(i.value.stops[0]) === "array" && mr(i.value.stops[0][0]) === "object", L = as({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(j) {
            if (r === "identity") return [new yt(j.key, j.value, 'identity function may not have a "stops" property')];
            let Z = [];
            const Y = j.value;
            return Z = Z.concat(Gc({ key: j.key, value: Y, valueSpec: j.valueSpec, validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec, arrayElementValidator: N })), mr(Y) === "array" && Y.length === 0 && Z.push(new yt(j.key, Y, "array must have at least one stop")), Z;
          }, default: function(j) {
            return j.validateSpec({ key: j.key, value: j.value, valueSpec: e, validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec });
          } } });
          return r === "identity" && E && L.push(new yt(i.key, i.value, 'missing required property "property"')), r === "identity" || i.value.stops || L.push(new yt(i.key, i.value, 'missing required property "stops"')), r === "exponential" && i.valueSpec.expression && !Vo(i.valueSpec) && L.push(new yt(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (k && !Aa(i.valueSpec) ? L.push(new yt(i.key, i.value, "property functions not supported")) : E && !Cl(i.valueSpec) && L.push(new yt(i.key, i.value, "zoom functions not supported"))), r !== "categorical" && !P || i.value.property !== void 0 || L.push(new yt(i.key, i.value, '"property" property is required')), L;
          function N(j) {
            let Z = [];
            const Y = j.value, X = j.key;
            if (mr(Y) !== "array") return [new yt(X, Y, `array expected, ${mr(Y)} found`)];
            if (Y.length !== 2) return [new yt(X, Y, `array length 2 expected, length ${Y.length} found`)];
            if (P) {
              if (mr(Y[0]) !== "object") return [new yt(X, Y, `object expected, ${mr(Y[0])} found`)];
              if (Y[0].zoom === void 0) return [new yt(X, Y, "object stop key must have zoom")];
              if (Y[0].value === void 0) return [new yt(X, Y, "object stop key must have value")];
              if (m && m > Pn(Y[0].zoom)) return [new yt(X, Y[0].zoom, "stop zoom values must appear in ascending order")];
              Pn(Y[0].zoom) !== m && (m = Pn(Y[0].zoom), f = void 0, v = {}), Z = Z.concat(as({ key: `${X}[0]`, value: Y[0], valueSpec: { zoom: {} }, validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec, objectElementValidators: { zoom: Pu, value: G } }));
            } else Z = Z.concat(G({ key: `${X}[0]`, value: Y[0], validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec }, Y));
            return Pl(qo(Y[1])) ? Z.concat([new yt(`${X}[1]`, Y[1], "expressions are not allowed in function stops.")]) : Z.concat(j.validateSpec({ key: `${X}[1]`, value: Y[1], valueSpec: e, validateSpec: j.validateSpec, style: j.style, styleSpec: j.styleSpec }));
          }
          function G(j, Z) {
            const Y = mr(j.value), X = Pn(j.value), ne = j.value !== null ? j.value : Z;
            if (c) {
              if (Y !== c) return [new yt(j.key, ne, `${Y} stop domain type must match previous stop domain type ${c}`)];
            } else c = Y;
            if (Y !== "number" && Y !== "string" && Y !== "boolean") return [new yt(j.key, ne, "stop domain value must be a number, string, or boolean")];
            if (Y !== "number" && r !== "categorical") {
              let xe = `number expected, ${Y} found`;
              return Aa(e) && r === void 0 && (xe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new yt(j.key, ne, xe)];
            }
            return r !== "categorical" || Y !== "number" || isFinite(X) && Math.floor(X) === X ? r !== "categorical" && Y === "number" && f !== void 0 && X < f ? [new yt(j.key, ne, "stop domain values must appear in ascending order")] : (f = X, r === "categorical" && X in v ? [new yt(j.key, ne, "stop domain values must be unique")] : (v[X] = !0, [])) : [new yt(j.key, ne, `integer expected, found ${X}`)];
          }
        }
        function oo(i) {
          const e = (i.expressionContext === "property" ? id : ku)(qo(i.value), i.valueSpec);
          if (e.result === "error") return e.value.map(((c) => new yt(`${i.key}${c.key}`, i.value, c.message)));
          const r = e.value.expression || e.value._styleExpression.expression;
          if (i.expressionContext === "property" && i.propertyKey === "text-font" && !r.outputDefined()) return [new yt(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (i.expressionContext === "property" && i.propertyType === "layout" && !so(r)) return [new yt(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (i.expressionContext === "filter" && !so(r)) return [new yt(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
          if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
            if (!jo(r, ["zoom", "feature-state"])) return [new yt(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (i.expressionContext === "cluster-initial" && !Go(r)) return [new yt(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function Au(i) {
          const e = i.key, r = i.value, c = mr(r);
          return c !== "string" ? [new yt(e, r, `color expected, ${c} found`)] : hr.parse(String(r)) ? [] : [new yt(e, r, `color expected, "${r}" found`)];
        }
        function $o(i) {
          const e = i.key, r = i.value, c = i.valueSpec, f = [];
          return Array.isArray(c.values) ? c.values.indexOf(Pn(r)) === -1 && f.push(new yt(e, r, `expected one of [${c.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(c.values).indexOf(Pn(r)) === -1 && f.push(new yt(e, r, `expected one of [${Object.keys(c.values).join(", ")}], ${JSON.stringify(r)} found`)), f;
        }
        function Al(i) {
          return sd(qo(i.value)) ? oo(bn({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Qf(i);
        }
        function Qf(i) {
          const e = i.value, r = i.key;
          if (mr(e) !== "array") return [new yt(r, e, `array expected, ${mr(e)} found`)];
          const c = i.styleSpec;
          let f, m = [];
          if (e.length < 1) return [new yt(r, e, "filter array must have at least 1 element")];
          switch (m = m.concat($o({ key: `${r}[0]`, value: e[0], valueSpec: c.filter_operator, style: i.style, styleSpec: i.styleSpec })), Pn(e[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e.length >= 2 && Pn(e[1]) === "$type" && m.push(new yt(r, e, `"$type" cannot be use with operator "${e[0]}"`));
            case "==":
            case "!=":
              e.length !== 3 && m.push(new yt(r, e, `filter array for operator "${e[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e.length >= 2 && (f = mr(e[1]), f !== "string" && m.push(new yt(`${r}[1]`, e[1], `string expected, ${f} found`)));
              for (let v = 2; v < e.length; v++) f = mr(e[v]), Pn(e[1]) === "$type" ? m = m.concat($o({ key: `${r}[${v}]`, value: e[v], valueSpec: c.geometry_type, style: i.style, styleSpec: i.styleSpec })) : f !== "string" && f !== "number" && f !== "boolean" && m.push(new yt(`${r}[${v}]`, e[v], `string, number, or boolean expected, ${f} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let v = 1; v < e.length; v++) m = m.concat(Qf({ key: `${r}[${v}]`, value: e[v], style: i.style, styleSpec: i.styleSpec }));
              break;
            case "has":
            case "!has":
              f = mr(e[1]), e.length !== 2 ? m.push(new yt(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : f !== "string" && m.push(new yt(`${r}[1]`, e[1], `string expected, ${f} found`));
          }
          return m;
        }
        function ep(i, e) {
          const r = i.key, c = i.validateSpec, f = i.style, m = i.styleSpec, v = i.value, E = i.objectKey, k = m[`${e}_${i.layerType}`];
          if (!k) return [];
          const P = E.match(/^(.*)-transition$/);
          if (e === "paint" && P && k[P[1]] && k[P[1]].transition) return c({ key: r, value: v, valueSpec: m.transition, style: f, styleSpec: m });
          const L = i.valueSpec || k[E];
          if (!L) return [new yt(r, v, `unknown property "${E}"`)];
          let N;
          if (mr(v) === "string" && Aa(L) && !L.tokens && (N = /^{([^}]+)}$/.exec(v))) return [new yt(r, v, `"${E}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(N[1])} }\`.`)];
          const G = [];
          return i.layerType === "symbol" && E === "text-font" && Rc(qo(v)) && Pn(v.type) === "identity" && G.push(new yt(r, v, '"text-font" does not support identity functions')), G.concat(c({ key: i.key, value: v, valueSpec: L, style: f, styleSpec: m, expressionContext: "property", propertyType: e, propertyKey: E }));
        }
        function tp(i) {
          return ep(i, "paint");
        }
        function rp(i) {
          return ep(i, "layout");
        }
        function np(i) {
          let e = [];
          const r = i.value, c = i.key, f = i.style, m = i.styleSpec;
          if (mr(r) !== "object") return [new yt(c, r, `object expected, ${mr(r)} found`)];
          r.type || r.ref || e.push(new yt(c, r, 'either "type" or "ref" is required'));
          let v = Pn(r.type);
          const E = Pn(r.ref);
          if (r.id) {
            const k = Pn(r.id);
            for (let P = 0; P < i.arrayIndex; P++) {
              const L = f.layers[P];
              Pn(L.id) === k && e.push(new yt(c, r.id, `duplicate layer id "${r.id}", previously used at line ${L.id.__line__}`));
            }
          }
          if ("ref" in r) {
            let k;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((P) => {
              P in r && e.push(new yt(c, r[P], `"${P}" is prohibited for ref layers`));
            })), f.layers.forEach(((P) => {
              Pn(P.id) === E && (k = P);
            })), k ? k.ref ? e.push(new yt(c, r.ref, "ref cannot reference another ref layer")) : v = Pn(k.type) : e.push(new yt(c, r.ref, `ref layer "${E}" not found`));
          } else if (v !== "background") if (r.source) {
            const k = f.sources && f.sources[r.source], P = k && Pn(k.type);
            k ? P === "vector" && v === "raster" ? e.push(new yt(c, r.source, `layer "${r.id}" requires a raster source`)) : P !== "raster-dem" && v === "hillshade" || P !== "raster-dem" && v === "color-relief" ? e.push(new yt(c, r.source, `layer "${r.id}" requires a raster-dem source`)) : P === "raster" && v !== "raster" ? e.push(new yt(c, r.source, `layer "${r.id}" requires a vector source`)) : P !== "vector" || r["source-layer"] ? P === "raster-dem" && v !== "hillshade" && v !== "color-relief" ? e.push(new yt(c, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : v !== "line" || !r.paint || !r.paint["line-gradient"] || P === "geojson" && k.lineMetrics || e.push(new yt(c, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new yt(c, r, `layer "${r.id}" must specify a "source-layer"`)) : e.push(new yt(c, r.source, `source "${r.source}" not found`));
          } else e.push(new yt(c, r, 'missing required property "source"'));
          return e = e.concat(as({ key: c, value: r, valueSpec: m.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${c}.type`, value: r.type, valueSpec: m.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: r, objectKey: "type" }), filter: Al, layout: (k) => as({ layer: r, key: k.key, value: k.value, style: k.style, styleSpec: k.styleSpec, validateSpec: k.validateSpec, objectElementValidators: { "*": (P) => rp(bn({ layerType: v }, P)) } }), paint: (k) => as({ layer: r, key: k.key, value: k.value, style: k.style, styleSpec: k.styleSpec, validateSpec: k.validateSpec, objectElementValidators: { "*": (P) => tp(bn({ layerType: v }, P)) } }) } })), e;
        }
        function lo(i) {
          const e = i.value, r = i.key, c = mr(e);
          return c !== "string" ? [new yt(r, e, `string expected, ${c} found`)] : [];
        }
        const ad = { promoteId: function({ key: i, value: e }) {
          if (mr(e) === "string") return lo({ key: i, value: e });
          {
            const r = [];
            for (const c in e) r.push(...lo({ key: `${i}.${c}`, value: e[c] }));
            return r;
          }
        } };
        function od(i) {
          const e = i.value, r = i.key, c = i.styleSpec, f = i.style, m = i.validateSpec;
          if (!e.type) return [new yt(r, e, '"type" is required')];
          const v = Pn(e.type);
          let E;
          switch (v) {
            case "vector":
            case "raster":
              return E = as({ key: r, value: e, valueSpec: c[`source_${v.replace("-", "_")}`], style: i.style, styleSpec: c, objectElementValidators: ad, validateSpec: m }), E;
            case "raster-dem":
              return E = (function(k) {
                var P;
                const L = (P = k.sourceName) !== null && P !== void 0 ? P : "", N = k.value, G = k.styleSpec, j = G.source_raster_dem, Z = k.style;
                let Y = [];
                const X = mr(N);
                if (N === void 0) return Y;
                if (X !== "object") return Y.push(new yt("source_raster_dem", N, `object expected, ${X} found`)), Y;
                const ne = Pn(N.encoding) === "custom", xe = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ae = k.value.encoding ? `"${k.value.encoding}"` : "Default";
                for (const ue in N) !ne && xe.includes(ue) ? Y.push(new yt(ue, N[ue], `In "${L}": "${ue}" is only valid when "encoding" is set to "custom". ${ae} encoding found`)) : j[ue] ? Y = Y.concat(k.validateSpec({ key: ue, value: N[ue], valueSpec: j[ue], validateSpec: k.validateSpec, style: Z, styleSpec: G })) : Y.push(new yt(ue, N[ue], `unknown property "${ue}"`));
                return Y;
              })({ sourceName: r, value: e, style: i.style, styleSpec: c, validateSpec: m }), E;
            case "geojson":
              if (E = as({ key: r, value: e, valueSpec: c.source_geojson, style: f, styleSpec: c, validateSpec: m, objectElementValidators: ad }), e.cluster) for (const k in e.clusterProperties) {
                const [P, L] = e.clusterProperties[k], N = typeof P == "string" ? [P, ["accumulated"], ["get", k]] : P;
                E.push(...oo({ key: `${r}.${k}.map`, value: L, expressionContext: "cluster-map" })), E.push(...oo({ key: `${r}.${k}.reduce`, value: N, expressionContext: "cluster-reduce" }));
              }
              return E;
            case "video":
              return as({ key: r, value: e, valueSpec: c.source_video, style: f, validateSpec: m, styleSpec: c });
            case "image":
              return as({ key: r, value: e, valueSpec: c.source_image, style: f, validateSpec: m, styleSpec: c });
            case "canvas":
              return [new yt(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return $o({ key: `${r}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Lu(i) {
          const e = i.value, r = i.styleSpec, c = r.light, f = i.style;
          let m = [];
          const v = mr(e);
          if (e === void 0) return m;
          if (v !== "object") return m = m.concat([new yt("light", e, `object expected, ${v} found`)]), m;
          for (const E in e) {
            const k = E.match(/^(.*)-transition$/);
            m = m.concat(k && c[k[1]] && c[k[1]].transition ? i.validateSpec({ key: E, value: e[E], valueSpec: r.transition, validateSpec: i.validateSpec, style: f, styleSpec: r }) : c[E] ? i.validateSpec({ key: E, value: e[E], valueSpec: c[E], validateSpec: i.validateSpec, style: f, styleSpec: r }) : [new yt(E, e[E], `unknown property "${E}"`)]);
          }
          return m;
        }
        function ip(i) {
          const e = i.value, r = i.styleSpec, c = r.sky, f = i.style, m = mr(e);
          if (e === void 0) return [];
          if (m !== "object") return [new yt("sky", e, `object expected, ${m} found`)];
          let v = [];
          for (const E in e) v = v.concat(c[E] ? i.validateSpec({ key: E, value: e[E], valueSpec: c[E], style: f, styleSpec: r }) : [new yt(E, e[E], `unknown property "${E}"`)]);
          return v;
        }
        function ld(i) {
          const e = i.value, r = i.styleSpec, c = r.terrain, f = i.style;
          let m = [];
          const v = mr(e);
          if (e === void 0) return m;
          if (v !== "object") return m = m.concat([new yt("terrain", e, `object expected, ${v} found`)]), m;
          for (const E in e) m = m.concat(c[E] ? i.validateSpec({ key: E, value: e[E], valueSpec: c[E], validateSpec: i.validateSpec, style: f, styleSpec: r }) : [new yt(E, e[E], `unknown property "${E}"`)]);
          return m;
        }
        function ud(i) {
          let e = [];
          const r = i.value, c = i.key;
          if (Array.isArray(r)) {
            const f = [], m = [];
            for (const v in r) r[v].id && f.includes(r[v].id) && e.push(new yt(c, r, `all the sprites' ids must be unique, but ${r[v].id} is duplicated`)), f.push(r[v].id), r[v].url && m.includes(r[v].url) && e.push(new yt(c, r, `all the sprites' URLs must be unique, but ${r[v].url} is duplicated`)), m.push(r[v].url), e = e.concat(as({ key: `${c}[${v}]`, value: r[v], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
            return e;
          }
          return lo({ key: c, value: r });
        }
        function sp(i) {
          return !!i && i.constructor === Object;
        }
        function cd(i) {
          return sp(i.value) ? [] : [new yt(i.key, i.value, `object expected, ${mr(i.value)} found`)];
        }
        const hd = { "*": () => [], array: Gc, boolean: function(i) {
          const e = i.value, r = i.key, c = mr(e);
          return c !== "boolean" ? [new yt(r, e, `boolean expected, ${c} found`)] : [];
        }, number: Pu, color: Au, constants: Kf, enum: $o, filter: Al, function: jc, layer: np, object: as, source: od, light: Lu, sky: ip, terrain: ld, projection: function(i) {
          const e = i.value, r = i.styleSpec, c = r.projection, f = i.style, m = mr(e);
          if (e === void 0) return [];
          if (m !== "object") return [new yt("projection", e, `object expected, ${m} found`)];
          let v = [];
          for (const E in e) v = v.concat(c[E] ? i.validateSpec({ key: E, value: e[E], valueSpec: c[E], style: f, styleSpec: r }) : [new yt(E, e[E], `unknown property "${E}"`)]);
          return v;
        }, projectionDefinition: function(i) {
          const e = i.key;
          let r = i.value;
          r = r instanceof String ? r.valueOf() : r;
          const c = mr(r);
          return c !== "array" || (function(f) {
            return Array.isArray(f) && f.length === 3 && typeof f[0] == "string" && typeof f[1] == "string" && typeof f[2] == "number";
          })(r) || (function(f) {
            return !!["interpolate", "step", "literal"].includes(f[0]);
          })(r) ? ["array", "string"].includes(c) ? [] : [new yt(e, r, `projection expected, invalid type "${c}" found`)] : [new yt(e, r, `projection expected, invalid array ${JSON.stringify(r)} found`)];
        }, string: lo, formatted: function(i) {
          return lo(i).length === 0 ? [] : oo(i);
        }, resolvedImage: function(i) {
          return lo(i).length === 0 ? [] : oo(i);
        }, padding: function(i) {
          const e = i.key, r = i.value;
          if (mr(r) === "array") {
            if (r.length < 1 || r.length > 4) return [new yt(e, r, `padding requires 1 to 4 values; ${r.length} values found`)];
            const c = { type: "number" };
            let f = [];
            for (let m = 0; m < r.length; m++) f = f.concat(i.validateSpec({ key: `${e}[${m}]`, value: r[m], validateSpec: i.validateSpec, valueSpec: c }));
            return f;
          }
          return Pu({ key: e, value: r, valueSpec: {} });
        }, numberArray: function(i) {
          const e = i.key, r = i.value;
          if (mr(r) === "array") {
            const c = { type: "number" };
            if (r.length < 1) return [new yt(e, r, "array length at least 1 expected, length 0 found")];
            let f = [];
            for (let m = 0; m < r.length; m++) f = f.concat(i.validateSpec({ key: `${e}[${m}]`, value: r[m], validateSpec: i.validateSpec, valueSpec: c }));
            return f;
          }
          return Pu({ key: e, value: r, valueSpec: {} });
        }, colorArray: function(i) {
          const e = i.key, r = i.value;
          if (mr(r) === "array") {
            if (r.length < 1) return [new yt(e, r, "array length at least 1 expected, length 0 found")];
            let c = [];
            for (let f = 0; f < r.length; f++) c = c.concat(Au({ key: `${e}[${f}]`, value: r[f] }));
            return c;
          }
          return Au({ key: e, value: r });
        }, variableAnchorOffsetCollection: function(i) {
          const e = i.key, r = i.value, c = mr(r), f = i.styleSpec;
          if (c !== "array" || r.length < 1 || r.length % 2 != 0) return [new yt(e, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let m = [];
          for (let v = 0; v < r.length; v += 2) m = m.concat($o({ key: `${e}[${v}]`, value: r[v], valueSpec: f.layout_symbol["text-anchor"] })), m = m.concat(Gc({ key: `${e}[${v + 1}]`, value: r[v + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: f }));
          return m;
        }, sprite: ud, state: cd, fontFaces: function(i) {
          const e = i.key, r = i.value, c = i.validateSpec, f = i.styleSpec, m = i.style;
          if (!sp(r)) return [new yt(e, r, `object expected, ${mr(r)} found`)];
          const v = [];
          for (const E in r) {
            const k = r[E], P = mr(k);
            if (P === "string") v.push(...lo({ key: `${e}.${E}`, value: k }));
            else if (P === "array") {
              const L = { url: { type: "string", required: !0 }, "unicode-range": { type: "array", value: "string" } };
              for (const [N, G] of k.entries()) v.push(...as({ key: `${e}.${E}[${N}]`, value: G, valueSpec: L, styleSpec: f, style: m, validateSpec: c }));
            } else v.push(new yt(`${e}.${E}`, k, `string or array expected, ${P} found`));
          }
          return v;
        } };
        function uo(i) {
          const e = i.value, r = i.valueSpec, c = i.styleSpec;
          return i.validateSpec = uo, r.expression && Rc(Pn(e)) ? jc(i) : r.expression && Pl(qo(e)) ? oo(i) : r.type && hd[r.type] ? hd[r.type](i) : as(bn({}, i, { valueSpec: r.type ? c[r.type] : r }));
        }
        function ap(i) {
          const e = i.value, r = i.key, c = lo(i);
          return c.length || (e.indexOf("{fontstack}") === -1 && c.push(new yt(r, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && c.push(new yt(r, e, '"glyphs" url must include a "{range}" token'))), c;
        }
        function ws(i, e = Xe) {
          let r = [];
          return r = r.concat(uo({ key: "", value: i, valueSpec: e.$root, styleSpec: e, style: i, validateSpec: uo, objectElementValidators: { glyphs: ap, "*": () => [] } })), i.constants && (r = r.concat(Kf({ key: "constants", value: i.constants }))), op(r);
        }
        function Os(i) {
          return function(e) {
            return i(Object.assign({}, e, { validateSpec: uo }));
          };
        }
        function op(i) {
          return [].concat(i).sort(((e, r) => e.line - r.line));
        }
        function zs(i) {
          return function(...e) {
            return op(i.apply(this, e));
          };
        }
        ws.source = zs(Os(od)), ws.sprite = zs(Os(ud)), ws.glyphs = zs(Os(ap)), ws.light = zs(Os(Lu)), ws.sky = zs(Os(ip)), ws.terrain = zs(Os(ld)), ws.state = zs(Os(cd)), ws.layer = zs(Os(np)), ws.filter = zs(Os(Al)), ws.paintProperty = zs(Os(tp)), ws.layoutProperty = zs(Os(rp));
        const um = { type: "enum", "property-type": "data-constant", expression: { interpolated: !1, parameters: ["global-state"] }, values: { visible: {}, none: {} }, transition: !1, default: "visible" };
        class Du {
          constructor(e, r) {
            this._globalState = r, this.setValue(e);
          }
          evaluate() {
            var e;
            return (e = this._literalValue) !== null && e !== void 0 ? e : this._compiledValue.evaluate({});
          }
          setValue(e) {
            if (e == null || e === "visible" || e === "none") return this._literalValue = e === "none" ? "none" : "visible", this._compiledValue = void 0, void (this._globalStateRefs = /* @__PURE__ */ new Set());
            const r = ku(e, um, this._globalState);
            if (r.result === "error") throw this._literalValue = "visible", this._compiledValue = void 0, new Error(r.value.map(((c) => `${c.key}: ${c.message}`)).join(", "));
            this._literalValue = void 0, this._compiledValue = r.value, this._globalStateRefs = ao(r.value.expression);
          }
          getGlobalStateRefs() {
            return this._globalStateRefs;
          }
        }
        const Ru = Xe, li = ws, Fu = li.light, lp = li.sky, cm = li.paintProperty, hm = li.layoutProperty;
        function Ll(i, e) {
          let r = !1;
          if (e && e.length) for (const c of e) i.fire(new cr(new Error(c.message))), r = !0;
          return r;
        }
        class Dl {
          constructor(e, r, c) {
            const f = this.cells = [];
            if (e instanceof ArrayBuffer) {
              this.arrayBuffer = e;
              const v = new Int32Array(this.arrayBuffer);
              e = v[0], this.d = (r = v[1]) + 2 * (c = v[2]);
              for (let k = 0; k < this.d * this.d; k++) {
                const P = v[3 + k], L = v[3 + k + 1];
                f.push(P === L ? null : v.subarray(P, L));
              }
              const E = v[3 + f.length + 1];
              this.keys = v.subarray(v[3 + f.length], E), this.bboxes = v.subarray(E), this.insert = this._insertReadonly;
            } else {
              this.d = r + 2 * c;
              for (let v = 0; v < this.d * this.d; v++) f.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = r, this.extent = e, this.padding = c, this.scale = r / e, this.uid = 0;
            const m = c / r * e;
            this.min = -m, this.max = e + m;
          }
          insert(e, r, c, f, m) {
            this._forEachCell(r, c, f, m, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(r), this.bboxes.push(c), this.bboxes.push(f), this.bboxes.push(m);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(e, r, c, f, m, v) {
            this.cells[m].push(v);
          }
          query(e, r, c, f, m) {
            const v = this.min, E = this.max;
            if (e <= v && r <= v && E <= c && E <= f && !m) return Array.prototype.slice.call(this.keys);
            {
              const k = [];
              return this._forEachCell(e, r, c, f, this._queryCell, k, {}, m), k;
            }
          }
          _queryCell(e, r, c, f, m, v, E, k) {
            const P = this.cells[m];
            if (P !== null) {
              const L = this.keys, N = this.bboxes;
              for (let G = 0; G < P.length; G++) {
                const j = P[G];
                if (E[j] === void 0) {
                  const Z = 4 * j;
                  (k ? k(N[Z + 0], N[Z + 1], N[Z + 2], N[Z + 3]) : e <= N[Z + 2] && r <= N[Z + 3] && c >= N[Z + 0] && f >= N[Z + 1]) ? (E[j] = !0, v.push(L[j])) : E[j] = !1;
                }
              }
            }
          }
          _forEachCell(e, r, c, f, m, v, E, k) {
            const P = this._convertToCellCoord(e), L = this._convertToCellCoord(r), N = this._convertToCellCoord(c), G = this._convertToCellCoord(f);
            for (let j = P; j <= N; j++) for (let Z = L; Z <= G; Z++) {
              const Y = this.d * Z + j;
              if ((!k || k(this._convertFromCellCoord(j), this._convertFromCellCoord(Z), this._convertFromCellCoord(j + 1), this._convertFromCellCoord(Z + 1))) && m.call(this, e, r, c, f, Y, v, E, k)) return;
            }
          }
          _convertFromCellCoord(e) {
            return (e - this.padding) / this.scale;
          }
          _convertToCellCoord(e) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const e = this.cells, r = 3 + this.cells.length + 1 + 1;
            let c = 0;
            for (let v = 0; v < this.cells.length; v++) c += this.cells[v].length;
            const f = new Int32Array(r + c + this.keys.length + this.bboxes.length);
            f[0] = this.extent, f[1] = this.n, f[2] = this.padding;
            let m = r;
            for (let v = 0; v < e.length; v++) {
              const E = e[v];
              f[3 + v] = m, f.set(E, m), m += E.length;
            }
            return f[3 + e.length] = m, f.set(this.keys, m), m += this.keys.length, f[3 + e.length + 1] = m, f.set(this.bboxes, m), m += this.bboxes.length, f.buffer;
          }
          static serialize(e, r) {
            const c = e.toArrayBuffer();
            return r && r.push(c), { buffer: c };
          }
          static deserialize(e) {
            return new Dl(e.buffer);
          }
        }
        const Bs = {};
        function jt(i, e, r = {}) {
          if (Bs[i]) throw new Error(`${i} is already registered.`);
          Object.defineProperty(e, "_classRegistryKey", { value: i, writeable: !1 }), Bs[i] = { klass: e, omit: r.omit || [], shallow: r.shallow || [] };
        }
        jt("Object", Object), jt("Set", Set), jt("TransferableGridIndex", Dl), jt("Color", hr), jt("Error", Error), jt("AJAXError", Be), jt("ResolvedImage", dr), jt("StylePropertyFunction", Nc), jt("StyleExpression", rd, { omit: ["_evaluator"] }), jt("ZoomDependentExpression", nd), jt("ZoomConstantExpression", Fc), jt("CompoundExpression", or, { omit: ["_evaluate"] });
        for (const i in _r) _r[i]._classRegistryKey || jt(`Expression_${i}`, _r[i]);
        function Vc(i) {
          return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
        }
        function dd(i) {
          return i.$name || i.constructor._classRegistryKey;
        }
        function Rl(i) {
          return !(function(e) {
            if (e === null || typeof e != "object") return !1;
            const r = dd(e);
            return !(!r || r === "Object");
          })(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || Vc(i) || _i(i) || ArrayBuffer.isView(i) || i instanceof ImageData);
        }
        function Nu(i, e) {
          if (Rl(i)) return (Vc(i) || _i(i)) && e && e.push(i), ArrayBuffer.isView(i) && e && e.push(i.buffer), i instanceof ImageData && e && e.push(i.data.buffer), i;
          if (Array.isArray(i)) {
            const m = [];
            for (const v of i) m.push(Nu(v, e));
            return m;
          }
          if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
          const r = dd(i);
          if (!r) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
          if (!Bs[r]) throw new Error(`${r} is not registered.`);
          const { klass: c } = Bs[r], f = c.serialize ? c.serialize(i, e) : {};
          if (c.serialize) {
            if (e && f === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const m in i) {
              if (!i.hasOwnProperty(m) || Bs[r].omit.indexOf(m) >= 0) continue;
              const v = i[m];
              f[m] = Bs[r].shallow.indexOf(m) >= 0 ? v : Nu(v, e);
            }
            i instanceof Error && (f.message = i.message);
          }
          if (f.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return r !== "Object" && (f.$name = r), f;
        }
        function Ou(i) {
          if (Rl(i)) return i;
          if (Array.isArray(i)) return i.map(Ou);
          if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
          const e = dd(i) || "Object";
          if (!Bs[e]) throw new Error(`can't deserialize unregistered class ${e}`);
          const { klass: r } = Bs[e];
          if (!r) throw new Error(`can't deserialize unregistered class ${e}`);
          if (r.deserialize) return r.deserialize(i);
          const c = Object.create(r.prototype);
          for (const f of Object.keys(i)) {
            if (f === "$name") continue;
            const m = i[f];
            c[f] = Bs[e].shallow.indexOf(f) >= 0 ? m : Ou(m);
          }
          return c;
        }
        class fd {
          constructor() {
            this.first = !0;
          }
          update(e, r) {
            const c = Math.floor(e);
            return this.first ? (this.first = !1, this.lastIntegerZoom = c, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = c, !0) : (this.lastFloorZoom > c ? (this.lastIntegerZoom = c + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < c && (this.lastIntegerZoom = c, this.lastIntegerZoomTime = r), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = c, !0));
          }
        }
        function zu(i) {
          return /[\u02EA\u02EB\u2E80-\u2FDF\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }
        function pd(i) {
          return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD83D\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD30-\uDEFB]|\uD833[\uDEC0-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDE00\uDF00-\uDFFF]|\uD83E[\uDD00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }
        function up(i) {
          return /\s/u.test(String.fromCodePoint(i));
        }
        function Fl(i) {
          for (const e of i) if (pd(e.codePointAt(0))) return !0;
          return !1;
        }
        function dm(i) {
          for (const e of i) if (!cp(e.codePointAt(0))) return !1;
          return !0;
        }
        function Uc(i) {
          const e = i.map(((r) => {
            try {
              return new RegExp(`\\p{sc=${r}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((r) => r));
          return new RegExp(e.join("|"), "u");
        }
        const qc = Uc(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function cp(i) {
          return !qc.test(String.fromCodePoint(i));
        }
        function gd(i) {
          return !(pd(i) || (e = i, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]|[\uDB80-\uDBFF][\uDC00-\uDFFF]/gim.test(String.fromCodePoint(e))));
          var e;
        }
        const hp = Uc(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function md(i) {
          return hp.test(String.fromCodePoint(i));
        }
        function _d(i, e) {
          return !(!e && md(i) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(i)));
        }
        function dp(i) {
          for (const e of i) if (md(e.codePointAt(0))) return !0;
          return !1;
        }
        const co = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(i) {
            this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(i) {
            if (co.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(i, e) {
            return u(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (i.pluginStatus !== "loading") return this.setState(i), i;
              const r = i.pluginURL, c = new Promise(((m) => {
                this.loadScriptResolve = m;
              }));
              e(r);
              const f = new Promise(((m) => setTimeout((() => m()), this.TIMEOUT)));
              if (yield Promise.race([c, f]), this.isParsed()) {
                const m = { pluginStatus: "loaded", pluginURL: r };
                return this.setState(m), m;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${r}`);
            }));
          }
        }();
        class Vr {
          constructor(e, r) {
            this.isSupportedScript = fm, this.zoom = e, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new fd(), this.transition = r.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new fd(), this.transition = {});
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const e = this.zoom, r = e - Math.floor(e), c = this.crossFadingFactor();
            return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: r + (1 - r) * c } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - c) * r };
          }
        }
        function fm(i) {
          return (function(e, r) {
            for (const c of e) if (!_d(c.codePointAt(0), r)) return !1;
            return !0;
          })(i, co.getRTLTextPluginStatus() === "loaded");
        }
        const Bu = "-transition";
        class $c {
          constructor(e, r, c) {
            this.property = e, this.value = r, this.expression = (function(f, m, v) {
              if (Rc(f)) return new Nc(f, m);
              if (Pl(f)) {
                const E = id(f, m, v);
                if (E.result === "error") throw new Error(E.value.map(((k) => `${k.key}: ${k.message}`)).join(", "));
                return E.value;
              }
              {
                let E = f;
                return m.type === "color" && typeof f == "string" ? E = hr.parse(f) : m.type !== "padding" || typeof f != "number" && !Array.isArray(f) ? m.type !== "numberArray" || typeof f != "number" && !Array.isArray(f) ? m.type !== "colorArray" || typeof f != "string" && !Array.isArray(f) ? m.type === "variableAnchorOffsetCollection" && Array.isArray(f) ? E = si.parse(f) : m.type === "projectionDefinition" && typeof f == "string" && (E = tn.parse(f)) : E = Qt.parse(f) : E = en.parse(f) : E = ii.parse(f), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => E };
              }
            })(r === void 0 ? e.specification.default : r, e.specification, c);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(e, r, c) {
            return this.property.possiblyEvaluate(this, e, r, c);
          }
        }
        class Zc {
          constructor(e, r) {
            this.property = e, this.value = new $c(e, void 0, r);
          }
          transitioned(e, r) {
            return new fp(this.property, this.value, r, Ze({}, e.transition, this.transition), e.now);
          }
          untransitioned() {
            return new fp(this.property, this.value, null, {}, 0);
          }
        }
        class yd {
          constructor(e, r) {
            this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._globalState = r;
          }
          getValue(e) {
            return Me(this._values[e].value.value);
          }
          setValue(e, r) {
            Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new Zc(this._values[e].property, this._globalState)), this._values[e].value = new $c(this._values[e].property, r === null ? void 0 : Me(r), this._globalState);
          }
          getTransition(e) {
            return Me(this._values[e].transition);
          }
          setTransition(e, r) {
            Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new Zc(this._values[e].property, this._globalState)), this._values[e].transition = Me(r) || void 0;
          }
          serialize() {
            const e = {};
            for (const r of Object.keys(this._values)) {
              const c = this.getValue(r);
              c !== void 0 && (e[r] = c);
              const f = this.getTransition(r);
              f !== void 0 && (e[`${r}${Bu}`] = f);
            }
            return e;
          }
          transitioned(e, r) {
            const c = new pp(this._properties);
            for (const f of Object.keys(this._values)) c._values[f] = this._values[f].transitioned(e, r._values[f]);
            return c;
          }
          untransitioned() {
            const e = new pp(this._properties);
            for (const r of Object.keys(this._values)) e._values[r] = this._values[r].untransitioned();
            return e;
          }
        }
        class fp {
          constructor(e, r, c, f, m) {
            this.property = e, this.value = r, this.begin = m + f.delay || 0, this.end = this.begin + f.duration || 0, e.specification.transition && (f.delay || f.duration) && (this.prior = c);
          }
          possiblyEvaluate(e, r, c) {
            const f = e.now || 0, m = this.value.possiblyEvaluate(e, r, c), v = this.prior;
            if (v) {
              if (f > this.end) return this.prior = null, m;
              if (this.value.isDataDriven()) return this.prior = null, m;
              if (f < this.begin) return v.possiblyEvaluate(e, r, c);
              {
                const E = (f - this.begin) / (this.end - this.begin);
                return this.property.interpolate(v.possiblyEvaluate(e, r, c), m, Ot(E));
              }
            }
            return m;
          }
        }
        class pp {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(e, r, c) {
            const f = new Gu(this._properties);
            for (const m of Object.keys(this._values)) f._values[m] = this._values[m].possiblyEvaluate(e, r, c);
            return f;
          }
          hasTransition() {
            for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
            return !1;
          }
        }
        class gp {
          constructor(e, r) {
            this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._globalState = r;
          }
          hasValue(e) {
            return this._values[e].value !== void 0;
          }
          getValue(e) {
            return Me(this._values[e].value);
          }
          setValue(e, r) {
            this._values[e] = new $c(this._values[e].property, r === null ? void 0 : Me(r), this._globalState);
          }
          serialize() {
            const e = {};
            for (const r of Object.keys(this._values)) {
              const c = this.getValue(r);
              c !== void 0 && (e[r] = c);
            }
            return e;
          }
          possiblyEvaluate(e, r, c) {
            const f = new Gu(this._properties);
            for (const m of Object.keys(this._values)) f._values[m] = this._values[m].possiblyEvaluate(e, r, c);
            return f;
          }
        }
        class Gs {
          constructor(e, r, c) {
            this.property = e, this.value = r, this.parameters = c;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(e) {
            return this.value.kind === "constant" ? this.value.value : e;
          }
          evaluate(e, r, c, f) {
            return this.property.evaluate(this.value, this.parameters, e, r, c, f);
          }
        }
        class Gu {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
          }
          get(e) {
            return this._values[e];
          }
        }
        class Zt {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, r) {
            if (e.isDataDriven()) throw new Error("Value should not be data driven");
            return e.expression.evaluate(r);
          }
          interpolate(e, r, c) {
            const f = Wr[this.specification.type];
            return f ? f(e, r, c) : e;
          }
        }
        class Jt {
          constructor(e, r) {
            this.specification = e, this.overrides = r;
          }
          possiblyEvaluate(e, r, c, f) {
            return new Gs(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(r, null, {}, c, f) } : e.expression, r);
          }
          interpolate(e, r, c) {
            if (e.value.kind !== "constant" || r.value.kind !== "constant") return e;
            if (e.value.value === void 0 || r.value.value === void 0) return new Gs(this, { kind: "constant", value: void 0 }, e.parameters);
            const f = Wr[this.specification.type];
            if (f) {
              const m = f(e.value.value, r.value.value, c);
              return new Gs(this, { kind: "constant", value: m }, e.parameters);
            }
            return e;
          }
          evaluate(e, r, c, f, m, v) {
            return e.kind === "constant" ? e.value : e.evaluate(r, c, f, m, v);
          }
        }
        class ju extends Jt {
          possiblyEvaluate(e, r, c, f) {
            if (e.value === void 0) return new Gs(this, { kind: "constant", value: void 0 }, r);
            if (e.expression.kind === "constant") {
              const m = e.expression.evaluate(r, null, {}, c, f), v = e.property.specification.type === "resolvedImage" && typeof m != "string" ? m.name : m, E = this._calculate(v, v, v, r);
              return new Gs(this, { kind: "constant", value: E }, r);
            }
            if (e.expression.kind === "camera") {
              const m = this._calculate(e.expression.evaluate({ zoom: r.zoom - 1 }), e.expression.evaluate({ zoom: r.zoom }), e.expression.evaluate({ zoom: r.zoom + 1 }), r);
              return new Gs(this, { kind: "constant", value: m }, r);
            }
            return new Gs(this, e.expression, r);
          }
          evaluate(e, r, c, f, m, v) {
            if (e.kind === "source") {
              const E = e.evaluate(r, c, f, m, v);
              return this._calculate(E, E, E, r);
            }
            return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(r.zoom) - 1 }, c, f), e.evaluate({ zoom: Math.floor(r.zoom) }, c, f), e.evaluate({ zoom: Math.floor(r.zoom) + 1 }, c, f), r) : e.value;
          }
          _calculate(e, r, c, f) {
            return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: e, to: r } : { from: c, to: r };
          }
          interpolate(e) {
            return e;
          }
        }
        class Hc {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, r, c, f) {
            if (e.value !== void 0) {
              if (e.expression.kind === "constant") {
                const m = e.expression.evaluate(r, null, {}, c, f);
                return this._calculate(m, m, m, r);
              }
              return this._calculate(e.expression.evaluate(new Vr(Math.floor(r.zoom - 1), r)), e.expression.evaluate(new Vr(Math.floor(r.zoom), r)), e.expression.evaluate(new Vr(Math.floor(r.zoom + 1), r)), r);
            }
          }
          _calculate(e, r, c, f) {
            return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: e, to: r } : { from: c, to: r };
          }
          interpolate(e) {
            return e;
          }
        }
        class Yc {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, r, c, f) {
            return !!e.expression.evaluate(r, null, {}, c, f);
          }
          interpolate() {
            return !1;
          }
        }
        class Vi {
          constructor(e) {
            this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const r in e) {
              const c = e[r];
              c.specification.overridable && this.overridableProperties.push(r);
              const f = this.defaultPropertyValues[r] = new $c(c, void 0, void 0), m = this.defaultTransitionablePropertyValues[r] = new Zc(c, void 0);
              this.defaultTransitioningPropertyValues[r] = m.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = f.possiblyEvaluate({});
            }
          }
        }
        jt("DataDrivenProperty", Jt), jt("DataConstantProperty", Zt), jt("CrossFadedDataDrivenProperty", ju), jt("CrossFadedProperty", Hc), jt("ColorRampProperty", Yc);
        class Es extends wr {
          constructor(e, r, c) {
            if (super(), this.id = e.id, this.type = e.type, this._globalState = c, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, this._visibilityExpression = (function(f, m) {
              return new Du(f, m);
            })(this.visibility, c), e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter, this._featureFilter = Iu(e.filter, c)), r.layout && (this._unevaluatedLayout = new gp(r.layout, c)), r.paint)) {
              this._transitionablePaint = new yd(r.paint, c);
              for (const f in e.paint) this.setPaintProperty(f, e.paint[f], { validate: !1 });
              for (const f in e.layout) this.setLayoutProperty(f, e.layout[f], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Gu(r.paint);
            }
          }
          setFilter(e) {
            this.filter = e, this._featureFilter = Iu(e, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(e) {
            return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
          }
          getLayoutAffectingGlobalStateRefs() {
            const e = /* @__PURE__ */ new Set();
            for (const r of this._visibilityExpression.getGlobalStateRefs()) e.add(r);
            if (this._unevaluatedLayout) for (const r in this._unevaluatedLayout._values) {
              const c = this._unevaluatedLayout._values[r];
              for (const f of c.getGlobalStateRefs()) e.add(f);
            }
            for (const r of this._featureFilter.getGlobalStateRefs()) e.add(r);
            return e;
          }
          getPaintAffectingGlobalStateRefs() {
            var e;
            const r = new globalThis.Map();
            if (this._transitionablePaint) for (const c in this._transitionablePaint._values) {
              const f = this._transitionablePaint._values[c].value;
              for (const m of f.getGlobalStateRefs()) {
                const v = (e = r.get(m)) !== null && e !== void 0 ? e : [];
                v.push({ name: c, value: f.value }), r.set(m, v);
              }
            }
            return r;
          }
          getVisibilityAffectingGlobalStateRefs() {
            return this._visibilityExpression.getGlobalStateRefs();
          }
          setLayoutProperty(e, r, c = {}) {
            if (r == null || !this._validate(hm, `layers.${this.id}.layout.${e}`, e, r, c)) return e === "visibility" ? (this.visibility = r, this._visibilityExpression.setValue(r), void this.recalculateVisibility()) : void this._unevaluatedLayout.setValue(e, r);
          }
          getPaintProperty(e) {
            return e.endsWith(Bu) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
          }
          setPaintProperty(e, r, c = {}) {
            if (r != null && this._validate(cm, `layers.${this.id}.paint.${e}`, e, r, c)) return !1;
            if (e.endsWith(Bu)) return this._transitionablePaint.setTransition(e.slice(0, -11), r || void 0), !1;
            {
              const f = this._transitionablePaint._values[e], m = f.property.specification["property-type"] === "cross-faded-data-driven", v = f.value.isDataDriven(), E = f.value;
              this._transitionablePaint.setValue(e, r), this._handleSpecialPaintPropertyUpdate(e);
              const k = this._transitionablePaint._values[e].value;
              return k.isDataDriven() || v || m || this._handleOverridablePaintPropertyUpdate(e, E, k);
            }
          }
          _handleSpecialPaintPropertyUpdate(e) {
          }
          _handleOverridablePaintPropertyUpdate(e, r, c) {
            return !1;
          }
          isHidden(e = this.minzoom, r = !1) {
            return !!(this.minzoom && e < (r ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && e >= this.maxzoom) || this._evaluatedVisibility === "none";
          }
          updateTransitions(e) {
            this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculateVisibility() {
            this._evaluatedVisibility = this._visibilityExpression.evaluate();
          }
          recalculate(e, r) {
            e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, r);
          }
          serialize() {
            const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), Ut(e, ((r, c) => !(r === void 0 || c === "layout" && !Object.keys(r).length || c === "paint" && !Object.keys(r).length)));
          }
          _validate(e, r, c, f, m = {}) {
            return (!m || m.validate !== !1) && Ll(this, e.call(li, { key: r, layerType: this.type, objectKey: c, value: f, styleSpec: Xe, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const e in this.paint._values) {
              const r = this.paint.get(e);
              if (r instanceof Gs && Aa(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        let vd;
        var mp = { get paint() {
          return vd = vd || new Vi({ "raster-opacity": new Zt(Xe.paint_raster["raster-opacity"]), "raster-hue-rotate": new Zt(Xe.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Zt(Xe.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Zt(Xe.paint_raster["raster-brightness-max"]), "raster-saturation": new Zt(Xe.paint_raster["raster-saturation"]), "raster-contrast": new Zt(Xe.paint_raster["raster-contrast"]), "raster-resampling": new Zt(Xe.paint_raster["raster-resampling"]), "raster-fade-duration": new Zt(Xe.paint_raster["raster-fade-duration"]) });
        } };
        class pm extends Es {
          constructor(e, r) {
            super(e, mp, r);
          }
        }
        const gm = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Vu {
          constructor(e, r) {
            this._structArray = e, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class mn {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(e, r) {
            return e._trim(), r && (e.isTransferred = !0, r.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
          }
          static deserialize(e) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = e.arrayBuffer, r.length = e.length, r.capacity = e.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(e) {
            this.reserve(e), this.length = e;
          }
          reserve(e) {
            if (e > this.capacity) {
              this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function An(i, e = 1) {
          let r = 0, c = 0;
          return { members: i.map(((f) => {
            const m = gm[f.type].BYTES_PER_ELEMENT, v = r = Zo(r, Math.max(e, m)), E = f.components || 1;
            return c = Math.max(c, m), r += m * E, { name: f.name, type: f.type, components: E, offset: v };
          })), size: Zo(r, Math.max(c, e)), alignment: e };
        }
        function Zo(i, e) {
          return Math.ceil(i / e) * e;
        }
        class Uu extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, r);
          }
          emplace(e, r, c) {
            const f = 2 * e;
            return this.int16[f + 0] = r, this.int16[f + 1] = c, e;
          }
        }
        Uu.prototype.bytesPerElement = 4, jt("StructArrayLayout2i4", Uu);
        class Wc extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 3 * e;
            return this.int16[m + 0] = r, this.int16[m + 1] = c, this.int16[m + 2] = f, e;
          }
        }
        Wc.prototype.bytesPerElement = 6, jt("StructArrayLayout3i6", Wc);
        class xd extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, e, r, c, f);
          }
          emplace(e, r, c, f, m) {
            const v = 4 * e;
            return this.int16[v + 0] = r, this.int16[v + 1] = c, this.int16[v + 2] = f, this.int16[v + 3] = m, e;
          }
        }
        xd.prototype.bytesPerElement = 8, jt("StructArrayLayout4i8", xd);
        class Xc extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, r, c, f, m, v);
          }
          emplace(e, r, c, f, m, v, E) {
            const k = 6 * e;
            return this.int16[k + 0] = r, this.int16[k + 1] = c, this.int16[k + 2] = f, this.int16[k + 3] = m, this.int16[k + 4] = v, this.int16[k + 5] = E, e;
          }
        }
        Xc.prototype.bytesPerElement = 12, jt("StructArrayLayout2i4i12", Xc);
        class bd extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, r, c, f, m, v);
          }
          emplace(e, r, c, f, m, v, E) {
            const k = 4 * e, P = 8 * e;
            return this.int16[k + 0] = r, this.int16[k + 1] = c, this.uint8[P + 4] = f, this.uint8[P + 5] = m, this.uint8[P + 6] = v, this.uint8[P + 7] = E, e;
          }
        }
        bd.prototype.bytesPerElement = 8, jt("StructArrayLayout2i4ub8", bd);
        class qu extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, r);
          }
          emplace(e, r, c) {
            const f = 2 * e;
            return this.float32[f + 0] = r, this.float32[f + 1] = c, e;
          }
        }
        qu.prototype.bytesPerElement = 8, jt("StructArrayLayout2f8", qu);
        class La extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P, L) {
            const N = this.length;
            return this.resize(N + 1), this.emplace(N, e, r, c, f, m, v, E, k, P, L);
          }
          emplace(e, r, c, f, m, v, E, k, P, L, N) {
            const G = 10 * e;
            return this.uint16[G + 0] = r, this.uint16[G + 1] = c, this.uint16[G + 2] = f, this.uint16[G + 3] = m, this.uint16[G + 4] = v, this.uint16[G + 5] = E, this.uint16[G + 6] = k, this.uint16[G + 7] = P, this.uint16[G + 8] = L, this.uint16[G + 9] = N, e;
          }
        }
        La.prototype.bytesPerElement = 20, jt("StructArrayLayout10ui20", La);
        class Jc extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k) {
            const P = this.length;
            return this.resize(P + 1), this.emplace(P, e, r, c, f, m, v, E, k);
          }
          emplace(e, r, c, f, m, v, E, k, P) {
            const L = 8 * e;
            return this.uint16[L + 0] = r, this.uint16[L + 1] = c, this.uint16[L + 2] = f, this.uint16[L + 3] = m, this.uint16[L + 4] = v, this.uint16[L + 5] = E, this.uint16[L + 6] = k, this.uint16[L + 7] = P, e;
          }
        }
        Jc.prototype.bytesPerElement = 16, jt("StructArrayLayout8ui16", Jc);
        class $u extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P, L, N, G) {
            const j = this.length;
            return this.resize(j + 1), this.emplace(j, e, r, c, f, m, v, E, k, P, L, N, G);
          }
          emplace(e, r, c, f, m, v, E, k, P, L, N, G, j) {
            const Z = 12 * e;
            return this.int16[Z + 0] = r, this.int16[Z + 1] = c, this.int16[Z + 2] = f, this.int16[Z + 3] = m, this.uint16[Z + 4] = v, this.uint16[Z + 5] = E, this.uint16[Z + 6] = k, this.uint16[Z + 7] = P, this.int16[Z + 8] = L, this.int16[Z + 9] = N, this.int16[Z + 10] = G, this.int16[Z + 11] = j, e;
          }
        }
        $u.prototype.bytesPerElement = 24, jt("StructArrayLayout4i4ui4i24", $u);
        class Kc extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 3 * e;
            return this.float32[m + 0] = r, this.float32[m + 1] = c, this.float32[m + 2] = f, e;
          }
        }
        Kc.prototype.bytesPerElement = 12, jt("StructArrayLayout3f12", Kc);
        class Zu extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.uint32[1 * e + 0] = r, e;
          }
        }
        Zu.prototype.bytesPerElement = 4, jt("StructArrayLayout1ul4", Zu);
        class wd extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, e, r, c, f, m, v, E, k, P);
          }
          emplace(e, r, c, f, m, v, E, k, P, L) {
            const N = 10 * e, G = 5 * e;
            return this.int16[N + 0] = r, this.int16[N + 1] = c, this.int16[N + 2] = f, this.int16[N + 3] = m, this.int16[N + 4] = v, this.int16[N + 5] = E, this.uint32[G + 3] = k, this.uint16[N + 8] = P, this.uint16[N + 9] = L, e;
          }
        }
        wd.prototype.bytesPerElement = 20, jt("StructArrayLayout6i1ul2ui20", wd);
        class Nl extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, r, c, f, m, v);
          }
          emplace(e, r, c, f, m, v, E) {
            const k = 6 * e;
            return this.int16[k + 0] = r, this.int16[k + 1] = c, this.int16[k + 2] = f, this.int16[k + 3] = m, this.int16[k + 4] = v, this.int16[k + 5] = E, e;
          }
        }
        Nl.prototype.bytesPerElement = 12, jt("StructArrayLayout2i2i2i12", Nl);
        class Ho extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, e, r, c, f, m);
          }
          emplace(e, r, c, f, m, v) {
            const E = 4 * e, k = 8 * e;
            return this.float32[E + 0] = r, this.float32[E + 1] = c, this.float32[E + 2] = f, this.int16[k + 6] = m, this.int16[k + 7] = v, e;
          }
        }
        Ho.prototype.bytesPerElement = 16, jt("StructArrayLayout2f1f2i16", Ho);
        class Ed extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, r, c, f, m, v);
          }
          emplace(e, r, c, f, m, v, E) {
            const k = 16 * e, P = 4 * e, L = 8 * e;
            return this.uint8[k + 0] = r, this.uint8[k + 1] = c, this.float32[P + 1] = f, this.float32[P + 2] = m, this.int16[L + 6] = v, this.int16[L + 7] = E, e;
          }
        }
        Ed.prototype.bytesPerElement = 16, jt("StructArrayLayout2ub2f2i16", Ed);
        class Hu extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 3 * e;
            return this.uint16[m + 0] = r, this.uint16[m + 1] = c, this.uint16[m + 2] = f, e;
          }
        }
        Hu.prototype.bytesPerElement = 6, jt("StructArrayLayout3ui6", Hu);
        class Yo extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, X, ne) {
            const xe = this.length;
            return this.resize(xe + 1), this.emplace(xe, e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, X, ne);
          }
          emplace(e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, X, ne, xe) {
            const ae = 24 * e, ue = 12 * e, Te = 48 * e;
            return this.int16[ae + 0] = r, this.int16[ae + 1] = c, this.uint16[ae + 2] = f, this.uint16[ae + 3] = m, this.uint32[ue + 2] = v, this.uint32[ue + 3] = E, this.uint32[ue + 4] = k, this.uint16[ae + 10] = P, this.uint16[ae + 11] = L, this.uint16[ae + 12] = N, this.float32[ue + 7] = G, this.float32[ue + 8] = j, this.uint8[Te + 36] = Z, this.uint8[Te + 37] = Y, this.uint8[Te + 38] = X, this.uint32[ue + 10] = ne, this.int16[ae + 22] = xe, e;
          }
        }
        Yo.prototype.bytesPerElement = 48, jt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Yo);
        class Td extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, X, ne, xe, ae, ue, Te, Ae, Ke, ht, lt, pt, Ct, _t) {
            const ut = this.length;
            return this.resize(ut + 1), this.emplace(ut, e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, X, ne, xe, ae, ue, Te, Ae, Ke, ht, lt, pt, Ct, _t);
          }
          emplace(e, r, c, f, m, v, E, k, P, L, N, G, j, Z, Y, X, ne, xe, ae, ue, Te, Ae, Ke, ht, lt, pt, Ct, _t, ut) {
            const st = 32 * e, Bt = 16 * e;
            return this.int16[st + 0] = r, this.int16[st + 1] = c, this.int16[st + 2] = f, this.int16[st + 3] = m, this.int16[st + 4] = v, this.int16[st + 5] = E, this.int16[st + 6] = k, this.int16[st + 7] = P, this.uint16[st + 8] = L, this.uint16[st + 9] = N, this.uint16[st + 10] = G, this.uint16[st + 11] = j, this.uint16[st + 12] = Z, this.uint16[st + 13] = Y, this.uint16[st + 14] = X, this.uint16[st + 15] = ne, this.uint16[st + 16] = xe, this.uint16[st + 17] = ae, this.uint16[st + 18] = ue, this.uint16[st + 19] = Te, this.uint16[st + 20] = Ae, this.uint16[st + 21] = Ke, this.uint16[st + 22] = ht, this.uint32[Bt + 12] = lt, this.float32[Bt + 13] = pt, this.float32[Bt + 14] = Ct, this.uint16[st + 30] = _t, this.uint16[st + 31] = ut, e;
          }
        }
        Td.prototype.bytesPerElement = 64, jt("StructArrayLayout8i15ui1ul2f2ui64", Td);
        class Qc extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.float32[1 * e + 0] = r, e;
          }
        }
        Qc.prototype.bytesPerElement = 4, jt("StructArrayLayout1f4", Qc);
        class eh extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 3 * e;
            return this.uint16[6 * e + 0] = r, this.float32[m + 1] = c, this.float32[m + 2] = f, e;
          }
        }
        eh.prototype.bytesPerElement = 12, jt("StructArrayLayout1ui2f12", eh);
        class Sd extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, c);
          }
          emplace(e, r, c, f) {
            const m = 4 * e;
            return this.uint32[2 * e + 0] = r, this.uint16[m + 2] = c, this.uint16[m + 3] = f, e;
          }
        }
        Sd.prototype.bytesPerElement = 8, jt("StructArrayLayout1ul2ui8", Sd);
        class b extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, r);
          }
          emplace(e, r, c) {
            const f = 2 * e;
            return this.uint16[f + 0] = r, this.uint16[f + 1] = c, e;
          }
        }
        b.prototype.bytesPerElement = 4, jt("StructArrayLayout2ui4", b);
        class t extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.uint16[1 * e + 0] = r, e;
          }
        }
        t.prototype.bytesPerElement = 2, jt("StructArrayLayout1ui2", t);
        class s extends mn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, c, f) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, e, r, c, f);
          }
          emplace(e, r, c, f, m) {
            const v = 4 * e;
            return this.float32[v + 0] = r, this.float32[v + 1] = c, this.float32[v + 2] = f, this.float32[v + 3] = m, e;
          }
        }
        s.prototype.bytesPerElement = 16, jt("StructArrayLayout4f16", s);
        class d extends Vu {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new R(this.anchorPointX, this.anchorPointY);
          }
        }
        d.prototype.size = 20;
        class g extends wd {
          get(e) {
            return new d(this, e);
          }
        }
        jt("CollisionBoxArray", g);
        class w extends Vu {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(e) {
            this._structArray.uint8[this._pos1 + 37] = e;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(e) {
            this._structArray.uint8[this._pos1 + 38] = e;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 10] = e;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        w.prototype.size = 48;
        class S extends Yo {
          get(e) {
            return new w(this, e);
          }
        }
        jt("PlacedSymbolArray", S);
        class C extends Vu {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 12] = e;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        C.prototype.size = 64;
        class A extends Td {
          get(e) {
            return new C(this, e);
          }
        }
        jt("SymbolInstanceArray", A);
        class F extends Qc {
          getoffsetX(e) {
            return this.float32[1 * e + 0];
          }
        }
        jt("GlyphOffsetArray", F);
        class O extends Wc {
          getx(e) {
            return this.int16[3 * e + 0];
          }
          gety(e) {
            return this.int16[3 * e + 1];
          }
          gettileUnitDistanceFromAnchor(e) {
            return this.int16[3 * e + 2];
          }
        }
        jt("SymbolLineVertexArray", O);
        class q extends Vu {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        q.prototype.size = 12;
        class V extends eh {
          get(e) {
            return new q(this, e);
          }
        }
        jt("TextAnchorOffsetArray", V);
        class W extends Vu {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        W.prototype.size = 8;
        class te extends Sd {
          get(e) {
            return new W(this, e);
          }
        }
        jt("FeatureIndexArray", te);
        class he extends Uu {
        }
        class pe extends Uu {
        }
        class fe extends Uu {
        }
        class we extends Xc {
        }
        class Le extends bd {
        }
        class ve extends qu {
        }
        class Ce extends La {
        }
        class Ne extends Jc {
        }
        class ke extends $u {
        }
        class Ge extends Kc {
        }
        class at extends Zu {
        }
        class tt extends Nl {
        }
        class nt extends Ed {
        }
        class it extends Hu {
        }
        class Et extends b {
        }
        const kt = An([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: gt } = kt;
        class At {
          constructor(e = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = e;
          }
          prepareSegment(e, r, c, f) {
            const m = this.segments[this.segments.length - 1];
            return e > At.MAX_VERTEX_ARRAY_LENGTH && ur(`Max vertices per segment is ${At.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${At.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !m || m.vertexLength + e > At.MAX_VERTEX_ARRAY_LENGTH || m.sortKey !== f ? this.createNewSegment(r, c, f) : m;
          }
          createNewSegment(e, r, c) {
            const f = { vertexOffset: e.length, primitiveOffset: r.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return c !== void 0 && (f.sortKey = c), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(f), f;
          }
          getOrCreateLatestSegment(e, r, c) {
            return this.prepareSegment(0, e, r, c);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const e of this.segments) for (const r in e.vaos) e.vaos[r].destroy();
          }
          static simpleSegment(e, r, c, f) {
            return new At([{ vertexOffset: e, primitiveOffset: r, vertexLength: c, primitiveLength: f, vaos: {}, sortKey: 0 }]);
          }
        }
        function ar(i, e) {
          return 256 * (i = Kt(Math.floor(i), 0, 255)) + Kt(Math.floor(e), 0, 255);
        }
        At.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, jt("SegmentVector", At);
        const zr = An([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), sn = An([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
        var qr, ln, $r, En = { exports: {} }, un = { exports: {} }, ui = { exports: {} }, On = (function() {
          if ($r) return En.exports;
          $r = 1;
          var i = (qr || (qr = 1, un.exports = function(r, c) {
            var f, m, v, E, k, P, L, N;
            for (m = r.length - (f = 3 & r.length), v = c, k = 3432918353, P = 461845907, N = 0; N < m; ) L = 255 & r.charCodeAt(N) | (255 & r.charCodeAt(++N)) << 8 | (255 & r.charCodeAt(++N)) << 16 | (255 & r.charCodeAt(++N)) << 24, ++N, v = 27492 + (65535 & (E = 5 * (65535 & (v = (v ^= L = (65535 & (L = (L = (65535 & L) * k + (((L >>> 16) * k & 65535) << 16) & 4294967295) << 15 | L >>> 17)) * P + (((L >>> 16) * P & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (E >>> 16) & 65535) << 16);
            switch (L = 0, f) {
              case 3:
                L ^= (255 & r.charCodeAt(N + 2)) << 16;
              case 2:
                L ^= (255 & r.charCodeAt(N + 1)) << 8;
              case 1:
                v ^= L = (65535 & (L = (L = (65535 & (L ^= 255 & r.charCodeAt(N))) * k + (((L >>> 16) * k & 65535) << 16) & 4294967295) << 15 | L >>> 17)) * P + (((L >>> 16) * P & 65535) << 16) & 4294967295;
            }
            return v ^= r.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
          }), un.exports), e = (ln || (ln = 1, ui.exports = function(r, c) {
            for (var f, m = r.length, v = c ^ m, E = 0; m >= 4; ) f = 1540483477 * (65535 & (f = 255 & r.charCodeAt(E) | (255 & r.charCodeAt(++E)) << 8 | (255 & r.charCodeAt(++E)) << 16 | (255 & r.charCodeAt(++E)) << 24)) + ((1540483477 * (f >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (f = 1540483477 * (65535 & (f ^= f >>> 24)) + ((1540483477 * (f >>> 16) & 65535) << 16)), m -= 4, ++E;
            switch (m) {
              case 3:
                v ^= (255 & r.charCodeAt(E + 2)) << 16;
              case 2:
                v ^= (255 & r.charCodeAt(E + 1)) << 8;
              case 1:
                v = 1540483477 * (65535 & (v ^= 255 & r.charCodeAt(E))) + ((1540483477 * (v >>> 16) & 65535) << 16);
            }
            return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
          }), ui.exports);
          return En.exports = i, En.exports.murmur3 = i, En.exports.murmur2 = e, En.exports;
        })(), Ln = z(On);
        class Ei {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(e, r, c, f) {
            this.ids.push(ho(e)), this.positions.push(r, c, f);
          }
          getPositions(e) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const r = ho(e);
            let c = 0, f = this.ids.length - 1;
            for (; c < f; ) {
              const v = c + f >> 1;
              this.ids[v] >= r ? f = v : c = v + 1;
            }
            const m = [];
            for (; this.ids[c] === r; ) m.push({ index: this.positions[3 * c], start: this.positions[3 * c + 1], end: this.positions[3 * c + 2] }), c++;
            return m;
          }
          static serialize(e, r) {
            const c = new Float64Array(e.ids), f = new Uint32Array(e.positions);
            return Da(c, f, 0, c.length - 1), r && r.push(c.buffer, f.buffer), { ids: c, positions: f };
          }
          static deserialize(e) {
            const r = new Ei();
            return r.ids = e.ids, r.positions = e.positions, r.indexed = !0, r;
          }
        }
        function ho(i) {
          const e = +i;
          return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : Ln(String(i));
        }
        function Da(i, e, r, c) {
          for (; r < c; ) {
            const f = i[r + c >> 1];
            let m = r - 1, v = c + 1;
            for (; ; ) {
              do
                m++;
              while (i[m] < f);
              do
                v--;
              while (i[v] > f);
              if (m >= v) break;
              oa(i, m, v), oa(e, 3 * m, 3 * v), oa(e, 3 * m + 1, 3 * v + 1), oa(e, 3 * m + 2, 3 * v + 2);
            }
            v - r < c - v ? (Da(i, e, r, v), r = v + 1) : (Da(i, e, v + 1, c), c = v);
          }
        }
        function oa(i, e, r) {
          const c = i[e];
          i[e] = i[r], i[r] = c;
        }
        jt("FeaturePositionMap", Ei);
        class Ji {
          constructor(e, r) {
            this.gl = e.gl, this.location = r;
          }
        }
        class Wo extends Ji {
          constructor(e, r) {
            super(e, r), this.current = 0;
          }
          set(e) {
            this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
          }
        }
        class Yu extends Ji {
          constructor(e, r) {
            super(e, r), this.current = [0, 0, 0, 0];
          }
          set(e) {
            e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
          }
        }
        class Xo extends Ji {
          constructor(e, r) {
            super(e, r), this.current = hr.transparent;
          }
          set(e) {
            e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
          }
        }
        const Ts = new Float32Array(16);
        function la(i) {
          return [ar(255 * i.r, 255 * i.g), ar(255 * i.b, 255 * i.a)];
        }
        class js {
          constructor(e, r, c) {
            this.value = e, this.uniformNames = r.map(((f) => `u_${f}`)), this.type = c;
          }
          setUniform(e, r, c) {
            e.set(c.constantOr(this.value));
          }
          getBinding(e, r, c) {
            return this.type === "color" ? new Xo(e, r) : new Wo(e, r);
          }
        }
        class Vs {
          constructor(e, r) {
            this.uniformNames = r.map(((c) => `u_${c}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(e, r) {
            this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = e.tlbr;
          }
          setConstantDashPositions(e, r) {
            this.dashTo = [0, e.y, e.height, e.width], this.dashFrom = [0, r.y, r.height, r.width];
          }
          setUniform(e, r, c, f) {
            let m = null;
            f === "u_pattern_to" ? m = this.patternTo : f === "u_pattern_from" ? m = this.patternFrom : f === "u_dasharray_to" ? m = this.dashTo : f === "u_dasharray_from" ? m = this.dashFrom : f === "u_pixel_ratio_to" ? m = this.pixelRatioTo : f === "u_pixel_ratio_from" && (m = this.pixelRatioFrom), m !== null && e.set(m);
          }
          getBinding(e, r, c) {
            return c.substr(0, 9) === "u_pattern" || c.substr(0, 12) === "u_dasharray_" ? new Yu(e, r) : new Wo(e, r);
          }
        }
        class Xr {
          constructor(e, r, c, f) {
            this.expression = e, this.type = c, this.maxValue = 0, this.paintVertexAttributes = r.map(((m) => ({ name: `a_${m}`, type: "Float32", components: c === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new f();
          }
          populatePaintArray(e, r, c) {
            const f = this.paintVertexArray.length, m = this.expression.evaluate(new Vr(0, c), r, {}, c.canonical, [], c.formattedSection);
            this.paintVertexArray.resize(e), this._setPaintValue(f, e, m);
          }
          updatePaintArray(e, r, c, f, m) {
            const v = this.expression.evaluate(new Vr(0, m), c, f);
            this._setPaintValue(e, r, v);
          }
          _setPaintValue(e, r, c) {
            if (this.type === "color") {
              const f = la(c);
              for (let m = e; m < r; m++) this.paintVertexArray.emplace(m, f[0], f[1]);
            } else {
              for (let f = e; f < r; f++) this.paintVertexArray.emplace(f, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(c));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Zr {
          constructor(e, r, c, f, m, v) {
            this.expression = e, this.uniformNames = r.map(((E) => `u_${E}_t`)), this.type = c, this.useIntegerZoom = f, this.zoom = m, this.maxValue = 0, this.paintVertexAttributes = r.map(((E) => ({ name: `a_${E}`, type: "Float32", components: c === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new v();
          }
          populatePaintArray(e, r, c) {
            const f = this.expression.evaluate(new Vr(this.zoom, c), r, {}, c.canonical, [], c.formattedSection), m = this.expression.evaluate(new Vr(this.zoom + 1, c), r, {}, c.canonical, [], c.formattedSection), v = this.paintVertexArray.length;
            this.paintVertexArray.resize(e), this._setPaintValue(v, e, f, m);
          }
          updatePaintArray(e, r, c, f, m) {
            const v = this.expression.evaluate(new Vr(this.zoom, m), c, f), E = this.expression.evaluate(new Vr(this.zoom + 1, m), c, f);
            this._setPaintValue(e, r, v, E);
          }
          _setPaintValue(e, r, c, f) {
            if (this.type === "color") {
              const m = la(c), v = la(f);
              for (let E = e; E < r; E++) this.paintVertexArray.emplace(E, m[0], m[1], v[0], v[1]);
            } else {
              for (let m = e; m < r; m++) this.paintVertexArray.emplace(m, c, f);
              this.maxValue = Math.max(this.maxValue, Math.abs(c), Math.abs(f));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(e, r) {
            const c = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, f = Kt(this.expression.interpolationFactor(c, this.zoom, this.zoom + 1), 0, 1);
            e.set(f);
          }
          getBinding(e, r, c) {
            return new Wo(e, r);
          }
        }
        class Kn {
          constructor(e, r, c, f, m, v) {
            this.expression = e, this.type = r, this.useIntegerZoom = c, this.zoom = f, this.layerId = v, this.zoomInPaintVertexArray = new m(), this.zoomOutPaintVertexArray = new m();
          }
          populatePaintArray(e, r, c) {
            const f = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(f, e, this.getPositionIds(r), c);
          }
          updatePaintArray(e, r, c, f, m) {
            this._setPaintValues(e, r, this.getPositionIds(c), m);
          }
          _setPaintValues(e, r, c, f) {
            const m = this.getPositions(f);
            if (!m || !c) return;
            const v = m[c.min], E = m[c.mid], k = m[c.max];
            if (v && E && k) for (let P = e; P < r; P++) this.emplace(this.zoomInPaintVertexArray, P, E, v), this.emplace(this.zoomOutPaintVertexArray, P, E, k);
          }
          upload(e) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const r = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, r, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, r, this.expression.isStateDependent);
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Qn extends Kn {
          getPositions(e) {
            return e.imagePositions;
          }
          getPositionIds(e) {
            return e.patterns && e.patterns[this.layerId];
          }
          getVertexAttributes() {
            return zr.members;
          }
          emplace(e, r, c, f) {
            e.emplace(r, c.tlbr[0], c.tlbr[1], c.tlbr[2], c.tlbr[3], f.tlbr[0], f.tlbr[1], f.tlbr[2], f.tlbr[3], c.pixelRatio, f.pixelRatio);
          }
        }
        class _p extends Kn {
          getPositions(e) {
            return e.dashPositions;
          }
          getPositionIds(e) {
            return e.dashes && e.dashes[this.layerId];
          }
          getVertexAttributes() {
            return sn.members;
          }
          emplace(e, r, c, f) {
            e.emplace(r, 0, c.y, c.height, c.width, 0, f.y, f.height, f.width);
          }
        }
        class yp {
          constructor(e, r, c) {
            this.binders = {}, this._buffers = [];
            const f = [];
            for (const m in e.paint._values) {
              if (!c(m)) continue;
              const v = e.paint.get(m);
              if (!(v instanceof Gs && Aa(v.property.specification))) continue;
              const E = mm(m, e.type), k = v.value, P = v.property.specification.type, L = v.property.useIntegerZoom, N = v.property.specification["property-type"], G = N === "cross-faded" || N === "cross-faded-data-driven";
              if (k.kind === "constant") this.binders[m] = G ? new Vs(k.value, E) : new js(k.value, E, P), f.push(`/u_${m}`);
              else if (k.kind === "source" || G) {
                const j = vp(m, P, "source");
                this.binders[m] = G ? m === "line-dasharray" ? new _p(k, P, L, r, j, e.id) : new Qn(k, P, L, r, j, e.id) : new Xr(k, E, P, j), f.push(`/a_${m}`);
              } else {
                const j = vp(m, P, "composite");
                this.binders[m] = new Zr(k, E, P, L, r, j), f.push(`/z_${m}`);
              }
            }
            this.cacheKey = f.sort().join("");
          }
          getMaxValue(e) {
            const r = this.binders[e];
            return r instanceof Xr || r instanceof Zr ? r.maxValue : 0;
          }
          populatePaintArrays(e, r, c) {
            for (const f in this.binders) {
              const m = this.binders[f];
              (m instanceof Xr || m instanceof Zr || m instanceof Kn) && m.populatePaintArray(e, r, c);
            }
          }
          setConstantPatternPositions(e, r) {
            for (const c in this.binders) {
              const f = this.binders[c];
              f instanceof Vs && f.setConstantPatternPositions(e, r);
            }
          }
          setConstantDashPositions(e, r) {
            for (const c in this.binders) {
              const f = this.binders[c];
              f instanceof Vs && f.setConstantDashPositions(e, r);
            }
          }
          updatePaintArrays(e, r, c, f, m) {
            let v = !1;
            for (const E in e) {
              const k = r.getPositions(E);
              for (const P of k) {
                const L = c.feature(P.index);
                for (const N in this.binders) {
                  const G = this.binders[N];
                  if ((G instanceof Xr || G instanceof Zr || G instanceof Kn) && G.expression.isStateDependent === !0) {
                    const j = f.paint.get(N);
                    G.expression = j.value, G.updatePaintArray(P.start, P.end, L, e[E], m), v = !0;
                  }
                }
              }
            }
            return v;
          }
          defines() {
            const e = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              (c instanceof js || c instanceof Vs) && e.push(...c.uniformNames.map(((f) => `#define HAS_UNIFORM_${f}`)));
            }
            return e;
          }
          getBinderAttributes() {
            const e = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (c instanceof Xr || c instanceof Zr) for (let f = 0; f < c.paintVertexAttributes.length; f++) e.push(c.paintVertexAttributes[f].name);
              else if (c instanceof Kn) {
                const f = c.getVertexAttributes();
                for (const m of f) e.push(m.name);
              }
            }
            return e;
          }
          getBinderUniforms() {
            const e = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (c instanceof js || c instanceof Vs || c instanceof Zr) for (const f of c.uniformNames) e.push(f);
            }
            return e;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(e, r) {
            const c = [];
            for (const f in this.binders) {
              const m = this.binders[f];
              if (m instanceof js || m instanceof Vs || m instanceof Zr) {
                for (const v of m.uniformNames) if (r[v]) {
                  const E = m.getBinding(e, r[v], v);
                  c.push({ name: v, property: f, binding: E });
                }
              }
            }
            return c;
          }
          setUniforms(e, r, c, f) {
            for (const { name: m, property: v, binding: E } of r) this.binders[v].setUniform(E, f, c.get(v), m);
          }
          updatePaintBuffers(e) {
            this._buffers = [];
            for (const r in this.binders) {
              const c = this.binders[r];
              if (e && c instanceof Kn) {
                const f = e.fromScale === 2 ? c.zoomInPaintVertexBuffer : c.zoomOutPaintVertexBuffer;
                f && this._buffers.push(f);
              } else (c instanceof Xr || c instanceof Zr) && c.paintVertexBuffer && this._buffers.push(c.paintVertexBuffer);
            }
          }
          upload(e) {
            for (const r in this.binders) {
              const c = this.binders[r];
              (c instanceof Xr || c instanceof Zr || c instanceof Kn) && c.upload(e);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const e in this.binders) {
              const r = this.binders[e];
              (r instanceof Xr || r instanceof Zr || r instanceof Kn) && r.destroy();
            }
          }
        }
        class Jo {
          constructor(e, r, c = () => !0) {
            this.programConfigurations = {};
            for (const f of e) this.programConfigurations[f.id] = new yp(f, r, c);
            this.needsUpload = !1, this._featureMap = new Ei(), this._bufferOffset = 0;
          }
          populatePaintArrays(e, r, c, f) {
            for (const m in this.programConfigurations) this.programConfigurations[m].populatePaintArrays(e, r, f);
            r.id !== void 0 && this._featureMap.add(r.id, c, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0;
          }
          updatePaintArrays(e, r, c, f) {
            for (const m of c) this.needsUpload = this.programConfigurations[m.id].updatePaintArrays(e, this._featureMap, r, m, f) || this.needsUpload;
          }
          get(e) {
            return this.programConfigurations[e];
          }
          upload(e) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(e);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
          }
        }
        function mm(i, e) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${e}-`, "").replace(/-/g, "_")];
        }
        function vp(i, e, r) {
          const c = { color: { source: qu, composite: s }, number: { source: Qc, composite: qu } }, f = (function(m) {
            return { "line-pattern": { source: Ce, composite: Ce }, "fill-pattern": { source: Ce, composite: Ce }, "fill-extrusion-pattern": { source: Ce, composite: Ce }, "line-dasharray": { source: Ne, composite: Ne } }[m];
          })(i);
          return f && f[r] || c[e][r];
        }
        jt("ConstantBinder", js), jt("CrossFadedConstantBinder", Vs), jt("SourceExpressionBinder", Xr), jt("CrossFadedPatternBinder", Qn), jt("CrossFadedDasharrayBinder", _p), jt("CompositeExpressionBinder", Zr), jt("ProgramConfiguration", yp, { omit: ["_buffers"] }), jt("ProgramConfigurationSet", Jo);
        const kd = Math.pow(2, 14) - 1, fo = -kd - 1;
        function po(i) {
          const e = We / i.extent, r = i.loadGeometry();
          for (let c = 0; c < r.length; c++) {
            const f = r[c];
            for (let m = 0; m < f.length; m++) {
              const v = f[m], E = Math.round(v.x * e), k = Math.round(v.y * e);
              v.x = Kt(E, fo, kd), v.y = Kt(k, fo, kd), (E < v.x || E > v.x + 1 || k < v.y || k > v.y + 1) && ur("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r;
        }
        function go(i, e) {
          return { type: i.type, id: i.id, properties: i.properties, geometry: e ? po(i) : [] };
        }
        const Id = -32768;
        function Md(i, e, r, c, f) {
          i.emplaceBack(Id + 8 * e + c, Id + 8 * r + f);
        }
        class th {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = e.index, this.hasDependencies = !1, this.layoutVertexArray = new pe(), this.indexArray = new it(), this.segments = new At(), this.programConfigurations = new Jo(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(e, r, c) {
            const f = this.layers[0], m = [];
            let v = null, E = !1, k = f.type === "heatmap";
            if (f.type === "circle") {
              const L = f;
              v = L.layout.get("circle-sort-key"), E = !v.isConstant(), k = k || L.paint.get("circle-pitch-alignment") === "map";
            }
            const P = k ? r.subdivisionGranularity.circle : 1;
            for (const { feature: L, id: N, index: G, sourceLayerIndex: j } of e) {
              const Z = this.layers[0]._featureFilter.needGeometry, Y = go(L, Z);
              if (!this.layers[0]._featureFilter.filter(new Vr(this.zoom), Y, c)) continue;
              const X = E ? v.evaluate(Y, {}, c) : void 0, ne = { id: N, properties: L.properties, type: L.type, sourceLayerIndex: j, index: G, geometry: Z ? Y.geometry : po(L), patterns: {}, sortKey: X };
              m.push(ne);
            }
            E && m.sort(((L, N) => L.sortKey - N.sortKey));
            for (const L of m) {
              const { geometry: N, index: G, sourceLayerIndex: j } = L, Z = e[G].feature;
              this.addFeature(L, N, G, c, P), r.featureIndex.insert(Z, N, G, j, this.index);
            }
          }
          update(e, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: c });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, gt), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(e, r, c, f, m = 1) {
            let v;
            switch (m) {
              case 1:
                v = [0, 7];
                break;
              case 3:
                v = [0, 2, 5, 7];
                break;
              case 5:
                v = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                v = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${m}; valid values are 1, 3, 5, 7.`);
            }
            const E = v.length;
            for (const k of r) for (const P of k) {
              const L = P.x, N = P.y;
              if (L < 0 || L >= We || N < 0 || N >= We) continue;
              const G = this.segments.prepareSegment(E * E, this.layoutVertexArray, this.indexArray, e.sortKey), j = G.vertexLength;
              for (let Z = 0; Z < E; Z++) for (let Y = 0; Y < E; Y++) Md(this.layoutVertexArray, L, N, v[Y], v[Z]);
              for (let Z = 0; Z < E - 1; Z++) for (let Y = 0; Y < E - 1; Y++) {
                const X = j + Z * E + Y, ne = j + (Z + 1) * E + Y;
                this.indexArray.emplaceBack(X, ne + 1, X + 1), this.indexArray.emplaceBack(X, ne, ne + 1);
              }
              G.vertexLength += E * E, G.primitiveLength += (E - 1) * (E - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, { imagePositions: {}, canonical: f });
          }
        }
        function rh(i, e) {
          for (let r = 0; r < i.length; r++) if (nh(e, i[r])) return !0;
          for (let r = 0; r < e.length; r++) if (nh(i, e[r])) return !0;
          return !!_m(i, e);
        }
        function xp(i, e, r) {
          return !!nh(i, e) || !!ym(e, i, r);
        }
        function Tv(i, e) {
          if (i.length === 1) return kv(e, i[0]);
          for (let r = 0; r < e.length; r++) {
            const c = e[r];
            for (let f = 0; f < c.length; f++) if (nh(i, c[f])) return !0;
          }
          for (let r = 0; r < i.length; r++) if (kv(e, i[r])) return !0;
          for (let r = 0; r < e.length; r++) if (_m(i, e[r])) return !0;
          return !1;
        }
        function bE(i, e, r) {
          if (i.length > 1) {
            if (_m(i, e)) return !0;
            for (let c = 0; c < e.length; c++) if (ym(e[c], i, r)) return !0;
          }
          for (let c = 0; c < i.length; c++) if (ym(i[c], e, r)) return !0;
          return !1;
        }
        function _m(i, e) {
          if (i.length === 0 || e.length === 0) return !1;
          for (let r = 0; r < i.length - 1; r++) {
            const c = i[r], f = i[r + 1];
            for (let m = 0; m < e.length - 1; m++) if (wE(c, f, e[m], e[m + 1])) return !0;
          }
          return !1;
        }
        function wE(i, e, r, c) {
          return tr(i, r, c) !== tr(e, r, c) && tr(i, e, r) !== tr(i, e, c);
        }
        function ym(i, e, r) {
          const c = r * r;
          if (e.length === 1) return i.distSqr(e[0]) < c;
          for (let f = 1; f < e.length; f++) if (Sv(i, e[f - 1], e[f]) < c) return !0;
          return !1;
        }
        function Sv(i, e, r) {
          const c = e.distSqr(r);
          if (c === 0) return i.distSqr(e);
          const f = ((i.x - e.x) * (r.x - e.x) + (i.y - e.y) * (r.y - e.y)) / c;
          return i.distSqr(f < 0 ? e : f > 1 ? r : r.sub(e)._mult(f)._add(e));
        }
        function kv(i, e) {
          let r, c, f, m = !1;
          for (let v = 0; v < i.length; v++) {
            r = i[v];
            for (let E = 0, k = r.length - 1; E < r.length; k = E++) c = r[E], f = r[k], c.y > e.y != f.y > e.y && e.x < (f.x - c.x) * (e.y - c.y) / (f.y - c.y) + c.x && (m = !m);
          }
          return m;
        }
        function nh(i, e) {
          let r = !1;
          for (let c = 0, f = i.length - 1; c < i.length; f = c++) {
            const m = i[c], v = i[f];
            m.y > e.y != v.y > e.y && e.x < (v.x - m.x) * (e.y - m.y) / (v.y - m.y) + m.x && (r = !r);
          }
          return r;
        }
        function EE(i, e, r) {
          const c = r[0], f = r[2];
          if (i.x < c.x && e.x < c.x || i.x > f.x && e.x > f.x || i.y < c.y && e.y < c.y || i.y > f.y && e.y > f.y) return !1;
          const m = tr(i, e, r[0]);
          return m !== tr(i, e, r[1]) || m !== tr(i, e, r[2]) || m !== tr(i, e, r[3]);
        }
        function ih(i, e, r) {
          const c = e.paint.get(i).value;
          return c.kind === "constant" ? c.value : r.programConfigurations.get(e.id).getMaxValue(i);
        }
        function bp(i) {
          return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
        }
        function wp(i, e, r, c, f) {
          if (!e[0] && !e[1]) return i;
          const m = R.convert(e)._mult(f);
          r === "viewport" && m._rotate(-c);
          const v = [];
          for (let E = 0; E < i.length; E++) v.push(i[E].sub(m));
          return v;
        }
        function TE(i) {
          const e = [];
          for (let r = 0; r < i.length; r++) {
            const c = i[r], f = e.at(-1);
            (r === 0 || f && !c.equals(f)) && e.push(c);
          }
          return e;
        }
        function SE({ queryGeometry: i, size: e }, r) {
          return xp(i, r, e);
        }
        function kE({ queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f }, m) {
          return xp(i, m, e * (r.projectTileCoordinates(m.x, m.y, c, f).signedDistanceFromCamera / r.cameraToCenterDistance));
        }
        function IE({ queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f }, m) {
          const v = r.projectTileCoordinates(m.x, m.y, c, f).signedDistanceFromCamera, E = e * (r.cameraToCenterDistance / v);
          return xp(i, vm(m, r, c, f), E);
        }
        function ME({ queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f }, m) {
          return xp(i, vm(m, r, c, f), e);
        }
        function Iv({ queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f, pitchAlignment: m = "map", pitchScale: v = "map" }, E) {
          const k = m === "map" ? v === "map" ? SE : kE : v === "map" ? IE : ME, P = { queryGeometry: i, size: e, transform: r, unwrappedTileID: c, getElevation: f };
          for (const L of E) for (const N of L) if (k(P, N)) return !0;
          return !1;
        }
        function vm(i, e, r, c) {
          const f = e.projectTileCoordinates(i.x, i.y, r, c).point;
          return new R((0.5 * f.x + 0.5) * e.width, (0.5 * -f.y + 0.5) * e.height);
        }
        let Mv, Cv;
        jt("CircleBucket", th, { omit: ["layers"] });
        var CE = { get paint() {
          return Cv = Cv || new Vi({ "circle-radius": new Jt(Xe.paint_circle["circle-radius"]), "circle-color": new Jt(Xe.paint_circle["circle-color"]), "circle-blur": new Jt(Xe.paint_circle["circle-blur"]), "circle-opacity": new Jt(Xe.paint_circle["circle-opacity"]), "circle-translate": new Zt(Xe.paint_circle["circle-translate"]), "circle-translate-anchor": new Zt(Xe.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Zt(Xe.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Zt(Xe.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Jt(Xe.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Jt(Xe.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Jt(Xe.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return Mv = Mv || new Vi({ "circle-sort-key": new Jt(Xe.layout_circle["circle-sort-key"]) });
        } };
        class PE extends Es {
          constructor(e, r) {
            super(e, CE, r);
          }
          createBucket(e) {
            return new th(e);
          }
          queryRadius(e) {
            const r = e;
            return ih("circle-radius", this, r) + ih("circle-stroke-width", this, r) + bp(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: c, geometry: f, transform: m, pixelsToTileUnits: v, unwrappedTileID: E, getElevation: k }) {
            const P = wp(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -m.bearingInRadians, v), L = this.paint.get("circle-radius").evaluate(r, c) + this.paint.get("circle-stroke-width").evaluate(r, c), N = this.paint.get("circle-pitch-scale"), G = this.paint.get("circle-pitch-alignment");
            let j, Z;
            return G === "map" ? (j = P, Z = L * v) : (j = (function(Y, X, ne, xe) {
              return Y.map(((ae) => vm(ae, X, ne, xe)));
            })(P, m, E, k), Z = L), Iv({ queryGeometry: j, size: Z, transform: m, unwrappedTileID: E, getElevation: k, pitchAlignment: G, pitchScale: N }, f);
          }
        }
        class Pv extends th {
        }
        let Av;
        jt("HeatmapBucket", Pv, { omit: ["layers"] });
        var AE = { get paint() {
          return Av = Av || new Vi({ "heatmap-radius": new Jt(Xe.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Jt(Xe.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Zt(Xe.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Yc(Xe.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Zt(Xe.paint_heatmap["heatmap-opacity"]) });
        } };
        function xm(i, { width: e, height: r }, c, f) {
          if (f) {
            if (f instanceof Uint8ClampedArray) f = new Uint8Array(f.buffer);
            else if (f.length !== e * r * c) throw new RangeError(`mismatched image size. expected: ${f.length} but got: ${e * r * c}`);
          } else f = new Uint8Array(e * r * c);
          return i.width = e, i.height = r, i.data = f, i;
        }
        function Lv(i, { width: e, height: r }, c) {
          if (e === i.width && r === i.height) return;
          const f = xm({}, { width: e, height: r }, c);
          bm(i, f, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, e), height: Math.min(i.height, r) }, c), i.width = e, i.height = r, i.data = f.data;
        }
        function bm(i, e, r, c, f, m) {
          if (f.width === 0 || f.height === 0) return e;
          if (f.width > i.width || f.height > i.height || r.x > i.width - f.width || r.y > i.height - f.height) throw new RangeError("out of range source coordinates for image copy");
          if (f.width > e.width || f.height > e.height || c.x > e.width - f.width || c.y > e.height - f.height) throw new RangeError("out of range destination coordinates for image copy");
          const v = i.data, E = e.data;
          if (v === E) throw new Error("srcData equals dstData, so image is already copied");
          for (let k = 0; k < f.height; k++) {
            const P = ((r.y + k) * i.width + r.x) * m, L = ((c.y + k) * e.width + c.x) * m;
            for (let N = 0; N < f.width * m; N++) E[L + N] = v[P + N];
          }
          return e;
        }
        class Cd {
          constructor(e, r) {
            xm(this, e, 1, r);
          }
          resize(e) {
            Lv(this, e, 1);
          }
          clone() {
            return new Cd({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, r, c, f, m) {
            bm(e, r, c, f, m, 1);
          }
        }
        class os {
          constructor(e, r) {
            xm(this, e, 4, r);
          }
          resize(e) {
            Lv(this, e, 4);
          }
          replace(e, r) {
            r ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
          }
          clone() {
            return new os({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, r, c, f, m) {
            bm(e, r, c, f, m, 4);
          }
          setPixel(e, r, c) {
            const f = 4 * (e * this.width + r);
            this.data[f + 0] = Math.round(255 * c.r / c.a), this.data[f + 1] = Math.round(255 * c.g / c.a), this.data[f + 2] = Math.round(255 * c.b / c.a), this.data[f + 3] = Math.round(255 * c.a);
          }
        }
        function Dv(i) {
          const e = {}, r = i.resolution || 256, c = i.clips ? i.clips.length : 1, f = i.image || new os({ width: r, height: c });
          if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
          const m = (v, E, k) => {
            e[i.evaluationKey] = k;
            const P = i.expression.evaluate(e);
            f.setPixel(v / 4 / r, E / 4, P);
          };
          if (i.clips) for (let v = 0, E = 0; v < c; ++v, E += 4 * r) for (let k = 0, P = 0; k < r; k++, P += 4) {
            const L = k / (r - 1), { start: N, end: G } = i.clips[v];
            m(E, P, N * (1 - L) + G * L);
          }
          else for (let v = 0, E = 0; v < r; v++, E += 4) m(0, E, v / (r - 1));
          return f;
        }
        jt("AlphaImage", Cd), jt("RGBAImage", os);
        const wm = "big-fb";
        class LE extends Es {
          createBucket(e) {
            return new Pv(e);
          }
          constructor(e, r) {
            super(e, AE, r), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Dv({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(wm) && this.heatmapFbos.delete(wm);
          }
          queryRadius(e) {
            return ih("heatmap-radius", this, e);
          }
          queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: c, geometry: f, transform: m, pixelsToTileUnits: v, unwrappedTileID: E, getElevation: k }) {
            return Iv({ queryGeometry: e, size: this.paint.get("heatmap-radius").evaluate(r, c) * v, transform: m, unwrappedTileID: E, getElevation: k }, f);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && !this.isHidden();
          }
        }
        let Rv;
        var DE = { get paint() {
          return Rv = Rv || new Vi({ "hillshade-illumination-direction": new Zt(Xe.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Zt(Xe.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Zt(Xe.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Zt(Xe.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Zt(Xe.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Zt(Xe.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Zt(Xe.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Zt(Xe.paint_hillshade["hillshade-method"]) });
        } };
        class RE extends Es {
          constructor(e, r) {
            super(e, DE, r), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let e = this.paint.get("hillshade-illumination-direction").values, r = this.paint.get("hillshade-illumination-altitude").values, c = this.paint.get("hillshade-highlight-color").values, f = this.paint.get("hillshade-shadow-color").values;
            const m = Math.max(e.length, r.length, c.length, f.length);
            e = e.concat(Array(m - e.length).fill(e.at(-1))), r = r.concat(Array(m - r.length).fill(r.at(-1))), c = c.concat(Array(m - c.length).fill(c.at(-1))), f = f.concat(Array(m - f.length).fill(f.at(-1)));
            const v = r.map(er);
            return { directionRadians: e.map(er), altitudeRadians: v, shadowColor: f, highlightColor: c };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && !this.isHidden();
          }
        }
        let Fv;
        var FE = { get paint() {
          return Fv = Fv || new Vi({ "color-relief-opacity": new Zt(Xe["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new Yc(Xe["paint_color-relief"]["color-relief-color"]) });
        } };
        class Em {
          constructor(e, r, c, f) {
            this.context = e, this.format = c, this.texture = e.gl.createTexture(), this.update(r, f);
          }
          update(e, r, c) {
            const { width: f, height: m } = e, v = !(this.size && this.size[0] === f && this.size[1] === m || c), { context: E } = this, { gl: k } = E;
            if (this.useMipmap = !!(r && r.useMipmap), k.bindTexture(k.TEXTURE_2D, this.texture), E.pixelStoreUnpackFlipY.set(!1), E.pixelStoreUnpack.set(1), E.pixelStoreUnpackPremultiplyAlpha.set(this.format === k.RGBA && (!r || r.premultiply !== !1)), v) this.size = [f, m], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || _i(e) ? k.texImage2D(k.TEXTURE_2D, 0, this.format, this.format, k.UNSIGNED_BYTE, e) : k.texImage2D(k.TEXTURE_2D, 0, this.format, f, m, 0, this.format, k.UNSIGNED_BYTE, e.data);
            else {
              const { x: P, y: L } = c || { x: 0, y: 0 };
              e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || _i(e) ? k.texSubImage2D(k.TEXTURE_2D, 0, P, L, k.RGBA, k.UNSIGNED_BYTE, e) : k.texSubImage2D(k.TEXTURE_2D, 0, P, L, f, m, k.RGBA, k.UNSIGNED_BYTE, e.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && k.generateMipmap(k.TEXTURE_2D), E.pixelStoreUnpackFlipY.setDefault(), E.pixelStoreUnpack.setDefault(), E.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(e, r, c) {
            const { context: f } = this, { gl: m } = f;
            m.bindTexture(m.TEXTURE_2D, this.texture), c !== m.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (c = m.LINEAR), e !== this.filter && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, e), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, c || e), this.filter = e), r !== this.wrap && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, r), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, r), this.wrap = r);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: e } = this.context;
            e.deleteTexture(this.texture), this.texture = null;
          }
        }
        class Nv {
          constructor(e, r, c, f = 1, m = 1, v = 1, E = 0) {
            if (this.uid = e, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (c && !["mapbox", "terrarium", "custom"].includes(c)) return void ur(`"${c}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = r.height;
            const k = this.dim = r.height - 2;
            switch (this.data = new Uint32Array(r.data.buffer), c) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = f, this.greenFactor = m, this.blueFactor = v, this.baseShift = E;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let P = 0; P < k; P++) this.data[this._idx(-1, P)] = this.data[this._idx(0, P)], this.data[this._idx(k, P)] = this.data[this._idx(k - 1, P)], this.data[this._idx(P, -1)] = this.data[this._idx(P, 0)], this.data[this._idx(P, k)] = this.data[this._idx(P, k - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(k, -1)] = this.data[this._idx(k - 1, 0)], this.data[this._idx(-1, k)] = this.data[this._idx(0, k - 1)], this.data[this._idx(k, k)] = this.data[this._idx(k - 1, k - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let P = 0; P < k; P++) for (let L = 0; L < k; L++) {
              const N = this.get(P, L);
              N > this.max && (this.max = N), N < this.min && (this.min = N);
            }
          }
          get(e, r) {
            const c = new Uint8Array(this.data.buffer), f = 4 * this._idx(e, r);
            return this.unpack(c[f], c[f + 1], c[f + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(e, r) {
            if (e < -1 || e >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError(`Out of range source coordinates for DEM data. x: ${e}, y: ${r}, dim: ${this.dim}`);
            return (r + 1) * this.stride + (e + 1);
          }
          unpack(e, r, c) {
            return e * this.redFactor + r * this.greenFactor + c * this.blueFactor - this.baseShift;
          }
          pack(e) {
            return Ov(e, this.getUnpackVector());
          }
          getPixels() {
            return new os({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(e, r, c) {
            if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
            let f = r * this.dim, m = r * this.dim + this.dim, v = c * this.dim, E = c * this.dim + this.dim;
            switch (r) {
              case -1:
                f = m - 1;
                break;
              case 1:
                m = f + 1;
            }
            switch (c) {
              case -1:
                v = E - 1;
                break;
              case 1:
                E = v + 1;
            }
            const k = -r * this.dim, P = -c * this.dim;
            for (let L = v; L < E; L++) for (let N = f; N < m; N++) this.data[this._idx(N, L)] = e.data[this._idx(N + k, L + P)];
          }
        }
        function Ov(i, e) {
          const r = e[0], c = e[1], f = e[2], m = e[3], v = Math.min(r, c, f), E = Math.round((i + m) / v);
          return { r: Math.floor(E * v / r) % 256, g: Math.floor(E * v / c) % 256, b: Math.floor(E * v / f) % 256 };
        }
        jt("DEMData", Nv);
        class NE extends Es {
          constructor(e, r) {
            super(e, FE, r);
          }
          _createColorRamp(e) {
            const r = { elevationStops: [], colorStops: [] }, c = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (c instanceof Fc && c._styleExpression.expression instanceof xi) {
              this.colorRampExpression = c;
              const v = c._styleExpression.expression;
              r.elevationStops = v.labels, r.colorStops = [];
              for (const E of r.elevationStops) r.colorStops.push(v.evaluate({ globals: { elevation: E } }));
            }
            if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [hr.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= e) return r;
            const f = { elevationStops: [], colorStops: [] }, m = (r.elevationStops.length - 1) / (e - 1);
            for (let v = 0; v < r.elevationStops.length - 0.5; v += m) f.elevationStops.push(r.elevationStops[Math.round(v)]), f.colorStops.push(r.colorStops[Math.round(v)]);
            return ur(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${e}, provided: ${r.elevationStops.length}`), f;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(e, r, c) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const f = this._createColorRamp(r), m = new os({ width: f.colorStops.length, height: 1 }), v = new os({ width: f.colorStops.length, height: 1 });
            for (let E = 0; E < f.elevationStops.length; E++) {
              const k = Ov(f.elevationStops[E], c);
              v.setPixel(0, E, new hr(k.r / 255, k.g / 255, k.b / 255, 1)), m.setPixel(0, E, f.colorStops[E]);
            }
            return this.colorRampTextures = { elevationTexture: new Em(e, v, e.gl.RGBA), colorTexture: new Em(e, m, e.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return !this.isHidden() && !!this.colorRampTextures;
          }
        }
        const OE = An([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: zE } = OE;
        function Ep(i, e, r) {
          const c = r.patternDependencies;
          let f = !1;
          for (const m of e) {
            const v = m.paint.get(`${i}-pattern`);
            v.isConstant() || (f = !0);
            const E = v.constantOr(null);
            E && (f = !0, c[E.to] = !0, c[E.from] = !0);
          }
          return f;
        }
        function Tm(i, e, r, c, f) {
          const { zoom: m } = c, v = f.patternDependencies;
          for (const E of e) {
            const k = E.paint.get(`${i}-pattern`).value;
            if (k.kind !== "constant") {
              let P = k.evaluate({ zoom: m - 1 }, r, {}, f.availableImages), L = k.evaluate({ zoom: m }, r, {}, f.availableImages), N = k.evaluate({ zoom: m + 1 }, r, {}, f.availableImages);
              P = P && P.name ? P.name : P, L = L && L.name ? L.name : L, N = N && N.name ? N.name : N, v[P] = !0, v[L] = !0, v[N] = !0, r.patterns[E.id] = { min: P, mid: L, max: N };
            }
          }
          return r;
        }
        function zv(i, e, r, c, f) {
          let m;
          if (f === (function(v, E, k, P) {
            let L = 0;
            for (let N = E, G = k - P; N < k; N += P) L += (v[G] - v[N]) * (v[N + 1] + v[G + 1]), G = N;
            return L;
          })(i, e, r, c) > 0) for (let v = e; v < r; v += c) m = Vv(v / c | 0, i[v], i[v + 1], m);
          else for (let v = r - c; v >= e; v -= c) m = Vv(v / c | 0, i[v], i[v + 1], m);
          return m && sh(m, m.next) && (Dd(m), m = m.next), m;
        }
        function Wu(i, e) {
          if (!i) return i;
          e || (e = i);
          let r, c = i;
          do
            if (r = !1, c.steiner || !sh(c, c.next) && zn(c.prev, c, c.next) !== 0) c = c.next;
            else {
              if (Dd(c), c = e = c.prev, c === c.next) break;
              r = !0;
            }
          while (r || c !== e);
          return e;
        }
        function Pd(i, e, r, c, f, m, v) {
          if (!i) return;
          !v && m && (function(k, P, L, N) {
            let G = k;
            do
              G.z === 0 && (G.z = Sm(G.x, G.y, P, L, N)), G.prevZ = G.prev, G.nextZ = G.next, G = G.next;
            while (G !== k);
            G.prevZ.nextZ = null, G.prevZ = null, (function(j) {
              let Z, Y = 1;
              do {
                let X, ne = j;
                j = null;
                let xe = null;
                for (Z = 0; ne; ) {
                  Z++;
                  let ae = ne, ue = 0;
                  for (let Ae = 0; Ae < Y && (ue++, ae = ae.nextZ, ae); Ae++) ;
                  let Te = Y;
                  for (; ue > 0 || Te > 0 && ae; ) ue !== 0 && (Te === 0 || !ae || ne.z <= ae.z) ? (X = ne, ne = ne.nextZ, ue--) : (X = ae, ae = ae.nextZ, Te--), xe ? xe.nextZ = X : j = X, X.prevZ = xe, xe = X;
                  ne = ae;
                }
                xe.nextZ = null, Y *= 2;
              } while (Z > 1);
            })(G);
          })(i, c, f, m);
          let E = i;
          for (; i.prev !== i.next; ) {
            const k = i.prev, P = i.next;
            if (m ? GE(i, c, f, m) : BE(i)) e.push(k.i, i.i, P.i), Dd(i), i = P.next, E = P.next;
            else if ((i = P) === E) {
              v ? v === 1 ? Pd(i = jE(Wu(i), e), e, r, c, f, m, 2) : v === 2 && VE(i, e, r, c, f, m) : Pd(Wu(i), e, r, c, f, m, 1);
              break;
            }
          }
        }
        function BE(i) {
          const e = i.prev, r = i, c = i.next;
          if (zn(e, r, c) >= 0) return !1;
          const f = e.x, m = r.x, v = c.x, E = e.y, k = r.y, P = c.y, L = Math.min(f, m, v), N = Math.min(E, k, P), G = Math.max(f, m, v), j = Math.max(E, k, P);
          let Z = c.next;
          for (; Z !== e; ) {
            if (Z.x >= L && Z.x <= G && Z.y >= N && Z.y <= j && Ad(f, E, m, k, v, P, Z.x, Z.y) && zn(Z.prev, Z, Z.next) >= 0) return !1;
            Z = Z.next;
          }
          return !0;
        }
        function GE(i, e, r, c) {
          const f = i.prev, m = i, v = i.next;
          if (zn(f, m, v) >= 0) return !1;
          const E = f.x, k = m.x, P = v.x, L = f.y, N = m.y, G = v.y, j = Math.min(E, k, P), Z = Math.min(L, N, G), Y = Math.max(E, k, P), X = Math.max(L, N, G), ne = Sm(j, Z, e, r, c), xe = Sm(Y, X, e, r, c);
          let ae = i.prevZ, ue = i.nextZ;
          for (; ae && ae.z >= ne && ue && ue.z <= xe; ) {
            if (ae.x >= j && ae.x <= Y && ae.y >= Z && ae.y <= X && ae !== f && ae !== v && Ad(E, L, k, N, P, G, ae.x, ae.y) && zn(ae.prev, ae, ae.next) >= 0 || (ae = ae.prevZ, ue.x >= j && ue.x <= Y && ue.y >= Z && ue.y <= X && ue !== f && ue !== v && Ad(E, L, k, N, P, G, ue.x, ue.y) && zn(ue.prev, ue, ue.next) >= 0)) return !1;
            ue = ue.nextZ;
          }
          for (; ae && ae.z >= ne; ) {
            if (ae.x >= j && ae.x <= Y && ae.y >= Z && ae.y <= X && ae !== f && ae !== v && Ad(E, L, k, N, P, G, ae.x, ae.y) && zn(ae.prev, ae, ae.next) >= 0) return !1;
            ae = ae.prevZ;
          }
          for (; ue && ue.z <= xe; ) {
            if (ue.x >= j && ue.x <= Y && ue.y >= Z && ue.y <= X && ue !== f && ue !== v && Ad(E, L, k, N, P, G, ue.x, ue.y) && zn(ue.prev, ue, ue.next) >= 0) return !1;
            ue = ue.nextZ;
          }
          return !0;
        }
        function jE(i, e) {
          let r = i;
          do {
            const c = r.prev, f = r.next.next;
            !sh(c, f) && Gv(c, r, r.next, f) && Ld(c, f) && Ld(f, c) && (e.push(c.i, r.i, f.i), Dd(r), Dd(r.next), r = i = f), r = r.next;
          } while (r !== i);
          return Wu(r);
        }
        function VE(i, e, r, c, f, m) {
          let v = i;
          do {
            let E = v.next.next;
            for (; E !== v.prev; ) {
              if (v.i !== E.i && HE(v, E)) {
                let k = jv(v, E);
                return v = Wu(v, v.next), k = Wu(k, k.next), Pd(v, e, r, c, f, m, 0), void Pd(k, e, r, c, f, m, 0);
              }
              E = E.next;
            }
            v = v.next;
          } while (v !== i);
        }
        function UE(i, e) {
          let r = i.x - e.x;
          return r === 0 && (r = i.y - e.y, r === 0) && (r = (i.next.y - i.y) / (i.next.x - i.x) - (e.next.y - e.y) / (e.next.x - e.x)), r;
        }
        function qE(i, e) {
          const r = (function(f, m) {
            let v = m;
            const E = f.x, k = f.y;
            let P, L = -1 / 0;
            if (sh(f, v)) return v;
            do {
              if (sh(f, v.next)) return v.next;
              if (k <= v.y && k >= v.next.y && v.next.y !== v.y) {
                const Y = v.x + (k - v.y) * (v.next.x - v.x) / (v.next.y - v.y);
                if (Y <= E && Y > L && (L = Y, P = v.x < v.next.x ? v : v.next, Y === E)) return P;
              }
              v = v.next;
            } while (v !== m);
            if (!P) return null;
            const N = P, G = P.x, j = P.y;
            let Z = 1 / 0;
            v = P;
            do {
              if (E >= v.x && v.x >= G && E !== v.x && Bv(k < j ? E : L, k, G, j, k < j ? L : E, k, v.x, v.y)) {
                const Y = Math.abs(k - v.y) / (E - v.x);
                Ld(v, f) && (Y < Z || Y === Z && (v.x > P.x || v.x === P.x && $E(P, v))) && (P = v, Z = Y);
              }
              v = v.next;
            } while (v !== N);
            return P;
          })(i, e);
          if (!r) return e;
          const c = jv(r, i);
          return Wu(c, c.next), Wu(r, r.next);
        }
        function $E(i, e) {
          return zn(i.prev, i, e.prev) < 0 && zn(e.next, i, i.next) < 0;
        }
        function Sm(i, e, r, c, f) {
          return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - r) * f | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - c) * f | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function ZE(i) {
          let e = i, r = i;
          do
            (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
          while (e !== i);
          return r;
        }
        function Bv(i, e, r, c, f, m, v, E) {
          return (f - v) * (e - E) >= (i - v) * (m - E) && (i - v) * (c - E) >= (r - v) * (e - E) && (r - v) * (m - E) >= (f - v) * (c - E);
        }
        function Ad(i, e, r, c, f, m, v, E) {
          return !(i === v && e === E) && Bv(i, e, r, c, f, m, v, E);
        }
        function HE(i, e) {
          return i.next.i !== e.i && i.prev.i !== e.i && !(function(r, c) {
            let f = r;
            do {
              if (f.i !== r.i && f.next.i !== r.i && f.i !== c.i && f.next.i !== c.i && Gv(f, f.next, r, c)) return !0;
              f = f.next;
            } while (f !== r);
            return !1;
          })(i, e) && (Ld(i, e) && Ld(e, i) && (function(r, c) {
            let f = r, m = !1;
            const v = (r.x + c.x) / 2, E = (r.y + c.y) / 2;
            do
              f.y > E != f.next.y > E && f.next.y !== f.y && v < (f.next.x - f.x) * (E - f.y) / (f.next.y - f.y) + f.x && (m = !m), f = f.next;
            while (f !== r);
            return m;
          })(i, e) && (zn(i.prev, i, e.prev) || zn(i, e.prev, e)) || sh(i, e) && zn(i.prev, i, i.next) > 0 && zn(e.prev, e, e.next) > 0);
        }
        function zn(i, e, r) {
          return (e.y - i.y) * (r.x - e.x) - (e.x - i.x) * (r.y - e.y);
        }
        function sh(i, e) {
          return i.x === e.x && i.y === e.y;
        }
        function Gv(i, e, r, c) {
          const f = Sp(zn(i, e, r)), m = Sp(zn(i, e, c)), v = Sp(zn(r, c, i)), E = Sp(zn(r, c, e));
          return f !== m && v !== E || !(f !== 0 || !Tp(i, r, e)) || !(m !== 0 || !Tp(i, c, e)) || !(v !== 0 || !Tp(r, i, c)) || !(E !== 0 || !Tp(r, e, c));
        }
        function Tp(i, e, r) {
          return e.x <= Math.max(i.x, r.x) && e.x >= Math.min(i.x, r.x) && e.y <= Math.max(i.y, r.y) && e.y >= Math.min(i.y, r.y);
        }
        function Sp(i) {
          return i > 0 ? 1 : i < 0 ? -1 : 0;
        }
        function Ld(i, e) {
          return zn(i.prev, i, i.next) < 0 ? zn(i, e, i.next) >= 0 && zn(i, i.prev, e) >= 0 : zn(i, e, i.prev) < 0 || zn(i, i.next, e) < 0;
        }
        function jv(i, e) {
          const r = km(i.i, i.x, i.y), c = km(e.i, e.x, e.y), f = i.next, m = e.prev;
          return i.next = e, e.prev = i, r.next = f, f.prev = r, c.next = r, r.prev = c, m.next = c, c.prev = m, c;
        }
        function Vv(i, e, r, c) {
          const f = km(i, e, r);
          return c ? (f.next = c.next, f.prev = c, c.next.prev = f, c.next = f) : (f.prev = f, f.next = f), f;
        }
        function Dd(i) {
          i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
        }
        function km(i, e, r) {
          return { i, x: e, y: r, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class ah {
          constructor(e, r) {
            if (r > e) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = e, this._minGranularity = r;
          }
          getGranularityForZoomLevel(e) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << e)), this._minGranularity, 1);
          }
        }
        class kp {
          constructor(e) {
            this.fill = e.fill, this.line = e.line, this.tile = e.tile, this.stencil = e.stencil, this.circle = e.circle;
          }
        }
        kp.noSubdivision = new kp({ fill: new ah(0, 0), line: new ah(0, 0), tile: new ah(0, 0), stencil: new ah(0, 0), circle: 1 }), jt("SubdivisionGranularityExpression", ah), jt("SubdivisionGranularitySetting", kp);
        const oh = -32768, Rd = 32767;
        class YE {
          constructor(e, r) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = e, this._granularityCellSize = We / e, this._canonical = r;
          }
          _getKey(e, r) {
            return (e += 32768) << 16 | r + 32768;
          }
          _vertexToIndex(e, r) {
            if (e < -32768 || r < -32768 || e > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const c = 0 | Math.round(e), f = 0 | Math.round(r), m = this._getKey(c, f);
            if (this._vertexDictionary.has(m)) return this._vertexDictionary.get(m);
            const v = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(m, v), this._vertexBuffer.push(c, f), v;
          }
          _subdivideTrianglesScanline(e) {
            if (this._granularity < 2) return (function(f, m) {
              const v = [];
              for (let E = 0; E < m.length; E += 3) {
                const k = m[E], P = m[E + 1], L = m[E + 2], N = f[2 * k], G = f[2 * k + 1];
                (f[2 * P] - N) * (f[2 * L + 1] - G) - (f[2 * P + 1] - G) * (f[2 * L] - N) > 0 ? (v.push(k), v.push(L), v.push(P)) : (v.push(k), v.push(P), v.push(L));
              }
              return v;
            })(this._vertexBuffer, e);
            const r = [], c = e.length;
            for (let f = 0; f < c; f += 3) {
              const m = [e[f + 0], e[f + 1], e[f + 2]], v = [this._vertexBuffer[2 * e[f + 0] + 0], this._vertexBuffer[2 * e[f + 0] + 1], this._vertexBuffer[2 * e[f + 1] + 0], this._vertexBuffer[2 * e[f + 1] + 1], this._vertexBuffer[2 * e[f + 2] + 0], this._vertexBuffer[2 * e[f + 2] + 1]];
              let E = 1 / 0, k = 1 / 0, P = -1 / 0, L = -1 / 0;
              for (let Y = 0; Y < 3; Y++) {
                const X = v[2 * Y], ne = v[2 * Y + 1];
                E = Math.min(E, X), P = Math.max(P, X), k = Math.min(k, ne), L = Math.max(L, ne);
              }
              if (E === P || k === L) continue;
              const N = Math.floor(E / this._granularityCellSize), G = Math.ceil(P / this._granularityCellSize), j = Math.floor(k / this._granularityCellSize), Z = Math.ceil(L / this._granularityCellSize);
              if (N !== G || j !== Z) for (let Y = j; Y < Z; Y++) {
                const X = this._scanlineGenerateVertexRingForCellRow(Y, v, m);
                WE(this._vertexBuffer, X, r);
              }
              else r.push(...m);
            }
            return r;
          }
          _scanlineGenerateVertexRingForCellRow(e, r, c) {
            const f = e * this._granularityCellSize, m = f + this._granularityCellSize, v = [];
            for (let E = 0; E < 3; E++) {
              const k = r[2 * E], P = r[2 * E + 1], L = r[2 * (E + 1) % 6], N = r[(2 * (E + 1) + 1) % 6], G = r[2 * (E + 2) % 6], j = r[(2 * (E + 2) + 1) % 6], Z = L - k, Y = N - P, X = Z === 0, ne = Y === 0, xe = (f - P) / Y, ae = (m - P) / Y, ue = Math.min(xe, ae), Te = Math.max(xe, ae);
              if (!ne && (ue >= 1 || Te <= 0) || ne && (P < f || P > m)) {
                N >= f && N <= m && v.push(c[(E + 1) % 3]);
                continue;
              }
              !ne && ue > 0 && v.push(this._vertexToIndex(k + Z * ue, P + Y * ue));
              const Ae = k + Z * Math.max(ue, 0), Ke = k + Z * Math.min(Te, 1);
              X || this._generateIntraEdgeVertices(v, k, P, L, N, Ae, Ke), !ne && Te < 1 && v.push(this._vertexToIndex(k + Z * Te, P + Y * Te)), (ne || N >= f && N <= m) && v.push(c[(E + 1) % 3]), !ne && (N <= f || N >= m) && this._generateInterEdgeVertices(v, k, P, L, N, G, j, Ke, f, m);
            }
            return v;
          }
          _generateIntraEdgeVertices(e, r, c, f, m, v, E) {
            const k = f - r, P = m - c, L = P === 0, N = L ? Math.min(r, f) : Math.min(v, E), G = L ? Math.max(r, f) : Math.max(v, E), j = Math.floor(N / this._granularityCellSize) + 1, Z = Math.ceil(G / this._granularityCellSize) - 1;
            if (L ? r < f : v < E) for (let Y = j; Y <= Z; Y++) {
              const X = Y * this._granularityCellSize;
              e.push(this._vertexToIndex(X, c + P * (X - r) / k));
            }
            else for (let Y = Z; Y >= j; Y--) {
              const X = Y * this._granularityCellSize;
              e.push(this._vertexToIndex(X, c + P * (X - r) / k));
            }
          }
          _generateInterEdgeVertices(e, r, c, f, m, v, E, k, P, L) {
            const N = m - c, G = v - f, j = E - m, Z = (P - m) / j, Y = (L - m) / j, X = Math.min(Z, Y), ne = Math.max(Z, Y), xe = f + G * X;
            let ae = Math.floor(Math.min(xe, k) / this._granularityCellSize) + 1, ue = Math.ceil(Math.max(xe, k) / this._granularityCellSize) - 1, Te = k < xe;
            const Ae = j === 0;
            if (Ae && (E === P || E === L)) return;
            if (Ae || X >= 1 || ne <= 0) {
              const ht = c - E, lt = v + (r - v) * Math.min((P - E) / ht, (L - E) / ht);
              ae = Math.floor(Math.min(lt, k) / this._granularityCellSize) + 1, ue = Math.ceil(Math.max(lt, k) / this._granularityCellSize) - 1, Te = k < lt;
            }
            const Ke = N > 0 ? L : P;
            if (Te) for (let ht = ae; ht <= ue; ht++) e.push(this._vertexToIndex(ht * this._granularityCellSize, Ke));
            else for (let ht = ue; ht >= ae; ht--) e.push(this._vertexToIndex(ht * this._granularityCellSize, Ke));
          }
          _generateOutline(e) {
            const r = [];
            for (const c of e) {
              const f = Xu(c, this._granularity, !0), m = this._pointArrayToIndices(f), v = [];
              for (let E = 1; E < m.length; E++) v.push(m[E - 1]), v.push(m[E]);
              r.push(v);
            }
            return r;
          }
          _handlePoles(e) {
            let r = !1, c = !1;
            this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (c = !0)), (r || c) && this._fillPoles(e, r, c);
          }
          _ensureNoPoleVertices() {
            const e = this._vertexBuffer;
            for (let r = 0; r < e.length; r += 2) {
              const c = e[r + 1];
              c === oh && (e[r + 1] = -32767), c === Rd && (e[r + 1] = 32766);
            }
          }
          _generatePoleQuad(e, r, c, f, m, v) {
            f > m != (v === oh) ? (e.push(r), e.push(c), e.push(this._vertexToIndex(f, v)), e.push(c), e.push(this._vertexToIndex(m, v)), e.push(this._vertexToIndex(f, v))) : (e.push(c), e.push(r), e.push(this._vertexToIndex(f, v)), e.push(this._vertexToIndex(m, v)), e.push(c), e.push(this._vertexToIndex(f, v)));
          }
          _fillPoles(e, r, c) {
            const f = this._vertexBuffer, m = We, v = e.length;
            for (let E = 2; E < v; E += 3) {
              const k = e[E - 2], P = e[E - 1], L = e[E], N = f[2 * k], G = f[2 * k + 1], j = f[2 * P], Z = f[2 * P + 1], Y = f[2 * L], X = f[2 * L + 1];
              r && (G === 0 && Z === 0 && this._generatePoleQuad(e, k, P, N, j, oh), Z === 0 && X === 0 && this._generatePoleQuad(e, P, L, j, Y, oh), X === 0 && G === 0 && this._generatePoleQuad(e, L, k, Y, N, oh)), c && (G === m && Z === m && this._generatePoleQuad(e, k, P, N, j, Rd), Z === m && X === m && this._generatePoleQuad(e, P, L, j, Y, Rd), X === m && G === m && this._generatePoleQuad(e, L, k, Y, N, Rd));
            }
          }
          _initializeVertices(e) {
            for (let r = 0; r < e.length; r += 2) this._vertexToIndex(e[r], e[r + 1]);
          }
          subdividePolygonInternal(e, r) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: c, holeIndices: f } = (function(E) {
              const k = [], P = [];
              for (const L of E) if (L.length !== 0) {
                L !== E[0] && k.push(P.length / 2);
                for (let N = 0; N < L.length; N++) P.push(L[N].x), P.push(L[N].y);
              }
              return { flattened: P, holeIndices: k };
            })(e);
            let m;
            this._initializeVertices(c);
            try {
              const E = (function(P, L, N = 2) {
                const G = L && L.length, j = G ? L[0] * N : P.length;
                let Z = zv(P, 0, j, N, !0);
                const Y = [];
                if (!Z || Z.next === Z.prev) return Y;
                let X, ne, xe;
                if (G && (Z = (function(ae, ue, Te, Ae) {
                  const Ke = [];
                  for (let ht = 0, lt = ue.length; ht < lt; ht++) {
                    const pt = zv(ae, ue[ht] * Ae, ht < lt - 1 ? ue[ht + 1] * Ae : ae.length, Ae, !1);
                    pt === pt.next && (pt.steiner = !0), Ke.push(ZE(pt));
                  }
                  Ke.sort(UE);
                  for (let ht = 0; ht < Ke.length; ht++) Te = qE(Ke[ht], Te);
                  return Te;
                })(P, L, Z, N)), P.length > 80 * N) {
                  X = P[0], ne = P[1];
                  let ae = X, ue = ne;
                  for (let Te = N; Te < j; Te += N) {
                    const Ae = P[Te], Ke = P[Te + 1];
                    Ae < X && (X = Ae), Ke < ne && (ne = Ke), Ae > ae && (ae = Ae), Ke > ue && (ue = Ke);
                  }
                  xe = Math.max(ae - X, ue - ne), xe = xe !== 0 ? 32767 / xe : 0;
                }
                return Pd(Z, Y, N, X, ne, xe, 0), Y;
              })(c, f), k = this._convertIndices(c, E);
              m = this._subdivideTrianglesScanline(k);
            } catch (E) {
              console.error(E);
            }
            let v = [];
            return r && (v = this._generateOutline(e)), this._ensureNoPoleVertices(), this._handlePoles(m), { verticesFlattened: this._vertexBuffer, indicesTriangles: m, indicesLineList: v };
          }
          _convertIndices(e, r) {
            const c = [];
            for (let f = 0; f < r.length; f++) c.push(this._vertexToIndex(e[2 * r[f]], e[2 * r[f] + 1]));
            return c;
          }
          _pointArrayToIndices(e) {
            const r = [];
            for (let c = 0; c < e.length; c++) {
              const f = e[c];
              r.push(this._vertexToIndex(f.x, f.y));
            }
            return r;
          }
        }
        function Uv(i, e, r, c = !0) {
          return new YE(r, e).subdividePolygonInternal(i, c);
        }
        function Xu(i, e, r = !1) {
          if (!i || i.length < 1) return [];
          if (i.length < 2) return [];
          const c = i[0], f = i[i.length - 1], m = r && (c.x !== f.x || c.y !== f.y);
          if (e < 2) return m ? [...i, i[0]] : [...i];
          const v = Math.floor(We / e), E = [];
          E.push(new R(i[0].x, i[0].y));
          const k = i.length, P = m ? k : k - 1;
          for (let L = 0; L < P; L++) {
            const N = i[L], G = L < k - 1 ? i[L + 1] : i[0], j = N.x, Z = N.y, Y = G.x, X = G.y, ne = j !== Y, xe = Z !== X;
            if (!ne && !xe) continue;
            const ae = Y - j, ue = X - Z, Te = Math.abs(ae), Ae = Math.abs(ue);
            let Ke = j, ht = Z;
            for (; ; ) {
              const pt = ae > 0 ? (Math.floor(Ke / v) + 1) * v : (Math.ceil(Ke / v) - 1) * v, Ct = ue > 0 ? (Math.floor(ht / v) + 1) * v : (Math.ceil(ht / v) - 1) * v, _t = Math.abs(Ke - pt), ut = Math.abs(ht - Ct), st = Math.abs(Ke - Y), Bt = Math.abs(ht - X), Rt = ne ? _t / Te : Number.POSITIVE_INFINITY, Vt = xe ? ut / Ae : Number.POSITIVE_INFINITY;
              if ((st <= _t || !ne) && (Bt <= ut || !xe)) break;
              if (Rt < Vt && ne || !xe) {
                Ke = pt, ht += ue * Rt;
                const Dt = new R(Ke, Math.round(ht));
                E[E.length - 1].x === Dt.x && E[E.length - 1].y === Dt.y || E.push(Dt);
              } else {
                Ke += ae * Vt, ht = Ct;
                const Dt = new R(Math.round(Ke), ht);
                E[E.length - 1].x === Dt.x && E[E.length - 1].y === Dt.y || E.push(Dt);
              }
            }
            const lt = new R(Y, X);
            E[E.length - 1].x === lt.x && E[E.length - 1].y === lt.y || E.push(lt);
          }
          return E;
        }
        function WE(i, e, r) {
          if (e.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let c = 0, f = i[2 * e[0]];
          for (let k = 1; k < e.length; k++) {
            const P = i[2 * e[k]];
            P < f && (f = P, c = k);
          }
          const m = e.length;
          let v = c, E = (v + 1) % m;
          for (; ; ) {
            const k = v - 1 >= 0 ? v - 1 : m - 1, P = (E + 1) % m, L = i[2 * e[k]], N = i[2 * e[P]], G = i[2 * e[v]], j = i[2 * e[v] + 1], Z = i[2 * e[E] + 1];
            let Y = !1;
            if (L < N) Y = !0;
            else if (L > N) Y = !1;
            else {
              const X = Z - j, ne = -(i[2 * e[E]] - G), xe = j < Z ? 1 : -1;
              ((L - G) * X + (i[2 * e[k] + 1] - j) * ne) * xe > ((N - G) * X + (i[2 * e[P] + 1] - j) * ne) * xe && (Y = !0);
            }
            if (Y) {
              const X = e[k], ne = e[v], xe = e[E];
              X !== ne && X !== xe && ne !== xe && r.push(xe, ne, X), v--, v < 0 && (v = m - 1);
            } else {
              const X = e[P], ne = e[v], xe = e[E];
              X !== ne && X !== xe && ne !== xe && r.push(xe, ne, X), E++, E >= m && (E = 0);
            }
            if (k === P) break;
          }
        }
        function qv(i, e, r, c, f, m, v, E, k) {
          const P = f.length / 2, L = v && E && k;
          if (P < At.MAX_VERTEX_ARRAY_LENGTH) {
            const N = e.prepareSegment(P, r, c), G = N.vertexLength;
            for (let Y = 0; Y < m.length; Y += 3) c.emplaceBack(G + m[Y], G + m[Y + 1], G + m[Y + 2]);
            let j, Z;
            N.vertexLength += P, N.primitiveLength += m.length / 3, L && (Z = v.prepareSegment(P, r, E), j = Z.vertexLength, Z.vertexLength += P);
            for (let Y = 0; Y < f.length; Y += 2) i(f[Y], f[Y + 1]);
            if (L) for (let Y = 0; Y < k.length; Y++) {
              const X = k[Y];
              for (let ne = 1; ne < X.length; ne += 2) E.emplaceBack(j + X[ne - 1], j + X[ne]);
              Z.primitiveLength += X.length / 2;
            }
          } else (function(N, G, j, Z, Y, X) {
            const ne = [];
            for (let Ae = 0; Ae < Z.length / 2; Ae++) ne.push(-1);
            const xe = { count: 0 };
            let ae = 0, ue = N.getOrCreateLatestSegment(G, j), Te = ue.vertexLength;
            for (let Ae = 2; Ae < Y.length; Ae += 3) {
              const Ke = Y[Ae - 2], ht = Y[Ae - 1], lt = Y[Ae];
              let pt = ne[Ke] < ae, Ct = ne[ht] < ae, _t = ne[lt] < ae;
              ue.vertexLength + ((pt ? 1 : 0) + (Ct ? 1 : 0) + (_t ? 1 : 0)) > At.MAX_VERTEX_ARRAY_LENGTH && (ue = N.createNewSegment(G, j), ae = xe.count, pt = !0, Ct = !0, _t = !0, Te = 0);
              const ut = Fd(ne, Z, X, xe, Ke, pt, ue), st = Fd(ne, Z, X, xe, ht, Ct, ue), Bt = Fd(ne, Z, X, xe, lt, _t, ue);
              j.emplaceBack(Te + ut - ae, Te + st - ae, Te + Bt - ae), ue.primitiveLength++;
            }
          })(e, r, c, f, m, i), L && (function(N, G, j, Z, Y, X) {
            const ne = [];
            for (let Ae = 0; Ae < Z.length / 2; Ae++) ne.push(-1);
            const xe = { count: 0 };
            let ae = 0, ue = N.getOrCreateLatestSegment(G, j), Te = ue.vertexLength;
            for (let Ae = 0; Ae < Y.length; Ae++) {
              const Ke = Y[Ae];
              for (let ht = 1; ht < Y[Ae].length; ht += 2) {
                const lt = Ke[ht - 1], pt = Ke[ht];
                let Ct = ne[lt] < ae, _t = ne[pt] < ae;
                ue.vertexLength + ((Ct ? 1 : 0) + (_t ? 1 : 0)) > At.MAX_VERTEX_ARRAY_LENGTH && (ue = N.createNewSegment(G, j), ae = xe.count, Ct = !0, _t = !0, Te = 0);
                const ut = Fd(ne, Z, X, xe, lt, Ct, ue), st = Fd(ne, Z, X, xe, pt, _t, ue);
                j.emplaceBack(Te + ut - ae, Te + st - ae), ue.primitiveLength++;
              }
            }
          })(v, r, E, f, k, i), e.forceNewSegmentOnNextPrepare(), v?.forceNewSegmentOnNextPrepare();
        }
        function Fd(i, e, r, c, f, m, v) {
          if (m) {
            const E = c.count;
            return r(e[2 * f], e[2 * f + 1]), i[f] = c.count, c.count++, v.vertexLength++, E;
          }
          return i[f];
        }
        class Im {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = e.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new fe(), this.indexArray = new it(), this.indexArray2 = new Et(), this.programConfigurations = new Jo(e.layers, e.zoom), this.segments = new At(), this.segments2 = new At(), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(e, r, c) {
            this.hasDependencies = Ep("fill", this.layers, r);
            const f = this.layers[0].layout.get("fill-sort-key"), m = !f.isConstant(), v = [];
            for (const { feature: E, id: k, index: P, sourceLayerIndex: L } of e) {
              const N = this.layers[0]._featureFilter.needGeometry, G = go(E, N);
              if (!this.layers[0]._featureFilter.filter(new Vr(this.zoom), G, c)) continue;
              const j = m ? f.evaluate(G, {}, c, r.availableImages) : void 0, Z = { id: k, properties: E.properties, type: E.type, sourceLayerIndex: L, index: P, geometry: N ? G.geometry : po(E), patterns: {}, sortKey: j };
              v.push(Z);
            }
            m && v.sort(((E, k) => E.sortKey - k.sortKey));
            for (const E of v) {
              const { geometry: k, index: P, sourceLayerIndex: L } = E;
              if (this.hasDependencies) {
                const N = Tm("fill", this.layers, E, { zoom: this.zoom }, r);
                this.patternFeatures.push(N);
              } else this.addFeature(E, k, P, c, {}, r.subdivisionGranularity);
              r.featureIndex.insert(e[P].feature, k, P, L, this.index);
            }
          }
          update(e, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: c });
          }
          addFeatures(e, r, c) {
            for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, r, c, e.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, zE), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(e, r, c, f, m, v) {
            for (const E of zo(r, 500)) {
              const k = Uv(E, f, v.fill.getGranularityForZoomLevel(f.z)), P = this.layoutVertexArray;
              qv(((L, N) => {
                P.emplaceBack(L, N);
              }), this.segments, this.layoutVertexArray, this.indexArray, k.verticesFlattened, k.indicesTriangles, this.segments2, this.indexArray2, k.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, { imagePositions: m, canonical: f });
          }
        }
        let $v, Zv;
        jt("FillBucket", Im, { omit: ["layers", "patternFeatures"] });
        var XE = { get paint() {
          return Zv = Zv || new Vi({ "fill-antialias": new Zt(Xe.paint_fill["fill-antialias"]), "fill-opacity": new Jt(Xe.paint_fill["fill-opacity"]), "fill-color": new Jt(Xe.paint_fill["fill-color"]), "fill-outline-color": new Jt(Xe.paint_fill["fill-outline-color"]), "fill-translate": new Zt(Xe.paint_fill["fill-translate"]), "fill-translate-anchor": new Zt(Xe.paint_fill["fill-translate-anchor"]), "fill-pattern": new ju(Xe.paint_fill["fill-pattern"]) });
        }, get layout() {
          return $v = $v || new Vi({ "fill-sort-key": new Jt(Xe.layout_fill["fill-sort-key"]) });
        } };
        class JE extends Es {
          constructor(e, r) {
            super(e, XE, r);
          }
          recalculate(e, r) {
            super.recalculate(e, r);
            const c = this.paint._values["fill-outline-color"];
            c.value.kind === "constant" && c.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(e) {
            return new Im(e);
          }
          queryRadius() {
            return bp(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, geometry: r, transform: c, pixelsToTileUnits: f }) {
            return Tv(wp(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -c.bearingInRadians, f), r);
          }
          isTileClipped() {
            return !0;
          }
        }
        const KE = An([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), QE = An([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: eT } = KE;
        class Nd {
          constructor(e, r, c, f, m) {
            this.properties = {}, this.extent = c, this.type = 0, this.id = void 0, this._pbf = e, this._geometry = -1, this._keys = f, this._values = m, e.readFields(tT, this, r);
          }
          loadGeometry() {
            const e = this._pbf;
            e.pos = this._geometry;
            const r = e.readVarint() + e.pos, c = [];
            let f, m = 1, v = 0, E = 0, k = 0;
            for (; e.pos < r; ) {
              if (v <= 0) {
                const P = e.readVarint();
                m = 7 & P, v = P >> 3;
              }
              if (v--, m === 1 || m === 2) E += e.readSVarint(), k += e.readSVarint(), m === 1 && (f && c.push(f), f = []), f && f.push(new R(E, k));
              else {
                if (m !== 7) throw new Error(`unknown command ${m}`);
                f && f.push(f[0].clone());
              }
            }
            return f && c.push(f), c;
          }
          bbox() {
            const e = this._pbf;
            e.pos = this._geometry;
            const r = e.readVarint() + e.pos;
            let c = 1, f = 0, m = 0, v = 0, E = 1 / 0, k = -1 / 0, P = 1 / 0, L = -1 / 0;
            for (; e.pos < r; ) {
              if (f <= 0) {
                const N = e.readVarint();
                c = 7 & N, f = N >> 3;
              }
              if (f--, c === 1 || c === 2) m += e.readSVarint(), v += e.readSVarint(), m < E && (E = m), m > k && (k = m), v < P && (P = v), v > L && (L = v);
              else if (c !== 7) throw new Error(`unknown command ${c}`);
            }
            return [E, P, k, L];
          }
          toGeoJSON(e, r, c) {
            const f = this.extent * Math.pow(2, c), m = this.extent * e, v = this.extent * r, E = this.loadGeometry();
            function k(G) {
              return [360 * (G.x + m) / f - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (G.y + v) / f) * Math.PI)) - 90];
            }
            function P(G) {
              return G.map(k);
            }
            let L;
            if (this.type === 1) {
              const G = [];
              for (const Z of E) G.push(Z[0]);
              const j = P(G);
              L = G.length === 1 ? { type: "Point", coordinates: j[0] } : { type: "MultiPoint", coordinates: j };
            } else if (this.type === 2) {
              const G = E.map(P);
              L = G.length === 1 ? { type: "LineString", coordinates: G[0] } : { type: "MultiLineString", coordinates: G };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const G = Hv(E), j = [];
                for (const Z of G) j.push(Z.map(P));
                L = j.length === 1 ? { type: "Polygon", coordinates: j[0] } : { type: "MultiPolygon", coordinates: j };
              }
            }
            const N = { type: "Feature", geometry: L, properties: this.properties };
            return this.id != null && (N.id = this.id), N;
          }
        }
        function tT(i, e, r) {
          i === 1 ? e.id = r.readVarint() : i === 2 ? (function(c, f) {
            const m = c.readVarint() + c.pos;
            for (; c.pos < m; ) {
              const v = f._keys[c.readVarint()], E = f._values[c.readVarint()];
              f.properties[v] = E;
            }
          })(r, e) : i === 3 ? e.type = r.readVarint() : i === 4 && (e._geometry = r.pos);
        }
        function Hv(i) {
          const e = i.length;
          if (e <= 1) return [i];
          const r = [];
          let c, f;
          for (let m = 0; m < e; m++) {
            const v = rT(i[m]);
            v !== 0 && (f === void 0 && (f = v < 0), f === v < 0 ? (c && r.push(c), c = [i[m]]) : c && c.push(i[m]));
          }
          return c && r.push(c), r;
        }
        function rT(i) {
          let e = 0;
          for (let r, c, f = 0, m = i.length, v = m - 1; f < m; v = f++) r = i[f], c = i[v], e += (c.x - r.x) * (r.y + c.y);
          return e;
        }
        Nd.types = ["Unknown", "Point", "LineString", "Polygon"];
        class nT {
          constructor(e, r) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(iT, this, r), this.length = this._features.length;
          }
          feature(e) {
            if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[e];
            const r = this._pbf.readVarint() + this._pbf.pos;
            return new Nd(this._pbf, r, this.extent, this._keys, this._values);
          }
        }
        function iT(i, e, r) {
          i === 15 ? e.version = r.readVarint() : i === 1 ? e.name = r.readString() : i === 5 ? e.extent = r.readVarint() : i === 2 ? e._features.push(r.pos) : i === 3 ? e._keys.push(r.readString()) : i === 4 && e._values.push((function(c) {
            let f = null;
            const m = c.readVarint() + c.pos;
            for (; c.pos < m; ) {
              const v = c.readVarint() >> 3;
              f = v === 1 ? c.readString() : v === 2 ? c.readFloat() : v === 3 ? c.readDouble() : v === 4 ? c.readVarint64() : v === 5 ? c.readVarint() : v === 6 ? c.readSVarint() : v === 7 ? c.readBoolean() : null;
            }
            if (f == null) throw new Error("unknown feature value");
            return f;
          })(r));
        }
        class Yv {
          constructor(e, r) {
            this.layers = e.readFields(sT, {}, r);
          }
        }
        function sT(i, e, r) {
          if (i === 3) {
            const c = new nT(r, r.readVarint() + r.pos);
            c.length && (e[c.name] = c);
          }
        }
        const Mm = Math.pow(2, 13);
        function Od(i, e, r, c, f, m, v, E) {
          i.emplaceBack(e, r, 2 * Math.floor(c * Mm) + v, f * Mm * 2, m * Mm * 2, Math.round(E));
        }
        class Cm {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = e.index, this.hasDependencies = !1, this.layoutVertexArray = new we(), this.centroidVertexArray = new he(), this.indexArray = new it(), this.programConfigurations = new Jo(e.layers, e.zoom), this.segments = new At(), this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(e, r, c) {
            this.features = [], this.hasDependencies = Ep("fill-extrusion", this.layers, r);
            for (const { feature: f, id: m, index: v, sourceLayerIndex: E } of e) {
              const k = this.layers[0]._featureFilter.needGeometry, P = go(f, k);
              if (!this.layers[0]._featureFilter.filter(new Vr(this.zoom), P, c)) continue;
              const L = { id: m, sourceLayerIndex: E, index: v, geometry: k ? P.geometry : po(f), properties: f.properties, type: f.type, patterns: {} };
              this.hasDependencies ? this.features.push(Tm("fill-extrusion", this.layers, L, { zoom: this.zoom }, r)) : this.addFeature(L, L.geometry, v, c, {}, r.subdivisionGranularity), r.featureIndex.insert(f, L.geometry, v, E, this.index, !0);
            }
          }
          addFeatures(e, r, c) {
            for (const f of this.features) {
              const { geometry: m } = f;
              this.addFeature(f, m, f.index, r, c, e.subdivisionGranularity);
            }
          }
          update(e, r, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: c });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, eT), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, QE.members, !0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(e, r, c, f, m, v) {
            for (const E of zo(r, 500)) {
              const k = { x: 0, y: 0, sampleCount: 0 }, P = this.layoutVertexArray.length;
              this.processPolygon(k, f, e, E, v);
              const L = this.layoutVertexArray.length - P, N = Math.floor(k.x / k.sampleCount), G = Math.floor(k.y / k.sampleCount);
              for (let j = 0; j < L; j++) this.centroidVertexArray.emplaceBack(N, G);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, { imagePositions: m, canonical: f });
          }
          processPolygon(e, r, c, f, m) {
            if (f.length < 1 || Wv(f[0])) return;
            for (const N of f) N.length !== 0 && aT(e, N);
            const v = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, E = m.fill.getGranularityForZoomLevel(r.z), k = Nd.types[c.type] === "Polygon";
            for (const N of f) {
              if (N.length === 0 || Wv(N)) continue;
              const G = Xu(N, E, k);
              this._generateSideFaces(G, v);
            }
            if (!k) return;
            const P = Uv(f, r, E, !1), L = this.layoutVertexArray;
            qv(((N, G) => {
              Od(L, N, G, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, P.verticesFlattened, P.indicesTriangles);
          }
          _generateSideFaces(e, r) {
            let c = 0;
            for (let f = 1; f < e.length; f++) {
              const m = e[f], v = e[f - 1];
              if (oT(m, v)) continue;
              r.segment.vertexLength + 4 > At.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const E = m.sub(v)._perp()._unit(), k = v.dist(m);
              c + k > 32768 && (c = 0), Od(this.layoutVertexArray, m.x, m.y, E.x, E.y, 0, 0, c), Od(this.layoutVertexArray, m.x, m.y, E.x, E.y, 0, 1, c), c += k, Od(this.layoutVertexArray, v.x, v.y, E.x, E.y, 0, 0, c), Od(this.layoutVertexArray, v.x, v.y, E.x, E.y, 0, 1, c);
              const P = r.segment.vertexLength;
              this.indexArray.emplaceBack(P, P + 2, P + 1), this.indexArray.emplaceBack(P + 1, P + 2, P + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2;
            }
          }
        }
        function aT(i, e) {
          for (let r = 0; r < e.length; r++) {
            const c = e[r];
            r === e.length - 1 && e[0].x === c.x && e[0].y === c.y || (i.x += c.x, i.y += c.y, i.sampleCount++);
          }
        }
        function oT(i, e) {
          return i.x === e.x && (i.x < 0 || i.x > We) || i.y === e.y && (i.y < 0 || i.y > We);
        }
        function Wv(i) {
          return i.every(((e) => e.x < 0)) || i.every(((e) => e.x > We)) || i.every(((e) => e.y < 0)) || i.every(((e) => e.y > We));
        }
        let Xv;
        jt("FillExtrusionBucket", Cm, { omit: ["layers", "features"] });
        var lT = { get paint() {
          return Xv = Xv || new Vi({ "fill-extrusion-opacity": new Zt(Xe["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Jt(Xe["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Zt(Xe["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Zt(Xe["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ju(Xe["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Jt(Xe["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Jt(Xe["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Zt(Xe["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class uT extends Es {
          constructor(e, r) {
            super(e, lT, r);
          }
          createBucket(e) {
            return new Cm(e);
          }
          queryRadius() {
            return bp(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: c, geometry: f, transform: m, pixelsToTileUnits: v, pixelPosMatrix: E }) {
            const k = wp(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -m.bearingInRadians, v), P = this.paint.get("fill-extrusion-height").evaluate(r, c), L = this.paint.get("fill-extrusion-base").evaluate(r, c), N = (function(j, Z) {
              const Y = [];
              for (const X of j) {
                const ne = [X.x, X.y, 0, 1];
                Re(ne, ne, Z), Y.push(new R(ne[0] / ne[3], ne[1] / ne[3]));
              }
              return Y;
            })(k, E), G = (function(j, Z, Y, X) {
              const ne = [], xe = [], ae = X[8] * Z, ue = X[9] * Z, Te = X[10] * Z, Ae = X[11] * Z, Ke = X[8] * Y, ht = X[9] * Y, lt = X[10] * Y, pt = X[11] * Y;
              for (const Ct of j) {
                const _t = [], ut = [];
                for (const st of Ct) {
                  const Bt = st.x, Rt = st.y, Vt = X[0] * Bt + X[4] * Rt + X[12], Dt = X[1] * Bt + X[5] * Rt + X[13], Yt = X[2] * Bt + X[6] * Rt + X[14], Sr = X[3] * Bt + X[7] * Rt + X[15], yr = Yt + Te, cn = Sr + Ae, Pi = Vt + Ke, Zn = Dt + ht, hn = Yt + lt, an = Sr + pt, Fr = new R((Vt + ae) / cn, (Dt + ue) / cn);
                  Fr.z = yr / cn, _t.push(Fr);
                  const Tn = new R(Pi / an, Zn / an);
                  Tn.z = hn / an, ut.push(Tn);
                }
                ne.push(_t), xe.push(ut);
              }
              return [ne, xe];
            })(f, L, P, E);
            return (function(j, Z, Y) {
              let X = 1 / 0;
              Tv(Y, Z) && (X = Jv(Y, Z[0]));
              for (let ne = 0; ne < Z.length; ne++) {
                const xe = Z[ne], ae = j[ne];
                for (let ue = 0; ue < xe.length - 1; ue++) {
                  const Te = xe[ue], Ae = [Te, xe[ue + 1], ae[ue + 1], ae[ue], Te];
                  rh(Y, Ae) && (X = Math.min(X, Jv(Y, Ae)));
                }
              }
              return X !== 1 / 0 && X;
            })(G[0], G[1], N);
          }
        }
        function zd(i, e) {
          return i.x * e.x + i.y * e.y;
        }
        function Jv(i, e) {
          if (i.length === 1) {
            let r = 0;
            const c = e[r++];
            let f;
            for (; !f || c.equals(f); ) if (f = e[r++], !f) return 1 / 0;
            for (; r < e.length; r++) {
              const m = e[r], v = i[0], E = f.sub(c), k = m.sub(c), P = v.sub(c), L = zd(E, E), N = zd(E, k), G = zd(k, k), j = zd(P, E), Z = zd(P, k), Y = L * G - N * N, X = (G * j - N * Z) / Y, ne = (L * Z - N * j) / Y, xe = c.z * (1 - X - ne) + f.z * X + m.z * ne;
              if (isFinite(xe)) return xe;
            }
            return 1 / 0;
          }
          {
            let r = 1 / 0;
            for (const c of e) r = Math.min(r, c.z);
            return r;
          }
        }
        const cT = An([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: hT } = cT, dT = An([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: fT } = dT, pT = Math.cos(Math.PI / 180 * 37.5), Kv = Math.pow(2, 14) / 0.5;
        class Pm {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((r) => r.id)), this.index = e.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((r) => {
              this.gradients[r.id] = {};
            })), this.layoutVertexArray = new Le(), this.layoutVertexArray2 = new ve(), this.indexArray = new it(), this.programConfigurations = new Jo(e.layers, e.zoom), this.segments = new At(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((r) => r.isStateDependent())).map(((r) => r.id));
          }
          populate(e, r, c) {
            this.hasDependencies = Ep("line", this.layers, r) || this.hasLineDasharray(this.layers);
            const f = this.layers[0].layout.get("line-sort-key"), m = !f.isConstant(), v = [];
            for (const { feature: E, id: k, index: P, sourceLayerIndex: L } of e) {
              const N = this.layers[0]._featureFilter.needGeometry, G = go(E, N);
              if (!this.layers[0]._featureFilter.filter(new Vr(this.zoom), G, c)) continue;
              const j = m ? f.evaluate(G, {}, c) : void 0, Z = { id: k, properties: E.properties, type: E.type, sourceLayerIndex: L, index: P, geometry: N ? G.geometry : po(E), patterns: {}, dashes: {}, sortKey: j };
              v.push(Z);
            }
            m && v.sort(((E, k) => E.sortKey - k.sortKey));
            for (const E of v) {
              const { geometry: k, index: P, sourceLayerIndex: L } = E;
              this.hasDependencies ? (Ep("line", this.layers, r) ? Tm("line", this.layers, E, { zoom: this.zoom }, r) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, E, this.zoom, r), this.patternFeatures.push(E)) : this.addFeature(E, k, P, c, {}, {}, r.subdivisionGranularity), r.featureIndex.insert(e[P].feature, k, P, L, this.index);
            }
          }
          update(e, r, c, f) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: c, dashPositions: f });
          }
          addFeatures(e, r, c, f) {
            for (const m of this.patternFeatures) this.addFeature(m, m.geometry, m.index, r, c, f, e.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, fT)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, hT), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(e) {
            if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
          }
          addFeature(e, r, c, f, m, v, E) {
            const k = this.layers[0].layout, P = k.get("line-join").evaluate(e, {}), L = k.get("line-cap"), N = k.get("line-miter-limit"), G = k.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(e);
            for (const j of r) this.addLine(j, e, P, L, N, G, f, E);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, { imagePositions: m, dashPositions: v, canonical: f });
          }
          addLine(e, r, c, f, m, v, E, k) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, e = Xu(e, E ? k.line.getGranularityForZoomLevel(E.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ae = 0; ae < e.length - 1; ae++) this.totalDistance += e[ae].dist(e[ae + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const P = Nd.types[r.type] === "Polygon";
            let L = e.length;
            for (; L >= 2 && e[L - 1].equals(e[L - 2]); ) L--;
            let N = 0;
            for (; N < L - 1 && e[N].equals(e[N + 1]); ) N++;
            if (L < (P ? 3 : 2)) return;
            c === "bevel" && (m = 1.05);
            const G = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, j = this.segments.prepareSegment(10 * L, this.layoutVertexArray, this.indexArray);
            let Z, Y, X, ne, xe;
            this.e1 = this.e2 = -1, P && (Z = e[L - 2], xe = e[N].sub(Z)._unit()._perp());
            for (let ae = N; ae < L; ae++) {
              if (X = ae === L - 1 ? P ? e[N + 1] : void 0 : e[ae + 1], X && e[ae].equals(X)) continue;
              xe && (ne = xe), Z && (Y = Z), Z = e[ae], xe = X ? X.sub(Z)._unit()._perp() : ne, ne = ne || xe;
              let ue = ne.add(xe);
              ue.x === 0 && ue.y === 0 || ue._unit();
              const Te = ne.x * xe.x + ne.y * xe.y, Ae = ue.x * xe.x + ue.y * xe.y, Ke = Ae !== 0 ? 1 / Ae : 1 / 0, ht = 2 * Math.sqrt(2 - 2 * Ae), lt = Ae < pT && Y && X, pt = ne.x * xe.y - ne.y * xe.x > 0;
              if (lt && ae > N) {
                const ut = Z.dist(Y);
                if (ut > 2 * G) {
                  const st = Z.sub(Z.sub(Y)._mult(G / ut)._round());
                  this.updateDistance(Y, st), this.addCurrentVertex(st, ne, 0, 0, j), Y = st;
                }
              }
              const Ct = Y && X;
              let _t = Ct ? c : P ? "butt" : f;
              if (Ct && _t === "round" && (Ke < v ? _t = "miter" : Ke <= 2 && (_t = "fakeround")), _t === "miter" && Ke > m && (_t = "bevel"), _t === "bevel" && (Ke > 2 && (_t = "flipbevel"), Ke < m && (_t = "miter")), Y && this.updateDistance(Y, Z), _t === "miter") ue._mult(Ke), this.addCurrentVertex(Z, ue, 0, 0, j);
              else if (_t === "flipbevel") {
                if (Ke > 100) ue = xe.mult(-1);
                else {
                  const ut = Ke * ne.add(xe).mag() / ne.sub(xe).mag();
                  ue._perp()._mult(ut * (pt ? -1 : 1));
                }
                this.addCurrentVertex(Z, ue, 0, 0, j), this.addCurrentVertex(Z, ue.mult(-1), 0, 0, j);
              } else if (_t === "bevel" || _t === "fakeround") {
                const ut = -Math.sqrt(Ke * Ke - 1), st = pt ? ut : 0, Bt = pt ? 0 : ut;
                if (Y && this.addCurrentVertex(Z, ne, st, Bt, j), _t === "fakeround") {
                  const Rt = Math.round(180 * ht / Math.PI / 20);
                  for (let Vt = 1; Vt < Rt; Vt++) {
                    let Dt = Vt / Rt;
                    if (Dt !== 0.5) {
                      const Sr = Dt - 0.5;
                      Dt += Dt * Sr * (Dt - 1) * ((1.0904 + Te * (Te * (3.55645 - 1.43519 * Te) - 3.2452)) * Sr * Sr + (0.848013 + Te * (0.215638 * Te - 1.06021)));
                    }
                    const Yt = xe.sub(ne)._mult(Dt)._add(ne)._unit()._mult(pt ? -1 : 1);
                    this.addHalfVertex(Z, Yt.x, Yt.y, !1, pt, 0, j);
                  }
                }
                X && this.addCurrentVertex(Z, xe, -st, -Bt, j);
              } else if (_t === "butt") this.addCurrentVertex(Z, ue, 0, 0, j);
              else if (_t === "square") {
                const ut = Y ? 1 : -1;
                this.addCurrentVertex(Z, ue, ut, ut, j);
              } else _t === "round" && (Y && (this.addCurrentVertex(Z, ne, 0, 0, j), this.addCurrentVertex(Z, ne, 1, 1, j, !0)), X && (this.addCurrentVertex(Z, xe, -1, -1, j, !0), this.addCurrentVertex(Z, xe, 0, 0, j)));
              if (lt && ae < L - 1) {
                const ut = Z.dist(X);
                if (ut > 2 * G) {
                  const st = Z.add(X.sub(Z)._mult(G / ut)._round());
                  this.updateDistance(Z, st), this.addCurrentVertex(st, xe, 0, 0, j), Z = st;
                }
              }
            }
          }
          addCurrentVertex(e, r, c, f, m, v = !1) {
            const E = r.y * f - r.x, k = -r.y - r.x * f;
            this.addHalfVertex(e, r.x + r.y * c, r.y - r.x * c, v, !1, c, m), this.addHalfVertex(e, E, k, v, !0, -f, m), this.distance > Kv / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, r, c, f, m, v));
          }
          addHalfVertex({ x: e, y: r }, c, f, m, v, E, k) {
            const P = 0.5 * (this.lineClips ? this.scaledDistance * (Kv - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((e << 1) + (m ? 1 : 0), (r << 1) + (v ? 1 : 0), Math.round(63 * c) + 128, Math.round(63 * f) + 128, 1 + (E === 0 ? 0 : E < 0 ? -1 : 1) | (63 & P) << 2, P >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const L = k.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, L, this.e2), k.primitiveLength++), v ? this.e2 = L : this.e1 = L;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(e, r) {
            this.distance += e.dist(r), this.updateScaledDistance();
          }
          hasLineDasharray(e) {
            for (const r of e) {
              const c = r.paint.get("line-dasharray");
              if (c && !c.isConstant()) return !0;
            }
            return !1;
          }
          addLineDashDependencies(e, r, c, f) {
            for (const m of e) {
              const v = m.paint.get("line-dasharray");
              if (!v || v.value.kind === "constant") continue;
              const E = m.layout.get("line-cap") === "round", k = { dasharray: v.value.evaluate({ zoom: c - 1 }, r, {}), round: E }, P = { dasharray: v.value.evaluate({ zoom: c }, r, {}), round: E }, L = { dasharray: v.value.evaluate({ zoom: c + 1 }, r, {}), round: E }, N = `${k.dasharray.join(",")},${k.round}`, G = `${P.dasharray.join(",")},${P.round}`, j = `${L.dasharray.join(",")},${L.round}`;
              f.dashDependencies[N] = k, f.dashDependencies[G] = P, f.dashDependencies[j] = L, r.dashes[m.id] = { min: N, mid: G, max: j };
            }
          }
        }
        let Qv, e0;
        jt("LineBucket", Pm, { omit: ["layers", "patternFeatures"] });
        var t0 = { get paint() {
          return e0 = e0 || new Vi({ "line-opacity": new Jt(Xe.paint_line["line-opacity"]), "line-color": new Jt(Xe.paint_line["line-color"]), "line-translate": new Zt(Xe.paint_line["line-translate"]), "line-translate-anchor": new Zt(Xe.paint_line["line-translate-anchor"]), "line-width": new Jt(Xe.paint_line["line-width"]), "line-gap-width": new Jt(Xe.paint_line["line-gap-width"]), "line-offset": new Jt(Xe.paint_line["line-offset"]), "line-blur": new Jt(Xe.paint_line["line-blur"]), "line-dasharray": new ju(Xe.paint_line["line-dasharray"]), "line-pattern": new ju(Xe.paint_line["line-pattern"]), "line-gradient": new Yc(Xe.paint_line["line-gradient"]) });
        }, get layout() {
          return Qv = Qv || new Vi({ "line-cap": new Zt(Xe.layout_line["line-cap"]), "line-join": new Jt(Xe.layout_line["line-join"]), "line-miter-limit": new Zt(Xe.layout_line["line-miter-limit"]), "line-round-limit": new Zt(Xe.layout_line["line-round-limit"]), "line-sort-key": new Jt(Xe.layout_line["line-sort-key"]) });
        } };
        class gT extends Jt {
          possiblyEvaluate(e, r) {
            return r = new Vr(Math.floor(r.zoom), { now: r.now, fadeDuration: r.fadeDuration, zoomHistory: r.zoomHistory, transition: r.transition }), super.possiblyEvaluate(e, r);
          }
          evaluate(e, r, c, f) {
            return r = Ze({}, r, { zoom: Math.floor(r.zoom) }), super.evaluate(e, r, c, f);
          }
        }
        let Ip;
        class mT extends Es {
          constructor(e, r) {
            super(e, t0, r), this.gradientVersion = 0, Ip || (Ip = new gT(t0.paint.properties["line-width"].specification), Ip.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(e) {
            if (e === "line-gradient") {
              const r = this.gradientExpression();
              this.stepInterpolant = !!(function(c) {
                return c._styleExpression !== void 0;
              })(r) && r._styleExpression.expression instanceof Jn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(e, r) {
            super.recalculate(e, r), this.paint._values["line-floorwidth"] = Ip.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
          }
          createBucket(e) {
            return new Pm(e);
          }
          queryRadius(e) {
            const r = e, c = r0(ih("line-width", this, r), ih("line-gap-width", this, r)), f = ih("line-offset", this, r);
            return c / 2 + Math.abs(f) + bp(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: c, geometry: f, transform: m, pixelsToTileUnits: v }) {
            const E = wp(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -m.bearingInRadians, v), k = v / 2 * r0(this.paint.get("line-width").evaluate(r, c), this.paint.get("line-gap-width").evaluate(r, c)), P = this.paint.get("line-offset").evaluate(r, c);
            return P && (f = (function(L, N) {
              const G = [];
              for (let j = 0; j < L.length; j++) {
                const Z = TE(L[j]), Y = [];
                for (let X = 0; X < Z.length; X++) {
                  const ne = Z[X], xe = Z[X - 1], ae = Z[X + 1], ue = X === 0 ? new R(0, 0) : ne.sub(xe)._unit()._perp(), Te = X === Z.length - 1 ? new R(0, 0) : ae.sub(ne)._unit()._perp(), Ae = ue._add(Te)._unit(), Ke = Ae.x * Te.x + Ae.y * Te.y;
                  Ke !== 0 && Ae._mult(1 / Ke), Y.push(Ae._mult(N)._add(ne));
                }
                G.push(Y);
              }
              return G;
            })(f, P * v)), (function(L, N, G) {
              for (let j = 0; j < N.length; j++) {
                const Z = N[j];
                if (L.length >= 3) {
                  for (let Y = 0; Y < Z.length; Y++) if (nh(L, Z[Y])) return !0;
                }
                if (bE(L, Z, G)) return !0;
              }
              return !1;
            })(E, f, k);
          }
          isTileClipped() {
            return !0;
          }
        }
        function r0(i, e) {
          return e > 0 ? e + 2 * i : i;
        }
        const _T = An([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), yT = An([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        An([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const vT = An([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        An([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const n0 = An([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), xT = An([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function bT(i, e, r) {
          return i.sections.forEach(((c) => {
            c.text = (function(f, m, v) {
              const E = m.layout.get("text-transform").evaluate(v, {});
              return E === "uppercase" ? f = f.toLocaleUpperCase() : E === "lowercase" && (f = f.toLocaleLowerCase()), co.applyArabicShaping && (f = co.applyArabicShaping(f)), f;
            })(c.text, e, r);
          })), i;
        }
        An([{ name: "triangle", components: 3, type: "Uint16" }]), An([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), An([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), An([{ type: "Float32", name: "offsetX" }]), An([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), An([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        var ci = 24;
        const Bd = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" }, wT = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, ET = { 40: !0 };
        function i0(i, e, r, c, f, m) {
          if ("fontStack" in e) {
            const v = r[e.fontStack], E = v && v[i];
            return E ? E.metrics.advance * e.scale + f : 0;
          }
          {
            const v = c[e.imageName];
            return v ? v.displaySize[0] * e.scale * ci / m + f : 0;
          }
        }
        function s0(i, e, r, c) {
          const f = Math.pow(i - e, 2);
          return c ? i < e ? f / 2 : 2 * f : f + Math.abs(r) * r;
        }
        function TT(i, e, r) {
          let c = 0;
          return i === 10 && (c -= 1e4), r && (c += 150), i !== 40 && i !== 65288 || (c += 50), e !== 41 && e !== 65289 || (c += 50), c;
        }
        function a0(i, e, r, c, f, m) {
          let v = null, E = s0(e, r, f, m);
          for (const k of c) {
            const P = s0(e - k.x, r, f, m) + k.badness;
            P <= E && (v = k, E = P);
          }
          return { index: i, x: e, priorBreak: v, badness: E };
        }
        function o0(i) {
          return i ? o0(i.priorBreak).concat(i.index) : [];
        }
        class lh {
          constructor(e = "", r = [], c = []) {
            this.text = e, this.sections = r, this.sectionIndex = c, this.imageSectionID = null;
          }
          static fromFeature(e, r) {
            const c = new lh();
            for (let f = 0; f < e.sections.length; f++) {
              const m = e.sections[f];
              m.image ? c.addImageSection(m) : c.addTextSection(m, r);
            }
            return c;
          }
          length() {
            return [...this.text].length;
          }
          getSection(e) {
            return this.sections[this.sectionIndex[e]];
          }
          getSectionIndex(e) {
            return this.sectionIndex[e];
          }
          verticalizePunctuation() {
            this.text = (function(e) {
              let r = "", c = { premature: !0, value: void 0 };
              const f = e[Symbol.iterator]();
              let m = f.next();
              const v = e[Symbol.iterator]();
              v.next();
              let E = v.next();
              for (; !m.done; ) r += !E.done && gd(E.value.codePointAt(0)) && !Bd[E.value] || !c.premature && gd(c.value.codePointAt(0)) && !Bd[c.value] || !Bd[m.value] ? m.value : Bd[m.value], c = { value: m.value, premature: !1 }, m = f.next(), E = v.next();
              return r;
            })(this.text);
          }
          hasZeroWidthSpaces() {
            return this.text.includes("");
          }
          trim() {
            const e = this.text.match(/^\s*/), r = e ? e[0].length : 0, c = this.text.match(/\S\s*$/), f = c ? c[0].length - 1 : 0;
            this.text = this.text.substring(r, this.text.length - f), this.sectionIndex = this.sectionIndex.slice(r, this.sectionIndex.length - f);
          }
          substring(e, r) {
            const c = [...this.text].slice(e, r).join(""), f = this.sectionIndex.slice(e, r);
            return new lh(c, this.sections, f);
          }
          toCodeUnitIndex(e) {
            return [...this.text].slice(0, e).join("").length;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((e, r) => Math.max(e, this.sections[r].scale)), 0);
          }
          getMaxImageSize(e) {
            let r = 0, c = 0;
            for (let f = 0; f < this.length(); f++) {
              const m = this.getSection(f);
              if ("imageName" in m) {
                const v = e[m.imageName];
                if (!v) continue;
                const E = v.displaySize;
                r = Math.max(r, E[0]), c = Math.max(c, E[1]);
              }
            }
            return { maxImageWidth: r, maxImageHeight: c };
          }
          addTextSection(e, r) {
            this.text += e.text, this.sections.push({ scale: e.scale || 1, verticalAlign: e.verticalAlign || "bottom", fontStack: e.fontStack || r });
            const c = this.sections.length - 1;
            this.sectionIndex.push(...[...e.text].map((() => c)));
          }
          addImageSection(e) {
            const r = e.image ? e.image.name : "";
            if (r.length === 0) return void ur("Can't add FormattedSection with an empty image.");
            const c = this.getNextImageSectionCharCode();
            c ? (this.text += String.fromCharCode(c), this.sections.push({ scale: 1, verticalAlign: e.verticalAlign || "bottom", imageName: r }), this.sectionIndex.push(this.sections.length - 1)) : ur("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
          determineLineBreaks(e, r, c, f, m) {
            const v = [], E = this.determineAverageLineWidth(e, r, c, f, m), k = this.hasZeroWidthSpaces();
            let P = 0, L = 0;
            const N = this.text[Symbol.iterator]();
            let G = N.next();
            const j = this.text[Symbol.iterator]();
            j.next();
            let Z = j.next();
            const Y = this.text[Symbol.iterator]();
            Y.next(), Y.next();
            let X = Y.next();
            for (; !G.done; ) {
              const ne = this.getSection(L), xe = G.value.codePointAt(0);
              if (up(xe) || (P += i0(xe, ne, c, f, e, m)), !Z.done) {
                const ae = zu(xe), ue = Z.value.codePointAt(0);
                (wT[xe] || ae || "imageName" in ne || !X.done && ET[ue]) && v.push(a0(L + 1, P, E, v, TT(xe, ue, ae && k), !1));
              }
              L++, G = N.next(), Z = j.next(), X = Y.next();
            }
            return o0(a0(this.length(), P, E, v, 0, !0));
          }
          determineAverageLineWidth(e, r, c, f, m) {
            let v = 0, E = 0;
            for (const k of this.text) {
              const P = this.getSection(E);
              v += i0(k.codePointAt(0), P, c, f, e, m), E++;
            }
            return v / Math.max(1, Math.ceil(v / r));
          }
        }
        const Am = 4294967296, l0 = 1 / Am, u0 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class Mp {
          constructor(e = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(e) ? e : new Uint8Array(e), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(e, r, c = this.length) {
            for (; this.pos < c; ) {
              const f = this.readVarint(), m = f >> 3, v = this.pos;
              this.type = 7 & f, e(m, r, this), this.pos === v && this.skip(f);
            }
            return r;
          }
          readMessage(e, r) {
            return this.readFields(e, r, this.readVarint() + this.pos);
          }
          readFixed32() {
            const e = this.dataView.getUint32(this.pos, !0);
            return this.pos += 4, e;
          }
          readSFixed32() {
            const e = this.dataView.getInt32(this.pos, !0);
            return this.pos += 4, e;
          }
          readFixed64() {
            const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * Am;
            return this.pos += 8, e;
          }
          readSFixed64() {
            const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * Am;
            return this.pos += 8, e;
          }
          readFloat() {
            const e = this.dataView.getFloat32(this.pos, !0);
            return this.pos += 4, e;
          }
          readDouble() {
            const e = this.dataView.getFloat64(this.pos, !0);
            return this.pos += 8, e;
          }
          readVarint(e) {
            const r = this.buf;
            let c, f;
            return f = r[this.pos++], c = 127 & f, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 7, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 14, f < 128 ? c : (f = r[this.pos++], c |= (127 & f) << 21, f < 128 ? c : (f = r[this.pos], c |= (15 & f) << 28, (function(m, v, E) {
              const k = E.buf;
              let P, L;
              if (L = k[E.pos++], P = (112 & L) >> 4, L < 128 || (L = k[E.pos++], P |= (127 & L) << 3, L < 128) || (L = k[E.pos++], P |= (127 & L) << 10, L < 128) || (L = k[E.pos++], P |= (127 & L) << 17, L < 128) || (L = k[E.pos++], P |= (127 & L) << 24, L < 128) || (L = k[E.pos++], P |= (1 & L) << 31, L < 128)) return uh(m, P, v);
              throw new Error("Expected varint not more than 10 bytes");
            })(c, e, this)))));
          }
          readVarint64() {
            return this.readVarint(!0);
          }
          readSVarint() {
            const e = this.readVarint();
            return e % 2 == 1 ? (e + 1) / -2 : e / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const e = this.readVarint() + this.pos, r = this.pos;
            return this.pos = e, e - r >= 12 && u0 ? u0.decode(this.buf.subarray(r, e)) : (function(c, f, m) {
              let v = "", E = f;
              for (; E < m; ) {
                const k = c[E];
                let P, L, N, G = null, j = k > 239 ? 4 : k > 223 ? 3 : k > 191 ? 2 : 1;
                if (E + j > m) break;
                j === 1 ? k < 128 && (G = k) : j === 2 ? (P = c[E + 1], (192 & P) == 128 && (G = (31 & k) << 6 | 63 & P, G <= 127 && (G = null))) : j === 3 ? (P = c[E + 1], L = c[E + 2], (192 & P) == 128 && (192 & L) == 128 && (G = (15 & k) << 12 | (63 & P) << 6 | 63 & L, (G <= 2047 || G >= 55296 && G <= 57343) && (G = null))) : j === 4 && (P = c[E + 1], L = c[E + 2], N = c[E + 3], (192 & P) == 128 && (192 & L) == 128 && (192 & N) == 128 && (G = (15 & k) << 18 | (63 & P) << 12 | (63 & L) << 6 | 63 & N, (G <= 65535 || G >= 1114112) && (G = null))), G === null ? (G = 65533, j = 1) : G > 65535 && (G -= 65536, v += String.fromCharCode(G >>> 10 & 1023 | 55296), G = 56320 | 1023 & G), v += String.fromCharCode(G), E += j;
              }
              return v;
            })(this.buf, r, e);
          }
          readBytes() {
            const e = this.readVarint() + this.pos, r = this.buf.subarray(this.pos, e);
            return this.pos = e, r;
          }
          readPackedVarint(e = [], r) {
            const c = this.readPackedEnd();
            for (; this.pos < c; ) e.push(this.readVarint(r));
            return e;
          }
          readPackedSVarint(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readSVarint());
            return e;
          }
          readPackedBoolean(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readBoolean());
            return e;
          }
          readPackedFloat(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readFloat());
            return e;
          }
          readPackedDouble(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readDouble());
            return e;
          }
          readPackedFixed32(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readFixed32());
            return e;
          }
          readPackedSFixed32(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readSFixed32());
            return e;
          }
          readPackedFixed64(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readFixed64());
            return e;
          }
          readPackedSFixed64(e = []) {
            const r = this.readPackedEnd();
            for (; this.pos < r; ) e.push(this.readSFixed64());
            return e;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(e) {
            const r = 7 & e;
            if (r === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (r === 2) this.pos = this.readVarint() + this.pos;
            else if (r === 5) this.pos += 4;
            else {
              if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
              this.pos += 8;
            }
          }
          writeTag(e, r) {
            this.writeVarint(e << 3 | r);
          }
          realloc(e) {
            let r = this.length || 16;
            for (; r < this.pos + e; ) r *= 2;
            if (r !== this.length) {
              const c = new Uint8Array(r);
              c.set(this.buf), this.buf = c, this.dataView = new DataView(c.buffer), this.length = r;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(e) {
            this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
          }
          writeSFixed32(e) {
            this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
          }
          writeFixed64(e) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * l0), !0), this.pos += 8;
          }
          writeSFixed64(e) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * l0), !0), this.pos += 8;
          }
          writeVarint(e) {
            (e = +e || 0) > 268435455 || e < 0 ? (function(r, c) {
              let f, m;
              if (r >= 0 ? (f = r % 4294967296 | 0, m = r / 4294967296 | 0) : (f = ~(-r % 4294967296), m = ~(-r / 4294967296), 4294967295 ^ f ? f = f + 1 | 0 : (f = 0, m = m + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              c.realloc(10), (function(v, E, k) {
                k.buf[k.pos++] = 127 & v | 128, v >>>= 7, k.buf[k.pos++] = 127 & v | 128, v >>>= 7, k.buf[k.pos++] = 127 & v | 128, v >>>= 7, k.buf[k.pos++] = 127 & v | 128, k.buf[k.pos] = 127 & (v >>>= 7);
              })(f, 0, c), (function(v, E) {
                const k = (7 & v) << 4;
                E.buf[E.pos++] |= k | ((v >>>= 3) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (E.buf[E.pos++] = 127 & v)))));
              })(m, c);
            })(e, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127))));
          }
          writeSVarint(e) {
            this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
          }
          writeBoolean(e) {
            this.writeVarint(+e);
          }
          writeString(e) {
            e = String(e), this.realloc(4 * e.length), this.pos++;
            const r = this.pos;
            this.pos = (function(f, m, v) {
              for (let E, k, P = 0; P < m.length; P++) {
                if (E = m.charCodeAt(P), E > 55295 && E < 57344) {
                  if (!k) {
                    E > 56319 || P + 1 === m.length ? (f[v++] = 239, f[v++] = 191, f[v++] = 189) : k = E;
                    continue;
                  }
                  if (E < 56320) {
                    f[v++] = 239, f[v++] = 191, f[v++] = 189, k = E;
                    continue;
                  }
                  E = k - 55296 << 10 | E - 56320 | 65536, k = null;
                } else k && (f[v++] = 239, f[v++] = 191, f[v++] = 189, k = null);
                E < 128 ? f[v++] = E : (E < 2048 ? f[v++] = E >> 6 | 192 : (E < 65536 ? f[v++] = E >> 12 | 224 : (f[v++] = E >> 18 | 240, f[v++] = E >> 12 & 63 | 128), f[v++] = E >> 6 & 63 | 128), f[v++] = 63 & E | 128);
              }
              return v;
            })(this.buf, e, this.pos);
            const c = this.pos - r;
            c >= 128 && c0(r, c, this), this.pos = r - 1, this.writeVarint(c), this.pos += c;
          }
          writeFloat(e) {
            this.realloc(4), this.dataView.setFloat32(this.pos, e, !0), this.pos += 4;
          }
          writeDouble(e) {
            this.realloc(8), this.dataView.setFloat64(this.pos, e, !0), this.pos += 8;
          }
          writeBytes(e) {
            const r = e.length;
            this.writeVarint(r), this.realloc(r);
            for (let c = 0; c < r; c++) this.buf[this.pos++] = e[c];
          }
          writeRawMessage(e, r) {
            this.pos++;
            const c = this.pos;
            e(r, this);
            const f = this.pos - c;
            f >= 128 && c0(c, f, this), this.pos = c - 1, this.writeVarint(f), this.pos += f;
          }
          writeMessage(e, r, c) {
            this.writeTag(e, 2), this.writeRawMessage(r, c);
          }
          writePackedVarint(e, r) {
            r.length && this.writeMessage(e, ST, r);
          }
          writePackedSVarint(e, r) {
            r.length && this.writeMessage(e, kT, r);
          }
          writePackedBoolean(e, r) {
            r.length && this.writeMessage(e, CT, r);
          }
          writePackedFloat(e, r) {
            r.length && this.writeMessage(e, IT, r);
          }
          writePackedDouble(e, r) {
            r.length && this.writeMessage(e, MT, r);
          }
          writePackedFixed32(e, r) {
            r.length && this.writeMessage(e, PT, r);
          }
          writePackedSFixed32(e, r) {
            r.length && this.writeMessage(e, AT, r);
          }
          writePackedFixed64(e, r) {
            r.length && this.writeMessage(e, LT, r);
          }
          writePackedSFixed64(e, r) {
            r.length && this.writeMessage(e, DT, r);
          }
          writeBytesField(e, r) {
            this.writeTag(e, 2), this.writeBytes(r);
          }
          writeFixed32Field(e, r) {
            this.writeTag(e, 5), this.writeFixed32(r);
          }
          writeSFixed32Field(e, r) {
            this.writeTag(e, 5), this.writeSFixed32(r);
          }
          writeFixed64Field(e, r) {
            this.writeTag(e, 1), this.writeFixed64(r);
          }
          writeSFixed64Field(e, r) {
            this.writeTag(e, 1), this.writeSFixed64(r);
          }
          writeVarintField(e, r) {
            this.writeTag(e, 0), this.writeVarint(r);
          }
          writeSVarintField(e, r) {
            this.writeTag(e, 0), this.writeSVarint(r);
          }
          writeStringField(e, r) {
            this.writeTag(e, 2), this.writeString(r);
          }
          writeFloatField(e, r) {
            this.writeTag(e, 5), this.writeFloat(r);
          }
          writeDoubleField(e, r) {
            this.writeTag(e, 1), this.writeDouble(r);
          }
          writeBooleanField(e, r) {
            this.writeVarintField(e, +r);
          }
        }
        function uh(i, e, r) {
          return r ? 4294967296 * e + (i >>> 0) : 4294967296 * (e >>> 0) + (i >>> 0);
        }
        function c0(i, e, r) {
          const c = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
          r.realloc(c);
          for (let f = r.pos - 1; f >= i; f--) r.buf[f + c] = r.buf[f];
        }
        function ST(i, e) {
          for (let r = 0; r < i.length; r++) e.writeVarint(i[r]);
        }
        function kT(i, e) {
          for (let r = 0; r < i.length; r++) e.writeSVarint(i[r]);
        }
        function IT(i, e) {
          for (let r = 0; r < i.length; r++) e.writeFloat(i[r]);
        }
        function MT(i, e) {
          for (let r = 0; r < i.length; r++) e.writeDouble(i[r]);
        }
        function CT(i, e) {
          for (let r = 0; r < i.length; r++) e.writeBoolean(i[r]);
        }
        function PT(i, e) {
          for (let r = 0; r < i.length; r++) e.writeFixed32(i[r]);
        }
        function AT(i, e) {
          for (let r = 0; r < i.length; r++) e.writeSFixed32(i[r]);
        }
        function LT(i, e) {
          for (let r = 0; r < i.length; r++) e.writeFixed64(i[r]);
        }
        function DT(i, e) {
          for (let r = 0; r < i.length; r++) e.writeSFixed64(i[r]);
        }
        function RT(i, e, r) {
          i === 1 && r.readMessage(FT, e);
        }
        function FT(i, e, r) {
          if (i === 3) {
            const { id: c, bitmap: f, width: m, height: v, left: E, top: k, advance: P } = r.readMessage(NT, {});
            e.push({ id: c, bitmap: new Cd({ width: m + 6, height: v + 6 }, f), metrics: { width: m, height: v, left: E, top: k, advance: P } });
          }
        }
        function NT(i, e, r) {
          i === 1 ? e.id = r.readVarint() : i === 2 ? e.bitmap = r.readBytes() : i === 3 ? e.width = r.readVarint() : i === 4 ? e.height = r.readVarint() : i === 5 ? e.left = r.readSVarint() : i === 6 ? e.top = r.readSVarint() : i === 7 && (e.advance = r.readVarint());
        }
        function h0(i) {
          let e = 0, r = 0;
          for (const v of i) e += v.w * v.h, r = Math.max(r, v.w);
          i.sort(((v, E) => E.h - v.h));
          const c = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), r), h: 1 / 0 }];
          let f = 0, m = 0;
          for (const v of i) for (let E = c.length - 1; E >= 0; E--) {
            const k = c[E];
            if (!(v.w > k.w || v.h > k.h)) {
              if (v.x = k.x, v.y = k.y, m = Math.max(m, v.y + v.h), f = Math.max(f, v.x + v.w), v.w === k.w && v.h === k.h) {
                const P = c.pop();
                P && E < c.length && (c[E] = P);
              } else v.h === k.h ? (k.x += v.w, k.w -= v.w) : v.w === k.w ? (k.y += v.h, k.h -= v.h) : (c.push({ x: k.x + v.w, y: k.y, w: k.w - v.w, h: v.h }), k.y += v.h, k.h -= v.h);
              break;
            }
          }
          return { w: f, h: m, fill: e / (f * m) || 0 };
        }
        class Lm {
          constructor(e, { pixelRatio: r, version: c, stretchX: f, stretchY: m, content: v, textFitWidth: E, textFitHeight: k }) {
            this.paddedRect = e, this.pixelRatio = r, this.stretchX = f, this.stretchY = m, this.content = v, this.version = c, this.textFitWidth = E, this.textFitHeight = k;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class d0 {
          constructor(e, r) {
            const c = {}, f = {};
            this.haveRenderCallbacks = [];
            const m = [];
            this.addImages(e, c, m), this.addImages(r, f, m);
            const { w: v, h: E } = h0(m), k = new os({ width: v || 1, height: E || 1 });
            for (const P in e) {
              const L = e[P], N = c[P].paddedRect;
              os.copy(L.data, k, { x: 0, y: 0 }, { x: N.x + 1, y: N.y + 1 }, L.data);
            }
            for (const P in r) {
              const L = r[P], N = f[P].paddedRect, G = N.x + 1, j = N.y + 1, Z = L.data.width, Y = L.data.height;
              os.copy(L.data, k, { x: 0, y: 0 }, { x: G, y: j }, L.data), os.copy(L.data, k, { x: 0, y: Y - 1 }, { x: G, y: j - 1 }, { width: Z, height: 1 }), os.copy(L.data, k, { x: 0, y: 0 }, { x: G, y: j + Y }, { width: Z, height: 1 }), os.copy(L.data, k, { x: Z - 1, y: 0 }, { x: G - 1, y: j }, { width: 1, height: Y }), os.copy(L.data, k, { x: 0, y: 0 }, { x: G + Z, y: j }, { width: 1, height: Y });
            }
            this.image = k, this.iconPositions = c, this.patternPositions = f;
          }
          addImages(e, r, c) {
            for (const f in e) {
              const m = e[f], v = { x: 0, y: 0, w: m.data.width + 2, h: m.data.height + 2 };
              c.push(v), r[f] = new Lm(v, m), m.hasRenderCallback && this.haveRenderCallbacks.push(f);
            }
          }
          patchUpdatedImages(e, r) {
            e.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const c in e.updatedImages) this.patchUpdatedImage(this.iconPositions[c], e.getImage(c), r), this.patchUpdatedImage(this.patternPositions[c], e.getImage(c), r);
          }
          patchUpdatedImage(e, r, c) {
            if (!e || !r || e.version === r.version) return;
            e.version = r.version;
            const [f, m] = e.tl;
            c.update(r.data, void 0, { x: f, y: m });
          }
        }
        var Ol;
        function Cp(i, e, r, c, f, m, v, E, k, P, L, N, G, j, Z) {
          const Y = lh.fromFeature(i, f);
          let X;
          N === T.az.vertical && Y.verticalizePunctuation();
          let ne = Y.determineLineBreaks(P, m, e, c, j);
          const { processBidirectionalText: xe, processStyledBidirectionalText: ae } = co;
          if (xe && Y.sections.length === 1) {
            X = [], ne = ne.map(((Ke) => Y.toCodeUnitIndex(Ke)));
            const Ae = xe(Y.toString(), ne);
            for (const Ke of Ae) {
              const ht = [...Ke].map((() => 0));
              X.push(new lh(Ke, Y.sections, ht));
            }
          } else if (ae) {
            X = [], ne = ne.map(((lt) => Y.toCodeUnitIndex(lt)));
            let Ae = 0;
            const Ke = [];
            for (const lt of Y.text) Ke.push(...Array(lt.length).fill(Y.sectionIndex[Ae])), Ae++;
            const ht = ae(Y.text, Ke, ne);
            for (const lt of ht) {
              const pt = [];
              let Ct = "";
              for (const _t of lt[0]) pt.push(lt[1][Ct.length]), Ct += _t;
              X.push(new lh(lt[0], Y.sections, pt));
            }
          } else X = (function(Ae, Ke) {
            const ht = [];
            let lt = 0;
            for (const pt of Ke) ht.push(Ae.substring(lt, pt)), lt = pt;
            return lt < Ae.length() && ht.push(Ae.substring(lt, Ae.length())), ht;
          })(Y, ne);
          const ue = [], Te = { positionedLines: ue, text: Y.toString(), top: L[1], bottom: L[1], left: L[0], right: L[0], writingMode: N, iconsInText: !1, verticalizable: !1 };
          return (function(Ae, Ke, ht, lt, pt, Ct, _t, ut, st, Bt, Rt, Vt) {
            let Dt = 0, Yt = 0, Sr = 0, yr = 0;
            const cn = ut === "right" ? 1 : ut === "left" ? 0 : 0.5, Pi = ci / Vt;
            let Zn = 0;
            for (const Fr of pt) {
              Fr.trim();
              const Tn = Fr.getMaxScale(), Dn = { positionedGlyphs: [], lineOffset: 0 };
              Ae.positionedLines[Zn] = Dn;
              const Jr = Dn.positionedGlyphs;
              let ls = 0;
              if (!Fr.length()) {
                Yt += Ct, ++Zn;
                continue;
              }
              const Ai = OT(lt, Fr, Pi);
              let us = 0;
              for (const fi of Fr.text) {
                const _n = Fr.getSection(us), Hn = fi.codePointAt(0), Sn = zT(st, Rt, Hn), pi = { glyph: Hn, imageName: null, x: Dt, y: Yt + -17, vertical: Sn, scale: 1, fontStack: "", sectionIndex: Fr.getSectionIndex(us), metrics: null, rect: null };
                let el;
                if ("fontStack" in _n) {
                  if (el = BT(_n, Hn, Sn, Ai, Ke, ht), !el) continue;
                  pi.fontStack = _n.fontStack;
                } else {
                  if (Ae.iconsInText = !0, _n.scale *= Pi, el = GT(_n, Sn, Tn, Ai, lt), !el) continue;
                  ls = Math.max(ls, el.imageOffset), pi.imageName = _n.imageName;
                }
                const { rect: Na, metrics: Zd, baselineOffset: Vl } = el;
                pi.y += Vl, pi.scale = _n.scale, pi.metrics = Zd, pi.rect = Na, Jr.push(pi), Sn ? (Ae.verticalizable = !0, Dt += ("imageName" in _n ? Zd.advance : ci) * _n.scale + Bt) : Dt += Zd.advance * _n.scale + Bt, us++;
              }
              Jr.length !== 0 && (Sr = Math.max(Dt - Bt, Sr), jT(Jr, 0, Jr.length - 1, cn)), Dt = 0, Dn.lineOffset = Math.max(ls, (Tn - 1) * ci);
              const ua = Ct * Tn + ls;
              Yt += ua, yr = Math.max(ua, yr), ++Zn;
            }
            const { horizontalAlign: hn, verticalAlign: an } = Dm(_t);
            (function(Fr, Tn, Dn, Jr, ls, Ai, us, ua, fi) {
              const _n = (Tn - Dn) * ls;
              let Hn = 0;
              Hn = Ai !== us ? -ua * Jr - -17 : -Jr * fi * us + 0.5 * us;
              for (const Sn of Fr) for (const pi of Sn.positionedGlyphs) pi.x += _n, pi.y += Hn;
            })(Ae.positionedLines, cn, hn, an, Sr, yr, Ct, Yt, pt.length), Ae.top += -an * Yt, Ae.bottom = Ae.top + Yt, Ae.left += -hn * Sr, Ae.right = Ae.left + Sr;
          })(Te, e, r, c, X, v, E, k, N, P, G, Z), !(function(Ae) {
            for (const Ke of Ae) if (Ke.positionedGlyphs.length !== 0) return !1;
            return !0;
          })(ue) && Te;
        }
        function Dm(i) {
          let e = 0.5, r = 0.5;
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              e = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e = 0;
          }
          switch (i) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0;
          }
          return { horizontalAlign: e, verticalAlign: r };
        }
        function OT(i, e, r) {
          const c = e.getMaxScale() * ci, { maxImageWidth: f, maxImageHeight: m } = e.getMaxImageSize(i), v = Math.max(c, m * r);
          return { verticalLineContentWidth: Math.max(c, f * r), horizontalLineContentHeight: v };
        }
        function f0(i) {
          switch (i) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function zT(i, e, r) {
          return !(i === T.az.horizontal || !e && !pd(r) || e && (up(r) || (c = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(c)))));
          var c;
        }
        function BT(i, e, r, c, f, m) {
          const v = m[i.fontStack], E = (function(P, L, N, G) {
            if (P && P.rect) return P;
            const j = L[N.fontStack], Z = j && j[G];
            return Z ? { rect: null, metrics: Z.metrics } : null;
          })(v && v[e], f, i, e);
          if (E === null) return null;
          let k;
          if (r) k = c.verticalLineContentWidth - i.scale * ci;
          else {
            const P = f0(i.verticalAlign);
            k = (c.horizontalLineContentHeight - i.scale * ci) * P;
          }
          return { rect: E.rect, metrics: E.metrics, baselineOffset: k };
        }
        function GT(i, e, r, c, f) {
          const m = f[i.imageName];
          if (!m) return null;
          const v = m.paddedRect, E = m.displaySize, k = { width: E[0], height: E[1], left: 1, top: -3, advance: e ? E[1] : E[0] };
          let P;
          if (e) P = c.verticalLineContentWidth - E[1] * i.scale;
          else {
            const L = f0(i.verticalAlign);
            P = (c.horizontalLineContentHeight - E[1] * i.scale) * L;
          }
          return { rect: v, metrics: k, baselineOffset: P, imageOffset: (e ? E[0] : E[1]) * i.scale - ci * r };
        }
        function jT(i, e, r, c) {
          if (c === 0) return;
          const f = i[r], m = (i[r].x + f.metrics.advance * f.scale) * c;
          for (let v = e; v <= r; v++) i[v].x -= m;
        }
        function VT(i, e, r) {
          const { horizontalAlign: c, verticalAlign: f } = Dm(r), m = e[0] - i.displaySize[0] * c, v = e[1] - i.displaySize[1] * f;
          return { image: i, top: v, bottom: v + i.displaySize[1], left: m, right: m + i.displaySize[0] };
        }
        function p0(i) {
          var e, r;
          let c = i.left, f = i.top, m = i.right - c, v = i.bottom - f;
          const E = (e = i.image.textFitWidth) !== null && e !== void 0 ? e : "stretchOrShrink", k = (r = i.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink", P = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
          if (k === "proportional") {
            if (E === "stretchOnly" && m / v < P || E === "proportional") {
              const L = Math.ceil(v * P);
              c *= L / m, m = L;
            }
          } else if (E === "proportional" && k === "stretchOnly" && P !== 0 && m / v > P) {
            const L = Math.ceil(m / P);
            f *= L / v, v = L;
          }
          return { x1: c, y1: f, x2: c + m, y2: f + v };
        }
        function g0(i, e, r, c, f, m) {
          const v = i.image;
          let E;
          if (v.content) {
            const X = v.content, ne = v.pixelRatio || 1;
            E = [X[0] / ne, X[1] / ne, v.displaySize[0] - X[2] / ne, v.displaySize[1] - X[3] / ne];
          }
          const k = e.left * m, P = e.right * m;
          let L, N, G, j;
          r === "width" || r === "both" ? (j = f[0] + k - c[3], N = f[0] + P + c[1]) : (j = f[0] + (k + P - v.displaySize[0]) / 2, N = j + v.displaySize[0]);
          const Z = e.top * m, Y = e.bottom * m;
          return r === "height" || r === "both" ? (L = f[1] + Z - c[0], G = f[1] + Y + c[2]) : (L = f[1] + (Z + Y - v.displaySize[1]) / 2, G = L + v.displaySize[1]), { image: v, top: L, right: N, bottom: G, left: j, collisionPadding: E };
        }
        jt("ImagePosition", Lm), jt("ImageAtlas", d0), T.az = void 0, (Ol = T.az || (T.az = {}))[Ol.none = 0] = "none", Ol[Ol.horizontal = 1] = "horizontal", Ol[Ol.vertical = 2] = "vertical", Ol[Ol.horizontalOnly = 3] = "horizontalOnly";
        const Ko = 128, zl = 32640;
        function m0(i, e) {
          const { expression: r } = e;
          if (r.kind === "constant") return { kind: "constant", layoutSize: r.evaluate(new Vr(i + 1)) };
          if (r.kind === "source") return { kind: "source" };
          {
            const { zoomStops: c, interpolationType: f } = r;
            let m = 0;
            for (; m < c.length && c[m] <= i; ) m++;
            m = Math.max(0, m - 1);
            let v = m;
            for (; v < c.length && c[v] < i + 1; ) v++;
            v = Math.min(c.length - 1, v);
            const E = c[m], k = c[v];
            return r.kind === "composite" ? { kind: "composite", minZoom: E, maxZoom: k, interpolationType: f } : { kind: "camera", minZoom: E, maxZoom: k, minSize: r.evaluate(new Vr(E)), maxSize: r.evaluate(new Vr(k)), interpolationType: f };
          }
        }
        function Rm(i, e, r) {
          let c = "never";
          const f = i.get(e);
          return f ? c = f : i.get(r) && (c = "always"), c;
        }
        const UT = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Pp(i, e, r, c, f, m, v, E, k, P, L, N, G) {
          const j = E ? Math.min(zl, Math.round(E[0])) : 0, Z = E ? Math.min(zl, Math.round(E[1])) : 0;
          i.emplaceBack(e, r, Math.round(32 * c), Math.round(32 * f), m, v, (j << 1) + (k ? 1 : 0), Z, 16 * P, 16 * L, 256 * N, 256 * G);
        }
        function Fm(i, e, r) {
          i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r);
        }
        function qT(i) {
          for (const e of i.sections) if (dp(e.text)) return !0;
          return !1;
        }
        class Nm {
          constructor(e) {
            this.layoutVertexArray = new ke(), this.indexArray = new it(), this.programConfigurations = e, this.segments = new At(), this.dynamicLayoutVertexArray = new Ge(), this.opacityVertexArray = new at(), this.hasVisibleVertices = !1, this.placedSymbolArray = new S();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(e, r, c, f) {
            this.isEmpty() || (c && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, _T.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, yT.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, UT, !0), this.opacityVertexBuffer.itemSize = 1), (c || f) && this.programConfigurations.upload(e));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        jt("SymbolBuffers", Nm);
        class Om {
          constructor(e, r, c) {
            this.layoutVertexArray = new e(), this.layoutAttributes = r, this.indexArray = new c(), this.segments = new At(), this.collisionVertexArray = new nt();
          }
          upload(e) {
            this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, vT.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        jt("CollisionBuffers", Om);
        class ch {
          constructor(e) {
            this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((v) => v.id)), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = m0(this.zoom, r["text-size"]), this.iconSizeData = m0(this.zoom, r["icon-size"]);
            const c = this.layers[0].layout, f = c.get("symbol-sort-key"), m = c.get("symbol-z-order");
            this.canOverlap = Rm(c, "text-overlap", "text-allow-overlap") !== "never" || Rm(c, "icon-overlap", "icon-allow-overlap") !== "never" || c.get("text-ignore-placement") || c.get("icon-ignore-placement"), this.sortFeaturesByKey = m !== "viewport-y" && !f.isConstant(), this.sortFeaturesByY = (m === "viewport-y" || m === "auto" && !this.sortFeaturesByKey) && this.canOverlap, c.get("symbol-placement") === "point" && (this.writingModes = c.get("text-writing-mode").map(((v) => T.az[v]))), this.stateDependentLayerIds = this.layers.filter(((v) => v.isStateDependent())).map(((v) => v.id)), this.sourceID = e.sourceID;
          }
          createArrays() {
            this.text = new Nm(new Jo(this.layers, this.zoom, ((e) => /^text/.test(e)))), this.icon = new Nm(new Jo(this.layers, this.zoom, ((e) => /^icon/.test(e)))), this.glyphOffsetArray = new F(), this.lineVertexArray = new O(), this.symbolInstances = new A(), this.textAnchorOffsets = new V();
          }
          calculateGlyphDependencies(e, r, c, f, m) {
            for (const v of e) if (r[v.codePointAt(0)] = !0, (c || f) && m) {
              const E = Bd[v];
              E && (r[E.codePointAt(0)] = !0);
            }
          }
          populate(e, r, c) {
            const f = this.layers[0], m = f.layout, v = m.get("text-font"), E = m.get("text-field"), k = m.get("icon-image"), P = (E.value.kind !== "constant" || E.value.value instanceof Wn && !E.value.value.isEmpty() || E.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), L = k.value.kind !== "constant" || !!k.value.value || Object.keys(k.parameters).length > 0, N = m.get("symbol-sort-key");
            if (this.features = [], !P && !L) return;
            const G = r.iconDependencies, j = r.glyphDependencies, Z = r.availableImages, Y = new Vr(this.zoom);
            for (const { feature: X, id: ne, index: xe, sourceLayerIndex: ae } of e) {
              const ue = f._featureFilter.needGeometry, Te = go(X, ue);
              if (!f._featureFilter.filter(Y, Te, c)) continue;
              let Ae, Ke;
              if (ue || (Te.geometry = po(X)), P) {
                const lt = f.getValueAndResolveTokens("text-field", Te, c, Z), pt = Wn.factory(lt), Ct = this.hasRTLText = this.hasRTLText || qT(pt);
                (!Ct || co.getRTLTextPluginStatus() === "unavailable" || Ct && co.isParsed()) && (Ae = bT(pt, f, Te));
              }
              if (L) {
                const lt = f.getValueAndResolveTokens("icon-image", Te, c, Z);
                Ke = lt instanceof dr ? lt : dr.fromString(lt);
              }
              if (!Ae && !Ke) continue;
              const ht = this.sortFeaturesByKey ? N.evaluate(Te, {}, c) : void 0;
              if (this.features.push({ id: ne, text: Ae, icon: Ke, index: xe, sourceLayerIndex: ae, geometry: Te.geometry, properties: X.properties, type: Nd.types[X.type], sortKey: ht }), Ke && (G[Ke.name] = !0), Ae) {
                const lt = v.evaluate(Te, {}, c).join(","), pt = m.get("text-rotation-alignment") !== "viewport" && m.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(T.az.vertical) >= 0;
                for (const Ct of Ae.sections) if (Ct.image) G[Ct.image.name] = !0;
                else {
                  const _t = Fl(Ae.toString()), ut = Ct.fontStack || lt, st = j[ut] = j[ut] || {};
                  this.calculateGlyphDependencies(Ct.text, st, pt, this.allowVerticalPlacement, _t);
                }
              }
            }
            m.get("symbol-placement") === "line" && (this.features = (function(X) {
              const ne = {}, xe = {}, ae = [];
              let ue = 0;
              function Te(lt) {
                ae.push(X[lt]), ue++;
              }
              function Ae(lt, pt, Ct) {
                const _t = xe[lt];
                return delete xe[lt], xe[pt] = _t, ae[_t].geometry[0].pop(), ae[_t].geometry[0] = ae[_t].geometry[0].concat(Ct[0]), _t;
              }
              function Ke(lt, pt, Ct) {
                const _t = ne[pt];
                return delete ne[pt], ne[lt] = _t, ae[_t].geometry[0].shift(), ae[_t].geometry[0] = Ct[0].concat(ae[_t].geometry[0]), _t;
              }
              function ht(lt, pt, Ct) {
                const _t = Ct ? pt[0][pt[0].length - 1] : pt[0][0];
                return `${lt}:${_t.x}:${_t.y}`;
              }
              for (let lt = 0; lt < X.length; lt++) {
                const pt = X[lt], Ct = pt.geometry, _t = pt.text ? pt.text.toString() : null;
                if (!_t) {
                  Te(lt);
                  continue;
                }
                const ut = ht(_t, Ct), st = ht(_t, Ct, !0);
                if (ut in xe && st in ne && xe[ut] !== ne[st]) {
                  const Bt = Ke(ut, st, Ct), Rt = Ae(ut, st, ae[Bt].geometry);
                  delete ne[ut], delete xe[st], xe[ht(_t, ae[Rt].geometry, !0)] = Rt, ae[Bt].geometry = null;
                } else ut in xe ? Ae(ut, st, Ct) : st in ne ? Ke(ut, st, Ct) : (Te(lt), ne[ut] = ue - 1, xe[st] = ue - 1);
              }
              return ae.filter(((lt) => lt.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((X, ne) => X.sortKey - ne.sortKey));
          }
          update(e, r, c) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, r, this.layers, { imagePositions: c }), this.icon.programConfigurations.updatePaintArrays(e, r, this.layers, { imagePositions: c }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(e) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(e, r) {
            const c = this.lineVertexArray.length;
            if (e.segment !== void 0) {
              let f = e.dist(r[e.segment + 1]), m = e.dist(r[e.segment]);
              const v = {};
              for (let E = e.segment + 1; E < r.length; E++) v[E] = { x: r[E].x, y: r[E].y, tileUnitDistanceFromAnchor: f }, E < r.length - 1 && (f += r[E + 1].dist(r[E]));
              for (let E = e.segment || 0; E >= 0; E--) v[E] = { x: r[E].x, y: r[E].y, tileUnitDistanceFromAnchor: m }, E > 0 && (m += r[E - 1].dist(r[E]));
              for (let E = 0; E < r.length; E++) {
                const k = v[E];
                this.lineVertexArray.emplaceBack(k.x, k.y, k.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: c, lineLength: this.lineVertexArray.length - c };
          }
          addSymbols(e, r, c, f, m, v, E, k, P, L, N, G) {
            const j = e.indexArray, Z = e.layoutVertexArray, Y = e.segments.prepareSegment(4 * r.length, Z, j, this.canOverlap ? v.sortKey : void 0), X = this.glyphOffsetArray.length, ne = Y.vertexLength, xe = this.allowVerticalPlacement && E === T.az.vertical ? Math.PI / 2 : 0, ae = v.text && v.text.sections;
            for (let ue = 0; ue < r.length; ue++) {
              const { tl: Te, tr: Ae, bl: Ke, br: ht, tex: lt, pixelOffsetTL: pt, pixelOffsetBR: Ct, minFontScaleX: _t, minFontScaleY: ut, glyphOffset: st, isSDF: Bt, sectionIndex: Rt } = r[ue], Vt = Y.vertexLength, Dt = st[1];
              Pp(Z, k.x, k.y, Te.x, Dt + Te.y, lt.x, lt.y, c, Bt, pt.x, pt.y, _t, ut), Pp(Z, k.x, k.y, Ae.x, Dt + Ae.y, lt.x + lt.w, lt.y, c, Bt, Ct.x, pt.y, _t, ut), Pp(Z, k.x, k.y, Ke.x, Dt + Ke.y, lt.x, lt.y + lt.h, c, Bt, pt.x, Ct.y, _t, ut), Pp(Z, k.x, k.y, ht.x, Dt + ht.y, lt.x + lt.w, lt.y + lt.h, c, Bt, Ct.x, Ct.y, _t, ut), Fm(e.dynamicLayoutVertexArray, k, xe), j.emplaceBack(Vt, Vt + 2, Vt + 1), j.emplaceBack(Vt + 1, Vt + 2, Vt + 3), Y.vertexLength += 4, Y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(st[0]), ue !== r.length - 1 && Rt === r[ue + 1].sectionIndex || e.programConfigurations.populatePaintArrays(Z.length, v, v.index, { imagePositions: {}, canonical: G, formattedSection: ae && ae[Rt] });
            }
            e.placedSymbolArray.emplaceBack(k.x, k.y, X, this.glyphOffsetArray.length - X, ne, P, L, k.segment, c ? c[0] : 0, c ? c[1] : 0, f[0], f[1], E, 0, !1, 0, N);
          }
          _addCollisionDebugVertex(e, r, c, f, m, v) {
            return r.emplaceBack(0, 0), e.emplaceBack(c.x, c.y, f, m, Math.round(v.x), Math.round(v.y));
          }
          addCollisionDebugVertices(e, r, c, f, m, v, E) {
            const k = m.segments.prepareSegment(4, m.layoutVertexArray, m.indexArray), P = k.vertexLength, L = m.layoutVertexArray, N = m.collisionVertexArray, G = E.anchorX, j = E.anchorY;
            this._addCollisionDebugVertex(L, N, v, G, j, new R(e, r)), this._addCollisionDebugVertex(L, N, v, G, j, new R(c, r)), this._addCollisionDebugVertex(L, N, v, G, j, new R(c, f)), this._addCollisionDebugVertex(L, N, v, G, j, new R(e, f)), k.vertexLength += 4;
            const Z = m.indexArray;
            Z.emplaceBack(P, P + 1), Z.emplaceBack(P + 1, P + 2), Z.emplaceBack(P + 2, P + 3), Z.emplaceBack(P + 3, P), k.primitiveLength += 4;
          }
          addDebugCollisionBoxes(e, r, c, f) {
            for (let m = e; m < r; m++) {
              const v = this.collisionBoxArray.get(m);
              this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, f ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, c);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Om(tt, n0.members, Et), this.iconCollisionBox = new Om(tt, n0.members, Et);
            for (let e = 0; e < this.symbolInstances.length; e++) {
              const r = this.symbolInstances.get(e);
              this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(e, r, c, f, m, v, E, k, P) {
            const L = {};
            for (let N = r; N < c; N++) {
              const G = e.get(N);
              L.textBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, L.textFeatureIndex = G.featureIndex;
              break;
            }
            for (let N = f; N < m; N++) {
              const G = e.get(N);
              L.verticalTextBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, L.verticalTextFeatureIndex = G.featureIndex;
              break;
            }
            for (let N = v; N < E; N++) {
              const G = e.get(N);
              L.iconBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, L.iconFeatureIndex = G.featureIndex;
              break;
            }
            for (let N = k; N < P; N++) {
              const G = e.get(N);
              L.verticalIconBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, L.verticalIconFeatureIndex = G.featureIndex;
              break;
            }
            return L;
          }
          deserializeCollisionBoxes(e) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const c = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, c.textBoxStartIndex, c.textBoxEndIndex, c.verticalTextBoxStartIndex, c.verticalTextBoxEndIndex, c.iconBoxStartIndex, c.iconBoxEndIndex, c.verticalIconBoxStartIndex, c.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(e, r) {
            const c = e.placedSymbolArray.get(r), f = c.vertexStartIndex + 4 * c.numGlyphs;
            for (let m = c.vertexStartIndex; m < f; m += 4) e.indexArray.emplaceBack(m, m + 2, m + 1), e.indexArray.emplaceBack(m + 1, m + 2, m + 3);
          }
          getSortedSymbolIndexes(e) {
            if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(e), c = Math.cos(e), f = [], m = [], v = [];
            for (let E = 0; E < this.symbolInstances.length; ++E) {
              v.push(E);
              const k = this.symbolInstances.get(E);
              f.push(0 | Math.round(r * k.anchorX + c * k.anchorY)), m.push(k.featureIndex);
            }
            return v.sort(((E, k) => f[E] - f[k] || m[k] - m[E])), v;
          }
          addToSortKeyRanges(e, r) {
            const c = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            c && c.sortKey === r ? c.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: r, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
          }
          sortFeatures(e) {
            if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const c = this.symbolInstances.get(r);
                this.featureSortOrder.push(c.featureIndex), [c.rightJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.leftJustifiedTextSymbolIndex].forEach(((f, m, v) => {
                  f >= 0 && v.indexOf(f) === m && this.addIndicesForPlacedSymbol(this.text, f);
                })), c.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, c.verticalPlacedTextSymbolIndex), c.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, c.placedIconSymbolIndex), c.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, c.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let _0, y0;
        jt("SymbolBucket", ch, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), ch.MAX_GLYPHS = 65535, ch.addDynamicAttributes = Fm;
        var zm = { get paint() {
          return y0 = y0 || new Vi({ "icon-opacity": new Jt(Xe.paint_symbol["icon-opacity"]), "icon-color": new Jt(Xe.paint_symbol["icon-color"]), "icon-halo-color": new Jt(Xe.paint_symbol["icon-halo-color"]), "icon-halo-width": new Jt(Xe.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Jt(Xe.paint_symbol["icon-halo-blur"]), "icon-translate": new Zt(Xe.paint_symbol["icon-translate"]), "icon-translate-anchor": new Zt(Xe.paint_symbol["icon-translate-anchor"]), "text-opacity": new Jt(Xe.paint_symbol["text-opacity"]), "text-color": new Jt(Xe.paint_symbol["text-color"], { runtimeType: pn, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new Jt(Xe.paint_symbol["text-halo-color"]), "text-halo-width": new Jt(Xe.paint_symbol["text-halo-width"]), "text-halo-blur": new Jt(Xe.paint_symbol["text-halo-blur"]), "text-translate": new Zt(Xe.paint_symbol["text-translate"]), "text-translate-anchor": new Zt(Xe.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return _0 = _0 || new Vi({ "symbol-placement": new Zt(Xe.layout_symbol["symbol-placement"]), "symbol-spacing": new Zt(Xe.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Zt(Xe.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Jt(Xe.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Zt(Xe.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Zt(Xe.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Zt(Xe.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Zt(Xe.layout_symbol["icon-ignore-placement"]), "icon-optional": new Zt(Xe.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Zt(Xe.layout_symbol["icon-rotation-alignment"]), "icon-size": new Jt(Xe.layout_symbol["icon-size"]), "icon-text-fit": new Zt(Xe.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Zt(Xe.layout_symbol["icon-text-fit-padding"]), "icon-image": new Jt(Xe.layout_symbol["icon-image"]), "icon-rotate": new Jt(Xe.layout_symbol["icon-rotate"]), "icon-padding": new Jt(Xe.layout_symbol["icon-padding"]), "icon-keep-upright": new Zt(Xe.layout_symbol["icon-keep-upright"]), "icon-offset": new Jt(Xe.layout_symbol["icon-offset"]), "icon-anchor": new Jt(Xe.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Zt(Xe.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Zt(Xe.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Zt(Xe.layout_symbol["text-rotation-alignment"]), "text-field": new Jt(Xe.layout_symbol["text-field"]), "text-font": new Jt(Xe.layout_symbol["text-font"]), "text-size": new Jt(Xe.layout_symbol["text-size"]), "text-max-width": new Jt(Xe.layout_symbol["text-max-width"]), "text-line-height": new Zt(Xe.layout_symbol["text-line-height"]), "text-letter-spacing": new Jt(Xe.layout_symbol["text-letter-spacing"]), "text-justify": new Jt(Xe.layout_symbol["text-justify"]), "text-radial-offset": new Jt(Xe.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Zt(Xe.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Jt(Xe.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Jt(Xe.layout_symbol["text-anchor"]), "text-max-angle": new Zt(Xe.layout_symbol["text-max-angle"]), "text-writing-mode": new Zt(Xe.layout_symbol["text-writing-mode"]), "text-rotate": new Jt(Xe.layout_symbol["text-rotate"]), "text-padding": new Zt(Xe.layout_symbol["text-padding"]), "text-keep-upright": new Zt(Xe.layout_symbol["text-keep-upright"]), "text-transform": new Jt(Xe.layout_symbol["text-transform"]), "text-offset": new Jt(Xe.layout_symbol["text-offset"]), "text-allow-overlap": new Zt(Xe.layout_symbol["text-allow-overlap"]), "text-overlap": new Zt(Xe.layout_symbol["text-overlap"]), "text-ignore-placement": new Zt(Xe.layout_symbol["text-ignore-placement"]), "text-optional": new Zt(Xe.layout_symbol["text-optional"]) });
        } };
        class v0 {
          constructor(e) {
            if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = e.property.overrides ? e.property.overrides.runtimeType : yi, this.defaultValue = e;
          }
          evaluate(e) {
            if (e.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(e.formattedSection)) return r.getOverride(e.formattedSection);
            }
            return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(e) {
            this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        jt("FormatSectionOverride", v0, { omit: ["defaultValue"] });
        class Ap extends Es {
          constructor(e, r) {
            super(e, zm, r);
          }
          recalculate(e, r) {
            if (super.recalculate(e, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const c = this.layout.get("text-writing-mode");
              if (c) {
                const f = [];
                for (const m of c) f.indexOf(m) < 0 && f.push(m);
                this.layout._values["text-writing-mode"] = f;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(e, r, c, f) {
            const m = this.layout.get(e).evaluate(r, {}, c, f), v = this._unevaluatedLayout._values[e];
            return v.isDataDriven() || Pl(v.value) || !m ? m : (function(E, k) {
              return k.replace(/{([^{}]+)}/g, ((P, L) => E && L in E ? String(E[L]) : ""));
            })(r.properties, m);
          }
          createBucket(e) {
            return new ch(e);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const e of zm.paint.overridableProperties) {
              if (!Ap.hasPaintOverride(this.layout, e)) continue;
              const r = this.paint.get(e), c = new v0(r), f = new rd(c, r.property.specification);
              let m = null;
              m = r.value.kind === "constant" || r.value.kind === "source" ? new Fc("source", f) : new nd("composite", f, r.value.zoomStops), this.paint._values[e] = new Gs(r.property, m, r.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(e, r, c) {
            return !(!this.layout || r.isDataDriven() || c.isDataDriven()) && Ap.hasPaintOverride(this.layout, e);
          }
          static hasPaintOverride(e, r) {
            const c = e.get("text-field"), f = zm.paint.properties[r];
            let m = !1;
            const v = (E) => {
              for (const k of E) if (f.overrides && f.overrides.hasOverride(k)) return void (m = !0);
            };
            if (c.value.kind === "constant" && c.value.value instanceof Wn) v(c.value.value.sections);
            else if (c.value.kind === "source" || c.value.kind === "composite") {
              const E = (P) => {
                m || (P instanceof rn && Ur(P.value) === bt ? v(P.value.sections) : P instanceof Ns ? v(P.sections) : P.eachChild(E));
              }, k = c.value;
              k._styleExpression && E(k._styleExpression.expression);
            }
            return m;
          }
        }
        let x0;
        var $T = { get paint() {
          return x0 = x0 || new Vi({ "background-color": new Zt(Xe.paint_background["background-color"]), "background-pattern": new Hc(Xe.paint_background["background-pattern"]), "background-opacity": new Zt(Xe.paint_background["background-opacity"]) });
        } };
        class ZT extends Es {
          constructor(e, r) {
            super(e, $T, r);
          }
        }
        class HT extends Es {
          constructor(e, r) {
            super(e, {}, r), this.onAdd = (c) => {
              this.implementation.onAdd && this.implementation.onAdd(c, c.painter.context.gl);
            }, this.onRemove = (c) => {
              this.implementation.onRemove && this.implementation.onRemove(c, c.painter.context.gl);
            }, this.implementation = e;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class YT {
          constructor(e) {
            this._methodToThrottle = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
              this._triggered = !1, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const WT = { once: !0 }, Bm = 63710088e-1;
        class Bl {
          constructor(e, r) {
            if (isNaN(e) || isNaN(r)) throw new Error(`Invalid LngLat object: (${e}, ${r})`);
            if (this.lng = +e, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Bl(gr(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(e) {
            const r = Math.PI / 180, c = this.lat * r, f = e.lat * r, m = Math.sin(c) * Math.sin(f) + Math.cos(c) * Math.cos(f) * Math.cos((e.lng - this.lng) * r);
            return Bm * Math.acos(Math.min(m, 1));
          }
          static convert(e) {
            if (e instanceof Bl) return e;
            if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new Bl(Number(e[0]), Number(e[1]));
            if (!Array.isArray(e) && typeof e == "object" && e !== null) return new Bl(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const b0 = 2 * Math.PI * Bm;
        function w0(i) {
          return b0 * Math.cos(i * Math.PI / 180);
        }
        function E0(i) {
          return (180 + i) / 360;
        }
        function T0(i) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
        }
        function S0(i, e) {
          return i / w0(e);
        }
        function k0(i) {
          return 360 * i - 180;
        }
        function Lp(i) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
        }
        function I0(i, e) {
          return i * w0(Lp(e));
        }
        class Gd {
          constructor(e, r, c = 0) {
            this.x = +e, this.y = +r, this.z = +c;
          }
          static fromLngLat(e, r = 0) {
            const c = Bl.convert(e);
            return new Gd(E0(c.lng), T0(c.lat), S0(r, c.lat));
          }
          toLngLat() {
            return new Bl(k0(this.x), Lp(this.y));
          }
          toAltitude() {
            return I0(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / b0 * (e = Lp(this.y), 1 / Math.cos(e * Math.PI / 180));
            var e;
          }
        }
        function M0(i, e, r) {
          var c = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
          return [i * c - 2 * Math.PI * 6378137 / 2, e * c - 2 * Math.PI * 6378137 / 2];
        }
        class Gm {
          constructor(e, r, c) {
            if (!(function(f, m, v) {
              return !(f < 0 || f > 25 || v < 0 || v >= Math.pow(2, f) || m < 0 || m >= Math.pow(2, f));
            })(e, r, c)) throw new Error(`x=${r}, y=${c}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `);
            this.z = e, this.x = r, this.y = c, this.key = hh(0, e, e, r, c);
          }
          equals(e) {
            return this.z === e.z && this.x === e.x && this.y === e.y;
          }
          url(e, r, c) {
            const f = (function(v, E, k) {
              var P = M0(256 * v, 256 * (E = Math.pow(2, k) - E - 1), k), L = M0(256 * (v + 1), 256 * (E + 1), k);
              return P[0] + "," + P[1] + "," + L[0] + "," + L[1];
            })(this.x, this.y, this.z), m = (function(v, E, k) {
              let P, L = "";
              for (let N = v; N > 0; N--) P = 1 << N - 1, L += (E & P ? 1 : 0) + (k & P ? 2 : 0);
              return L;
            })(this.z, this.x, this.y);
            return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(c === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, m).replace(/{bbox-epsg-3857}/g, f);
          }
          isChildOf(e) {
            const r = this.z - e.z;
            return r > 0 && e.x === this.x >> r && e.y === this.y >> r;
          }
          getTilePoint(e) {
            const r = Math.pow(2, this.z);
            return new R((e.x * r - this.x) * We, (e.y * r - this.y) * We);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class C0 {
          constructor(e, r) {
            this.wrap = e, this.canonical = r, this.key = hh(e, r.z, r.z, r.x, r.y);
          }
        }
        class Us {
          constructor(e, r, c, f, m) {
            if (this.terrainRttPosMatrix32f = null, e < c) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${c}`);
            this.overscaledZ = e, this.wrap = r, this.canonical = new Gm(c, +f, +m), this.key = hh(r, e, c, f, m);
          }
          clone() {
            return new Us(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(e) {
            return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
          }
          scaledTo(e) {
            if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
            const r = this.canonical.z - e;
            return e > this.canonical.z ? new Us(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Us(e, this.wrap, e, this.canonical.x >> r, this.canonical.y >> r);
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z;
          }
          calculateScaledKey(e, r) {
            if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
            const c = this.canonical.z - e;
            return e > this.canonical.z ? hh(this.wrap * +r, e, this.canonical.z, this.canonical.x, this.canonical.y) : hh(this.wrap * +r, e, e, this.canonical.x >> c, this.canonical.y >> c);
          }
          isChildOf(e) {
            if (e.wrap !== this.wrap || this.overscaledZ - e.overscaledZ <= 0) return !1;
            if (e.overscaledZ === 0) return this.overscaledZ > 0;
            const r = this.canonical.z - e.canonical.z;
            return !(r < 0) && e.canonical.x === this.canonical.x >> r && e.canonical.y === this.canonical.y >> r;
          }
          children(e) {
            if (this.overscaledZ >= e) return [new Us(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1, c = 2 * this.canonical.x, f = 2 * this.canonical.y;
            return [new Us(r, this.wrap, r, c, f), new Us(r, this.wrap, r, c + 1, f), new Us(r, this.wrap, r, c, f + 1), new Us(r, this.wrap, r, c + 1, f + 1)];
          }
          isLessThan(e) {
            return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
          }
          wrapped() {
            return new Us(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(e) {
            return new Us(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new C0(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(e) {
            return this.canonical.getTilePoint(new Gd(e.x - this.wrap, e.y));
          }
        }
        function hh(i, e, r, c, f) {
          (i *= 2) < 0 && (i = -1 * i - 1);
          const m = 1 << r;
          return (m * m * i + m * f + c).toString(36) + r.toString(36) + e.toString(36);
        }
        function jm(i, e) {
          return e ? i.properties[e] : i.id;
        }
        function XT(i, e) {
          const r = { id: i.id };
          if (e.removeAllProperties && (delete i.removeProperties, delete i.addOrUpdateProperties, delete e.removeProperties), e.removeProperties) for (const c of e.removeProperties) {
            const f = i.addOrUpdateProperties.findIndex(((m) => m.key === c));
            f > -1 && i.addOrUpdateProperties.splice(f, 1);
          }
          return (i.removeAllProperties || e.removeAllProperties) && (r.removeAllProperties = !0), (i.removeProperties || e.removeProperties) && (r.removeProperties = [...i.removeProperties || [], ...e.removeProperties || []]), (i.addOrUpdateProperties || e.addOrUpdateProperties) && (r.addOrUpdateProperties = [...i.addOrUpdateProperties || [], ...e.addOrUpdateProperties || []]), (i.newGeometry || e.newGeometry) && (r.newGeometry = e.newGeometry || i.newGeometry), r;
        }
        function P0(i) {
          var e, r;
          if (!i) return {};
          const c = {};
          return c.removeAll = i.removeAll, c.remove = new Set(i.remove || []), c.add = new Map((e = i.add) === null || e === void 0 ? void 0 : e.map(((f) => [f.id, f]))), c.update = new Map((r = i.update) === null || r === void 0 ? void 0 : r.map(((f) => [f.id, f]))), c;
        }
        jt("CanonicalTileID", Gm), jt("OverscaledTileID", Us, { omit: ["terrainRttPosMatrix32f"] });
        class Ju {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(e) {
            return this.minX = Math.min(this.minX, e.x), this.minY = Math.min(this.minY, e.y), this.maxX = Math.max(this.maxX, e.x), this.maxY = Math.max(this.maxY, e.y), this;
          }
          expandBy(e) {
            return this.minX -= e, this.minY -= e, this.maxX += e, this.maxY += e, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(e) {
            return this.expandBy(-e);
          }
          map(e) {
            const r = new Ju();
            return r.extend(e(new R(this.minX, this.minY))), r.extend(e(new R(this.maxX, this.minY))), r.extend(e(new R(this.minX, this.maxY))), r.extend(e(new R(this.maxX, this.maxY))), r;
          }
          static fromPoints(e) {
            const r = new Ju();
            for (const c of e) r.extend(c);
            return r;
          }
          contains(e) {
            return e.x >= this.minX && e.x <= this.maxX && e.y >= this.minY && e.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(e) {
            return !this.empty() && !e.empty() && e.minX >= this.minX && e.maxX <= this.maxX && e.minY >= this.minY && e.maxY <= this.maxY;
          }
          intersects(e) {
            return !this.empty() && !e.empty() && e.minX <= this.maxX && e.maxX >= this.minX && e.minY <= this.maxY && e.maxY >= this.minY;
          }
        }
        class A0 {
          constructor(e) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < e.length; r++) {
              const c = e[r];
              this._stringToNumber[c] = r, this._numberToString[r] = c;
            }
          }
          encode(e) {
            return this._stringToNumber[e];
          }
          decode(e) {
            if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[e];
          }
        }
        class L0 {
          constructor(e, r, c, f, m) {
            this.type = "Feature", this._vectorTileFeature = e, this._x = c, this._y = f, this._z = r, this.properties = e.properties, this.id = m;
          }
          projectPoint(e, r, c, f) {
            return [360 * (e.x + r) / f - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (e.y + c) / f) * Math.PI)) - 90];
          }
          projectLine(e, r, c, f) {
            return e.map(((m) => this.projectPoint(m, r, c, f)));
          }
          get geometry() {
            if (this._geometry) return this._geometry;
            const e = this._vectorTileFeature, r = e.extent * Math.pow(2, this._z), c = e.extent * this._x, f = e.extent * this._y, m = e.loadGeometry();
            switch (e.type) {
              case 1: {
                const v = [];
                for (const k of m) v.push(k[0]);
                const E = this.projectLine(v, c, f, r);
                this._geometry = v.length === 1 ? { type: "Point", coordinates: E[0] } : { type: "MultiPoint", coordinates: E };
                break;
              }
              case 2: {
                const v = m.map(((E) => this.projectLine(E, c, f, r)));
                this._geometry = v.length === 1 ? { type: "LineString", coordinates: v[0] } : { type: "MultiLineString", coordinates: v };
                break;
              }
              case 3: {
                const v = Hv(m), E = [];
                for (const k of v) E.push(k.map(((P) => this.projectLine(P, c, f, r))));
                this._geometry = E.length === 1 ? { type: "Polygon", coordinates: E[0] } : { type: "MultiPolygon", coordinates: E };
                break;
              }
              default:
                throw new Error(`unknown feature type: ${e.type}`);
            }
            return this._geometry;
          }
          set geometry(e) {
            this._geometry = e;
          }
          toJSON() {
            const e = { geometry: this.geometry };
            for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && r !== "_x" && r !== "_y" && r !== "_z" && (e[r] = this[r]);
            return e;
          }
        }
        class dh {
          _name;
          dataBuffer;
          nullabilityBuffer;
          _size;
          constructor(e, r, c) {
            this._name = e, this.dataBuffer = r, typeof c == "number" ? this._size = c : (this.nullabilityBuffer = c, this._size = c.size());
          }
          getValue(e) {
            return this.nullabilityBuffer && !this.nullabilityBuffer.get(e) ? null : this.getValueFromBuffer(e);
          }
          has(e) {
            return this.nullabilityBuffer && this.nullabilityBuffer.get(e) || !this.nullabilityBuffer;
          }
          get name() {
            return this._name;
          }
          get size() {
            return this._size;
          }
        }
        class Dp extends dh {
        }
        class Vm extends Dp {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class Um extends Dp {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class D0 extends dh {
          delta;
          constructor(e, r, c, f) {
            super(e, r, f), this.delta = c;
          }
        }
        class qm extends D0 {
          constructor(e, r, c, f) {
            super(e, Int32Array.of(r), c, f);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0] + e * this.delta;
          }
        }
        class $m extends dh {
          constructor(e, r, c) {
            super(e, Int32Array.of(r), c);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0];
          }
        }
        class JT {
          _name;
          _geometryVector;
          _idVector;
          _propertyVectors;
          _extent;
          propertyVectorsMap;
          constructor(e, r, c, f, m = 4096) {
            this._name = e, this._geometryVector = r, this._idVector = c, this._propertyVectors = f, this._extent = m;
          }
          get name() {
            return this._name;
          }
          get idVector() {
            return this._idVector;
          }
          get geometryVector() {
            return this._geometryVector;
          }
          get propertyVectors() {
            return this._propertyVectors;
          }
          getPropertyVector(e) {
            return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map(((r) => [r.name, r])))), this.propertyVectorsMap.get(e);
          }
          *[Symbol.iterator]() {
            const e = this.geometryVector[Symbol.iterator]();
            let r = 0;
            for (; r < this.numFeatures; ) {
              let c;
              this.idVector && (c = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(r)) : this.idVector.getValue(r));
              const f = e?.next().value, m = {};
              for (const v of this.propertyVectors) {
                if (!v) continue;
                const E = v.name, k = v.getValue(r);
                k !== null && (m[E] = k);
              }
              r++, yield { id: c, geometry: f, properties: m };
            }
          }
          get numFeatures() {
            return this.geometryVector.numGeometries;
          }
          get extent() {
            return this._extent;
          }
          getFeatures() {
            const e = [], r = this.geometryVector.getGeometries();
            for (let c = 0; c < this.numFeatures; c++) {
              let f;
              this.idVector && (f = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(c)) : this.idVector.getValue(c));
              const m = { coordinates: r[c], type: this.geometryVector.geometryType(c) }, v = {};
              for (const E of this.propertyVectors) {
                if (!E) continue;
                const k = E.name, P = E.getValue(c);
                P !== null && (v[k] = P);
              }
              e.push({ id: f, geometry: m, properties: v });
            }
            return e;
          }
          containsMaxSaveIntegerValues(e) {
            return e instanceof Vm || e instanceof $m && e instanceof qm || e instanceof Um;
          }
        }
        class KT {
          value;
          constructor(e) {
            this.value = e;
          }
          get() {
            return this.value;
          }
          set(e) {
            this.value = e;
          }
          increment() {
            return this.value++;
          }
          add(e) {
            this.value += e;
          }
        }
        var xr, Qo, Mi, Ra, Ku, Ss, hi, di, R0, qs;
        function Ti(i, e, r) {
          const c = new Int32Array(r);
          let f = 0, m = e.get();
          for (let v = 0; v < c.length; v++) {
            let E = i[m++], k = 127 & E;
            E < 128 || (E = i[m++], k |= (127 & E) << 7, E < 128 || (E = i[m++], k |= (127 & E) << 14, E < 128 || (E = i[m++], k |= (127 & E) << 21, E < 128 || (E = i[m++], k |= (15 & E) << 28)))), c[f++] = k;
          }
          return e.set(m), c;
        }
        function Rp(i, e, r) {
          const c = new BigInt64Array(r);
          for (let f = 0; f < c.length; f++) c[f] = eS(i, e);
          return c;
        }
        function QT(i, e) {
          let r, c;
          return c = i[e.get()], e.increment(), r = 127 & c, c < 128 ? r : (c = i[e.get()], e.increment(), r |= (127 & c) << 7, c < 128 ? r : (c = i[e.get()], e.increment(), r |= (127 & c) << 14, c < 128 ? r : (c = i[e.get()], e.increment(), r |= (127 & c) << 21, c < 128 ? r : (c = i[e.get()], r |= (15 & c) << 28, (function(f, m, v) {
            let E, k;
            if (k = m[v.get()], v.increment(), E = (112 & k) >> 4, k < 128 || (k = m[v.get()], v.increment(), E |= (127 & k) << 3, k < 128) || (k = m[v.get()], v.increment(), E |= (127 & k) << 10, k < 128) || (k = m[v.get()], v.increment(), E |= (127 & k) << 17, k < 128) || (k = m[v.get()], v.increment(), E |= (127 & k) << 24, k < 128) || (k = m[v.get()], v.increment(), E |= (1 & k) << 31, k < 128)) return 4294967296 * E + (f >>> 0);
            throw new Error("Expected varint not more than 10 bytes");
          })(r, i, e)))));
        }
        function F0(i, e, r, c) {
          throw new Error("FastPFor is not implemented yet.");
        }
        function Qu(i) {
          return i >>> 1 ^ -(1 & i);
        }
        function fh(i) {
          return i >> 1n ^ -(1n & i);
        }
        function eS(i, e) {
          let r = 0n, c = 0, f = e.get();
          for (; f < i.length; ) {
            const m = i[f++];
            if (r |= BigInt(127 & m) << BigInt(c), !(128 & m)) break;
            if (c += 7, c >= 64) throw new Error("Varint too long");
          }
          return e.set(f), r;
        }
        function N0(i, e, r) {
          const c = new Int32Array(r);
          let f = 0;
          for (let m = 0; m < e; m++) {
            const v = i[m];
            c.fill(i[m + e], f, f + v), f += v;
          }
          return c;
        }
        function O0(i, e, r) {
          const c = new BigInt64Array(r);
          let f = 0;
          for (let m = 0; m < e; m++) {
            const v = Number(i[m]);
            c.fill(i[m + e], f, f + v), f += v;
          }
          return c;
        }
        function z0(i, e, r) {
          const c = new Float64Array(r);
          let f = 0;
          for (let m = 0; m < e; m++) {
            const v = i[m];
            c.fill(i[m + e], f, f + v), f += v;
          }
          return c;
        }
        function Zm(i) {
          const e = i.length / 4 * 4;
          let r = 1;
          if (e >= 4) for (let c = i[0]; r < e - 4; r += 4) c = i[r] += c, c = i[r + 1] += c, c = i[r + 2] += c, c = i[r + 3] += c;
          for (; r != i.length; ) i[r] += i[r - 1], ++r;
        }
        function B0(i) {
          i[0] = i[0] >>> 1 ^ -(1 & i[0]), i[1] = i[1] >>> 1 ^ -(1 & i[1]);
          const e = i.length / 4 * 4;
          let r = 2;
          if (e >= 4) for (; r < e - 4; r += 4) {
            const c = i[r], f = i[r + 1], m = i[r + 2], v = i[r + 3];
            i[r] = (c >>> 1 ^ -(1 & c)) + i[r - 2], i[r + 1] = (f >>> 1 ^ -(1 & f)) + i[r - 1], i[r + 2] = (m >>> 1 ^ -(1 & m)) + i[r], i[r + 3] = (v >>> 1 ^ -(1 & v)) + i[r + 1];
          }
          for (; r != i.length; r += 2) i[r] = (i[r] >>> 1 ^ -(1 & i[r])) + i[r - 2], i[r + 1] = (i[r + 1] >>> 1 ^ -(1 & i[r + 1])) + i[r - 1];
        }
        (function(i) {
          i.NONE = "NONE", i.DELTA = "DELTA", i.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", i.RLE = "RLE", i.MORTON = "MORTON", i.PDE = "PDE";
        })(xr || (xr = {})), (function(i) {
          i.NONE = "NONE", i.FAST_PFOR = "FAST_PFOR", i.VARINT = "VARINT", i.ALP = "ALP";
        })(Qo || (Qo = {})), (function(i) {
          i.PRESENT = "PRESENT", i.DATA = "DATA", i.OFFSET = "OFFSET", i.LENGTH = "LENGTH";
        })(Mi || (Mi = {}));
        class Hm {
          _dictionaryType;
          _offsetType;
          _lengthType;
          constructor(e, r, c) {
            this._dictionaryType = e, this._offsetType = r, this._lengthType = c;
          }
          get dictionaryType() {
            return this._dictionaryType;
          }
          get offsetType() {
            return this._offsetType;
          }
          get lengthType() {
            return this._lengthType;
          }
        }
        function Ki(i, e) {
          const r = (function(c, f) {
            const m = c[f.get()], v = Object.values(Mi)[m >> 4];
            let E = null;
            switch (v) {
              case Mi.DATA:
                E = new Hm(Object.values(Ra)[15 & m]);
                break;
              case Mi.OFFSET:
                E = new Hm(null, Object.values(Ku)[15 & m]);
                break;
              case Mi.LENGTH:
                E = new Hm(null, null, Object.values(Ss)[15 & m]);
            }
            f.increment();
            const k = c[f.get()], P = Object.values(xr)[k >> 5], L = Object.values(xr)[k >> 2 & 7], N = Object.values(Qo)[3 & k];
            f.increment();
            const G = Ti(c, f, 2), j = G[0];
            return { physicalStreamType: v, logicalStreamType: E, logicalLevelTechnique1: P, logicalLevelTechnique2: L, physicalLevelTechnique: N, numValues: j, byteLength: G[1], decompressedCount: j };
          })(i, e);
          return r.logicalLevelTechnique1 === xr.MORTON ? (function(c, f, m) {
            const v = Ti(f, m, 2);
            return { physicalStreamType: c.physicalStreamType, logicalStreamType: c.logicalStreamType, logicalLevelTechnique1: c.logicalLevelTechnique1, logicalLevelTechnique2: c.logicalLevelTechnique2, physicalLevelTechnique: c.physicalLevelTechnique, numValues: c.numValues, byteLength: c.byteLength, decompressedCount: c.decompressedCount, numBits: v[0], coordinateShift: v[1] };
          })(r, i, e) : xr.RLE !== r.logicalLevelTechnique1 && xr.RLE !== r.logicalLevelTechnique2 || Qo.NONE === r.physicalLevelTechnique ? r : (function(c, f, m) {
            const v = Ti(f, m, 2);
            return { physicalStreamType: c.physicalStreamType, logicalStreamType: c.logicalStreamType, logicalLevelTechnique1: c.logicalLevelTechnique1, logicalLevelTechnique2: c.logicalLevelTechnique2, physicalLevelTechnique: c.physicalLevelTechnique, numValues: c.numValues, byteLength: c.byteLength, decompressedCount: v[1], runs: v[0], numRleValues: v[1] };
          })(r, i, e);
        }
        (function(i) {
          i.NONE = "NONE", i.SINGLE = "SINGLE", i.SHARED = "SHARED", i.VERTEX = "VERTEX", i.MORTON = "MORTON", i.FSST = "FSST";
        })(Ra || (Ra = {})), (function(i) {
          i.VERTEX = "VERTEX", i.INDEX = "INDEX", i.STRING = "STRING", i.KEY = "KEY";
        })(Ku || (Ku = {})), (function(i) {
          i.VAR_BINARY = "VAR_BINARY", i.GEOMETRIES = "GEOMETRIES", i.PARTS = "PARTS", i.RINGS = "RINGS", i.TRIANGLES = "TRIANGLES", i.SYMBOL = "SYMBOL", i.DICTIONARY = "DICTIONARY";
        })(Ss || (Ss = {})), (function(i) {
          i[i.FLAT = 0] = "FLAT", i[i.CONST = 1] = "CONST", i[i.SEQUENCE = 2] = "SEQUENCE", i[i.DICTIONARY = 3] = "DICTIONARY", i[i.FSST_DICTIONARY = 4] = "FSST_DICTIONARY";
        })(hi || (hi = {}));
        class Fa {
          values;
          _size;
          constructor(e, r) {
            this.values = e, this._size = r;
          }
          get(e) {
            const r = Math.floor(e / 8);
            return (this.values[r] >> e % 8 & 1) == 1;
          }
          set(e, r) {
            const c = Math.floor(e / 8);
            this.values[c] = this.values[c] | (r ? 1 : 0) << e % 8;
          }
          getInt(e) {
            const r = Math.floor(e / 8);
            return this.values[r] >> e % 8 & 1;
          }
          size() {
            return this._size;
          }
          getBuffer() {
            return this.values;
          }
        }
        function Qi(i, e, r, c, f) {
          return (function(m, v, E) {
            switch (v.logicalLevelTechnique1) {
              case xr.DELTA:
                return v.logicalLevelTechnique2 === xr.RLE ? (function(k, P, L) {
                  const N = new Int32Array(L);
                  let G = 0, j = 0;
                  for (let Z = 0; Z < P; Z++) {
                    const Y = k[Z], X = Qu(k[Z + P]);
                    for (let ne = 0; ne < Y; ne++) j += X, N[G++] = j;
                  }
                  return N;
                })(m, v.runs, v.numRleValues) : ((function(k) {
                  k[0] = k[0] >>> 1 ^ -(1 & k[0]);
                  const P = k.length / 4 * 4;
                  let L = 1;
                  if (P >= 4) for (; L < P - 4; L += 4) {
                    const N = k[L], G = k[L + 1], j = k[L + 2], Z = k[L + 3];
                    k[L] = (N >>> 1 ^ -(1 & N)) + k[L - 1], k[L + 1] = (G >>> 1 ^ -(1 & G)) + k[L], k[L + 2] = (j >>> 1 ^ -(1 & j)) + k[L + 1], k[L + 3] = (Z >>> 1 ^ -(1 & Z)) + k[L + 2];
                  }
                  for (; L != k.length; ++L) k[L] = (k[L] >>> 1 ^ -(1 & k[L])) + k[L - 1];
                })(m), m);
              case xr.RLE:
                return (function(k, P, L) {
                  return L ? (function(N, G, j) {
                    const Z = new Int32Array(j);
                    let Y = 0;
                    for (let X = 0; X < G; X++) {
                      const ne = N[X];
                      let xe = N[X + G];
                      xe = xe >>> 1 ^ -(1 & xe), Z.fill(xe, Y, Y + ne), Y += ne;
                    }
                    return Z;
                  })(k, P.runs, P.numRleValues) : N0(k, P.runs, P.numRleValues);
                })(m, v, E);
              case xr.MORTON:
                return Zm(m), m;
              case xr.COMPONENTWISE_DELTA:
                return B0(m), m;
              case xr.NONE:
                return E && (function(k) {
                  for (let P = 0; P < k.length; P++) {
                    const L = k[P];
                    k[P] = L >>> 1 ^ -(1 & L);
                  }
                })(m), m;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${v.logicalLevelTechnique1}`);
            }
          })(Fp(i, e, r), r, c);
        }
        function Gl(i, e, r) {
          return (function(c, f) {
            if (f.logicalLevelTechnique1 === xr.DELTA && f.logicalLevelTechnique2 === xr.NONE)
              return (function(v) {
                const E = new Int32Array(v.length + 1);
                E[0] = 0, E[1] = Qu(v[0]);
                let k = E[1], P = 2;
                for (; P != E.length; ++P) {
                  const L = v[P - 1];
                  k += L >>> 1 ^ -(1 & L), E[P] = E[P - 1] + k;
                }
                return E;
              })(c);
            if (f.logicalLevelTechnique1 === xr.RLE && f.logicalLevelTechnique2 === xr.NONE)
              return (function(v, E, k) {
                const P = new Int32Array(k + 1);
                P[0] = 0;
                let L = 1, N = P[0];
                for (let G = 0; G < E; G++) {
                  const j = v[G], Z = v[G + E];
                  for (let Y = L; Y < L + j; Y++) P[Y] = Z + N, N = P[Y];
                  L += j;
                }
                return P;
              })(c, f.runs, f.numRleValues);
            if (f.logicalLevelTechnique1 === xr.NONE && f.logicalLevelTechnique2 === xr.NONE) {
              (function(v) {
                let E = 0;
                for (let k = 0; k < v.length; k++) v[k] += E, E = v[k];
              })(c);
              const m = new Int32Array(f.numValues + 1);
              return m[0] = 0, m.set(c, 1), m;
            }
            if (f.logicalLevelTechnique1 === xr.DELTA && f.logicalLevelTechnique2 === xr.RLE) {
              const m = (function(v, E, k) {
                const P = new Int32Array(k + 1);
                P[0] = 0;
                let L = 1, N = P[0];
                for (let G = 0; G < E; G++) {
                  const j = v[G];
                  let Z = v[G + E];
                  Z = Z >>> 1 ^ -(1 & Z);
                  for (let Y = L; Y < L + j; Y++) P[Y] = Z + N, N = P[Y];
                  L += j;
                }
                return P;
              })(c, f.runs, f.numRleValues);
              return Zm(m), m;
            }
            throw new Error("Only delta encoding is supported for transforming length to offset streams yet.");
          })(Fp(i, e, r), r);
        }
        function Fp(i, e, r) {
          const c = r.physicalLevelTechnique;
          if (c === Qo.FAST_PFOR) return F0();
          if (c === Qo.VARINT) return Ti(i, e, r.numValues);
          if (c === Qo.NONE) {
            const f = e.get();
            e.add(r.byteLength);
            const m = i.subarray(f, e.get());
            return new Int32Array(m);
          }
          throw new Error("Specified physicalLevelTechnique is not supported (yet).");
        }
        function Ym(i, e, r, c) {
          const f = Fp(i, e, r);
          if (f.length === 1) {
            const m = f[0];
            return c ? Qu(m) : m;
          }
          return c ? (function(m) {
            return Qu(m[1]);
          })(f) : (function(m) {
            return m[1];
          })(f);
        }
        function G0(i, e, r) {
          return (function(c) {
            if (c.length == 2) {
              const f = Qu(c[1]);
              return [f, f];
            }
            return [Qu(c[2]), Qu(c[3])];
          })(Fp(i, e, r));
        }
        function j0(i, e, r) {
          return (function(c) {
            if (c.length == 2) {
              const f = fh(c[1]);
              return [f, f];
            }
            return [fh(c[2]), fh(c[3])];
          })(Rp(i, e, r.numValues));
        }
        function V0(i, e, r, c) {
          return (function(f, m, v) {
            switch (m.logicalLevelTechnique1) {
              case xr.DELTA:
                return m.logicalLevelTechnique2 === xr.RLE ? (function(E, k, P) {
                  const L = new BigInt64Array(P);
                  let N = 0, G = 0n;
                  for (let j = 0; j < k; j++) {
                    const Z = Number(E[j]), Y = fh(E[j + k]);
                    for (let X = 0; X < Z; X++) G += Y, L[N++] = G;
                  }
                  return L;
                })(f, m.runs, m.numRleValues) : ((function(E) {
                  E[0] = E[0] >> 1n ^ -(1n & E[0]);
                  const k = E.length / 4 * 4;
                  let P = 1;
                  if (k >= 4) for (; P < k - 4; P += 4) {
                    const L = E[P], N = E[P + 1], G = E[P + 2], j = E[P + 3];
                    E[P] = (L >> 1n ^ -(1n & L)) + E[P - 1], E[P + 1] = (N >> 1n ^ -(1n & N)) + E[P], E[P + 2] = (G >> 1n ^ -(1n & G)) + E[P + 1], E[P + 3] = (j >> 1n ^ -(1n & j)) + E[P + 2];
                  }
                  for (; P != E.length; ++P) E[P] = (E[P] >> 1n ^ -(1n & E[P])) + E[P - 1];
                })(f), f);
              case xr.RLE:
                return (function(E, k, P) {
                  return P ? (function(L, N, G) {
                    const j = new BigInt64Array(G);
                    let Z = 0;
                    for (let Y = 0; Y < N; Y++) {
                      const X = Number(L[Y]);
                      let ne = L[Y + N];
                      ne = ne >> 1n ^ -(1n & ne), j.fill(ne, Z, Z + X), Z += X;
                    }
                    return j;
                  })(E, k.runs, k.numRleValues) : O0(E, k.runs, k.numRleValues);
                })(f, m, v);
              case xr.NONE:
                return v && (function(E) {
                  for (let k = 0; k < E.length; k++) {
                    const P = E[k];
                    E[k] = P >> 1n ^ -(1n & P);
                  }
                })(f), f;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${m.logicalLevelTechnique1}`);
            }
          })(Rp(i, e, r.numValues), r, c);
        }
        function U0(i, e, r, c) {
          const f = Rp(i, e, r.numValues);
          if (f.length === 1) {
            const m = f[0];
            return c ? fh(m) : m;
          }
          return c ? (function(m) {
            return fh(m[1]);
          })(f) : (function(m) {
            return m[1];
          })(f);
        }
        function Wm(i, e, r, c, f) {
          return (function(m, v, E, k) {
            switch (v.logicalLevelTechnique1) {
              case xr.DELTA:
                return v.logicalLevelTechnique2 === xr.RLE && (m = N0(m, v.runs, v.numRleValues)), (function(P, L) {
                  const N = new Int32Array(P.size());
                  let G = 0;
                  P.get(0) ? (N[0] = P.get(0) ? L[0] >>> 1 ^ -(1 & L[0]) : 0, G = 1) : N[0] = 0;
                  let j = 1;
                  for (; j != N.length; ++j) N[j] = P.get(j) ? N[j - 1] + (L[G] >>> 1 ^ -(1 & L[G++])) : N[j - 1];
                  return N;
                })(k, m);
              case xr.RLE:
                return (function(P, L, N, G) {
                  const j = L;
                  return N ? (function(Z, Y, X) {
                    const ne = new Int32Array(Z.size());
                    let xe = 0;
                    for (let ae = 0; ae < X; ae++) {
                      const ue = Y[ae];
                      let Te = Y[ae + X];
                      Te = Te >>> 1 ^ -(1 & Te);
                      for (let Ae = xe; Ae < xe + ue; Ae++) Z.get(Ae) ? ne[Ae] = Te : (ne[Ae] = 0, xe++);
                      xe += ue;
                    }
                    return ne;
                  })(G, P, j.runs) : (function(Z, Y, X) {
                    const ne = new Int32Array(Z.size());
                    let xe = 0;
                    for (let ae = 0; ae < X; ae++) {
                      const ue = Y[ae], Te = Y[ae + X];
                      for (let Ae = xe; Ae < xe + ue; Ae++) Z.get(Ae) ? ne[Ae] = Te : (ne[Ae] = 0, xe++);
                      xe += ue;
                    }
                    return ne;
                  })(G, P, j.runs);
                })(m, v, E, k);
              case xr.MORTON:
                return Zm(m), m;
              case xr.COMPONENTWISE_DELTA:
                return B0(m), m;
              case xr.NONE:
                return m = E ? (function(P, L) {
                  const N = new Int32Array(P.size());
                  let G = 0, j = 0;
                  for (; j != N.length; ++j) if (P.get(j)) {
                    const Z = L[G++];
                    N[j] = Z >>> 1 ^ -(1 & Z);
                  } else N[j] = 0;
                  return N;
                })(k, m) : (function(P, L) {
                  const N = new Int32Array(P.size());
                  let G = 0, j = 0;
                  for (; j != N.length; ++j) N[j] = P.get(j) ? L[G++] : 0;
                  return N;
                })(k, m), m;
              default:
                throw new Error("The specified Logical level technique is not supported");
            }
          })(r.physicalLevelTechnique === Qo.FAST_PFOR ? F0() : Ti(i, e, r.numValues), r, c, f);
        }
        function Np(i, e, r, c) {
          const f = i.logicalLevelTechnique1;
          if (f === xr.RLE) return i.runs === 1 ? hi.CONST : hi.FLAT;
          const m = e instanceof Fa ? e.size() : e;
          if (f === xr.DELTA && i.logicalLevelTechnique2 === xr.RLE) {
            const v = i.runs, E = 2;
            if (i.numRleValues !== m) return hi.FLAT;
            if (v === 1) return hi.SEQUENCE;
            if (v === 2) {
              const k = c.get();
              let P;
              if (i.physicalLevelTechnique === Qo.VARINT) P = Ti(r, c, 4);
              else {
                const L = c.get();
                P = new Int32Array(r.buffer, r.byteOffset + L, 4);
              }
              if (c.set(k), P[2] === E && P[3] === E) return hi.SEQUENCE;
            }
          }
          return i.numValues === 1 ? hi.CONST : hi.FLAT;
        }
        class q0 extends Dp {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class $0 extends D0 {
          constructor(e, r, c, f) {
            super(e, BigInt64Array.of(r), c, f);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0] + BigInt(e) * this.delta;
          }
        }
        class ph {
          _geometryOffsets;
          _partOffsets;
          _ringOffsets;
          constructor(e, r, c) {
            this._geometryOffsets = e, this._partOffsets = r, this._ringOffsets = c;
          }
          get geometryOffsets() {
            return this._geometryOffsets;
          }
          get partOffsets() {
            return this._partOffsets;
          }
          get ringOffsets() {
            return this._ringOffsets;
          }
        }
        function Xm(i, e, r) {
          return { x: Z0(i, e) - r, y: Z0(i >> 1, e) - r };
        }
        function Z0(i, e) {
          let r = 0;
          for (let c = 0; c < e; c++) r |= (i & 1 << 2 * c) >> c;
          return r;
        }
        (function(i) {
          i[i.POINT = 0] = "POINT", i[i.LINESTRING = 1] = "LINESTRING", i[i.POLYGON = 2] = "POLYGON", i[i.MULTIPOINT = 3] = "MULTIPOINT", i[i.MULTILINESTRING = 4] = "MULTILINESTRING", i[i.MULTIPOLYGON = 5] = "MULTIPOLYGON";
        })(di || (di = {})), (function(i) {
          i[i.POINT = 0] = "POINT", i[i.LINESTRING = 1] = "LINESTRING", i[i.POLYGON = 2] = "POLYGON";
        })(R0 || (R0 = {})), (function(i) {
          i[i.MORTON = 0] = "MORTON", i[i.VEC_2 = 1] = "VEC_2", i[i.VEC_3 = 2] = "VEC_3";
        })(qs || (qs = {}));
        class tS {
          createPoint(e) {
            return [[e]];
          }
          createMultiPoint(e) {
            return e.map(((r) => [r]));
          }
          createLineString(e) {
            return [e];
          }
          createMultiLineString(e) {
            return e;
          }
          createPolygon(e, r) {
            return [e].concat(r);
          }
          createMultiPolygon(e) {
            return e.flat();
          }
        }
        function H0(i) {
          const e = new Array(i.numGeometries);
          let r = 1, c = 1, f = 1, m = 0;
          const v = new tS();
          let E = 0, k = 0;
          const P = i.mortonSettings, L = i.topologyVector, N = L.geometryOffsets, G = L.partOffsets, j = L.ringOffsets, Z = i.vertexOffsets, Y = i.containsPolygonGeometry(), X = i.vertexBuffer;
          for (let ne = 0; ne < i.numGeometries; ne++) {
            const xe = i.geometryType(ne);
            if (xe === di.POINT) {
              if (Z && Z.length !== 0) if (i.vertexBufferType === qs.VEC_2) {
                const ae = 2 * Z[k++], ue = new R(X[ae], X[ae + 1]);
                e[m++] = v.createPoint(ue);
              } else {
                const ae = Xm(X[Z[k++]], P.numBits, P.coordinateShift), ue = new R(ae.x, ae.y);
                e[m++] = v.createPoint(ue);
              }
              else {
                const ae = new R(X[E++], X[E++]);
                e[m++] = v.createPoint(ae);
              }
              N && f++, G && r++, j && c++;
            } else if (xe === di.MULTIPOINT) {
              const ae = N[f] - N[f - 1];
              f++;
              const ue = new Array(ae);
              if (Z && Z.length !== 0) {
                for (let Te = 0; Te < ae; Te++) {
                  const Ae = 2 * Z[k++];
                  ue[Te] = new R(X[Ae], X[Ae + 1]);
                }
                e[m++] = v.createMultiPoint(ue);
              } else {
                for (let Te = 0; Te < ae; Te++) {
                  const Ae = X[E++], Ke = X[E++];
                  ue[Te] = new R(Ae, Ke);
                }
                e[m++] = v.createMultiPoint(ue);
              }
            } else if (xe === di.LINESTRING) {
              let ae, ue = 0;
              Y ? (ue = j[c] - j[c - 1], c++) : ue = G[r] - G[r - 1], r++, Z && Z.length !== 0 ? (ae = i.vertexBufferType === qs.VEC_2 ? Km(X, Z, k, ue, !1) : Qm(X, Z, k, ue, !1, P), k += ue) : (ae = Jm(X, E, ue, !1), E += 2 * ue), e[m++] = v.createLineString(ae), N && f++;
            } else if (xe === di.POLYGON) {
              const ae = G[r] - G[r - 1];
              r++;
              const ue = new Array(ae - 1);
              let Te = j[c] - j[c - 1];
              if (c++, Z && Z.length !== 0) {
                const Ae = i.vertexBufferType === qs.VEC_2 ? zp(X, Z, k, Te) : Bp(X, Z, k, Te, 0, P);
                k += Te;
                for (let Ke = 0; Ke < ue.length; Ke++) Te = j[c] - j[c - 1], c++, ue[Ke] = i.vertexBufferType === qs.VEC_2 ? zp(X, Z, k, Te) : Bp(X, Z, k, Te, 0, P), k += Te;
                e[m++] = v.createPolygon(Ae, ue);
              } else {
                const Ae = Op(X, E, Te);
                E += 2 * Te;
                for (let Ke = 0; Ke < ue.length; Ke++) Te = j[c] - j[c - 1], c++, ue[Ke] = Op(X, E, Te), E += 2 * Te;
                e[m++] = v.createPolygon(Ae, ue);
              }
              N && f++;
            } else if (xe === di.MULTILINESTRING) {
              const ae = N[f] - N[f - 1];
              f++;
              const ue = new Array(ae);
              if (Z && Z.length !== 0) {
                for (let Te = 0; Te < ae; Te++) {
                  let Ae = 0;
                  Y ? (Ae = j[c] - j[c - 1], c++) : Ae = G[r] - G[r - 1], r++;
                  const Ke = i.vertexBufferType === qs.VEC_2 ? Km(X, Z, k, Ae, !1) : Qm(X, Z, k, Ae, !1, P);
                  ue[Te] = Ke, k += Ae;
                }
                e[m++] = v.createMultiLineString(ue);
              } else {
                for (let Te = 0; Te < ae; Te++) {
                  let Ae = 0;
                  Y ? (Ae = j[c] - j[c - 1], c++) : Ae = G[r] - G[r - 1], r++, ue[Te] = Jm(X, E, Ae, !1), E += 2 * Ae;
                }
                e[m++] = v.createMultiLineString(ue);
              }
            } else {
              if (xe !== di.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported.");
              {
                const ae = N[f] - N[f - 1];
                f++;
                const ue = new Array(ae);
                let Te = 0;
                if (Z && Z.length !== 0) {
                  for (let Ae = 0; Ae < ae; Ae++) {
                    const Ke = G[r] - G[r - 1];
                    r++;
                    const ht = new Array(Ke - 1);
                    Te = j[c] - j[c - 1], c++;
                    const lt = i.vertexBufferType === qs.VEC_2 ? zp(X, Z, k, Te) : Bp(X, Z, k, Te, 0, P);
                    k += Te;
                    for (let pt = 0; pt < ht.length; pt++) Te = j[c] - j[c - 1], c++, ht[pt] = i.vertexBufferType === qs.VEC_2 ? zp(X, Z, k, Te) : Bp(X, Z, k, Te, 0, P), k += Te;
                    ue[Ae] = v.createPolygon(lt, ht);
                  }
                  e[m++] = v.createMultiPolygon(ue);
                } else {
                  for (let Ae = 0; Ae < ae; Ae++) {
                    const Ke = G[r] - G[r - 1];
                    r++;
                    const ht = new Array(Ke - 1);
                    Te = j[c] - j[c - 1], c++;
                    const lt = Op(X, E, Te);
                    E += 2 * Te;
                    for (let pt = 0; pt < ht.length; pt++) {
                      const Ct = j[c] - j[c - 1];
                      c++, ht[pt] = Op(X, E, Ct), E += 2 * Ct;
                    }
                    ue[Ae] = v.createPolygon(lt, ht);
                  }
                  e[m++] = v.createMultiPolygon(ue);
                }
              }
            }
          }
          return e;
        }
        function Op(i, e, r) {
          return Jm(i, e, r, !0);
        }
        function zp(i, e, r, c) {
          return Km(i, e, r, c, !0);
        }
        function Bp(i, e, r, c, f, m) {
          return Qm(i, e, r, c, !0, m);
        }
        function Jm(i, e, r, c) {
          const f = new Array(c ? r + 1 : r);
          for (let m = 0; m < 2 * r; m += 2) f[m / 2] = new R(i[e + m], i[e + m + 1]);
          return c && (f[f.length - 1] = f[0]), f;
        }
        function Km(i, e, r, c, f) {
          const m = new Array(f ? c + 1 : c);
          for (let v = 0; v < 2 * c; v += 2) {
            const E = 2 * e[r + v / 2];
            m[v / 2] = new R(i[E], i[E + 1]);
          }
          return f && (m[m.length - 1] = m[0]), m;
        }
        function Qm(i, e, r, c, f, m) {
          const v = new Array(f ? c + 1 : c);
          for (let E = 0; E < c; E++) {
            const k = Xm(i[e[r + E]], m.numBits, m.coordinateShift);
            v[E] = new R(k.x, k.y);
          }
          return f && (v[v.length - 1] = v[0]), v;
        }
        class Y0 {
          _vertexBufferType;
          _topologyVector;
          _vertexOffsets;
          _vertexBuffer;
          _mortonSettings;
          constructor(e, r, c, f, m) {
            this._vertexBufferType = e, this._topologyVector = r, this._vertexOffsets = c, this._vertexBuffer = f, this._mortonSettings = m;
          }
          get vertexBufferType() {
            return this._vertexBufferType;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          get vertexOffsets() {
            return this._vertexOffsets;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          *[Symbol.iterator]() {
            const e = H0(this);
            let r = 0;
            for (; r < this.numGeometries; ) yield { coordinates: e[r], type: this.geometryType(r) }, r++;
          }
          getSimpleEncodedVertex(e) {
            const r = this.vertexOffsets ? 2 * this.vertexOffsets[e] : 2 * e;
            return [this.vertexBuffer[r], this.vertexBuffer[r + 1]];
          }
          getVertex(e) {
            if (this.vertexOffsets && this.mortonSettings) {
              const c = Xm(this.vertexBuffer[this.vertexOffsets[e]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift);
              return [c.x, c.y];
            }
            const r = this.vertexOffsets ? 2 * this.vertexOffsets[e] : 2 * e;
            return [this.vertexBuffer[r], this.vertexBuffer[r + 1]];
          }
          getGeometries() {
            return H0(this);
          }
          get mortonSettings() {
            return this._mortonSettings;
          }
        }
        class W0 extends Y0 {
          _numGeometries;
          _geometryType;
          constructor(e, r, c, f, m, v, E) {
            super(c, f, m, v, E), this._numGeometries = e, this._geometryType = r;
          }
          geometryType(e) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsPolygonGeometry() {
            return this._geometryType === di.POLYGON || this._geometryType === di.MULTIPOLYGON;
          }
          containsSingleGeometryType() {
            return !0;
          }
        }
        class X0 extends Y0 {
          _geometryTypes;
          constructor(e, r, c, f, m, v) {
            super(e, c, f, m, v), this._geometryTypes = r;
          }
          geometryType(e) {
            return this._geometryTypes[e];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsPolygonGeometry() {
            for (let e = 0; e < this.numGeometries; e++) if (this.geometryType(e) === di.POLYGON || this.geometryType(e) === di.MULTIPOLYGON) return !0;
            return !1;
          }
          containsSingleGeometryType() {
            return !1;
          }
        }
        class J0 {
          _triangleOffsets;
          _indexBuffer;
          _vertexBuffer;
          _topologyVector;
          constructor(e, r, c, f) {
            this._triangleOffsets = e, this._indexBuffer = r, this._vertexBuffer = c, this._topologyVector = f;
          }
          get triangleOffsets() {
            return this._triangleOffsets;
          }
          get indexBuffer() {
            return this._indexBuffer;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          getGeometries() {
            if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information");
            const e = new Array(this.numGeometries), r = this._topologyVector, c = r.partOffsets, f = r.ringOffsets, m = r.geometryOffsets;
            let v = 0, E = 1, k = 1, P = 1;
            for (let L = 0; L < this.numGeometries; L++) switch (this.geometryType(L)) {
              case di.POLYGON:
                {
                  const N = c[E] - c[E - 1];
                  E++;
                  const G = [];
                  for (let j = 0; j < N; j++) {
                    const Z = f[k] - f[k - 1];
                    k++;
                    const Y = [];
                    for (let X = 0; X < Z; X++) {
                      const ne = this._vertexBuffer[v++], xe = this._vertexBuffer[v++];
                      Y.push(new R(ne, xe));
                    }
                    Y.length > 0 && Y.push(Y[0]), G.push(Y);
                  }
                  e[L] = G, m && P++;
                }
                break;
              case di.MULTIPOLYGON: {
                const N = m[P] - m[P - 1];
                P++;
                const G = [];
                for (let j = 0; j < N; j++) {
                  const Z = c[E] - c[E - 1];
                  E++;
                  for (let Y = 0; Y < Z; Y++) {
                    const X = f[k] - f[k - 1];
                    k++;
                    const ne = [];
                    for (let xe = 0; xe < X; xe++) {
                      const ae = this._vertexBuffer[v++], ue = this._vertexBuffer[v++];
                      ne.push(new R(ae, ue));
                    }
                    ne.length > 0 && ne.push(ne[0]), G.push(ne);
                  }
                }
                e[L] = G;
              }
            }
            return e;
          }
          [Symbol.iterator]() {
            return null;
          }
        }
        function K0(i, e, r, c, f, m) {
          return new rS(i, e, r, c, f, m);
        }
        class rS extends J0 {
          _numGeometries;
          _geometryType;
          constructor(e, r, c, f, m, v) {
            super(c, f, m, v), this._numGeometries = e, this._geometryType = r;
          }
          geometryType(e) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsSingleGeometryType() {
            return !0;
          }
        }
        function Q0(i, e, r, c, f) {
          return new nS(i, e, r, c, f);
        }
        class nS extends J0 {
          _geometryTypes;
          constructor(e, r, c, f, m) {
            super(r, c, f, m), this._geometryTypes = e;
          }
          geometryType(e) {
            return this._geometryTypes[e];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsSingleGeometryType() {
            return !1;
          }
        }
        function iS(i, e, r, c, f) {
          const m = Ki(i, r);
          let v = null, E = null, k = null, P = null, L = null, N = null, G = null, j = null;
          if (Np(m, c, i, r) === hi.CONST) {
            const Y = Ym(i, r, m, !1);
            for (let X = 0; X < e - 1; X++) {
              const ne = Ki(i, r);
              switch (ne.physicalStreamType) {
                case Mi.LENGTH:
                  switch (ne.logicalStreamType.lengthType) {
                    case Ss.GEOMETRIES:
                      v = Gl(i, r, ne);
                      break;
                    case Ss.PARTS:
                      E = Gl(i, r, ne);
                      break;
                    case Ss.RINGS:
                      k = Gl(i, r, ne);
                      break;
                    case Ss.TRIANGLES:
                      G = Gl(i, r, ne);
                  }
                  break;
                case Mi.OFFSET:
                  switch (ne.logicalStreamType.offsetType) {
                    case Ku.VERTEX:
                      P = Qi(i, r, ne, !1);
                      break;
                    case Ku.INDEX:
                      j = Qi(i, r, ne, !1);
                  }
                  break;
                case Mi.DATA:
                  Ra.VERTEX === ne.logicalStreamType.dictionaryType ? L = Qi(i, r, ne, !0) : (N = { numBits: ne.numBits, coordinateShift: ne.coordinateShift }, L = Qi(i, r, ne, !1));
              }
            }
            return j !== null ? v != null || E != null ? K0(c, Y, G, j, L, new ph(v, E, k)) : K0(c, Y, G, j, L) : N === null ? (function(X, ne, xe, ae, ue) {
              return new W0(X, ne, qs.VEC_2, xe, ae, ue);
            })(c, Y, new ph(v, E, k), P, L) : (function(X, ne, xe, ae, ue, Te) {
              return new W0(X, ne, qs.MORTON, xe, ae, ue, Te);
            })(c, Y, new ph(v, E, k), P, L, N);
          }
          const Z = Qi(i, r, m, !1);
          for (let Y = 0; Y < e - 1; Y++) {
            const X = Ki(i, r);
            switch (X.physicalStreamType) {
              case Mi.LENGTH:
                switch (X.logicalStreamType.lengthType) {
                  case Ss.GEOMETRIES:
                    v = Qi(i, r, X, !1);
                    break;
                  case Ss.PARTS:
                    E = Qi(i, r, X, !1);
                    break;
                  case Ss.RINGS:
                    k = Qi(i, r, X, !1);
                    break;
                  case Ss.TRIANGLES:
                    G = Gl(i, r, X);
                }
                break;
              case Mi.OFFSET:
                switch (X.logicalStreamType.offsetType) {
                  case Ku.VERTEX:
                    P = Qi(i, r, X, !1);
                    break;
                  case Ku.INDEX:
                    j = Qi(i, r, X, !1);
                }
                break;
              case Mi.DATA:
                Ra.VERTEX === X.logicalStreamType.dictionaryType ? L = Qi(i, r, X, !0) : (N = { numBits: X.numBits, coordinateShift: X.coordinateShift }, L = Qi(i, r, X, !1));
            }
          }
          return j !== null && E === null ? Q0(Z, G, j, L) : (v !== null ? (v = e_(Z, v, 2), E !== null && k !== null ? (E = ex(Z, v, E, !1), k = (function(Y, X, ne, xe) {
            const ae = new Int32Array(ne[ne.length - 1] + 1);
            let ue = 0;
            ae[0] = ue;
            let Te = 1, Ae = 1, Ke = 0;
            for (let ht = 0; ht < Y.length; ht++) {
              const lt = Y[ht], pt = X[ht + 1] - X[ht];
              if (lt !== 0 && lt !== 3) for (let Ct = 0; Ct < pt; Ct++) {
                const _t = ne[Te] - ne[Te - 1];
                Te++;
                for (let ut = 0; ut < _t; ut++) ue = ae[Ae++] = ue + xe[Ke++];
              }
              else for (let Ct = 0; Ct < pt; Ct++) ae[Ae++] = ++ue, Te++;
            }
            return ae;
          })(Z, v, E, k)) : E !== null && (E = (function(Y, X, ne) {
            const xe = new Int32Array(X[X.length - 1] + 1);
            let ae = 0;
            xe[0] = ae;
            let ue = 1, Te = 0;
            for (let Ae = 0; Ae < Y.length; Ae++) {
              const Ke = Y[Ae], ht = X[Ae + 1] - X[Ae];
              if (Ke === 4 || Ke === 1) for (let lt = 0; lt < ht; lt++) ae = xe[ue++] = ae + ne[Te++];
              else for (let lt = 0; lt < ht; lt++) xe[ue++] = ++ae;
            }
            return xe;
          })(Z, v, E))) : E !== null && k !== null ? (E = e_(Z, E, 1), k = ex(Z, E, k, !0)) : E !== null && (E = e_(Z, E, 0)), j !== null ? Q0(Z, G, j, L, new ph(v, E, k)) : N === null ? (function(Y, X, ne, xe) {
            return new X0(qs.VEC_2, Y, X, ne, xe);
          })(Z, new ph(v, E, k), P, L) : (function(Y, X, ne, xe, ae) {
            return new X0(qs.MORTON, Y, X, ne, xe, ae);
          })(Z, new ph(v, E, k), P, L, N));
        }
        function e_(i, e, r) {
          const c = new Int32Array(i.length + 1);
          let f = 0;
          c[0] = f;
          let m = 0;
          for (let v = 0; v < i.length; v++) f = c[v + 1] = f + (i[v] > r ? e[m++] : 1);
          return c;
        }
        function ex(i, e, r, c) {
          const f = new Int32Array(e[e.length - 1] + 1);
          let m = 0;
          f[0] = m;
          let v = 1, E = 0;
          for (let k = 0; k < i.length; k++) {
            const P = i[k], L = e[k + 1] - e[k];
            if (P === 5 || P === 2 || c && (P === 4 || P === 1)) for (let N = 0; N < L; N++) m = f[v++] = m + r[E++];
            else for (let N = 0; N < L; N++) f[v++] = ++m;
          }
          return f;
        }
        class sS extends dh {
          dataVector;
          constructor(e, r, c) {
            super(e, r.getBuffer(), c), this.dataVector = r;
          }
          getValueFromBuffer(e) {
            return this.dataVector.get(e);
          }
        }
        class aS extends Dp {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class tx extends dh {
          constructor(e, r, c) {
            super(e, BigInt64Array.of(r), c);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0];
          }
        }
        function jd(i, e, r) {
          return rx(i, Math.ceil(e / 8), r);
        }
        function rx(i, e, r) {
          const c = new Uint8Array(e);
          let f = 0;
          for (; f < e; ) {
            const m = i[r.increment()];
            if (m <= 127) {
              const v = m + 3, E = i[r.increment()], k = f + v;
              c.fill(E, f, k), f = k;
            } else {
              const v = 256 - m;
              for (let E = 0; E < v; E++) c[f++] = i[r.increment()];
            }
          }
          return c;
        }
        const oS = new TextDecoder();
        function t_(i, e, r) {
          return r - e >= 12 ? oS.decode(i.subarray(e, r)) : (function(c, f, m) {
            let v = "", E = f;
            for (; E < m; ) {
              const k = c[E];
              let P, L, N, G = null, j = k > 239 ? 4 : k > 223 ? 3 : k > 191 ? 2 : 1;
              if (E + j > m) break;
              j === 1 ? k < 128 && (G = k) : j === 2 ? (P = c[E + 1], (192 & P) == 128 && (G = (31 & k) << 6 | 63 & P, G <= 127 && (G = null))) : j === 3 ? (P = c[E + 1], L = c[E + 2], (192 & P) == 128 && (192 & L) == 128 && (G = (15 & k) << 12 | (63 & P) << 6 | 63 & L, (G <= 2047 || G >= 55296 && G <= 57343) && (G = null))) : j === 4 && (P = c[E + 1], L = c[E + 2], N = c[E + 3], (192 & P) == 128 && (192 & L) == 128 && (192 & N) == 128 && (G = (15 & k) << 18 | (63 & P) << 12 | (63 & L) << 6 | 63 & N, (G <= 65535 || G >= 1114112) && (G = null))), G === null ? (G = 65533, j = 1) : G > 65535 && (G -= 65536, v += String.fromCharCode(G >>> 10 & 1023 | 55296), G = 56320 | 1023 & G), v += String.fromCharCode(G), E += j;
            }
            return v;
          })(i, e, r);
        }
        class r_ extends dh {
          offsetBuffer;
          constructor(e, r, c, f) {
            super(e, c, f), this.offsetBuffer = r;
          }
        }
        class nx extends r_ {
          textEncoder;
          constructor(e, r, c, f) {
            super(e, r, c, f ?? r.length - 1), this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            return t_(this.dataBuffer, this.offsetBuffer[e], this.offsetBuffer[e + 1]);
          }
        }
        class gh extends r_ {
          indexBuffer;
          textEncoder;
          constructor(e, r, c, f, m) {
            super(e, c, f, m ?? r.length), this.indexBuffer = r, this.indexBuffer = r, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            const r = this.indexBuffer[e];
            return t_(this.dataBuffer, this.offsetBuffer[r], this.offsetBuffer[r + 1]);
          }
        }
        class ix extends r_ {
          indexBuffer;
          symbolOffsetBuffer;
          symbolTableBuffer;
          textEncoder;
          symbolLengthBuffer;
          lengthBuffer;
          decodedDictionary;
          constructor(e, r, c, f, m, v, E) {
            super(e, c, f, E), this.indexBuffer = r, this.symbolOffsetBuffer = m, this.symbolTableBuffer = v, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            this.decodedDictionary == null && (this.symbolLengthBuffer == null && (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = (function(c, f, m) {
              const v = [], E = new Array(f.length).fill(0);
              for (let k = 1; k < f.length; k++) E[k] = E[k - 1] + f[k - 1];
              for (let k = 0; k < m.length; k++) if (m[k] === 255) v.push(m[++k]);
              else {
                const P = f[m[k]], L = E[m[k]];
                for (let N = 0; N < P; N++) v.push(c[L + N]);
              }
              return new Uint8Array(v);
            })(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer));
            const r = this.indexBuffer[e];
            return t_(this.decodedDictionary, this.offsetBuffer[r], this.offsetBuffer[r + 1]);
          }
          offsetToLengthBuffer(e) {
            const r = new Uint32Array(e.length - 1);
            let c = e[0];
            for (let f = 1; f < e.length; f++) {
              const m = e[f];
              r[f - 1] = m - c, c = m;
            }
            return r;
          }
        }
        function lS(i, e, r, c, f, m) {
          return r.type === "scalarType" ? (function(v, E, k, P, L, N) {
            let G = null, j = 0;
            if (v === 0) return null;
            if (N.nullable) {
              const Y = Ki(E, k);
              j = Y.numValues;
              const X = k.get(), ne = jd(E, j, k);
              k.set(X + Y.byteLength), G = new Fa(ne, Y.numValues);
            }
            const Z = G ?? P;
            switch (L.physicalType) {
              case 4:
              case 3:
                return (function(Y, X, ne, xe, ae) {
                  const ue = Ki(Y, X), Te = Np(ue, ae, Y, X), Ae = xe.physicalType === 3;
                  if (Te === hi.FLAT) {
                    const Ke = Vd(ae) ? Wm(Y, X, ue, Ae, ae) : Qi(Y, X, ue, Ae);
                    return new Vm(ne.name, Ke, ae);
                  }
                  if (Te === hi.SEQUENCE) {
                    const Ke = G0(Y, X, ue);
                    return new qm(ne.name, Ke[0], Ke[1], ue.numRleValues);
                  }
                  {
                    const Ke = Ym(Y, X, ue, Ae);
                    return new $m(ne.name, Ke, ae);
                  }
                })(E, k, N, L, Z);
              case 9:
                return (function(Y, X, ne, xe, ae) {
                  let ue = null, Te = null, Ae = null, Ke = null, ht = null, lt = null, pt = null, Ct = null;
                  for (let _t = 0; _t < xe; _t++) {
                    const ut = Ki(X, ne);
                    if (ut.byteLength !== 0) switch (ut.physicalStreamType) {
                      case Mi.PRESENT: {
                        const st = jd(X, ut.numValues, ne);
                        lt = new Fa(st, ut.numValues);
                        break;
                      }
                      case Mi.OFFSET:
                        Te = ae != null || lt != null ? Wm(X, ne, ut, !1, ae ?? lt) : Qi(X, ne, ut, !1);
                        break;
                      case Mi.LENGTH: {
                        const st = Gl(X, ne, ut);
                        Ss.DICTIONARY === ut.logicalStreamType.lengthType ? ue = st : Ss.SYMBOL === ut.logicalStreamType.lengthType ? Ke = st : pt = st;
                        break;
                      }
                      case Mi.DATA: {
                        const st = X.subarray(ne.get(), ne.get() + ut.byteLength);
                        ne.add(ut.byteLength);
                        const Bt = ut.logicalStreamType.dictionaryType;
                        Ra.FSST === Bt ? ht = st : Ra.SINGLE === Bt || Ra.SHARED === Bt ? Ae = st : Ra.NONE === Bt && (Ct = st);
                        break;
                      }
                    }
                  }
                  return (function(_t, ut, st, Bt, Rt, Vt, Dt) {
                    return ut ? new ix(_t, st, Bt, Rt, Vt, ut, Dt) : null;
                  })(Y, ht, Te, ue, Ae, Ke, ae ?? lt) ?? (function(_t, ut, st, Bt, Rt) {
                    return ut ? Rt ? new gh(_t, st, Bt, ut, Rt) : new gh(_t, st, Bt, ut) : null;
                  })(Y, Ae, Te, ue, ae ?? lt) ?? (function(_t, ut, st, Bt, Rt) {
                    if (!ut || !st) return null;
                    if (Bt) return Rt ? new gh(_t, Bt, ut, st, Rt) : new gh(_t, Bt, ut, st);
                    if (Rt && Rt.size() !== ut.length - 1) {
                      const Vt = new Int32Array(Rt.size());
                      let Dt = 0;
                      for (let Yt = 0; Yt < Rt.size(); Yt++) Vt[Yt] = Rt.get(Yt) ? Dt++ : 0;
                      return new gh(_t, Vt, ut, st, Rt);
                    }
                    return Rt ? new nx(_t, ut, st, Rt) : new nx(_t, ut, st);
                  })(Y, pt, Ct, Te, ae ?? lt);
                })(N.name, E, k, N.nullable ? v - 1 : v, G);
              case 0:
                return (function(Y, X, ne, xe, ae) {
                  const ue = Ki(Y, X), Te = ue.numValues, Ae = X.get(), Ke = Vd(ae) ? (function(lt, pt, Ct, _t) {
                    const ut = rx(lt, Math.ceil(pt / 8), Ct), st = new Fa(ut, pt), Bt = _t.size(), Rt = new Fa(new Uint8Array(Bt), Bt);
                    let Vt = 0;
                    for (let Dt = 0; Dt < _t.size(); Dt++) {
                      const Yt = !!_t.get(Dt) && st.get(Vt++);
                      Rt.set(Dt, Yt);
                    }
                    return Rt.getBuffer();
                  })(Y, Te, X, ae) : jd(Y, Te, X);
                  X.set(Ae + ue.byteLength);
                  const ht = new Fa(Ke, Te);
                  return new sS(ne.name, ht, ae);
                })(E, k, N, 0, Z);
              case 6:
              case 5:
                return (function(Y, X, ne, xe, ae) {
                  const ue = Ki(Y, X), Te = Np(ue, xe, Y, X), Ae = ae.physicalType === 5;
                  if (Te === hi.FLAT) {
                    const Ke = Vd(xe) ? (function(ht, lt, pt, Ct, _t) {
                      return (function(ut, st, Bt, Rt) {
                        switch (st.logicalLevelTechnique1) {
                          case xr.DELTA:
                            return st.logicalLevelTechnique2 === xr.RLE && (ut = O0(ut, st.runs, st.numRleValues)), (function(Vt, Dt) {
                              const Yt = new BigInt64Array(Vt.size());
                              let Sr = 0;
                              Vt.get(0) ? (Yt[0] = Vt.get(0) ? Dt[0] >> 1n ^ -(1n & Dt[0]) : 0n, Sr = 1) : Yt[0] = 0n;
                              let yr = 1;
                              for (; yr != Yt.length; ++yr) Yt[yr] = Vt.get(yr) ? Yt[yr - 1] + (Dt[Sr] >> 1n ^ -(1n & Dt[Sr++])) : Yt[yr - 1];
                              return Yt;
                            })(Rt, ut);
                          case xr.RLE:
                            return (function(Vt, Dt, Yt, Sr) {
                              const yr = Dt;
                              return Yt ? (function(cn, Pi, Zn) {
                                const hn = new BigInt64Array(cn.size());
                                let an = 0;
                                for (let Fr = 0; Fr < Zn; Fr++) {
                                  const Tn = Number(Pi[Fr]);
                                  let Dn = Pi[Fr + Zn];
                                  Dn = Dn >> 1n ^ -(1n & Dn);
                                  for (let Jr = an; Jr < an + Tn; Jr++) cn.get(Jr) ? hn[Jr] = Dn : (hn[Jr] = 0n, an++);
                                  an += Tn;
                                }
                                return hn;
                              })(Sr, Vt, yr.runs) : (function(cn, Pi, Zn) {
                                const hn = new BigInt64Array(cn.size());
                                let an = 0;
                                for (let Fr = 0; Fr < Zn; Fr++) {
                                  const Tn = Number(Pi[Fr]), Dn = Pi[Fr + Zn];
                                  for (let Jr = an; Jr < an + Tn; Jr++) cn.get(Jr) ? hn[Jr] = Dn : (hn[Jr] = 0n, an++);
                                  an += Tn;
                                }
                                return hn;
                              })(Sr, Vt, yr.runs);
                            })(ut, st, Bt, Rt);
                          case xr.NONE:
                            return ut = Bt ? (function(Vt, Dt) {
                              const Yt = new BigInt64Array(Vt.size());
                              let Sr = 0, yr = 0;
                              for (; yr != Yt.length; ++yr) if (Vt.get(yr)) {
                                const cn = Dt[Sr++];
                                Yt[yr] = cn >> 1n ^ -(1n & cn);
                              } else Yt[yr] = 0n;
                              return Yt;
                            })(Rt, ut) : (function(Vt, Dt) {
                              const Yt = new BigInt64Array(Vt.size());
                              let Sr = 0, yr = 0;
                              for (; yr != Yt.length; ++yr) Yt[yr] = Vt.get(yr) ? Dt[Sr++] : 0n;
                              return Yt;
                            })(Rt, ut), ut;
                          default:
                            throw new Error("The specified Logical level technique is not supported");
                        }
                      })(Rp(ht, lt, pt.numValues), pt, Ct, _t);
                    })(Y, X, ue, Ae, xe) : V0(Y, X, ue, Ae);
                    return new q0(ne.name, Ke, xe);
                  }
                  if (Te === hi.SEQUENCE) {
                    const Ke = j0(Y, X, ue);
                    return new $0(ne.name, Ke[0], Ke[1], ue.numRleValues);
                  }
                  {
                    const Ke = U0(Y, X, ue, Ae);
                    return new tx(ne.name, Ke, xe);
                  }
                })(E, k, N, Z, L);
              case 7:
                return (function(Y, X, ne, xe) {
                  const ae = Ki(Y, X), ue = Vd(xe) ? (function(Te, Ae, Ke, ht) {
                    const lt = Ae.get(), pt = lt + ht * Float32Array.BYTES_PER_ELEMENT, Ct = new Uint8Array(Te.subarray(lt, pt)).buffer, _t = new Float32Array(Ct);
                    Ae.set(pt);
                    const ut = Ke.size(), st = new Float32Array(ut);
                    let Bt = 0;
                    for (let Rt = 0; Rt < ut; Rt++) st[Rt] = Ke.get(Rt) ? _t[Bt++] : 0;
                    return st;
                  })(Y, X, xe, ae.numValues) : (function(Te, Ae, Ke) {
                    const ht = Ae.get(), lt = ht + Ke * Float32Array.BYTES_PER_ELEMENT, pt = new Uint8Array(Te.subarray(ht, lt)).buffer, Ct = new Float32Array(pt);
                    return Ae.set(lt), Ct;
                  })(Y, X, ae.numValues);
                  return new aS(ne.name, ue, xe);
                })(E, k, N, Z);
              case 8:
                return (function(Y, X, ne, xe) {
                  const ae = Ki(Y, X), ue = Vd(xe) ? (function(Te, Ae, Ke, ht) {
                    const lt = Ae.get(), pt = lt + ht * Float64Array.BYTES_PER_ELEMENT, Ct = new Uint8Array(Te.subarray(lt, pt)).buffer, _t = new Float64Array(Ct);
                    Ae.set(pt);
                    const ut = Ke.size(), st = new Float64Array(ut);
                    let Bt = 0;
                    for (let Rt = 0; Rt < ut; Rt++) st[Rt] = Ke.get(Rt) ? _t[Bt++] : 0;
                    return st;
                  })(Y, X, xe, ae.numValues) : (function(Te, Ae, Ke) {
                    const ht = Ae.get(), lt = ht + Ke * Float64Array.BYTES_PER_ELEMENT, pt = new Uint8Array(Te.subarray(ht, lt)).buffer, Ct = new Float64Array(pt);
                    return Ae.set(lt), Ct;
                  })(Y, X, ae.numValues);
                  return new Um(ne.name, ue, xe);
                })(E, k, N, Z);
              default:
                throw new Error(`The specified data type for the field is currently not supported: ${L}`);
            }
          })(c, i, e, f, r.scalarType, r) : c != 1 ? null : (function(v, E, k, P) {
            let L = null, N = null, G = null, j = null, Z = !1;
            for (; !Z; ) {
              const xe = Ki(v, E);
              switch (xe.physicalStreamType) {
                case Mi.LENGTH:
                  Ss.DICTIONARY === xe.logicalStreamType.lengthType ? L = Gl(v, E, xe) : G = Gl(v, E, xe);
                  break;
                case Mi.DATA:
                  Ra.SINGLE === xe.logicalStreamType.dictionaryType || Ra.SHARED === xe.logicalStreamType.dictionaryType ? (N = v.subarray(E.get(), E.get() + xe.byteLength), Z = !0) : j = v.subarray(E.get(), E.get() + xe.byteLength), E.add(xe.byteLength);
              }
            }
            const Y = k.complexType.children, X = [];
            let ne = 0;
            for (const xe of Y) {
              const ae = Ti(v, E, 1)[0];
              if (ae == 0) continue;
              const ue = `${k.name}${xe.name === "default" ? "" : ":" + xe.name}`;
              if (ae !== 2 || xe.type !== "scalarField" || xe.scalarField.physicalType !== 9) throw new Error("Currently only optional string fields are implemented for a struct.");
              const Te = Ki(v, E), Ae = jd(v, Te.numValues, E), Ke = Ki(v, E), ht = Ke.decompressedCount !== P ? Wm(v, E, Ke, !1, new Fa(Ae, Te.numValues)) : Qi(v, E, Ke, !1);
              X[ne++] = j ? new ix(ue, ht, L, N, G, j, new Fa(Ae, Te.numValues)) : new gh(ue, ht, L, N, new Fa(Ae, Te.numValues));
            }
            return X;
          })(i, e, r, f);
        }
        function Vd(i) {
          return i instanceof Fa;
        }
        function uS(i) {
          if (i.name === "id") return !1;
          if (i.type === "scalarType") {
            const e = i.scalarType;
            if (e.type === "physicalType") switch (e.physicalType) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              default:
                return !1;
              case 9:
                return !0;
            }
            else if (e.type === "logicalType") return !1;
          } else if (i.type === "complexType") {
            const e = i.complexType;
            if (e.type === "physicalType") switch (e.physicalType) {
              case 0:
              case 1:
                return !0;
              default:
                return !1;
            }
          }
          return console.warn("Unexpected column type in hasStreamCount", i), !1;
        }
        const cS = new TextDecoder();
        function sx(i, e) {
          const r = Ti(i, e, 1)[0];
          if (r === 0) return "";
          const c = e.get(), f = i.subarray(c, c + r);
          return e.add(r), cS.decode(f);
        }
        function ax(i, e) {
          const r = Ti(i, e, 1)[0] >>> 0, c = !!(4 & r), f = !!(2 & r), m = Ti(i, e, 1)[0] >>> 0, v = {};
          if (1 & r && (v.nullable = !0), f) {
            const E = {};
            if (c ? (E.type = "logicalType", E.logicalType = m) : (E.type = "physicalType", E.physicalType = m), 8 & r) {
              const k = Ti(i, e, 1)[0] >>> 0;
              E.children = new Array(k);
              for (let P = 0; P < k; P++) E.children[P] = ax(i, e);
            }
            v.type = "complexField", v.complexField = E;
          } else {
            const E = {};
            c ? (E.type = "logicalType", E.logicalType = m) : (E.type = "physicalType", E.physicalType = m), v.type = "scalarField", v.scalarField = E;
          }
          return v;
        }
        function hS(i, e) {
          const r = Ti(i, e, 1)[0] >>> 0, c = (function(f) {
            switch (f) {
              case 0:
              case 1:
              case 2:
              case 3: {
                const m = {};
                m.nullable = !!(1 & f), m.columnScope = 0;
                const v = {};
                return v.physicalType = f > 1 ? 6 : 4, v.type = "physicalType", m.scalarType = v, m.type = "scalarType", m;
              }
              case 4: {
                const m = { nullable: !1, columnScope: 0 }, v = { type: "physicalType", physicalType: 0 };
                return m.type = "complexType", m.complexType = v, m;
              }
              case 30: {
                const m = { nullable: !1, columnScope: 0 }, v = { type: "physicalType", physicalType: 1 };
                return m.type = "complexType", m.complexType = v, m;
              }
              default:
                return (function(m) {
                  let v = null;
                  switch (m) {
                    case 10:
                    case 11:
                      v = 0;
                      break;
                    case 12:
                    case 13:
                      v = 1;
                      break;
                    case 14:
                    case 15:
                      v = 2;
                      break;
                    case 16:
                    case 17:
                      v = 3;
                      break;
                    case 18:
                    case 19:
                      v = 4;
                      break;
                    case 20:
                    case 21:
                      v = 5;
                      break;
                    case 22:
                    case 23:
                      v = 6;
                      break;
                    case 24:
                    case 25:
                      v = 7;
                      break;
                    case 26:
                    case 27:
                      v = 8;
                      break;
                    case 28:
                    case 29:
                      v = 9;
                      break;
                    default:
                      return null;
                  }
                  const E = {};
                  E.nullable = !!(1 & m), E.columnScope = 0;
                  const k = { type: "physicalType" };
                  return k.physicalType = v, E.type = "scalarType", E.scalarType = k, E;
                })(f);
            }
          })(r);
          if (!c) throw new Error(`Unsupported column type code: ${r}`);
          if ((function(f) {
            return f >= 10;
          })(r) ? c.name = sx(i, e) : r >= 0 && r <= 3 ? c.name = "id" : r === 4 && (c.name = "geometry"), /* @__PURE__ */ (function(f) {
            return f === 30;
          })(r)) {
            const f = Ti(i, e, 1)[0] >>> 0, m = c.complexType;
            m.children = new Array(f);
            for (let v = 0; v < f; v++) m.children[v] = ax(i, e);
          }
          return c;
        }
        function dS(i, e) {
          const r = { featureTables: [] }, c = {};
          c.name = sx(i, e);
          const f = Ti(i, e, 1)[0] >>> 0, m = Ti(i, e, 1)[0] >>> 0;
          c.columns = new Array(m);
          for (let v = 0; v < m; v++) c.columns[v] = hS(i, e);
          return r.featureTables.push(c), [r, f];
        }
        function fS(i, e, r, c, f, m, v = !1) {
          const E = e.scalarType.physicalType, k = Np(f, m, i, r);
          if (E === 4) switch (k) {
            case hi.FLAT: {
              const P = Qi(i, r, f, !1);
              return new Vm(c, P, m);
            }
            case hi.SEQUENCE: {
              const P = G0(i, r, f);
              return new qm(c, P[0], P[1], f.numRleValues);
            }
            case hi.CONST: {
              const P = Ym(i, r, f, !1);
              return new $m(c, P, m);
            }
          }
          else switch (k) {
            case hi.FLAT: {
              if (v) {
                const L = (function(N, G, j, Z) {
                  const Y = (function(X, ne, xe) {
                    const ae = new Float64Array(ne);
                    for (let ue = 0; ue < ne; ue++) ae[ue] = QT(X, xe);
                    return ae;
                  })(N, j.numValues, G);
                  return (function(X, ne, xe) {
                    switch (ne.logicalLevelTechnique1) {
                      case xr.DELTA:
                        return ne.logicalLevelTechnique2 === xr.RLE && (X = z0(X, ne.runs, ne.numRleValues)), (function(ae) {
                          ae[0] = ae[0] % 2 == 1 ? (ae[0] + 1) / -2 : ae[0] / 2;
                          const ue = ae.length / 4 * 4;
                          let Te = 1;
                          if (ue >= 4) for (; Te < ue - 4; Te += 4) {
                            const Ae = ae[Te], Ke = ae[Te + 1], ht = ae[Te + 2], lt = ae[Te + 3];
                            ae[Te] = (Ae % 2 == 1 ? (Ae + 1) / -2 : Ae / 2) + ae[Te - 1], ae[Te + 1] = (Ke % 2 == 1 ? (Ke + 1) / -2 : Ke / 2) + ae[Te], ae[Te + 2] = (ht % 2 == 1 ? (ht + 1) / -2 : ht / 2) + ae[Te + 1], ae[Te + 3] = (lt % 2 == 1 ? (lt + 1) / -2 : lt / 2) + ae[Te + 2];
                          }
                          for (; Te != ae.length; ++Te) ae[Te] = (ae[Te] % 2 == 1 ? (ae[Te] + 1) / -2 : ae[Te] / 2) + ae[Te - 1];
                        })(X), X;
                      case xr.RLE:
                        return (function(ae, ue, Te) {
                          return z0(ae, ue.runs, ue.numRleValues);
                        })(X, ne);
                      case xr.NONE:
                        return X;
                      default:
                        throw new Error(`The specified Logical level technique is not supported: ${ne.logicalLevelTechnique1}`);
                    }
                  })(Y, j);
                })(i, r, f);
                return new Um(c, L, m);
              }
              const P = V0(i, r, f, !1);
              return new q0(c, P, m);
            }
            case hi.SEQUENCE: {
              const P = j0(i, r, f);
              return new $0(c, P[0], P[1], f.numRleValues);
            }
            case hi.CONST: {
              const P = U0(i, r, f, !1);
              return new tx(c, P, m);
            }
          }
          throw new Error("Vector type not supported for id column.");
        }
        class pS {
          constructor(e, r) {
            var c;
            switch (this._featureData = e, this.properties = this._featureData.properties || {}, (c = this._featureData.geometry) === null || c === void 0 ? void 0 : c.type) {
              case di.POINT:
              case di.MULTIPOINT:
                this.type = 1;
                break;
              case di.LINESTRING:
              case di.MULTILINESTRING:
                this.type = 2;
                break;
              case di.POLYGON:
              case di.MULTIPOLYGON:
                this.type = 3;
                break;
              default:
                this.type = 0;
            }
            this.extent = r, this.id = Number(this._featureData.id);
          }
          loadGeometry() {
            const e = [];
            for (const r of this._featureData.geometry.coordinates) {
              const c = [];
              for (const f of r) c.push(new R(f.x, f.y));
              e.push(c);
            }
            return e;
          }
        }
        class gS {
          constructor(e) {
            this.features = [], this.featureTable = e, this.name = e.name, this.extent = e.extent, this.version = 2, this.features = e.getFeatures(), this.length = this.features.length;
          }
          feature(e) {
            return new pS(this.features[e], this.extent);
          }
        }
        class ox {
          constructor(e) {
            this.layers = {};
            const r = (function(c, f, m = !0) {
              const v = new KT(0), E = [];
              for (; v.get() < c.length; ) {
                const k = Ti(c, v, 1)[0] >>> 0, P = v.get() + k;
                if (P > c.length) throw new Error(`Block overruns tile: ${P} > ${c.length}`);
                if (Ti(c, v, 1)[0] >>> 0 != 1) {
                  v.set(P);
                  continue;
                }
                const L = dS(c, v), N = L[1], G = L[0].featureTables[0];
                let j = null, Z = null;
                const Y = [];
                let X = 0;
                for (const xe of G.columns) {
                  const ae = xe.name;
                  if (ae === "id") {
                    let ue = null;
                    if (xe.nullable) {
                      const Ae = Ki(c, v), Ke = v.get(), ht = jd(c, Ae.numValues, v);
                      v.set(Ke + Ae.byteLength), ue = new Fa(ht, Ae.numValues);
                    }
                    const Te = Ki(c, v);
                    X = Te.decompressedCount, j = fS(c, xe, v, ae, Te, ue ?? X, m);
                  } else if (ae === "geometry") {
                    const ue = Ti(c, v, 1)[0];
                    if (X === 0) {
                      const Te = v.get();
                      X = Ki(c, v).decompressedCount, v.set(Te);
                    }
                    Z = iS(c, ue, v, X);
                  } else {
                    const ue = uS(xe) ? Ti(c, v, 1)[0] : 1;
                    if (ue === 0 && xe.type === "scalarType") continue;
                    const Te = lS(c, v, xe, ue, X);
                    if (Te) if (Array.isArray(Te)) for (const Ae of Te) Y.push(Ae);
                    else Y.push(Te);
                  }
                }
                const ne = new JT(G.name, Z, j, Y, N);
                E.push(ne), v.set(P);
              }
              return E;
            })(new Uint8Array(e));
            this.layers = r.reduce(((c, f) => Object.assign(Object.assign({}, c), { [f.name]: new gS(f) })), {});
          }
        }
        class mS {
          constructor(e, r) {
            this.feature = e, this.type = e.type, this.properties = e.tags ? e.tags : {}, this.extent = r, "id" in e && (typeof e.id == "string" ? this.id = parseInt(e.id, 10) : typeof e.id != "number" || isNaN(e.id) || (this.id = e.id));
          }
          loadGeometry() {
            const e = [], r = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const c of r) {
              const f = [];
              for (const m of c) f.push(new R(m[0], m[1]));
              e.push(f);
            }
            return e;
          }
        }
        const Ud = "_geojsonTileLayer";
        function _S(i, e) {
          e.writeVarintField(15, i.version || 1), e.writeStringField(1, i.name || ""), e.writeVarintField(5, i.extent || 4096);
          const r = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let m = 0; m < i.length; m++) r.feature = i.feature(m), e.writeMessage(2, yS, r);
          const c = r.keys;
          for (const m of c) e.writeStringField(3, m);
          const f = r.values;
          for (const m of f) e.writeMessage(4, bS, m);
        }
        function yS(i, e) {
          if (!i.feature) return;
          const r = i.feature;
          r.id !== void 0 && e.writeVarintField(1, r.id), e.writeMessage(2, vS, i), e.writeVarintField(3, r.type), e.writeMessage(4, xS, r);
        }
        function vS(i, e) {
          for (const r in i.feature?.properties) {
            let c = i.feature.properties[r], f = i.keycache[r];
            if (c == null) continue;
            f === void 0 && (i.keys.push(r), f = i.keys.length - 1, i.keycache[r] = f), e.writeVarint(f), typeof c != "string" && typeof c != "boolean" && typeof c != "number" && (c = JSON.stringify(c));
            const m = typeof c + ":" + c;
            let v = i.valuecache[m];
            v === void 0 && (i.values.push(c), v = i.values.length - 1, i.valuecache[m] = v), e.writeVarint(v);
          }
        }
        function n_(i, e) {
          return (e << 3) + (7 & i);
        }
        function lx(i) {
          return i << 1 ^ i >> 31;
        }
        function xS(i, e) {
          const r = i.loadGeometry(), c = i.type;
          let f = 0, m = 0;
          for (const v of r) {
            let E = 1;
            c === 1 && (E = v.length), e.writeVarint(n_(1, E));
            const k = c === 3 ? v.length - 1 : v.length;
            for (let P = 0; P < k; P++) {
              P === 1 && c !== 1 && e.writeVarint(n_(2, k - 1));
              const L = v[P].x - f, N = v[P].y - m;
              e.writeVarint(lx(L)), e.writeVarint(lx(N)), f += L, m += N;
            }
            i.type === 3 && e.writeVarint(n_(7, 1));
          }
        }
        function bS(i, e) {
          const r = typeof i;
          r === "string" ? e.writeStringField(1, i) : r === "boolean" ? e.writeBooleanField(7, i) : r === "number" && (i % 1 != 0 ? e.writeDoubleField(3, i) : i < 0 ? e.writeSVarintField(6, i) : e.writeVarintField(5, i));
        }
        class ux {
          constructor(e, r) {
            this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Dl(We, 16, 0), this.grid3D = new Dl(We, 16, 0), this.featureIndexArray = new te(), this.promoteId = r;
          }
          insert(e, r, c, f, m, v) {
            const E = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(c, f, m);
            const k = v ? this.grid3D : this.grid;
            for (let P = 0; P < r.length; P++) {
              const L = r[P], N = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let G = 0; G < L.length; G++) {
                const j = L[G];
                N[0] = Math.min(N[0], j.x), N[1] = Math.min(N[1], j.y), N[2] = Math.max(N[2], j.x), N[3] = Math.max(N[3], j.y);
              }
              N[0] < We && N[1] < We && N[2] >= 0 && N[3] >= 0 && k.insert(E, N[0], N[1], N[2], N[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = this.encoding !== "mlt" ? new Yv(new Mp(this.rawTileData)).layers : new ox(this.rawTileData).layers, this.sourceLayerCoder = new A0(this.vtLayers ? Object.keys(this.vtLayers).sort() : [Ud])), this.vtLayers;
          }
          query(e, r, c, f) {
            this.loadVTLayers();
            const m = e.params, v = We / e.tileSize / e.scale, E = Iu(m.filter, m.globalState), k = e.queryGeometry, P = e.queryPadding * v, L = Ju.fromPoints(k), N = this.grid.query(L.minX - P, L.minY - P, L.maxX + P, L.maxY + P), G = Ju.fromPoints(e.cameraQueryGeometry).expandBy(P), j = this.grid3D.query(G.minX, G.minY, G.maxX, G.maxY, ((X, ne, xe, ae) => (function(ue, Te, Ae, Ke, ht) {
              for (const pt of ue) if (Te <= pt.x && Ae <= pt.y && Ke >= pt.x && ht >= pt.y) return !0;
              const lt = [new R(Te, Ae), new R(Te, ht), new R(Ke, ht), new R(Ke, Ae)];
              if (ue.length > 2) {
                for (const pt of lt) if (nh(ue, pt)) return !0;
              }
              for (let pt = 0; pt < ue.length - 1; pt++) if (EE(ue[pt], ue[pt + 1], lt)) return !0;
              return !1;
            })(e.cameraQueryGeometry, X - P, ne - P, xe + P, ae + P)));
            for (const X of j) N.push(X);
            N.sort(wS);
            const Z = {};
            let Y;
            for (let X = 0; X < N.length; X++) {
              const ne = N[X];
              if (ne === Y) continue;
              Y = ne;
              const xe = this.featureIndexArray.get(ne);
              let ae = null;
              this.loadMatchingFeature(Z, xe.bucketIndex, xe.sourceLayerIndex, xe.featureIndex, E, m.layers, m.availableImages, r, c, f, ((ue, Te, Ae) => (ae || (ae = po(ue)), Te.queryIntersectsFeature({ queryGeometry: k, feature: ue, featureState: Ae, geometry: ae, zoom: this.z, transform: e.transform, pixelsToTileUnits: v, pixelPosMatrix: e.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: e.getElevation }))));
            }
            return Z;
          }
          loadMatchingFeature(e, r, c, f, m, v, E, k, P, L, N) {
            const G = this.bucketLayerIDs[r];
            if (v && !G.some(((X) => v.has(X)))) return;
            const j = this.sourceLayerCoder.decode(c), Z = this.vtLayers[j].feature(f);
            if (m.needGeometry) {
              const X = go(Z, !0);
              if (!m.filter(new Vr(this.tileID.overscaledZ), X, this.tileID.canonical)) return;
            } else if (!m.filter(new Vr(this.tileID.overscaledZ), Z)) return;
            const Y = this.getId(Z, j);
            for (let X = 0; X < G.length; X++) {
              const ne = G[X];
              if (v && !v.has(ne)) continue;
              const xe = k[ne];
              if (!xe) continue;
              let ae = {};
              Y && L && (ae = L.getState(xe.sourceLayer || Ud, Y));
              const ue = Ze({}, P[ne]);
              ue.paint = cx(ue.paint, xe.paint, Z, ae, E), ue.layout = cx(ue.layout, xe.layout, Z, ae, E);
              const Te = !N || N(Z, xe, ae);
              if (!Te) continue;
              const Ae = new L0(Z, this.z, this.x, this.y, Y);
              Ae.layer = ue;
              let Ke = e[ne];
              Ke === void 0 && (Ke = e[ne] = []), Ke.push({ featureIndex: f, feature: Ae, intersectionZ: Te });
            }
          }
          lookupSymbolFeatures(e, r, c, f, m, v, E, k) {
            const P = {};
            this.loadVTLayers();
            const L = Iu(m.filterSpec, m.globalState);
            for (const N of e) this.loadMatchingFeature(P, c, f, N, L, v, E, k, r);
            return P;
          }
          hasLayer(e) {
            for (const r of this.bucketLayerIDs) for (const c of r) if (e === c) return !0;
            return !1;
          }
          getId(e, r) {
            var c;
            let f = e.id;
            return this.promoteId && (f = e.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof f == "boolean" && (f = Number(f)), f === void 0 && (!((c = e.properties) === null || c === void 0) && c.cluster) && this.promoteId && (f = Number(e.properties.cluster_id))), f;
          }
        }
        function cx(i, e, r, c, f) {
          return lr(i, ((m, v) => {
            const E = e instanceof Gu ? e.get(v) : null;
            return E && E.evaluate ? E.evaluate(r, c, f) : E;
          }));
        }
        function wS(i, e) {
          return e - i;
        }
        function hx(i, e, r, c, f) {
          const m = [];
          for (let v = 0; v < i.length; v++) {
            const E = i[v];
            let k;
            for (let P = 0; P < E.length - 1; P++) {
              let L = E[P], N = E[P + 1];
              L.x < e && N.x < e || (L.x < e ? L = new R(e, L.y + (e - L.x) / (N.x - L.x) * (N.y - L.y))._round() : N.x < e && (N = new R(e, L.y + (e - L.x) / (N.x - L.x) * (N.y - L.y))._round()), L.y < r && N.y < r || (L.y < r ? L = new R(L.x + (r - L.y) / (N.y - L.y) * (N.x - L.x), r)._round() : N.y < r && (N = new R(L.x + (r - L.y) / (N.y - L.y) * (N.x - L.x), r)._round()), L.x >= c && N.x >= c || (L.x >= c ? L = new R(c, L.y + (c - L.x) / (N.x - L.x) * (N.y - L.y))._round() : N.x >= c && (N = new R(c, L.y + (c - L.x) / (N.x - L.x) * (N.y - L.y))._round()), L.y >= f && N.y >= f || (L.y >= f ? L = new R(L.x + (f - L.y) / (N.y - L.y) * (N.x - L.x), f)._round() : N.y >= f && (N = new R(L.x + (f - L.y) / (N.y - L.y) * (N.x - L.x), f)._round()), k && L.equals(k[k.length - 1]) || (k = [L], m.push(k)), k.push(N)))));
            }
          }
          return m;
        }
        function dx(i, e, r, c, f) {
          switch (e) {
            case 1:
              return (function(m, v, E, k) {
                const P = [];
                for (const L of m) for (const N of L) {
                  const G = k === 0 ? N.x : N.y;
                  G >= v && G <= E && P.push([N]);
                }
                return P;
              })(i, r, c, f);
            case 2:
              return fx(i, r, c, f, !1);
            case 3:
              return fx(i, r, c, f, !0);
          }
          return [];
        }
        function ES(i, e, r, c, f) {
          const m = c === 0 ? TS : SS;
          let v = [];
          const E = [];
          for (let L = 0; L < i.length - 1; L++) {
            const N = i[L], G = i[L + 1], j = c === 0 ? N.x : N.y, Z = c === 0 ? G.x : G.y;
            let Y = !1;
            j < e ? Z > e && v.push(m(N, G, e)) : j > r ? Z < r && v.push(m(N, G, r)) : v.push(N), Z < e && j >= e && (v.push(m(N, G, e)), Y = !0), Z > r && j <= r && (v.push(m(N, G, r)), Y = !0), !f && Y && (E.push(v), v = []);
          }
          const k = i.length - 1, P = c === 0 ? i[k].x : i[k].y;
          return P >= e && P <= r && v.push(i[k]), f && v.length > 0 && !v[0].equals(v[v.length - 1]) && v.push(new R(v[0].x, v[0].y)), v.length > 0 && E.push(v), E;
        }
        function fx(i, e, r, c, f) {
          const m = [];
          for (const v of i) {
            const E = ES(v, e, r, c, f);
            E.length > 0 && m.push(...E);
          }
          return m;
        }
        function TS(i, e, r) {
          return new R(r, i.y + (r - i.x) / (e.x - i.x) * (e.y - i.y));
        }
        function SS(i, e, r) {
          return new R(i.x + (r - i.y) / (e.y - i.y) * (e.x - i.x), r);
        }
        jt("FeatureIndex", ux, { omit: ["rawTileData", "sourceLayerCoder"] });
        class jl extends R {
          constructor(e, r, c, f) {
            super(e, r), this.angle = c, f !== void 0 && (this.segment = f);
          }
          clone() {
            return new jl(this.x, this.y, this.angle, this.segment);
          }
        }
        function px(i, e, r, c, f) {
          if (e.segment === void 0 || r === 0) return !0;
          let m = e, v = e.segment + 1, E = 0;
          for (; E > -r / 2; ) {
            if (v--, v < 0) return !1;
            E -= i[v].dist(m), m = i[v];
          }
          E += i[v].dist(i[v + 1]), v++;
          const k = [];
          let P = 0;
          for (; E < r / 2; ) {
            const L = i[v], N = i[v + 1];
            if (!N) return !1;
            let G = i[v - 1].angleTo(L) - L.angleTo(N);
            for (G = Math.abs((G + 3 * Math.PI) % (2 * Math.PI) - Math.PI), k.push({ distance: E, angleDelta: G }), P += G; E - k[0].distance > c; ) P -= k.shift().angleDelta;
            if (P > f) return !1;
            v++, E += L.dist(N);
          }
          return !0;
        }
        function gx(i) {
          let e = 0;
          for (let r = 0; r < i.length - 1; r++) e += i[r].dist(i[r + 1]);
          return e;
        }
        function mx(i, e, r) {
          return i ? 0.6 * e * r : 0;
        }
        function _x(i, e) {
          return Math.max(i ? i.right - i.left : 0, e ? e.right - e.left : 0);
        }
        function kS(i, e, r, c, f, m) {
          const v = mx(r, f, m), E = _x(r, c) * m;
          let k = 0;
          const P = gx(i) / 2;
          for (let L = 0; L < i.length - 1; L++) {
            const N = i[L], G = i[L + 1], j = N.dist(G);
            if (k + j > P) {
              const Z = (P - k) / j, Y = Wr.number(N.x, G.x, Z), X = Wr.number(N.y, G.y, Z), ne = new jl(Y, X, G.angleTo(N), L);
              return ne._round(), !v || px(i, ne, E, v, e) ? ne : void 0;
            }
            k += j;
          }
        }
        function IS(i, e, r, c, f, m, v, E, k) {
          const P = mx(c, m, v), L = _x(c, f), N = L * v, G = i[0].x === 0 || i[0].x === k || i[0].y === 0 || i[0].y === k;
          return e - N < e / 4 && (e = N + e / 4), yx(i, G ? e / 2 * E % e : (L / 2 + 2 * m) * v * E % e, e, P, r, N, G, !1, k);
        }
        function yx(i, e, r, c, f, m, v, E, k) {
          const P = m / 2, L = gx(i);
          let N = 0, G = e - r, j = [];
          for (let Z = 0; Z < i.length - 1; Z++) {
            const Y = i[Z], X = i[Z + 1], ne = Y.dist(X), xe = X.angleTo(Y);
            for (; G + r < N + ne; ) {
              G += r;
              const ae = (G - N) / ne, ue = Wr.number(Y.x, X.x, ae), Te = Wr.number(Y.y, X.y, ae);
              if (ue >= 0 && ue < k && Te >= 0 && Te < k && G - P >= 0 && G + P <= L) {
                const Ae = new jl(ue, Te, xe, Z);
                Ae._round(), c && !px(i, Ae, m, c, f) || j.push(Ae);
              }
            }
            N += ne;
          }
          return E || j.length || v || (j = yx(i, N / 2, r, c, f, m, v, !0, k)), j;
        }
        function vx(i, e, r, c) {
          const f = [], m = i.image, v = m.pixelRatio, E = m.paddedRect.w - 2, k = m.paddedRect.h - 2;
          let P = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
          const L = m.stretchX || [[0, E]], N = m.stretchY || [[0, k]], G = (st, Bt) => st + Bt[1] - Bt[0], j = L.reduce(G, 0), Z = N.reduce(G, 0), Y = E - j, X = k - Z;
          let ne = 0, xe = j, ae = 0, ue = Z, Te = 0, Ae = Y, Ke = 0, ht = X;
          if (m.content && c) {
            const st = m.content, Bt = st[2] - st[0], Rt = st[3] - st[1];
            (m.textFitWidth || m.textFitHeight) && (P = p0(i)), ne = Gp(L, 0, st[0]), ae = Gp(N, 0, st[1]), xe = Gp(L, st[0], st[2]), ue = Gp(N, st[1], st[3]), Te = st[0] - ne, Ke = st[1] - ae, Ae = Bt - xe, ht = Rt - ue;
          }
          const lt = P.x1, pt = P.y1, Ct = P.x2 - lt, _t = P.y2 - pt, ut = (st, Bt, Rt, Vt) => {
            const Dt = jp(st.stretch - ne, xe, Ct, lt), Yt = Vp(st.fixed - Te, Ae, st.stretch, j), Sr = jp(Bt.stretch - ae, ue, _t, pt), yr = Vp(Bt.fixed - Ke, ht, Bt.stretch, Z), cn = jp(Rt.stretch - ne, xe, Ct, lt), Pi = Vp(Rt.fixed - Te, Ae, Rt.stretch, j), Zn = jp(Vt.stretch - ae, ue, _t, pt), hn = Vp(Vt.fixed - Ke, ht, Vt.stretch, Z), an = new R(Dt, Sr), Fr = new R(cn, Sr), Tn = new R(cn, Zn), Dn = new R(Dt, Zn), Jr = new R(Yt / v, yr / v), ls = new R(Pi / v, hn / v), Ai = e * Math.PI / 180;
            if (Ai) {
              const fi = Math.sin(Ai), _n = Math.cos(Ai), Hn = [_n, -fi, fi, _n];
              an._matMult(Hn), Fr._matMult(Hn), Dn._matMult(Hn), Tn._matMult(Hn);
            }
            const us = st.stretch + st.fixed, ua = Bt.stretch + Bt.fixed;
            return { tl: an, tr: Fr, bl: Dn, br: Tn, tex: { x: m.paddedRect.x + 1 + us, y: m.paddedRect.y + 1 + ua, w: Rt.stretch + Rt.fixed - us, h: Vt.stretch + Vt.fixed - ua }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Jr, pixelOffsetBR: ls, minFontScaleX: Ae / v / Ct, minFontScaleY: ht / v / _t, isSDF: r };
          };
          if (c && (m.stretchX || m.stretchY)) {
            const st = xx(L, Y, j), Bt = xx(N, X, Z);
            for (let Rt = 0; Rt < st.length - 1; Rt++) {
              const Vt = st[Rt], Dt = st[Rt + 1];
              for (let Yt = 0; Yt < Bt.length - 1; Yt++) f.push(ut(Vt, Bt[Yt], Dt, Bt[Yt + 1]));
            }
          } else f.push(ut({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: E + 1 }, { fixed: 0, stretch: k + 1 }));
          return f;
        }
        function Gp(i, e, r) {
          let c = 0;
          for (const f of i) c += Math.max(e, Math.min(r, f[1])) - Math.max(e, Math.min(r, f[0]));
          return c;
        }
        function xx(i, e, r) {
          const c = [{ fixed: -1, stretch: 0 }];
          for (const [f, m] of i) {
            const v = c[c.length - 1];
            c.push({ fixed: f - v.stretch, stretch: v.stretch }), c.push({ fixed: f - v.stretch, stretch: v.stretch + (m - f) });
          }
          return c.push({ fixed: e + 1, stretch: r }), c;
        }
        function jp(i, e, r, c) {
          return i / e * r + c;
        }
        function Vp(i, e, r, c) {
          return i - e * r / c;
        }
        jt("Anchor", jl);
        class Up {
          constructor(e, r, c, f, m, v, E, k, P, L) {
            var N;
            if (this.boxStartIndex = e.length, P) {
              let G = v.top, j = v.bottom;
              const Z = v.collisionPadding;
              Z && (G -= Z[1], j += Z[3]);
              let Y = j - G;
              Y > 0 && (Y = Math.max(10, Y), this.circleDiameter = Y);
            } else {
              const G = !((N = v.image) === null || N === void 0) && N.content && (v.image.textFitWidth || v.image.textFitHeight) ? p0(v) : { x1: v.left, y1: v.top, x2: v.right, y2: v.bottom };
              G.y1 = G.y1 * E - k[0], G.y2 = G.y2 * E + k[2], G.x1 = G.x1 * E - k[3], G.x2 = G.x2 * E + k[1];
              const j = v.collisionPadding;
              if (j && (G.x1 -= j[0] * E, G.y1 -= j[1] * E, G.x2 += j[2] * E, G.y2 += j[3] * E), L) {
                const Z = new R(G.x1, G.y1), Y = new R(G.x2, G.y1), X = new R(G.x1, G.y2), ne = new R(G.x2, G.y2), xe = L * Math.PI / 180;
                Z._rotate(xe), Y._rotate(xe), X._rotate(xe), ne._rotate(xe), G.x1 = Math.min(Z.x, Y.x, X.x, ne.x), G.x2 = Math.max(Z.x, Y.x, X.x, ne.x), G.y1 = Math.min(Z.y, Y.y, X.y, ne.y), G.y2 = Math.max(Z.y, Y.y, X.y, ne.y);
              }
              e.emplaceBack(r.x, r.y, G.x1, G.y1, G.x2, G.y2, c, f, m);
            }
            this.boxEndIndex = e.length;
          }
        }
        class MS {
          constructor(e = [], r = (c, f) => c < f ? -1 : c > f ? 1 : 0) {
            if (this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (let c = (this.length >> 1) - 1; c >= 0; c--) this._down(c);
          }
          push(e) {
            this.data.push(e), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const e = this.data[0], r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), e;
          }
          peek() {
            return this.data[0];
          }
          _up(e) {
            const { data: r, compare: c } = this, f = r[e];
            for (; e > 0; ) {
              const m = e - 1 >> 1, v = r[m];
              if (c(f, v) >= 0) break;
              r[e] = v, e = m;
            }
            r[e] = f;
          }
          _down(e) {
            const { data: r, compare: c } = this, f = this.length >> 1, m = r[e];
            for (; e < f; ) {
              let v = 1 + (e << 1);
              const E = v + 1;
              if (E < this.length && c(r[E], r[v]) < 0 && (v = E), c(r[v], m) >= 0) break;
              r[e] = r[v], e = v;
            }
            r[e] = m;
          }
        }
        function CS(i, e = 1, r = !1) {
          const c = Ju.fromPoints(i[0]), f = Math.min(c.width(), c.height());
          let m = f / 2;
          const v = new MS([], PS), { minX: E, minY: k, maxX: P, maxY: L } = c;
          if (f === 0) return new R(E, k);
          for (let j = E; j < P; j += f) for (let Z = k; Z < L; Z += f) v.push(new mh(j + m, Z + m, m, i));
          let N = (function(j) {
            let Z = 0, Y = 0, X = 0;
            const ne = j[0];
            for (let xe = 0, ae = ne.length, ue = ae - 1; xe < ae; ue = xe++) {
              const Te = ne[xe], Ae = ne[ue], Ke = Te.x * Ae.y - Ae.x * Te.y;
              Y += (Te.x + Ae.x) * Ke, X += (Te.y + Ae.y) * Ke, Z += 3 * Ke;
            }
            return new mh(Y / Z, X / Z, 0, j);
          })(i), G = v.length;
          for (; v.length; ) {
            const j = v.pop();
            (j.d > N.d || !N.d) && (N = j, r && console.log("found best %d after %d probes", Math.round(1e4 * j.d) / 1e4, G)), j.max - N.d <= e || (m = j.h / 2, v.push(new mh(j.p.x - m, j.p.y - m, m, i)), v.push(new mh(j.p.x + m, j.p.y - m, m, i)), v.push(new mh(j.p.x - m, j.p.y + m, m, i)), v.push(new mh(j.p.x + m, j.p.y + m, m, i)), G += 4);
          }
          return r && (console.log(`num probes: ${G}`), console.log(`best distance: ${N.d}`)), N.p;
        }
        function PS(i, e) {
          return e.max - i.max;
        }
        function mh(i, e, r, c) {
          this.p = new R(i, e), this.h = r, this.d = (function(f, m) {
            let v = !1, E = 1 / 0;
            for (let k = 0; k < m.length; k++) {
              const P = m[k];
              for (let L = 0, N = P.length, G = N - 1; L < N; G = L++) {
                const j = P[L], Z = P[G];
                j.y > f.y != Z.y > f.y && f.x < (Z.x - j.x) * (f.y - j.y) / (Z.y - j.y) + j.x && (v = !v), E = Math.min(E, Sv(f, j, Z));
              }
            }
            return (v ? 1 : -1) * Math.sqrt(E);
          })(this.p, c), this.max = this.d + this.h * Math.SQRT2;
        }
        var Ci;
        T.aP = void 0, (Ci = T.aP || (T.aP = {}))[Ci.center = 1] = "center", Ci[Ci.left = 2] = "left", Ci[Ci.right = 3] = "right", Ci[Ci.top = 4] = "top", Ci[Ci.bottom = 5] = "bottom", Ci[Ci["top-left"] = 6] = "top-left", Ci[Ci["top-right"] = 7] = "top-right", Ci[Ci["bottom-left"] = 8] = "bottom-left", Ci[Ci["bottom-right"] = 9] = "bottom-right";
        const i_ = Number.POSITIVE_INFINITY;
        function bx(i, e) {
          return e[1] !== i_ ? (function(r, c, f) {
            let m = 0, v = 0;
            switch (c = Math.abs(c), f = Math.abs(f), r) {
              case "top-right":
              case "top-left":
              case "top":
                v = f - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                v = 7 - f;
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
              case "right":
                m = -c;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                m = c;
            }
            return [m, v];
          })(i, e[0], e[1]) : (function(r, c) {
            let f = 0, m = 0;
            c < 0 && (c = 0);
            const v = c / Math.SQRT2;
            switch (r) {
              case "top-right":
              case "top-left":
                m = v - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                m = 7 - v;
                break;
              case "bottom":
                m = 7 - c;
                break;
              case "top":
                m = c - 7;
            }
            switch (r) {
              case "top-right":
              case "bottom-right":
                f = -v;
                break;
              case "top-left":
              case "bottom-left":
                f = v;
                break;
              case "left":
                f = c;
                break;
              case "right":
                f = -c;
            }
            return [f, m];
          })(i, e[0]);
        }
        function wx(i, e, r) {
          var c;
          const f = i.layout, m = (c = f.get("text-variable-anchor-offset")) === null || c === void 0 ? void 0 : c.evaluate(e, {}, r);
          if (m) {
            const E = m.values, k = [];
            for (let P = 0; P < E.length; P += 2) {
              const L = k[P] = E[P], N = E[P + 1].map(((G) => G * ci));
              L.startsWith("top") ? N[1] -= 7 : L.startsWith("bottom") && (N[1] += 7), k[P + 1] = N;
            }
            return new si(k);
          }
          const v = f.get("text-variable-anchor");
          if (v) {
            let E;
            E = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [f.get("text-radial-offset").evaluate(e, {}, r) * ci, i_] : f.get("text-offset").evaluate(e, {}, r).map(((P) => P * ci));
            const k = [];
            for (const P of v) k.push(P, bx(P, E));
            return new si(k);
          }
          return null;
        }
        function s_(i) {
          switch (i) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function AS(i, e, r, c, f, m, v, E, k, P, L, N) {
          let G = m.textMaxSize.evaluate(e, {});
          G === void 0 && (G = v);
          const j = i.layers[0].layout, Z = j.get("icon-offset").evaluate(e, {}, L), Y = Tx(r.horizontal), X = v / 24, ne = i.tilePixelRatio * X, xe = i.tilePixelRatio * G / 24, ae = i.tilePixelRatio * E, ue = i.tilePixelRatio * j.get("symbol-spacing"), Te = j.get("text-padding") * i.tilePixelRatio, Ae = (function(Rt, Vt, Dt, Yt = 1) {
            const Sr = Rt.get("icon-padding").evaluate(Vt, {}, Dt), yr = Sr && Sr.values;
            return [yr[0] * Yt, yr[1] * Yt, yr[2] * Yt, yr[3] * Yt];
          })(j, e, L, i.tilePixelRatio), Ke = j.get("text-max-angle") / 180 * Math.PI, ht = j.get("text-rotation-alignment") !== "viewport" && j.get("symbol-placement") !== "point", lt = j.get("icon-rotation-alignment") === "map" && j.get("symbol-placement") !== "point", pt = j.get("symbol-placement"), Ct = ue / 2, _t = j.get("icon-text-fit");
          let ut;
          c && _t !== "none" && (i.allowVerticalPlacement && r.vertical && (ut = g0(c, r.vertical, _t, j.get("icon-text-fit-padding"), Z, X)), Y && (c = g0(c, Y, _t, j.get("icon-text-fit-padding"), Z, X)));
          const st = L ? N.line.getGranularityForZoomLevel(L.z) : 1, Bt = (Rt, Vt) => {
            Vt.x < 0 || Vt.x >= We || Vt.y < 0 || Vt.y >= We || (function(Dt, Yt, Sr, yr, cn, Pi, Zn, hn, an, Fr, Tn, Dn, Jr, ls, Ai, us, ua, fi, _n, Hn, Sn, pi, el, Na, Zd) {
              const Vl = Dt.addToLineVertexArray(Yt, Sr);
              let ec, _h, yh, vh, Mx = 0, Cx = 0, Px = 0, Ax = 0, f_ = -1, p_ = -1;
              const tl = {};
              let Lx = Ln("");
              if (Dt.allowVerticalPlacement && yr.vertical) {
                const Ui = hn.layout.get("text-rotate").evaluate(Sn, {}, Na) + 90;
                yh = new Up(an, Yt, Fr, Tn, Dn, yr.vertical, Jr, ls, Ai, Ui), Zn && (vh = new Up(an, Yt, Fr, Tn, Dn, Zn, ua, fi, Ai, Ui));
              }
              if (cn) {
                const Ui = hn.layout.get("icon-rotate").evaluate(Sn, {}), $s = hn.layout.get("icon-text-fit") !== "none", tc = vx(cn, Ui, el, $s), za = Zn ? vx(Zn, Ui, el, $s) : void 0;
                _h = new Up(an, Yt, Fr, Tn, Dn, cn, ua, fi, !1, Ui), Mx = 4 * tc.length;
                const rc = Dt.iconSizeData;
                let mo = null;
                rc.kind === "source" ? (mo = [Ko * hn.layout.get("icon-size").evaluate(Sn, {})], mo[0] > zl && ur(`${Dt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : rc.kind === "composite" && (mo = [Ko * pi.compositeIconSizes[0].evaluate(Sn, {}, Na), Ko * pi.compositeIconSizes[1].evaluate(Sn, {}, Na)], (mo[0] > zl || mo[1] > zl) && ur(`${Dt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Dt.addSymbols(Dt.icon, tc, mo, Hn, _n, Sn, T.az.none, Yt, Vl.lineStartIndex, Vl.lineLength, -1, Na), f_ = Dt.icon.placedSymbolArray.length - 1, za && (Cx = 4 * za.length, Dt.addSymbols(Dt.icon, za, mo, Hn, _n, Sn, T.az.vertical, Yt, Vl.lineStartIndex, Vl.lineLength, -1, Na), p_ = Dt.icon.placedSymbolArray.length - 1);
              }
              const Dx = Object.keys(yr.horizontal);
              for (const Ui of Dx) {
                const $s = yr.horizontal[Ui];
                if (!ec) {
                  Lx = Ln($s.text);
                  const za = hn.layout.get("text-rotate").evaluate(Sn, {}, Na);
                  ec = new Up(an, Yt, Fr, Tn, Dn, $s, Jr, ls, Ai, za);
                }
                const tc = $s.positionedLines.length === 1;
                if (Px += Ex(Dt, Yt, $s, Pi, hn, Ai, Sn, us, Vl, yr.vertical ? T.az.horizontal : T.az.horizontalOnly, tc ? Dx : [Ui], tl, f_, pi, Na), tc) break;
              }
              yr.vertical && (Ax += Ex(Dt, Yt, yr.vertical, Pi, hn, Ai, Sn, us, Vl, T.az.vertical, ["vertical"], tl, p_, pi, Na));
              const RS = ec ? ec.boxStartIndex : Dt.collisionBoxArray.length, FS = ec ? ec.boxEndIndex : Dt.collisionBoxArray.length, NS = yh ? yh.boxStartIndex : Dt.collisionBoxArray.length, OS = yh ? yh.boxEndIndex : Dt.collisionBoxArray.length, zS = _h ? _h.boxStartIndex : Dt.collisionBoxArray.length, BS = _h ? _h.boxEndIndex : Dt.collisionBoxArray.length, GS = vh ? vh.boxStartIndex : Dt.collisionBoxArray.length, jS = vh ? vh.boxEndIndex : Dt.collisionBoxArray.length;
              let Oa = -1;
              const $p = (Ui, $s) => Ui && Ui.circleDiameter ? Math.max(Ui.circleDiameter, $s) : $s;
              Oa = $p(ec, Oa), Oa = $p(yh, Oa), Oa = $p(_h, Oa), Oa = $p(vh, Oa);
              const Rx = Oa > -1 ? 1 : 0;
              Rx && (Oa *= Zd / ci), Dt.glyphOffsetArray.length >= ch.MAX_GLYPHS && ur("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Sn.sortKey !== void 0 && Dt.addToSortKeyRanges(Dt.symbolInstances.length, Sn.sortKey);
              const VS = wx(hn, Sn, Na), [US, qS] = (function(Ui, $s) {
                const tc = Ui.length, za = $s?.values;
                if (za?.length > 0) for (let rc = 0; rc < za.length; rc += 2) {
                  const mo = za[rc + 1];
                  Ui.emplaceBack(T.aP[za[rc]], mo[0], mo[1]);
                }
                return [tc, Ui.length];
              })(Dt.textAnchorOffsets, VS);
              Dt.symbolInstances.emplaceBack(Yt.x, Yt.y, tl.right >= 0 ? tl.right : -1, tl.center >= 0 ? tl.center : -1, tl.left >= 0 ? tl.left : -1, tl.vertical || -1, f_, p_, Lx, RS, FS, NS, OS, zS, BS, GS, jS, Fr, Px, Ax, Mx, Cx, Rx, 0, Jr, Oa, US, qS);
            })(i, Vt, Rt, r, c, f, ut, i.layers[0], i.collisionBoxArray, e.index, e.sourceLayerIndex, i.index, ne, [Te, Te, Te, Te], ht, k, ae, Ae, lt, Z, e, m, P, L, v);
          };
          if (pt === "line") for (const Rt of hx(e.geometry, 0, 0, We, We)) {
            const Vt = Xu(Rt, st), Dt = IS(Vt, ue, Ke, r.vertical || Y, c, 24, xe, i.overscaling, We);
            for (const Yt of Dt) Y && LS(i, Y.text, Ct, Yt) || Bt(Vt, Yt);
          }
          else if (pt === "line-center") {
            for (const Rt of e.geometry) if (Rt.length > 1) {
              const Vt = Xu(Rt, st), Dt = kS(Vt, Ke, r.vertical || Y, c, 24, xe);
              Dt && Bt(Vt, Dt);
            }
          } else if (e.type === "Polygon") for (const Rt of zo(e.geometry, 0)) {
            const Vt = CS(Rt, 16);
            Bt(Xu(Rt[0], st, !0), new jl(Vt.x, Vt.y, 0));
          }
          else if (e.type === "LineString") for (const Rt of e.geometry) {
            const Vt = Xu(Rt, st);
            Bt(Vt, new jl(Vt[0].x, Vt[0].y, 0));
          }
          else if (e.type === "Point") for (const Rt of e.geometry) for (const Vt of Rt) Bt([Vt], new jl(Vt.x, Vt.y, 0));
        }
        function Ex(i, e, r, c, f, m, v, E, k, P, L, N, G, j, Z) {
          const Y = (function(xe, ae, ue, Te, Ae, Ke, ht, lt) {
            const pt = Te.layout.get("text-rotate").evaluate(Ke, {}) * Math.PI / 180, Ct = [];
            for (const _t of ae.positionedLines) for (const ut of _t.positionedGlyphs) {
              if (!ut.rect) continue;
              const st = ut.rect || {};
              let Bt = 4, Rt = !0, Vt = 1, Dt = 0;
              const Yt = (Ae || lt) && ut.vertical, Sr = ut.metrics.advance * ut.scale / 2;
              if (lt && ae.verticalizable && (Dt = _t.lineOffset / 2 - (ut.imageName ? -(ci - ut.metrics.width * ut.scale) / 2 : (ut.scale - 1) * ci)), ut.imageName) {
                const fi = ht[ut.imageName];
                Rt = fi.sdf, Vt = fi.pixelRatio, Bt = 1 / Vt;
              }
              const yr = Ae ? [ut.x + Sr, ut.y] : [0, 0];
              let cn = Ae ? [0, 0] : [ut.x + Sr + ue[0], ut.y + ue[1] - Dt], Pi = [0, 0];
              Yt && (Pi = cn, cn = [0, 0]);
              const Zn = ut.metrics.isDoubleResolution ? 2 : 1, hn = (ut.metrics.left - Bt) * ut.scale - Sr + cn[0], an = (-ut.metrics.top - Bt) * ut.scale + cn[1], Fr = hn + st.w / Zn * ut.scale / Vt, Tn = an + st.h / Zn * ut.scale / Vt, Dn = new R(hn, an), Jr = new R(Fr, an), ls = new R(hn, Tn), Ai = new R(Fr, Tn);
              if (Yt) {
                const fi = new R(-Sr, Sr - -17), _n = -Math.PI / 2, Hn = 12 - Sr, Sn = new R(22 - Hn, -(ut.imageName ? Hn : 0)), pi = new R(...Pi);
                Dn._rotateAround(_n, fi)._add(Sn)._add(pi), Jr._rotateAround(_n, fi)._add(Sn)._add(pi), ls._rotateAround(_n, fi)._add(Sn)._add(pi), Ai._rotateAround(_n, fi)._add(Sn)._add(pi);
              }
              if (pt) {
                const fi = Math.sin(pt), _n = Math.cos(pt), Hn = [_n, -fi, fi, _n];
                Dn._matMult(Hn), Jr._matMult(Hn), ls._matMult(Hn), Ai._matMult(Hn);
              }
              const us = new R(0, 0), ua = new R(0, 0);
              Ct.push({ tl: Dn, tr: Jr, bl: ls, br: Ai, tex: st, writingMode: ae.writingMode, glyphOffset: yr, sectionIndex: ut.sectionIndex, isSDF: Rt, pixelOffsetTL: us, pixelOffsetBR: ua, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Ct;
          })(0, r, E, f, m, v, c, i.allowVerticalPlacement), X = i.textSizeData;
          let ne = null;
          X.kind === "source" ? (ne = [Ko * f.layout.get("text-size").evaluate(v, {})], ne[0] > zl && ur(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : X.kind === "composite" && (ne = [Ko * j.compositeTextSizes[0].evaluate(v, {}, Z), Ko * j.compositeTextSizes[1].evaluate(v, {}, Z)], (ne[0] > zl || ne[1] > zl) && ur(`${i.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), i.addSymbols(i.text, Y, ne, E, m, v, P, e, k.lineStartIndex, k.lineLength, G, Z);
          for (const xe of L) N[xe] = i.text.placedSymbolArray.length - 1;
          return 4 * Y.length;
        }
        function Tx(i) {
          for (const e in i) return i[e];
          return null;
        }
        function LS(i, e, r, c) {
          const f = i.compareText;
          if (e in f) {
            const m = f[e];
            for (let v = m.length - 1; v >= 0; v--) if (c.dist(m[v]) < r) return !0;
          } else f[e] = [];
          return f[e].push(c), !1;
        }
        const Sx = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class a_ {
          static from(e) {
            if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, c] = new Uint8Array(e, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const f = c >> 4;
            if (f !== 1) throw new Error(`Got v${f} data when expected v1.`);
            const m = Sx[15 & c];
            if (!m) throw new Error("Unrecognized array type.");
            const [v] = new Uint16Array(e, 2, 1), [E] = new Uint32Array(e, 4, 1);
            return new a_(E, v, m, e);
          }
          constructor(e, r = 64, c = Float64Array, f) {
            if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
            this.numItems = +e, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = c, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
            const m = Sx.indexOf(this.ArrayType), v = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, E = e * this.IndexArrayType.BYTES_PER_ELEMENT, k = (8 - E % 8) % 8;
            if (m < 0) throw new Error(`Unexpected typed array class: ${c}.`);
            f && f instanceof ArrayBuffer ? (this.data = f, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + E + k, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + v + E + k), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + E + k, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + m]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = e);
          }
          add(e, r) {
            const c = this._pos >> 1;
            return this.ids[c] = c, this.coords[this._pos++] = e, this.coords[this._pos++] = r, c;
          }
          finish() {
            const e = this._pos >> 1;
            if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
            return o_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(e, r, c, f) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: m, coords: v, nodeSize: E } = this, k = [0, m.length - 1, 0], P = [];
            for (; k.length; ) {
              const L = k.pop() || 0, N = k.pop() || 0, G = k.pop() || 0;
              if (N - G <= E) {
                for (let X = G; X <= N; X++) {
                  const ne = v[2 * X], xe = v[2 * X + 1];
                  ne >= e && ne <= c && xe >= r && xe <= f && P.push(m[X]);
                }
                continue;
              }
              const j = G + N >> 1, Z = v[2 * j], Y = v[2 * j + 1];
              Z >= e && Z <= c && Y >= r && Y <= f && P.push(m[j]), (L === 0 ? e <= Z : r <= Y) && (k.push(G), k.push(j - 1), k.push(1 - L)), (L === 0 ? c >= Z : f >= Y) && (k.push(j + 1), k.push(N), k.push(1 - L));
            }
            return P;
          }
          within(e, r, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: f, coords: m, nodeSize: v } = this, E = [0, f.length - 1, 0], k = [], P = c * c;
            for (; E.length; ) {
              const L = E.pop() || 0, N = E.pop() || 0, G = E.pop() || 0;
              if (N - G <= v) {
                for (let X = G; X <= N; X++) Ix(m[2 * X], m[2 * X + 1], e, r) <= P && k.push(f[X]);
                continue;
              }
              const j = G + N >> 1, Z = m[2 * j], Y = m[2 * j + 1];
              Ix(Z, Y, e, r) <= P && k.push(f[j]), (L === 0 ? e - c <= Z : r - c <= Y) && (E.push(G), E.push(j - 1), E.push(1 - L)), (L === 0 ? e + c >= Z : r + c >= Y) && (E.push(j + 1), E.push(N), E.push(1 - L));
            }
            return k;
          }
        }
        function o_(i, e, r, c, f, m) {
          if (f - c <= r) return;
          const v = c + f >> 1;
          kx(i, e, v, c, f, m), o_(i, e, r, c, v - 1, 1 - m), o_(i, e, r, v + 1, f, 1 - m);
        }
        function kx(i, e, r, c, f, m) {
          for (; f > c; ) {
            if (f - c > 600) {
              const P = f - c + 1, L = r - c + 1, N = Math.log(P), G = 0.5 * Math.exp(2 * N / 3), j = 0.5 * Math.sqrt(N * G * (P - G) / P) * (L - P / 2 < 0 ? -1 : 1);
              kx(i, e, r, Math.max(c, Math.floor(r - L * G / P + j)), Math.min(f, Math.floor(r + (P - L) * G / P + j)), m);
            }
            const v = e[2 * r + m];
            let E = c, k = f;
            for (qd(i, e, c, r), e[2 * f + m] > v && qd(i, e, c, f); E < k; ) {
              for (qd(i, e, E, k), E++, k--; e[2 * E + m] < v; ) E++;
              for (; e[2 * k + m] > v; ) k--;
            }
            e[2 * c + m] === v ? qd(i, e, c, k) : (k++, qd(i, e, k, f)), k <= r && (c = k + 1), r <= k && (f = k - 1);
          }
        }
        function qd(i, e, r, c) {
          l_(i, r, c), l_(e, 2 * r, 2 * c), l_(e, 2 * r + 1, 2 * c + 1);
        }
        function l_(i, e, r) {
          const c = i[e];
          i[e] = i[r], i[r] = c;
        }
        function Ix(i, e, r, c) {
          const f = i - r, m = e - c;
          return f * f + m * m;
        }
        var u_;
        T.cH = void 0, (u_ = T.cH || (T.cH = {})).create = "create", u_.load = "load", u_.fullLoad = "fullLoad";
        let qp = null, $d = [];
        const c_ = 1e3 / 60, h_ = "loadTime", d_ = "fullLoadTime", DS = { mark(i) {
          performance.mark(i);
        }, frame(i) {
          const e = i;
          qp != null && $d.push(e - qp), qp = e;
        }, clearMetrics() {
          qp = null, $d = [], performance.clearMeasures(h_), performance.clearMeasures(d_);
          for (const i in T.cH) performance.clearMarks(T.cH[i]);
        }, getPerformanceMetrics() {
          performance.measure(h_, T.cH.create, T.cH.load), performance.measure(d_, T.cH.create, T.cH.fullLoad);
          const i = performance.getEntriesByName(h_)[0].duration, e = performance.getEntriesByName(d_)[0].duration, r = $d.length, c = 1 / ($d.reduce(((m, v) => m + v), 0) / r / 1e3), f = $d.filter(((m) => m > c_)).reduce(((m, v) => m + (v - c_) / c_), 0);
          return { loadTime: i, fullLoadTime: e, fps: c, percentDroppedFrames: f / (r + f) * 100, totalFrames: r };
        } };
        T.$ = re, T.A = je, T.B = Ll, T.C = li, T.D = Zt, T.E = wr, T.F = function([i, e, r]) {
          return e += 90, e *= Math.PI / 180, r *= Math.PI / 180, { x: i * Math.cos(e) * Math.sin(r), y: i * Math.sin(e) * Math.sin(r), z: i * Math.cos(r) };
        }, T.G = Wr, T.H = Vr, T.I = Lm, T.J = lp, T.K = function(i) {
          if (Nr == null) {
            const e = i.navigator ? i.navigator.userAgent : null;
            Nr = !!i.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
          }
          return Nr;
        }, T.L = class {
          constructor(i, e) {
            this.target = i, this.mapId = e, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new YT((() => this.process())), this.subscription = Ks(this.target, "message", ((r) => this.receive(r)), !1), this.globalScope = mi(self) ? i : window;
          }
          registerMessageHandler(i, e) {
            this.messageHandlers[i] = e;
          }
          unregisterMessageHandler(i) {
            delete this.messageHandlers[i];
          }
          sendAsync(i, e) {
            return new Promise(((r, c) => {
              const f = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), m = e ? Ks(e.signal, "abort", (() => {
                m?.unsubscribe(), delete this.resolveRejects[f];
                const k = { id: f, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(k);
              }), WT) : null;
              this.resolveRejects[f] = { resolve: (k) => {
                m?.unsubscribe(), r(k);
              }, reject: (k) => {
                m?.unsubscribe(), c(k);
              } };
              const v = [], E = Object.assign(Object.assign({}, i), { id: f, sourceMapId: this.mapId, origin: location.origin, data: Nu(i.data, v) });
              this.target.postMessage(E, { transfer: v });
            }));
          }
          receive(i) {
            const e = i.data, r = e.id;
            if (!(e.origin !== "file://" && location.origin !== "file://" && e.origin !== "resource://android" && location.origin !== "resource://android" && e.origin !== location.origin || e.targetMapId && this.mapId !== e.targetMapId)) {
              if (e.type === "<cancel>") {
                delete this.tasks[r];
                const c = this.abortControllers[r];
                return delete this.abortControllers[r], void (c && c.abort());
              }
              if (mi(self) || e.mustQueue) return this.tasks[r] = e, this.taskQueue.push(r), void this.invoker.trigger();
              this.processTask(r, e);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const i = this.taskQueue.shift(), e = this.tasks[i];
            delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), e && this.processTask(i, e);
          }
          processTask(i, e) {
            return u(this, void 0, void 0, (function* () {
              if (e.type === "<response>") {
                const f = this.resolveRejects[i];
                return delete this.resolveRejects[i], f ? void (e.error ? f.reject(Ou(e.error)) : f.resolve(Ou(e.data))) : void 0;
              }
              if (!this.messageHandlers[e.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${e.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const r = Ou(e.data), c = new AbortController();
              this.abortControllers[i] = c;
              try {
                const f = yield this.messageHandlers[e.type](e.sourceMapId, r, c);
                this.completeTask(i, null, f);
              } catch (f) {
                this.completeTask(i, f);
              }
            }));
          }
          completeTask(i, e, r) {
            const c = [];
            delete this.abortControllers[i];
            const f = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e ? Nu(e) : null, data: Nu(r, c) };
            this.target.postMessage(f, { transfer: c });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, T.M = qe, T.N = function() {
          var i = new je(16);
          return je != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
        }, T.O = function(i, e, r) {
          var c, f, m, v, E, k, P, L, N, G, j, Z, Y = r[0], X = r[1], ne = r[2];
          return e === i ? (i[12] = e[0] * Y + e[4] * X + e[8] * ne + e[12], i[13] = e[1] * Y + e[5] * X + e[9] * ne + e[13], i[14] = e[2] * Y + e[6] * X + e[10] * ne + e[14], i[15] = e[3] * Y + e[7] * X + e[11] * ne + e[15]) : (f = e[1], m = e[2], v = e[3], E = e[4], k = e[5], P = e[6], L = e[7], N = e[8], G = e[9], j = e[10], Z = e[11], i[0] = c = e[0], i[1] = f, i[2] = m, i[3] = v, i[4] = E, i[5] = k, i[6] = P, i[7] = L, i[8] = N, i[9] = G, i[10] = j, i[11] = Z, i[12] = c * Y + E * X + N * ne + e[12], i[13] = f * Y + k * X + G * ne + e[13], i[14] = m * Y + P * X + j * ne + e[14], i[15] = v * Y + L * X + Z * ne + e[15]), i;
        }, T.P = R, T.Q = function(i, e, r) {
          var c = r[0], f = r[1], m = r[2];
          return i[0] = e[0] * c, i[1] = e[1] * c, i[2] = e[2] * c, i[3] = e[3] * c, i[4] = e[4] * f, i[5] = e[5] * f, i[6] = e[6] * f, i[7] = e[7] * f, i[8] = e[8] * m, i[9] = e[9] * m, i[10] = e[10] * m, i[11] = e[11] * m, i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
        }, T.R = os, T.S = function(i, e, r) {
          var c = e[0], f = e[1], m = e[2], v = e[3], E = e[4], k = e[5], P = e[6], L = e[7], N = e[8], G = e[9], j = e[10], Z = e[11], Y = e[12], X = e[13], ne = e[14], xe = e[15], ae = r[0], ue = r[1], Te = r[2], Ae = r[3];
          return i[0] = ae * c + ue * E + Te * N + Ae * Y, i[1] = ae * f + ue * k + Te * G + Ae * X, i[2] = ae * m + ue * P + Te * j + Ae * ne, i[3] = ae * v + ue * L + Te * Z + Ae * xe, i[4] = (ae = r[4]) * c + (ue = r[5]) * E + (Te = r[6]) * N + (Ae = r[7]) * Y, i[5] = ae * f + ue * k + Te * G + Ae * X, i[6] = ae * m + ue * P + Te * j + Ae * ne, i[7] = ae * v + ue * L + Te * Z + Ae * xe, i[8] = (ae = r[8]) * c + (ue = r[9]) * E + (Te = r[10]) * N + (Ae = r[11]) * Y, i[9] = ae * f + ue * k + Te * G + Ae * X, i[10] = ae * m + ue * P + Te * j + Ae * ne, i[11] = ae * v + ue * L + Te * Z + Ae * xe, i[12] = (ae = r[12]) * c + (ue = r[13]) * E + (Te = r[14]) * N + (Ae = r[15]) * Y, i[13] = ae * f + ue * k + Te * G + Ae * X, i[14] = ae * m + ue * P + Te * j + Ae * ne, i[15] = ae * v + ue * L + Te * Z + Ae * xe, i;
        }, T.T = Em, T.U = function(i, e) {
          const r = {};
          for (let c = 0; c < e.length; c++) {
            const f = e[c];
            f in i && (r[f] = i[f]);
          }
          return r;
        }, T.V = Bl, T.W = gr, T.X = T0, T.Y = E0, T.Z = be, T._ = u, T.a = le, T.a$ = ge, T.a0 = Pe, T.a1 = $i, T.a2 = Us, T.a3 = k0, T.a4 = Lp, T.a5 = We, T.a6 = function(i, e, r) {
          if (!i) return e || {};
          if (!e) return i || {};
          const c = P0(i), f = P0(e);
          (function(v, E) {
            E.removeAll && (v.add.clear(), v.update.clear(), v.remove.clear(), E.remove.clear());
            for (const k of E.remove) v.add.delete(k), v.update.delete(k);
            for (const [k, P] of E.update) {
              const L = v.update.get(k);
              L && (E.update.set(k, XT(L, P)), v.update.delete(k));
            }
          })(c, f);
          const m = {};
          if ((c.removeAll || f.removeAll) && (m.removeAll = !0), m.remove = /* @__PURE__ */ new Set([...c.remove, ...f.remove]), m.add = new Map([...c.add, ...f.add]), m.update = new Map([...c.update, ...f.update]), m.remove.size && m.add.size) for (const v of m.add.keys()) m.remove.delete(v);
          return (function(v) {
            const E = {};
            return v.removeAll && (E.removeAll = v.removeAll), v.remove && (E.remove = Array.from(v.remove)), v.add && (E.add = Array.from(v.add.values())), v.update && (E.update = Array.from(v.update.values())), E;
          })(m);
        }, T.a7 = function(i, e) {
          const r = /* @__PURE__ */ new Map();
          if (i == null || i.type == null) return r;
          if (i.type === "Feature") {
            const c = jm(i, e);
            return c == null ? void 0 : (r.set(c, i), r);
          }
          if (i.type === "FeatureCollection") {
            const c = /* @__PURE__ */ new Set();
            for (const f of i.features) {
              const m = jm(f, e);
              if (m == null || c.has(m)) return;
              c.add(m), r.set(m, f);
            }
            return r;
          }
        }, T.a8 = function(i, e, r) {
          var c, f;
          const m = [];
          if (e.removeAll) i.clear();
          else if (e.remove) for (const v of e.remove) {
            const E = i.get(v);
            E && (m.push(E.geometry), i.delete(v));
          }
          if (e.add) for (const v of e.add) {
            const E = jm(v, r);
            if (E == null) continue;
            const k = i.get(E);
            k && m.push(k.geometry), m.push(v.geometry), i.set(E, v);
          }
          if (e.update) for (const v of e.update) {
            const E = i.get(v.id);
            if (!E) continue;
            const k = !!v.newGeometry, P = v.removeAllProperties || ((c = v.removeProperties) === null || c === void 0 ? void 0 : c.length) > 0 || ((f = v.addOrUpdateProperties) === null || f === void 0 ? void 0 : f.length) > 0;
            if (!k && !P) continue;
            m.push(E.geometry);
            const L = Object.assign({}, E);
            if (i.set(v.id, L), k && (m.push(v.newGeometry), L.geometry = v.newGeometry), P) {
              if (L.properties = v.removeAllProperties ? {} : Object.assign({}, L.properties || {}), v.removeProperties) for (const N of v.removeProperties) delete L.properties[N];
              if (v.addOrUpdateProperties) for (const { key: N, value: G } of v.addOrUpdateProperties) L.properties[N] = G;
            }
          }
          return m;
        }, T.a9 = Gd, T.aA = function(i, { uSize: e, uSizeT: r }, { lowerSize: c, upperSize: f }) {
          return i.kind === "source" ? c / Ko : i.kind === "composite" ? Wr.number(c / Ko, f / Ko, r) : e;
        }, T.aB = function(i, e) {
          var r = e[0], c = e[1], f = e[2], m = e[3], v = e[4], E = e[5], k = e[6], P = e[7], L = e[8], N = e[9], G = e[10], j = e[11], Z = e[12], Y = e[13], X = e[14], ne = e[15], xe = r * E - c * v, ae = r * k - f * v, ue = r * P - m * v, Te = c * k - f * E, Ae = c * P - m * E, Ke = f * P - m * k, ht = L * Y - N * Z, lt = L * X - G * Z, pt = L * ne - j * Z, Ct = N * X - G * Y, _t = N * ne - j * Y, ut = G * ne - j * X, st = xe * ut - ae * _t + ue * Ct + Te * pt - Ae * lt + Ke * ht;
          return st ? (i[0] = (E * ut - k * _t + P * Ct) * (st = 1 / st), i[1] = (f * _t - c * ut - m * Ct) * st, i[2] = (Y * Ke - X * Ae + ne * Te) * st, i[3] = (G * Ae - N * Ke - j * Te) * st, i[4] = (k * pt - v * ut - P * lt) * st, i[5] = (r * ut - f * pt + m * lt) * st, i[6] = (X * ue - Z * Ke - ne * ae) * st, i[7] = (L * Ke - G * ue + j * ae) * st, i[8] = (v * _t - E * pt + P * ht) * st, i[9] = (c * pt - r * _t - m * ht) * st, i[10] = (Z * Ae - Y * ue + ne * xe) * st, i[11] = (N * ue - L * Ae - j * xe) * st, i[12] = (E * lt - v * Ct - k * ht) * st, i[13] = (r * Ct - c * lt + f * ht) * st, i[14] = (Y * ae - Z * Te - X * xe) * st, i[15] = (L * Te - N * ae + G * xe) * st, i) : null;
        }, T.aC = Ue, T.aD = function(i) {
          var e = i[0], r = i[1];
          return Math.sqrt(e * e + r * r);
        }, T.aE = function(i) {
          return i[0] = 0, i[1] = 0, i;
        }, T.aF = function(i, e, r) {
          return i[0] = e[0] * r, i[1] = e[1] * r, i;
        }, T.aG = Fm, T.aH = Re, T.aI = function(i, e, r, c) {
          const f = e.y - i.y, m = e.x - i.x, v = c.y - r.y, E = c.x - r.x, k = v * m - E * f;
          if (k === 0) return null;
          const P = (E * (i.y - r.y) - v * (i.x - r.x)) / k;
          return new R(i.x + P * m, i.y + P * f);
        }, T.aJ = hx, T.aK = rh, T.aL = function(i) {
          let e = 1 / 0, r = 1 / 0, c = -1 / 0, f = -1 / 0;
          for (const m of i) e = Math.min(e, m.x), r = Math.min(r, m.y), c = Math.max(c, m.x), f = Math.max(f, m.y);
          return [e, r, c, f];
        }, T.aM = ci, T.aN = dt, T.aO = function(i, e, r, c, f = !1) {
          if (!r[0] && !r[1]) return [0, 0];
          const m = f ? c === "map" ? -i.bearingInRadians : 0 : c === "viewport" ? i.bearingInRadians : 0;
          if (m) {
            const v = Math.sin(m), E = Math.cos(m);
            r = [r[0] * E - r[1] * v, r[0] * v + r[1] * E];
          }
          return [f ? r[0] : dt(e, r[0], i.zoom), f ? r[1] : dt(e, r[1], i.zoom)];
        }, T.aQ = Rm, T.aR = s_, T.aS = Dm, T.aT = a_, T.aU = An, T.aV = kp, T.aW = he, T.aX = At, T.aY = it, T.aZ = Kr, T.a_ = I0, T.aa = Ju, T.ab = 25, T.ac = Gm, T.ad = (i) => {
          const e = window.document.createElement("video");
          return e.muted = !0, new Promise(((r) => {
            e.onloadstart = () => {
              r(e);
            };
            for (const c of i) {
              const f = window.document.createElement("source");
              ct(c) || (e.crossOrigin = "Anonymous"), f.src = c, e.appendChild(f);
            }
          }));
        }, T.ae = yt, T.af = function() {
          return ri++;
        }, T.ag = g, T.ah = ch, T.ai = Ud, T.aj = Iu, T.ak = go, T.al = L0, T.am = function(i) {
          const e = {};
          if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((r, c, f, m) => {
            const v = f || m;
            return e[c] = !v || v.toLowerCase(), "";
          })), e["max-age"]) {
            const r = parseInt(e["max-age"], 10);
            isNaN(r) ? delete e["max-age"] : e["max-age"] = r;
          }
          return e;
        }, T.an = Kt, T.ao = 85.051129, T.ap = er, T.aq = function(i) {
          return Math.pow(2, i);
        }, T.ar = et, T.as = S0, T.at = function(i) {
          return Math.log(i) / Math.LN2;
        }, T.au = function(i) {
          var e = i[0], r = i[1];
          return e * e + r * r;
        }, T.av = function(i) {
          if (!i.length) return /* @__PURE__ */ new Set();
          const e = Math.max(...i.map(((k) => k.canonical.z)));
          let r = 1 / 0, c = -1 / 0, f = 1 / 0, m = -1 / 0;
          const v = [];
          for (const k of i) {
            const { x: P, y: L, z: N } = k.canonical, G = Math.pow(2, e - N), j = P * G, Z = L * G;
            v.push({ id: k, x: j, y: Z }), j < r && (r = j), j > c && (c = j), Z < f && (f = Z), Z > m && (m = Z);
          }
          const E = /* @__PURE__ */ new Set();
          for (const k of v) k.x !== r && k.x !== c && k.y !== f && k.y !== m || E.add(k.id);
          return E;
        }, T.aw = function(i, e) {
          const r = Math.abs(2 * i.wrap) - +(i.wrap < 0), c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return i.overscaledZ - e.overscaledZ || c - r || e.canonical.y - i.canonical.y || e.canonical.x - i.canonical.x;
        }, T.ax = class {
          constructor(i, e) {
            this.max = i, this.onRemove = e, this.reset();
          }
          reset() {
            for (const i in this.data) for (const e of this.data[i]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);
            return this.data = {}, this.order = [], this;
          }
          add(i, e, r) {
            const c = i.wrapped().key;
            this.data[c] === void 0 && (this.data[c] = []);
            const f = { value: e, timeout: void 0 };
            if (r !== void 0 && (f.timeout = setTimeout((() => {
              this.remove(i, f);
            }), r)), this.data[c].push(f), this.order.push(c), this.order.length > this.max) {
              const m = this._getAndRemoveByKey(this.order[0]);
              m && this.onRemove(m);
            }
            return this;
          }
          has(i) {
            return i.wrapped().key in this.data;
          }
          getAndRemove(i) {
            return this.has(i) ? this._getAndRemoveByKey(i.wrapped().key) : null;
          }
          _getAndRemoveByKey(i) {
            const e = this.data[i].shift();
            return e.timeout && clearTimeout(e.timeout), this.data[i].length === 0 && delete this.data[i], this.order.splice(this.order.indexOf(i), 1), e.value;
          }
          getByKey(i) {
            const e = this.data[i];
            return e ? e[0].value : null;
          }
          get(i) {
            return this.has(i) ? this.data[i.wrapped().key][0].value : null;
          }
          remove(i, e) {
            if (!this.has(i)) return this;
            const r = i.wrapped().key, c = e === void 0 ? 0 : this.data[r].indexOf(e), f = this.data[r][c];
            return this.data[r].splice(c, 1), f.timeout && clearTimeout(f.timeout), this.data[r].length === 0 && delete this.data[r], this.onRemove(f.value), this.order.splice(this.order.indexOf(r), 1), this;
          }
          setMaxSize(i) {
            for (this.max = i; this.order.length > this.max; ) {
              const e = this._getAndRemoveByKey(this.order[0]);
              e && this.onRemove(e);
            }
            return this;
          }
          filter(i) {
            const e = [];
            for (const r in this.data) for (const c of this.data[r]) i(c.value) || e.push(c);
            for (const r of e) this.remove(r.value.tileID, r);
          }
        }, T.ay = function(i, e) {
          let r = 0, c = 0;
          if (i.kind === "constant") c = i.layoutSize;
          else if (i.kind !== "source") {
            const { interpolationType: f, minZoom: m, maxZoom: v } = i, E = f ? Kt(xi.interpolationFactor(f, e, m, v), 0, 1) : 0;
            i.kind === "camera" ? c = Wr.number(i.minSize, i.maxSize, E) : r = E;
          }
          return { uSizeT: r, uSize: c };
        }, T.b = _i, T.b$ = Xo, T.b0 = ie, T.b1 = function(i) {
          var e = new je(3);
          return e[0] = i[0], e[1] = i[1], e[2] = i[2], e;
        }, T.b2 = function(i, e, r) {
          return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], i;
        }, T.b3 = function(i, e) {
          var r = e[0], c = e[1], f = e[2], m = r * r + c * c + f * f;
          return m > 0 && (m = 1 / Math.sqrt(m)), i[0] = e[0] * m, i[1] = e[1] * m, i[2] = e[2] * m, i;
        }, T.b4 = Se, T.b5 = function(i, e) {
          return i[0] * e[0] + i[1] * e[1] + i[2] * e[2];
        }, T.b6 = function(i, e, r) {
          return i[0] = e[0] * r[0], i[1] = e[1] * r[1], i[2] = e[2] * r[2], i[3] = e[3] * r[3], i;
        }, T.b7 = ot, T.b8 = function(i, e, r) {
          const c = e[0] * r[0] + e[1] * r[1] + e[2] * r[2];
          return c === 0 ? null : (-(i[0] * r[0] + i[1] * r[1] + i[2] * r[2]) - r[3]) / c;
        }, T.b9 = Oe, T.bA = function(i, e, r, c) {
          return i[0] = e[0] + r[0] * c, i[1] = e[1] + r[1] * c, i[2] = e[2] + r[2] * c, i;
        }, T.bB = Fe, T.bC = function(i, e, r) {
          var c = r[0], f = r[1], m = r[2], v = r[3], E = e[0], k = e[1], P = e[2], L = f * P - m * k, N = m * E - c * P, G = c * k - f * E;
          return i[0] = E + v * (L += L) + f * (G += G) - m * (N += N), i[1] = k + v * N + m * L - c * G, i[2] = P + v * G + c * N - f * L, i;
        }, T.bD = function(i, e, r) {
          const c = (function(k) {
            var P = k[3], L = k[4], N = k[5], G = k[6], j = k[7], Z = k[8];
            return k[0] * (Z * L - N * j) + k[1] * (-Z * P + N * G) + k[2] * (j * P - L * G);
          })([i[0], i[1], i[2], e[0], e[1], e[2], r[0], r[1], r[2]]);
          if (c === 0) return null;
          const f = Se([], [e[0], e[1], e[2]], [r[0], r[1], r[2]]), m = Se([], [r[0], r[1], r[2]], [i[0], i[1], i[2]]), v = Se([], [i[0], i[1], i[2]], [e[0], e[1], e[2]]), E = ge([], f, -i[3]);
          return ie(E, E, ge([], m, -e[3])), ie(E, E, ge([], v, -r[3])), ge(E, E, 1 / c), E;
        }, T.bE = Bm, T.bF = function() {
          return new Float64Array(4);
        }, T.bG = function(i, e, r, c) {
          var f = [], m = [];
          return f[0] = e[0] - r[0], f[1] = e[1] - r[1], f[2] = e[2] - r[2], m[0] = f[0] * Math.cos(c) - f[1] * Math.sin(c), m[1] = f[0] * Math.sin(c) + f[1] * Math.cos(c), m[2] = f[2], i[0] = m[0] + r[0], i[1] = m[1] + r[1], i[2] = m[2] + r[2], i;
        }, T.bH = function(i, e, r, c) {
          var f = [], m = [];
          return f[0] = e[0] - r[0], f[1] = e[1] - r[1], f[2] = e[2] - r[2], m[0] = f[0], m[1] = f[1] * Math.cos(c) - f[2] * Math.sin(c), m[2] = f[1] * Math.sin(c) + f[2] * Math.cos(c), i[0] = m[0] + r[0], i[1] = m[1] + r[1], i[2] = m[2] + r[2], i;
        }, T.bI = function(i, e, r, c) {
          var f = [], m = [];
          return f[0] = e[0] - r[0], f[1] = e[1] - r[1], f[2] = e[2] - r[2], m[0] = f[2] * Math.sin(c) + f[0] * Math.cos(c), m[1] = f[1], m[2] = f[2] * Math.cos(c) - f[0] * Math.sin(c), i[0] = m[0] + r[0], i[1] = m[1] + r[1], i[2] = m[2] + r[2], i;
        }, T.bJ = function(i, e, r) {
          var c = Math.sin(r), f = Math.cos(r), m = e[0], v = e[1], E = e[2], k = e[3], P = e[8], L = e[9], N = e[10], G = e[11];
          return e !== i && (i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[0] = m * f - P * c, i[1] = v * f - L * c, i[2] = E * f - N * c, i[3] = k * f - G * c, i[8] = m * c + P * f, i[9] = v * c + L * f, i[10] = E * c + N * f, i[11] = k * c + G * f, i;
        }, T.bK = function(i, e) {
          const r = Tt(i, 360), c = Tt(e, 360), f = c - r, m = c > r ? f - 360 : f + 360;
          return Math.abs(f) < Math.abs(m) ? f : m;
        }, T.bL = function(i) {
          return i[0] = 0, i[1] = 0, i[2] = 0, i;
        }, T.bM = function(i, e, r, c) {
          const f = Math.sqrt(i * i + e * e), m = Math.sqrt(r * r + c * c);
          i /= f, e /= f, r /= m, c /= m;
          const v = Math.acos(i * r + e * c);
          return -e * r + i * c > 0 ? v : -v;
        }, T.bN = function(i, e) {
          const r = Tt(i, 2 * Math.PI), c = Tt(e, 2 * Math.PI);
          return Math.min(Math.abs(r - c), Math.abs(r - c + 2 * Math.PI), Math.abs(r - c - 2 * Math.PI));
        }, T.bO = function() {
          const i = {}, e = Xe.$version;
          for (const r in Xe.$root) {
            const c = Xe.$root[r];
            if (c.required) {
              let f = null;
              f = r === "version" ? e : c.type === "array" ? [] : {}, f != null && (i[r] = f);
            }
          }
          return i;
        }, T.bP = ze, T.bQ = fd, T.bR = function i(e, r) {
          if (Array.isArray(e)) {
            if (!Array.isArray(r) || e.length !== r.length) return !1;
            for (let c = 0; c < e.length; c++) if (!i(e[c], r[c])) return !1;
            return !0;
          }
          if (typeof e == "object" && e !== null && r !== null) {
            if (typeof r != "object" || Object.keys(e).length !== Object.keys(r).length) return !1;
            for (const c in e) if (!i(e[c], r[c])) return !1;
            return !0;
          }
          return e === r;
        }, T.bS = function(i) {
          i = i.slice();
          const e = /* @__PURE__ */ Object.create(null);
          for (let r = 0; r < i.length; r++) e[i[r].id] = i[r];
          for (let r = 0; r < i.length; r++) "ref" in i[r] && (i[r] = Mn(i[r], e[i[r].ref]));
          return i;
        }, T.bT = function(i, e) {
          if (i.type === "custom") return new HT(i, e);
          switch (i.type) {
            case "background":
              return new ZT(i, e);
            case "circle":
              return new PE(i, e);
            case "color-relief":
              return new NE(i, e);
            case "fill":
              return new JE(i, e);
            case "fill-extrusion":
              return new uT(i, e);
            case "heatmap":
              return new LE(i, e);
            case "hillshade":
              return new RE(i, e);
            case "line":
              return new mT(i, e);
            case "raster":
              return new pm(i, e);
            case "symbol":
              return new Ap(i, e);
          }
        }, T.bU = (i) => i.type === "raster", T.bV = Me, T.bW = function(i, e) {
          if (!i) return [{ command: "setStyle", args: [e] }];
          let r = [];
          try {
            if (!qt(i.version, e.version)) return [{ command: "setStyle", args: [e] }];
            qt(i.center, e.center) || r.push({ command: "setCenter", args: [e.center] }), qt(i.state, e.state) || r.push({ command: "setGlobalState", args: [e.state] }), qt(i.centerAltitude, e.centerAltitude) || r.push({ command: "setCenterAltitude", args: [e.centerAltitude] }), qt(i.zoom, e.zoom) || r.push({ command: "setZoom", args: [e.zoom] }), qt(i.bearing, e.bearing) || r.push({ command: "setBearing", args: [e.bearing] }), qt(i.pitch, e.pitch) || r.push({ command: "setPitch", args: [e.pitch] }), qt(i.roll, e.roll) || r.push({ command: "setRoll", args: [e.roll] }), qt(i.sprite, e.sprite) || r.push({ command: "setSprite", args: [e.sprite] }), qt(i.glyphs, e.glyphs) || r.push({ command: "setGlyphs", args: [e.glyphs] }), qt(i.transition, e.transition) || r.push({ command: "setTransition", args: [e.transition] }), qt(i.light, e.light) || r.push({ command: "setLight", args: [e.light] }), qt(i.terrain, e.terrain) || r.push({ command: "setTerrain", args: [e.terrain] }), qt(i.sky, e.sky) || r.push({ command: "setSky", args: [e.sky] }), qt(i.projection, e.projection) || r.push({ command: "setProjection", args: [e.projection] });
            const c = {}, f = [];
            (function(v, E, k, P) {
              let L;
              for (L in E = E || {}, v = v || {}) Object.prototype.hasOwnProperty.call(v, L) && (Object.prototype.hasOwnProperty.call(E, L) || Ir(L, k, P));
              for (L in E) Object.prototype.hasOwnProperty.call(E, L) && (Object.prototype.hasOwnProperty.call(v, L) ? qt(v[L], E[L]) || (v[L].type === "geojson" && E[L].type === "geojson" && Mr(v, E, L) ? mt(k, { command: "setGeoJSONSourceData", args: [L, E[L].data] }) : Pr(L, E, k, P)) : fn(L, E, k));
            })(i.sources, e.sources, f, c);
            const m = [];
            i.layers && i.layers.forEach(((v) => {
              "source" in v && c[v.source] ? r.push({ command: "removeLayer", args: [v.id] }) : m.push(v);
            })), r = r.concat(f), (function(v, E, k) {
              E = E || [];
              const P = (v = v || []).map(Qs), L = E.map(Qs), N = v.reduce(Rn, {}), G = E.reduce(Rn, {}), j = P.slice(), Z = /* @__PURE__ */ Object.create(null);
              let Y, X, ne, xe, ae;
              for (let ue = 0, Te = 0; ue < P.length; ue++) Y = P[ue], Object.prototype.hasOwnProperty.call(G, Y) ? Te++ : (mt(k, { command: "removeLayer", args: [Y] }), j.splice(j.indexOf(Y, Te), 1));
              for (let ue = 0, Te = 0; ue < L.length; ue++) Y = L[L.length - 1 - ue], j[j.length - 1 - ue] !== Y && (Object.prototype.hasOwnProperty.call(N, Y) ? (mt(k, { command: "removeLayer", args: [Y] }), j.splice(j.lastIndexOf(Y, j.length - Te), 1)) : Te++, xe = j[j.length - ue], mt(k, { command: "addLayer", args: [G[Y], xe] }), j.splice(j.length - ue, 0, Y), Z[Y] = !0);
              for (let ue = 0; ue < L.length; ue++) if (Y = L[ue], X = N[Y], ne = G[Y], !Z[Y] && !qt(X, ne)) if (qt(X.source, ne.source) && qt(X["source-layer"], ne["source-layer"]) && qt(X.type, ne.type)) {
                for (ae in Yr(X.layout, ne.layout, k, Y, null, "setLayoutProperty"), Yr(X.paint, ne.paint, k, Y, null, "setPaintProperty"), qt(X.filter, ne.filter) || mt(k, { command: "setFilter", args: [Y, ne.filter] }), qt(X.minzoom, ne.minzoom) && qt(X.maxzoom, ne.maxzoom) || mt(k, { command: "setLayerZoomRange", args: [Y, ne.minzoom, ne.maxzoom] }), X) Object.prototype.hasOwnProperty.call(X, ae) && ae !== "layout" && ae !== "paint" && ae !== "filter" && ae !== "metadata" && ae !== "minzoom" && ae !== "maxzoom" && (ae.indexOf("paint.") === 0 ? Yr(X[ae], ne[ae], k, Y, ae.slice(6), "setPaintProperty") : qt(X[ae], ne[ae]) || mt(k, { command: "setLayerProperty", args: [Y, ae, ne[ae]] }));
                for (ae in ne) Object.prototype.hasOwnProperty.call(ne, ae) && !Object.prototype.hasOwnProperty.call(X, ae) && ae !== "layout" && ae !== "paint" && ae !== "filter" && ae !== "metadata" && ae !== "minzoom" && ae !== "maxzoom" && (ae.indexOf("paint.") === 0 ? Yr(X[ae], ne[ae], k, Y, ae.slice(6), "setPaintProperty") : qt(X[ae], ne[ae]) || mt(k, { command: "setLayerProperty", args: [Y, ae, ne[ae]] }));
              } else mt(k, { command: "removeLayer", args: [Y] }), xe = j[j.lastIndexOf(Y) + 1], mt(k, { command: "addLayer", args: [ne, xe] });
            })(m, e.layers, r);
          } catch (c) {
            console.warn("Unable to compute style diff:", c), r = [{ command: "setStyle", args: [e] }];
          }
          return r;
        }, T.bX = function(i) {
          const e = [], r = i.id;
          return r === void 0 && e.push({ message: `layers.${r}: missing required property "id"` }), i.render === void 0 && e.push({ message: `layers.${r}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && e.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), e;
        }, T.bY = lr, T.bZ = Ut, T.b_ = class extends Ji {
          constructor(i, e) {
            super(i, e), this.current = 0;
          }
          set(i) {
            this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
          }
        }, T.ba = function(i, e, r) {
          return i[0] = e[0] * r, i[1] = e[1] * r, i[2] = e[2] * r, i[3] = e[3] * r, i;
        }, T.bb = function(i, e) {
          return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3];
        }, T.bc = C0, T.bd = hh, T.be = function(i, e, r, c, f) {
          var m = 1 / Math.tan(e / 2);
          if (i[0] = m / r, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = m, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, f != null && f !== 1 / 0) {
            var v = 1 / (c - f);
            i[10] = (f + c) * v, i[14] = 2 * f * c * v;
          } else i[10] = -1, i[14] = -2 * c;
          return i;
        }, T.bf = function(i) {
          var e = new je(16);
          return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], e;
        }, T.bg = function(i, e, r) {
          var c = Math.sin(r), f = Math.cos(r), m = e[0], v = e[1], E = e[2], k = e[3], P = e[4], L = e[5], N = e[6], G = e[7];
          return e !== i && (i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[0] = m * f + P * c, i[1] = v * f + L * c, i[2] = E * f + N * c, i[3] = k * f + G * c, i[4] = P * f - m * c, i[5] = L * f - v * c, i[6] = N * f - E * c, i[7] = G * f - k * c, i;
        }, T.bh = function(i, e, r) {
          var c = Math.sin(r), f = Math.cos(r), m = e[4], v = e[5], E = e[6], k = e[7], P = e[8], L = e[9], N = e[10], G = e[11];
          return e !== i && (i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[4] = m * f + P * c, i[5] = v * f + L * c, i[6] = E * f + N * c, i[7] = k * f + G * c, i[8] = P * f - m * c, i[9] = L * f - v * c, i[10] = N * f - E * c, i[11] = G * f - k * c, i;
        }, T.bi = function() {
          const i = new Float32Array(16);
          return et(i), i;
        }, T.bj = function() {
          const i = new Float64Array(16);
          return et(i), i;
        }, T.bk = function() {
          return new Float64Array(16);
        }, T.bl = function(i, e, r) {
          const c = new Float64Array(4);
          return Fe(c, i, e - 90, r), c;
        }, T.bm = function(i, e, r, c) {
          var f, m, v, E, k, P = e[0], L = e[1], N = e[2], G = e[3], j = r[0], Z = r[1], Y = r[2], X = r[3];
          return (m = P * j + L * Z + N * Y + G * X) < 0 && (m = -m, j = -j, Z = -Z, Y = -Y, X = -X), 1 - m > _e ? (f = Math.acos(m), v = Math.sin(f), E = Math.sin((1 - c) * f) / v, k = Math.sin(c * f) / v) : (E = 1 - c, k = c), i[0] = E * P + k * j, i[1] = E * L + k * Z, i[2] = E * N + k * Y, i[3] = E * G + k * X, i;
        }, T.bn = function(i) {
          const e = new Float64Array(9);
          (function(m, v) {
            var E = v[0], k = v[1], P = v[2], L = v[3], N = E + E, G = k + k, j = P + P, Z = E * N, Y = k * N, X = k * G, ne = P * N, xe = P * G, ae = P * j, ue = L * N, Te = L * G, Ae = L * j;
            m[0] = 1 - X - ae, m[3] = Y - Ae, m[6] = ne + Te, m[1] = Y + Ae, m[4] = 1 - Z - ae, m[7] = xe - ue, m[2] = ne - Te, m[5] = xe + ue, m[8] = 1 - Z - X;
          })(e, i);
          const r = Kr(-Math.asin(Kt(e[2], -1, 1)));
          let c, f;
          return Math.hypot(e[5], e[8]) < 1e-3 ? (c = 0, f = -Kr(Math.atan2(e[3], e[4]))) : (c = Kr(e[5] === 0 && e[8] === 0 ? 0 : Math.atan2(e[5], e[8])), f = Kr(e[1] === 0 && e[0] === 0 ? 0 : Math.atan2(e[1], e[0]))), { roll: c, pitch: r + 90, bearing: f };
        }, T.bo = function(i, e) {
          return i.roll == e.roll && i.pitch == e.pitch && i.bearing == e.bearing;
        }, T.bp = hr, T.bq = Wo, T.br = oh, T.bs = Rd, T.bt = ah, T.bu = Ht, T.bv = Ot, T.bw = tn, T.bx = function(i, e, r, c, f) {
          return Ht(c, f, Kt((i - e) / (r - e), 0, 1));
        }, T.by = Tt, T.bz = function() {
          return new Float64Array(3);
        }, T.c = ye, T.c$ = function(i, e, r, c, f) {
          return u(this, void 0, void 0, (function* () {
            if (Pe()) try {
              return yield $i(i, e, r, c, f);
            } catch {
            }
            return (function(m, v, E, k, P) {
              const L = m.width, N = m.height;
              Zi && In || (Zi = new OffscreenCanvas(L, N), In = Zi.getContext("2d", { willReadFrequently: !0 })), Zi.width = L, Zi.height = N, In.drawImage(m, 0, 0, L, N);
              const G = In.getImageData(v, E, k, P);
              return In.clearRect(0, 0, L, N), G.data;
            })(i, e, r, c, f);
          }));
        }, T.c0 = class extends Ji {
          constructor(i, e) {
            super(i, e), this.current = Ts;
          }
          set(i) {
            if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
            for (let e = 1; e < 16; e++) if (i[e] !== this.current[e]) {
              this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
              break;
            }
          }
        }, T.c1 = Yu, T.c2 = class extends Ji {
          constructor(i, e) {
            super(i, e), this.current = [0, 0, 0];
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
          }
        }, T.c3 = class extends Ji {
          constructor(i, e) {
            super(i, e), this.current = [0, 0];
          }
          set(i) {
            i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
          }
        }, T.c4 = Qe, T.c5 = function(i, e) {
          var r = Math.sin(e), c = Math.cos(e);
          return i[0] = c, i[1] = r, i[2] = 0, i[3] = -r, i[4] = c, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i;
        }, T.c6 = function(i, e, r) {
          var c = e[0], f = e[1], m = e[2];
          return i[0] = c * r[0] + f * r[3] + m * r[6], i[1] = c * r[1] + f * r[4] + m * r[7], i[2] = c * r[2] + f * r[5] + m * r[8], i;
        }, T.c7 = function(i, e, r, c, f, m, v) {
          var E = 1 / (e - r), k = 1 / (c - f), P = 1 / (m - v);
          return i[0] = -2 * E, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * k, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * P, i[11] = 0, i[12] = (e + r) * E, i[13] = (f + c) * k, i[14] = (v + m) * P, i[15] = 1, i;
        }, T.c8 = class extends Ji {
          constructor(i, e) {
            super(i, e), this.current = new Array();
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const e = new Float32Array(4 * i.length);
              for (let r = 0; r < i.length; r++) e[4 * r] = i[r].r, e[4 * r + 1] = i[r].g, e[4 * r + 2] = i[r].b, e[4 * r + 3] = i[r].a;
              this.gl.uniform4fv(this.location, e);
            }
          }
        }, T.c9 = class extends Ji {
          constructor(i, e) {
            super(i, e), this.current = new Array();
          }
          set(i) {
            if (i != this.current) {
              this.current = i;
              const e = new Float32Array(i);
              this.gl.uniform1fv(this.location, e);
            }
          }
        }, T.cA = function(i, e) {
          return He[e] && "touches" in i;
        }, T.cB = function(i) {
          return He[i] || K[i];
        }, T.cC = function(i, e, r) {
          var c = e[0], f = e[1];
          return i[0] = r[0] * c + r[4] * f + r[12], i[1] = r[1] * c + r[5] * f + r[13], i;
        }, T.cD = function(i, e) {
          const { x: r, y: c } = Gd.fromLngLat(e);
          return !(i < 0 || i > 25 || c < 0 || c >= 1 || r < 0 || r >= 1);
        }, T.cE = function(i, e) {
          return i[0] = e[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = e[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = e[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
        }, T.cF = class extends Wc {
        }, T.cG = DS, T.cI = Be, T.cJ = function(i, e) {
          ye.REGISTERED_PROTOCOLS[i] = e;
        }, T.cK = function(i) {
          delete ye.REGISTERED_PROTOCOLS[i];
        }, T.cL = function(i, e) {
          const r = {};
          for (let f = 0; f < i.length; f++) {
            const m = e && e[i[f].id] || Jf(i[f]);
            e && (e[i[f].id] = m);
            let v = r[m];
            v || (v = r[m] = []), v.push(i[f]);
          }
          const c = [];
          for (const f in r) c.push(r[f]);
          return c;
        }, T.cM = jt, T.cN = A0, T.cO = ux, T.cP = d0, T.cQ = function(i) {
          i.bucket.createArrays(), i.bucket.tilePixelRatio = We / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
          const e = i.bucket.layers[0], r = e.layout, c = e._unevaluatedLayout._values, f = { layoutIconSize: c["icon-size"].possiblyEvaluate(new Vr(i.bucket.zoom + 1), i.canonical), layoutTextSize: c["text-size"].possiblyEvaluate(new Vr(i.bucket.zoom + 1), i.canonical), textMaxSize: c["text-size"].possiblyEvaluate(new Vr(18)) };
          if (i.bucket.textSizeData.kind === "composite") {
            const { minZoom: P, maxZoom: L } = i.bucket.textSizeData;
            f.compositeTextSizes = [c["text-size"].possiblyEvaluate(new Vr(P), i.canonical), c["text-size"].possiblyEvaluate(new Vr(L), i.canonical)];
          }
          if (i.bucket.iconSizeData.kind === "composite") {
            const { minZoom: P, maxZoom: L } = i.bucket.iconSizeData;
            f.compositeIconSizes = [c["icon-size"].possiblyEvaluate(new Vr(P), i.canonical), c["icon-size"].possiblyEvaluate(new Vr(L), i.canonical)];
          }
          const m = r.get("text-line-height") * ci, v = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point", E = r.get("text-keep-upright"), k = r.get("text-size");
          for (const P of i.bucket.features) {
            const L = r.get("text-font").evaluate(P, {}, i.canonical).join(","), N = k.evaluate(P, {}, i.canonical), G = f.layoutTextSize.evaluate(P, {}, i.canonical), j = f.layoutIconSize.evaluate(P, {}, i.canonical), Z = { horizontal: {}, vertical: void 0 }, Y = P.text;
            let X, ne = [0, 0];
            if (Y) {
              const ue = Y.toString(), Te = r.get("text-letter-spacing").evaluate(P, {}, i.canonical) * ci, Ae = dm(ue) ? Te : 0, Ke = r.get("text-anchor").evaluate(P, {}, i.canonical), ht = wx(e, P, i.canonical);
              if (!ht) {
                const _t = r.get("text-radial-offset").evaluate(P, {}, i.canonical);
                ne = _t ? bx(Ke, [_t * ci, i_]) : r.get("text-offset").evaluate(P, {}, i.canonical).map(((ut) => ut * ci));
              }
              let lt = v ? "center" : r.get("text-justify").evaluate(P, {}, i.canonical);
              const pt = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(P, {}, i.canonical) * ci : 1 / 0, Ct = () => {
                i.bucket.allowVerticalPlacement && Fl(ue) && (Z.vertical = Cp(Y, i.glyphMap, i.glyphPositions, i.imagePositions, L, pt, m, Ke, "left", Ae, ne, T.az.vertical, !0, G, N));
              };
              if (!v && ht) {
                const _t = /* @__PURE__ */ new Set();
                if (lt === "auto") for (let st = 0; st < ht.values.length; st += 2) _t.add(s_(ht.values[st]));
                else _t.add(lt);
                let ut = !1;
                for (const st of _t) if (!Z.horizontal[st]) if (ut) Z.horizontal[st] = Z.horizontal[0];
                else {
                  const Bt = Cp(Y, i.glyphMap, i.glyphPositions, i.imagePositions, L, pt, m, "center", st, Ae, ne, T.az.horizontal, !1, G, N);
                  Bt && (Z.horizontal[st] = Bt, ut = Bt.positionedLines.length === 1);
                }
                Ct();
              } else {
                lt === "auto" && (lt = s_(Ke));
                const _t = Cp(Y, i.glyphMap, i.glyphPositions, i.imagePositions, L, pt, m, Ke, lt, Ae, ne, T.az.horizontal, !1, G, N);
                _t && (Z.horizontal[lt] = _t), Ct(), Fl(ue) && v && E && (Z.vertical = Cp(Y, i.glyphMap, i.glyphPositions, i.imagePositions, L, pt, m, Ke, lt, Ae, ne, T.az.vertical, !1, G, N));
              }
            }
            let xe = !1;
            if (P.icon && P.icon.name) {
              const ue = i.imageMap[P.icon.name];
              ue && (X = VT(i.imagePositions[P.icon.name], r.get("icon-offset").evaluate(P, {}, i.canonical), r.get("icon-anchor").evaluate(P, {}, i.canonical)), xe = !!ue.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = xe : i.bucket.sdfIcons !== xe && ur("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ue.pixelRatio !== i.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
            }
            const ae = Tx(Z.horizontal) || Z.vertical;
            i.bucket.iconsInText = !!ae && ae.iconsInText, (ae || X) && AS(i.bucket, P, Z, X, i.imageMap, f, G, j, ne, xe, i.canonical, i.subdivisionGranularity);
          }
          i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
        }, T.cR = Im, T.cS = Cm, T.cT = Pm, T.cU = function(i) {
          const e = new Mp();
          return (function(r, c) {
            for (const f in r.layers) c.writeMessage(3, _S, r.layers[f]);
          })(i, e), e.finish();
        }, T.cV = function(i, e, r, c, f, m) {
          let v = dx(i, e, r, f, 0);
          return v = dx(v, e, c, m, 1), v;
        }, T.cW = class {
          constructor(i) {
            this.maxEntries = i, this.map = /* @__PURE__ */ new Map();
          }
          get(i) {
            const e = this.map.get(i);
            return e !== void 0 && (this.map.delete(i), this.map.set(i, e)), e;
          }
          set(i, e) {
            if (this.map.has(i)) this.map.delete(i);
            else if (this.map.size >= this.maxEntries) {
              const r = this.map.keys().next().value;
              this.map.delete(r);
            }
            this.map.set(i, e);
          }
          clear() {
            this.map.clear();
          }
        }, T.cX = Yv, T.cY = Mp, T.cZ = ox, T.c_ = class {
          constructor(i) {
            this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let i = performance.getEntriesByName(this._marks.measure);
            return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
          }
        }, T.ca = class extends Ho {
        }, T.cb = xT, T.cc = class extends Hu {
        }, T.cd = wm, T.ce = function(i) {
          return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
        }, T.cf = Dv, T.cg = function(i, e, r) {
          var c = e[0], f = e[1], m = e[2], v = r[3] * c + r[7] * f + r[11] * m + r[15];
          return i[0] = (r[0] * c + r[4] * f + r[8] * m + r[12]) / (v = v || 1), i[1] = (r[1] * c + r[5] * f + r[9] * m + r[13]) / v, i[2] = (r[2] * c + r[6] * f + r[10] * m + r[14]) / v, i;
        }, T.ch = class extends xd {
        }, T.ci = class extends t {
        }, T.cj = function(i, e) {
          return i[0] === e[0] && i[1] === e[1] && i[2] === e[2] && i[3] === e[3] && i[4] === e[4] && i[5] === e[5] && i[6] === e[6] && i[7] === e[7] && i[8] === e[8] && i[9] === e[9] && i[10] === e[10] && i[11] === e[11] && i[12] === e[12] && i[13] === e[13] && i[14] === e[14] && i[15] === e[15];
        }, T.ck = function(i, e) {
          var r = i[0], c = i[1], f = i[2], m = i[3], v = i[4], E = i[5], k = i[6], P = i[7], L = i[8], N = i[9], G = i[10], j = i[11], Z = i[12], Y = i[13], X = i[14], ne = i[15], xe = e[0], ae = e[1], ue = e[2], Te = e[3], Ae = e[4], Ke = e[5], ht = e[6], lt = e[7], pt = e[8], Ct = e[9], _t = e[10], ut = e[11], st = e[12], Bt = e[13], Rt = e[14], Vt = e[15];
          return Math.abs(r - xe) <= _e * Math.max(1, Math.abs(r), Math.abs(xe)) && Math.abs(c - ae) <= _e * Math.max(1, Math.abs(c), Math.abs(ae)) && Math.abs(f - ue) <= _e * Math.max(1, Math.abs(f), Math.abs(ue)) && Math.abs(m - Te) <= _e * Math.max(1, Math.abs(m), Math.abs(Te)) && Math.abs(v - Ae) <= _e * Math.max(1, Math.abs(v), Math.abs(Ae)) && Math.abs(E - Ke) <= _e * Math.max(1, Math.abs(E), Math.abs(Ke)) && Math.abs(k - ht) <= _e * Math.max(1, Math.abs(k), Math.abs(ht)) && Math.abs(P - lt) <= _e * Math.max(1, Math.abs(P), Math.abs(lt)) && Math.abs(L - pt) <= _e * Math.max(1, Math.abs(L), Math.abs(pt)) && Math.abs(N - Ct) <= _e * Math.max(1, Math.abs(N), Math.abs(Ct)) && Math.abs(G - _t) <= _e * Math.max(1, Math.abs(G), Math.abs(_t)) && Math.abs(j - ut) <= _e * Math.max(1, Math.abs(j), Math.abs(ut)) && Math.abs(Z - st) <= _e * Math.max(1, Math.abs(Z), Math.abs(st)) && Math.abs(Y - Bt) <= _e * Math.max(1, Math.abs(Y), Math.abs(Bt)) && Math.abs(X - Rt) <= _e * Math.max(1, Math.abs(X), Math.abs(Rt)) && Math.abs(ne - Vt) <= _e * Math.max(1, Math.abs(ne), Math.abs(Vt));
        }, T.cl = function(i, e) {
          return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
        }, T.cm = (i) => i.type === "symbol", T.cn = (i) => i.type === "circle", T.co = (i) => i.type === "heatmap", T.cp = (i) => i.type === "line", T.cq = (i) => i.type === "fill", T.cr = (i) => i.type === "fill-extrusion", T.cs = (i) => i.type === "hillshade", T.ct = (i) => i.type === "color-relief", T.cu = (i) => i.type === "background", T.cv = (i) => i.type === "custom", T.cw = Pt, T.cx = function(i, e, r) {
          const c = Ve(e.x - r.x, e.y - r.y), f = Ve(i.x - r.x, i.y - r.y), m = Math.atan2(c[0] * f[1] - c[1] * f[0], (function(v, E) {
            return v[0] * E[0] + v[1] * E[1];
          })(c, f));
          return Kr(m);
        }, T.cy = Mt, T.cz = function(i, e) {
          return K[e] && (i instanceof MouseEvent || i instanceof WheelEvent);
        }, T.d = ct, T.d0 = Nv, T.d1 = z, T.d2 = class {
          constructor(i, e) {
            this.layers = { [Ud]: this }, this.name = Ud, this.version = e ? e.version : 1, this.extent = e ? e.extent : 4096, this.length = i.length, this.features = i;
          }
          feature(i) {
            return new mS(this.features[i], this.extent);
          }
        }, T.d3 = ku, T.d4 = co, T.e = Ze, T.f = (i) => u(void 0, void 0, void 0, (function* () {
          if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const e = new Blob([new Uint8Array(i)], { type: "image/png" });
          try {
            return createImageBitmap(e);
          } catch (r) {
            throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), T.g = Je, T.h = (i) => new Promise(((e, r) => {
          const c = new Image();
          c.onload = () => {
            e(c), URL.revokeObjectURL(c.src), c.onload = null, window.requestAnimationFrame((() => {
              c.src = St;
            }));
          }, c.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const f = new Blob([new Uint8Array(i)], { type: "image/png" });
          c.src = i.byteLength ? URL.createObjectURL(f) : St;
        })), T.i = mi, T.j = (i, e) => ft(Ze(i, { type: "json" }), e), T.k = cr, T.l = Wt, T.m = ft, T.n = (i, e) => ft(Ze(i, { type: "arrayBuffer" }), e), T.o = function(i) {
          return new Mp(i).readFields(RT, []);
        }, T.p = h0, T.q = function(i) {
          return /[\u02EA\u02EB\u1100-\u11FF\u2E80-\u2FDF\u3000-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(i));
        }, T.r = Cd, T.s = Ks, T.t = Vi, T.u = Xe, T.v = Ru, T.w = ur, T.x = yd, T.y = Fu, T.z = Bu;
      })), x("worker", ["./shared"], (function(T) {
        class u {
          constructor(K, J) {
            this.keyCache = {}, K && this.replace(K, J);
          }
          replace(K, J) {
            this._layerConfigs = {}, this._layers = {}, this.update(K, [], J);
          }
          update(K, J, le) {
            for (const ye of K) {
              this._layerConfigs[ye.id] = ye;
              const Je = this._layers[ye.id] = T.bT(ye, le);
              Je._featureFilter = T.aj(Je.filter, le), this.keyCache[ye.id] && delete this.keyCache[ye.id];
            }
            for (const ye of J) delete this.keyCache[ye], delete this._layerConfigs[ye], delete this._layers[ye];
            this.familiesBySource = {};
            const be = T.cL(Object.values(this._layerConfigs), this.keyCache);
            for (const ye of be) {
              const Je = ye.map(((Lt) => this._layers[Lt.id])), qe = Je[0];
              if (qe.isHidden()) continue;
              const Be = qe.source || "";
              let ze = this.familiesBySource[Be];
              ze || (ze = this.familiesBySource[Be] = {});
              const ft = qe.sourceLayer || T.ai;
              let ct = ze[ft];
              ct || (ct = ze[ft] = []), ct.push(Je);
            }
          }
        }
        class R {
          constructor(K) {
            const J = {}, le = [];
            for (const qe in K) {
              const Be = K[qe], ze = J[qe] = {};
              for (const ft in Be) {
                const ct = Be[+ft];
                if (!ct || ct.bitmap.width === 0 || ct.bitmap.height === 0) continue;
                const Lt = { x: 0, y: 0, w: ct.bitmap.width + 2, h: ct.bitmap.height + 2 };
                le.push(Lt), ze[ft] = { rect: Lt, metrics: ct.metrics };
              }
            }
            const { w: be, h: ye } = T.p(le), Je = new T.r({ width: be || 1, height: ye || 1 });
            for (const qe in K) {
              const Be = K[qe];
              for (const ze in Be) {
                const ft = Be[+ze];
                if (!ft || ft.bitmap.width === 0 || ft.bitmap.height === 0) continue;
                const ct = J[qe][ze].rect;
                T.r.copy(ft.bitmap, Je, { x: 0, y: 0 }, { x: ct.x + 1, y: ct.y + 1 }, ft.bitmap);
              }
            }
            this.image = Je, this.positions = J;
          }
        }
        T.cM("GlyphAtlas", R);
        class z {
          constructor(K) {
            this.tileID = new T.a2(K.tileID.overscaledZ, K.tileID.wrap, K.tileID.canonical.z, K.tileID.canonical.x, K.tileID.canonical.y), this.uid = K.uid, this.zoom = K.zoom, this.pixelRatio = K.pixelRatio, this.tileSize = K.tileSize, this.source = K.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = K.showCollisionBoxes, this.collectResourceTiming = !!K.collectResourceTiming, this.returnDependencies = !!K.returnDependencies, this.promoteId = K.promoteId, this.inFlightDependencies = [];
          }
          parse(K, J, le, be, ye) {
            return T._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = K, this.collisionBoxArray = new T.ag();
              const Je = new T.cN(Object.keys(K.layers).sort()), qe = new T.cO(this.tileID, this.promoteId);
              qe.bucketLayerIDs = [];
              const Be = {}, ze = { featureIndex: qe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: le, subdivisionGranularity: ye }, ft = J.familiesBySource[this.source];
              for (const Mr in ft) {
                const Yr = K.layers[Mr];
                if (!Yr) continue;
                Yr.version === 1 && T.w(`Vector tile source "${this.source}" layer "${Mr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Qs = Je.encode(Mr), Rn = [];
                for (let yt = 0; yt < Yr.length; yt++) {
                  const bn = Yr.feature(yt), Un = qe.getId(bn, Mr);
                  Rn.push({ feature: bn, id: Un, index: yt, sourceLayerIndex: Qs });
                }
                for (const yt of ft[Mr]) {
                  const bn = yt[0];
                  bn.source !== this.source && T.w(`layer.source = ${bn.source} does not equal this.source = ${this.source}`), bn.isHidden(this.zoom, !0) || (U(yt, this.zoom, le), (Be[bn.id] = bn.createBucket({ index: qe.bucketLayerIDs.length, layers: yt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Qs, sourceID: this.source })).populate(Rn, ze, this.tileID.canonical), qe.bucketLayerIDs.push(yt.map(((Un) => Un.id))));
                }
              }
              const ct = T.bY(ze.glyphDependencies, ((Mr) => Object.keys(Mr).map(Number)));
              this.inFlightDependencies.forEach(((Mr) => Mr?.abort())), this.inFlightDependencies = [];
              let Lt = Promise.resolve({});
              if (Object.keys(ct).length) {
                const Mr = new AbortController();
                this.inFlightDependencies.push(Mr), Lt = be.sendAsync({ type: "GG", data: { stacks: ct, source: this.source, tileID: this.tileID, type: "glyphs" } }, Mr);
              }
              const Nt = Object.keys(ze.iconDependencies);
              let Wt = Promise.resolve({});
              if (Nt.length) {
                const Mr = new AbortController();
                this.inFlightDependencies.push(Mr), Wt = be.sendAsync({ type: "GI", data: { icons: Nt, source: this.source, tileID: this.tileID, type: "icons" } }, Mr);
              }
              const cr = Object.keys(ze.patternDependencies);
              let wr = Promise.resolve({});
              if (cr.length) {
                const Mr = new AbortController();
                this.inFlightDependencies.push(Mr), wr = be.sendAsync({ type: "GI", data: { icons: cr, source: this.source, tileID: this.tileID, type: "patterns" } }, Mr);
              }
              const Xe = ze.dashDependencies;
              let Rr = Promise.resolve({});
              if (Object.keys(Xe).length) {
                const Mr = new AbortController();
                this.inFlightDependencies.push(Mr), Rr = be.sendAsync({ type: "GDA", data: { dashes: Xe } }, Mr);
              }
              const [Mn, qt, mt, fn] = yield Promise.all([Lt, Wt, wr, Rr]), Ir = new R(Mn), Pr = new T.cP(qt, mt);
              for (const Mr in Be) {
                const Yr = Be[Mr];
                Yr instanceof T.ah ? (U(Yr.layers, this.zoom, le), T.cQ({ bucket: Yr, glyphMap: Mn, glyphPositions: Ir.positions, imageMap: qt, imagePositions: Pr.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: ze.subdivisionGranularity })) : Yr.hasDependencies && (Yr instanceof T.cR || Yr instanceof T.cS || Yr instanceof T.cT) && (U(Yr.layers, this.zoom, le), Yr.addFeatures(ze, this.tileID.canonical, Pr.patternPositions, fn));
              }
              return this.status = "done", { buckets: Object.values(Be).filter(((Mr) => !Mr.isEmpty())), featureIndex: qe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ir.image, imageAtlas: Pr, dashPositions: fn, glyphMap: this.returnDependencies ? Mn : null, iconMap: this.returnDependencies ? qt : null, glyphPositions: this.returnDependencies ? Ir.positions : null };
            }));
          }
        }
        function U(He, K, J) {
          const le = new T.H(K);
          for (const be of He) be.recalculate(le, J);
        }
        class $ {
          constructor(K, J, le, be, ye) {
            this.type = K, this.properties = le || {}, this.extent = ye, this.pointsArray = J, this.id = be;
          }
          loadGeometry() {
            return this.pointsArray.map(((K) => K.map(((J) => new T.P(J.x, J.y)))));
          }
        }
        class ee {
          constructor(K, J, le) {
            this.version = 2, this._myFeatures = K, this.name = J, this.length = K.length, this.extent = le;
          }
          feature(K) {
            return this._myFeatures[K];
          }
        }
        class oe {
          constructor() {
            this.layers = {};
          }
          addLayer(K) {
            this.layers[K.name] = K;
          }
        }
        function ce(He) {
          let K = T.cU(He);
          return K.byteOffset === 0 && K.byteLength === K.buffer.byteLength || (K = new Uint8Array(K)), { vectorTile: He, rawData: K.buffer };
        }
        function me(He, K, J) {
          const { extent: le } = He, be = Math.pow(2, J.z - K.z), ye = (J.x - K.x * be) * le, Je = (J.y - K.y * be) * le, qe = [];
          for (let Be = 0; Be < He.length; Be++) {
            const ze = He.feature(Be);
            let ft = ze.loadGeometry();
            for (const Lt of ft) for (const Nt of Lt) Nt.x = Nt.x * be - ye, Nt.y = Nt.y * be - Je;
            const ct = 128;
            ft = T.cV(ft, ze.type, -ct, -ct, le + ct, le + ct), ft.length !== 0 && qe.push(new $(ze.type, ft, ze.properties, ze.id, le));
          }
          return new ee(qe, He.name, le);
        }
        class re {
          constructor(K, J, le) {
            this.actor = K, this.layerIndex = J, this.availableImages = le, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new T.cW(1e3);
          }
          loadVectorTile(K, J) {
            return T._(this, void 0, void 0, (function* () {
              const le = yield T.n(K.request, J);
              try {
                return { vectorTile: K.encoding !== "mlt" ? new T.cX(new T.cY(le.data)) : new T.cZ(le.data), rawData: le.data, cacheControl: le.cacheControl, expires: le.expires };
              } catch (be) {
                const ye = new Uint8Array(le.data);
                let Je = `Unable to parse the tile at ${K.request.url}, `;
                throw Je += ye[0] === 31 && ye[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${be.message}`, new Error(Je);
              }
            }));
          }
          loadTile(K) {
            return T._(this, void 0, void 0, (function* () {
              const { uid: J, overzoomParameters: le } = K;
              le && (K.request = le.overzoomRequest);
              const be = !!(K && K.request && K.request.collectResourceTiming) && new T.c_(K.request), ye = new z(K);
              this.loading[J] = ye;
              const Je = new AbortController();
              ye.abort = Je;
              try {
                const qe = yield this.loadVectorTile(K, Je);
                if (delete this.loading[J], !qe) return null;
                if (le) {
                  const Lt = this._getOverzoomTile(K, qe.vectorTile);
                  qe.rawData = Lt.rawData, qe.vectorTile = Lt.vectorTile;
                }
                const Be = qe.rawData, ze = {};
                qe.expires && (ze.expires = qe.expires), qe.cacheControl && (ze.cacheControl = qe.cacheControl);
                const ft = {};
                if (be) {
                  const Lt = be.finish();
                  Lt && (ft.resourceTiming = JSON.parse(JSON.stringify(Lt)));
                }
                ye.vectorTile = qe.vectorTile;
                const ct = ye.parse(qe.vectorTile, this.layerIndex, this.availableImages, this.actor, K.subdivisionGranularity);
                this.loaded[J] = ye, this.fetching[J] = { rawTileData: Be, cacheControl: ze, resourceTiming: ft };
                try {
                  const Lt = yield ct;
                  return T.e({ rawTileData: Be.slice(0), encoding: K.encoding }, Lt, ze, ft);
                } finally {
                  delete this.fetching[J];
                }
              } catch (qe) {
                throw delete this.loading[J], ye.status = "done", this.loaded[J] = ye, qe;
              }
            }));
          }
          _getOverzoomTile(K, J) {
            const { tileID: le, source: be, overzoomParameters: ye } = K, { maxZoomTileID: Je } = ye, qe = `${Je.key}_${le.key}`, Be = this.overzoomedTileResultCache.get(qe);
            if (Be) return Be;
            const ze = new oe(), ft = this.layerIndex.familiesBySource[be];
            for (const Lt in ft) {
              const Nt = J.layers[Lt];
              if (!Nt) continue;
              const Wt = me(Nt, Je, le.canonical);
              Wt.length > 0 && ze.addLayer(Wt);
            }
            const ct = ce(ze);
            return this.overzoomedTileResultCache.set(qe, ct), ct;
          }
          reloadTile(K) {
            return T._(this, void 0, void 0, (function* () {
              const J = K.uid;
              if (!this.loaded || !this.loaded[J]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const le = this.loaded[J];
              if (le.showCollisionBoxes = K.showCollisionBoxes, le.status === "parsing") {
                const be = yield le.parse(le.vectorTile, this.layerIndex, this.availableImages, this.actor, K.subdivisionGranularity);
                let ye;
                if (this.fetching[J]) {
                  const { rawTileData: Je, cacheControl: qe, resourceTiming: Be } = this.fetching[J];
                  delete this.fetching[J], ye = T.e({ rawTileData: Je.slice(0), encoding: K.encoding }, be, qe, Be);
                } else ye = be;
                return ye;
              }
              if (le.status === "done" && le.vectorTile) return le.parse(le.vectorTile, this.layerIndex, this.availableImages, this.actor, K.subdivisionGranularity);
            }));
          }
          abortTile(K) {
            return T._(this, void 0, void 0, (function* () {
              const J = this.loading, le = K.uid;
              J && J[le] && J[le].abort && (J[le].abort.abort(), delete J[le]);
            }));
          }
          removeTile(K) {
            return T._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[K.uid] && delete this.loaded[K.uid];
            }));
          }
        }
        class Pe {
          constructor() {
            this.loaded = {};
          }
          loadTile(K) {
            return T._(this, void 0, void 0, (function* () {
              const { uid: J, encoding: le, rawImageData: be, redFactor: ye, greenFactor: Je, blueFactor: qe, baseShift: Be } = K, ze = be.width + 2, ft = be.height + 2, ct = T.b(be) ? new T.R({ width: ze, height: ft }, yield T.c$(be, -1, -1, ze, ft)) : be, Lt = new T.d0(J, ct, le, ye, Je, qe, Be);
              return this.loaded = this.loaded || {}, this.loaded[J] = Lt, Lt;
            }));
          }
          removeTile(K) {
            const J = this.loaded, le = K.uid;
            J && J[le] && delete J[le];
          }
        }
        var _e, je, Qe = (function() {
          if (je) return _e;
          function He(J, le) {
            if (J.length !== 0) {
              K(J[0], le);
              for (var be = 1; be < J.length; be++) K(J[be], !le);
            }
          }
          function K(J, le) {
            for (var be = 0, ye = 0, Je = 0, qe = J.length, Be = qe - 1; Je < qe; Be = Je++) {
              var ze = (J[Je][0] - J[Be][0]) * (J[Be][1] + J[Je][1]), ft = be + ze;
              ye += Math.abs(be) >= Math.abs(ze) ? be - ft + ze : ze - ft + be, be = ft;
            }
            be + ye >= 0 != !!le && J.reverse();
          }
          return je = 1, _e = function J(le, be) {
            var ye, Je = le && le.type;
            if (Je === "FeatureCollection") for (ye = 0; ye < le.features.length; ye++) J(le.features[ye], be);
            else if (Je === "GeometryCollection") for (ye = 0; ye < le.geometries.length; ye++) J(le.geometries[ye], be);
            else if (Je === "Feature") J(le.geometry, be);
            else if (Je === "Polygon") He(le.coordinates, be);
            else if (Je === "MultiPolygon") for (ye = 0; ye < le.coordinates.length; ye++) He(le.coordinates[ye], be);
            return le;
          };
        })(), et = T.d1(Qe);
        const Ye = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (He) => He }, ot = Math.fround || (Q = new Float32Array(1), (He) => (Q[0] = +He, Q[0]));
        var Q;
        class ie {
          constructor(K) {
            this.options = Object.assign(Object.create(Ye), K), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(K) {
            const { log: J, minZoom: le, maxZoom: be } = this.options;
            J && console.time("total time");
            const ye = `prepare ${K.length} points`;
            J && console.time(ye), this.points = K;
            const Je = [];
            for (let Be = 0; Be < K.length; Be++) {
              const ze = K[Be];
              if (!ze.geometry) continue;
              const [ft, ct] = ze.geometry.coordinates, Lt = ot(Ie(ft)), Nt = ot(Oe(ct));
              Je.push(Lt, Nt, 1 / 0, Be, -1, 1), this.options.reduce && Je.push(0);
            }
            let qe = this.trees[be + 1] = this._createTree(Je);
            J && console.timeEnd(ye);
            for (let Be = be; Be >= le; Be--) {
              const ze = +Date.now();
              qe = this.trees[Be] = this._createTree(this._cluster(qe, Be)), J && console.log("z%d: %d clusters in %dms", Be, qe.numItems, +Date.now() - ze);
            }
            return J && console.timeEnd("total time"), this;
          }
          getClusters(K, J) {
            let le = ((K[0] + 180) % 360 + 360) % 360 - 180;
            const be = Math.max(-90, Math.min(90, K[1]));
            let ye = K[2] === 180 ? 180 : ((K[2] + 180) % 360 + 360) % 360 - 180;
            const Je = Math.max(-90, Math.min(90, K[3]));
            if (K[2] - K[0] >= 360) le = -180, ye = 180;
            else if (le > ye) {
              const ct = this.getClusters([le, be, 180, Je], J), Lt = this.getClusters([-180, be, ye, Je], J);
              return ct.concat(Lt);
            }
            const qe = this.trees[this._limitZoom(J)], Be = qe.range(Ie(le), Oe(Je), Ie(ye), Oe(be)), ze = qe.data, ft = [];
            for (const ct of Be) {
              const Lt = this.stride * ct;
              ft.push(ze[Lt + 5] > 1 ? ge(ze, Lt, this.clusterProps) : this.points[ze[Lt + 3]]);
            }
            return ft;
          }
          getChildren(K) {
            const J = this._getOriginId(K), le = this._getOriginZoom(K), be = "No cluster with the specified id.", ye = this.trees[le];
            if (!ye) throw new Error(be);
            const Je = ye.data;
            if (J * this.stride >= Je.length) throw new Error(be);
            const qe = this.options.radius / (this.options.extent * Math.pow(2, le - 1)), Be = ye.within(Je[J * this.stride], Je[J * this.stride + 1], qe), ze = [];
            for (const ft of Be) {
              const ct = ft * this.stride;
              Je[ct + 4] === K && ze.push(Je[ct + 5] > 1 ? ge(Je, ct, this.clusterProps) : this.points[Je[ct + 3]]);
            }
            if (ze.length === 0) throw new Error(be);
            return ze;
          }
          getLeaves(K, J, le) {
            const be = [];
            return this._appendLeaves(be, K, J = J || 10, le = le || 0, 0), be;
          }
          getTile(K, J, le) {
            const be = this.trees[this._limitZoom(K)], ye = Math.pow(2, K), { extent: Je, radius: qe } = this.options, Be = qe / Je, ze = (le - Be) / ye, ft = (le + 1 + Be) / ye, ct = { features: [] };
            return this._addTileFeatures(be.range((J - Be) / ye, ze, (J + 1 + Be) / ye, ft), be.data, J, le, ye, ct), J === 0 && this._addTileFeatures(be.range(1 - Be / ye, ze, 1, ft), be.data, ye, le, ye, ct), J === ye - 1 && this._addTileFeatures(be.range(0, ze, Be / ye, ft), be.data, -1, le, ye, ct), ct.features.length ? ct : null;
          }
          getClusterExpansionZoom(K) {
            let J = this._getOriginZoom(K) - 1;
            for (; J <= this.options.maxZoom; ) {
              const le = this.getChildren(K);
              if (J++, le.length !== 1) break;
              K = le[0].properties.cluster_id;
            }
            return J;
          }
          _appendLeaves(K, J, le, be, ye) {
            const Je = this.getChildren(J);
            for (const qe of Je) {
              const Be = qe.properties;
              if (Be && Be.cluster ? ye + Be.point_count <= be ? ye += Be.point_count : ye = this._appendLeaves(K, Be.cluster_id, le, be, ye) : ye < be ? ye++ : K.push(qe), K.length === le) break;
            }
            return ye;
          }
          _createTree(K) {
            const J = new T.aT(K.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let le = 0; le < K.length; le += this.stride) J.add(K[le], K[le + 1]);
            return J.finish(), J.data = K, J;
          }
          _addTileFeatures(K, J, le, be, ye, Je) {
            for (const qe of K) {
              const Be = qe * this.stride, ze = J[Be + 5] > 1;
              let ft, ct, Lt;
              if (ze) ft = Se(J, Be, this.clusterProps), ct = J[Be], Lt = J[Be + 1];
              else {
                const cr = this.points[J[Be + 3]];
                ft = cr.properties;
                const [wr, Xe] = cr.geometry.coordinates;
                ct = Ie(wr), Lt = Oe(Xe);
              }
              const Nt = { type: 1, geometry: [[Math.round(this.options.extent * (ct * ye - le)), Math.round(this.options.extent * (Lt * ye - be))]], tags: ft };
              let Wt;
              Wt = ze || this.options.generateId ? J[Be + 3] : this.points[J[Be + 3]].id, Wt !== void 0 && (Nt.id = Wt), Je.features.push(Nt);
            }
          }
          _limitZoom(K) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+K), this.options.maxZoom + 1));
          }
          _cluster(K, J) {
            const { radius: le, extent: be, reduce: ye, minPoints: Je } = this.options, qe = le / (be * Math.pow(2, J)), Be = K.data, ze = [], ft = this.stride;
            for (let ct = 0; ct < Be.length; ct += ft) {
              if (Be[ct + 2] <= J) continue;
              Be[ct + 2] = J;
              const Lt = Be[ct], Nt = Be[ct + 1], Wt = K.within(Be[ct], Be[ct + 1], qe), cr = Be[ct + 5];
              let wr = cr;
              for (const Xe of Wt) {
                const Rr = Xe * ft;
                Be[Rr + 2] > J && (wr += Be[Rr + 5]);
              }
              if (wr > cr && wr >= Je) {
                let Xe, Rr = Lt * cr, Mn = Nt * cr, qt = -1;
                const mt = (ct / ft << 5) + (J + 1) + this.points.length;
                for (const fn of Wt) {
                  const Ir = fn * ft;
                  if (Be[Ir + 2] <= J) continue;
                  Be[Ir + 2] = J;
                  const Pr = Be[Ir + 5];
                  Rr += Be[Ir] * Pr, Mn += Be[Ir + 1] * Pr, Be[Ir + 4] = mt, ye && (Xe || (Xe = this._map(Be, ct, !0), qt = this.clusterProps.length, this.clusterProps.push(Xe)), ye(Xe, this._map(Be, Ir)));
                }
                Be[ct + 4] = mt, ze.push(Rr / wr, Mn / wr, 1 / 0, mt, -1, wr), ye && ze.push(qt);
              } else {
                for (let Xe = 0; Xe < ft; Xe++) ze.push(Be[ct + Xe]);
                if (wr > 1) for (const Xe of Wt) {
                  const Rr = Xe * ft;
                  if (!(Be[Rr + 2] <= J)) {
                    Be[Rr + 2] = J;
                    for (let Mn = 0; Mn < ft; Mn++) ze.push(Be[Rr + Mn]);
                  }
                }
              }
            }
            return ze;
          }
          _getOriginId(K) {
            return K - this.points.length >> 5;
          }
          _getOriginZoom(K) {
            return (K - this.points.length) % 32;
          }
          _map(K, J, le) {
            if (K[J + 5] > 1) {
              const Je = this.clusterProps[K[J + 6]];
              return le ? Object.assign({}, Je) : Je;
            }
            const be = this.points[K[J + 3]].properties, ye = this.options.map(be);
            return le && ye === be ? Object.assign({}, ye) : ye;
          }
        }
        function ge(He, K, J) {
          return { type: "Feature", id: He[K + 3], properties: Se(He, K, J), geometry: { type: "Point", coordinates: [(le = He[K], 360 * (le - 0.5)), Re(He[K + 1])] } };
          var le;
        }
        function Se(He, K, J) {
          const le = He[K + 5], be = le >= 1e4 ? `${Math.round(le / 1e3)}k` : le >= 1e3 ? Math.round(le / 100) / 10 + "k" : le, ye = He[K + 6], Je = ye === -1 ? {} : Object.assign({}, J[ye]);
          return Object.assign(Je, { cluster: !0, cluster_id: He[K + 3], point_count: le, point_count_abbreviated: be });
        }
        function Ie(He) {
          return He / 360 + 0.5;
        }
        function Oe(He) {
          const K = Math.sin(He * Math.PI / 180), J = 0.5 - 0.25 * Math.log((1 + K) / (1 - K)) / Math.PI;
          return J < 0 ? 0 : J > 1 ? 1 : J;
        }
        function Re(He) {
          const K = (180 - 360 * He) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(K)) / Math.PI - 90;
        }
        function De(He, K, J, le) {
          let be = le;
          const ye = K + (J - K >> 1);
          let Je, qe = J - K;
          const Be = He[K], ze = He[K + 1], ft = He[J], ct = He[J + 1];
          for (let Lt = K + 3; Lt < J; Lt += 3) {
            const Nt = Fe(He[Lt], He[Lt + 1], Be, ze, ft, ct);
            if (Nt > be) Je = Lt, be = Nt;
            else if (Nt === be) {
              const Wt = Math.abs(Lt - ye);
              Wt < qe && (Je = Lt, qe = Wt);
            }
          }
          be > le && (Je - K > 3 && De(He, K, Je, le), He[Je + 2] = be, J - Je > 3 && De(He, Je, J, le));
        }
        function Fe(He, K, J, le, be, ye) {
          let Je = be - J, qe = ye - le;
          if (Je !== 0 || qe !== 0) {
            const Be = ((He - J) * Je + (K - le) * qe) / (Je * Je + qe * qe);
            Be > 1 ? (J = be, le = ye) : Be > 0 && (J += Je * Be, le += qe * Be);
          }
          return Je = He - J, qe = K - le, Je * Je + qe * qe;
        }
        function Ue(He, K, J, le) {
          const be = { id: He ?? null, type: K, geometry: J, tags: le, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (K === "Point" || K === "MultiPoint" || K === "LineString") Ve(be, J);
          else if (K === "Polygon") Ve(be, J[0]);
          else if (K === "MultiLineString") for (const ye of J) Ve(be, ye);
          else if (K === "MultiPolygon") for (const ye of J) Ve(be, ye[0]);
          return be;
        }
        function Ve(He, K) {
          for (let J = 0; J < K.length; J += 3) He.minX = Math.min(He.minX, K[J]), He.minY = Math.min(He.minY, K[J + 1]), He.maxX = Math.max(He.maxX, K[J]), He.maxY = Math.max(He.maxY, K[J + 1]);
        }
        function We(He, K, J, le) {
          if (!K.geometry) return;
          const be = K.geometry.coordinates;
          if (be && be.length === 0) return;
          const ye = K.geometry.type, Je = Math.pow(J.tolerance / ((1 << J.maxZoom) * J.extent), 2);
          let qe = [], Be = K.id;
          if (J.promoteId ? Be = K.properties[J.promoteId] : J.generateId && (Be = le || 0), ye === "Point") dt(be, qe);
          else if (ye === "MultiPoint") for (const ze of be) dt(ze, qe);
          else if (ye === "LineString") Tt(be, qe, Je, !1);
          else if (ye === "MultiLineString") {
            if (J.lineMetrics) {
              for (const ze of be) qe = [], Tt(ze, qe, Je, !1), He.push(Ue(Be, "LineString", qe, K.properties));
              return;
            }
            Ht(be, qe, Je, !1);
          } else if (ye === "Polygon") Ht(be, qe, Je, !0);
          else {
            if (ye !== "MultiPolygon") {
              if (ye === "GeometryCollection") {
                for (const ze of K.geometry.geometries) We(He, { id: Be, geometry: ze, properties: K.properties }, J, le);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const ze of be) {
              const ft = [];
              Ht(ze, ft, Je, !0), qe.push(ft);
            }
          }
          He.push(Ue(Be, ye, qe, K.properties));
        }
        function dt(He, K) {
          K.push(Ot(He[0]), Pt(He[1]), 0);
        }
        function Tt(He, K, J, le) {
          let be, ye, Je = 0;
          for (let Be = 0; Be < He.length; Be++) {
            const ze = Ot(He[Be][0]), ft = Pt(He[Be][1]);
            K.push(ze, ft, 0), Be > 0 && (Je += le ? (be * ft - ze * ye) / 2 : Math.sqrt(Math.pow(ze - be, 2) + Math.pow(ft - ye, 2))), be = ze, ye = ft;
          }
          const qe = K.length - 3;
          K[2] = 1, De(K, 0, qe, J), K[qe + 2] = 1, K.size = Math.abs(Je), K.start = 0, K.end = K.size;
        }
        function Ht(He, K, J, le) {
          for (let be = 0; be < He.length; be++) {
            const ye = [];
            Tt(He[be], ye, J, le), K.push(ye);
          }
        }
        function Ot(He) {
          return He / 360 + 0.5;
        }
        function Pt(He) {
          const K = Math.sin(He * Math.PI / 180), J = 0.5 - 0.25 * Math.log((1 + K) / (1 - K)) / Math.PI;
          return J < 0 ? 0 : J > 1 ? 1 : J;
        }
        function Mt(He, K, J, le, be, ye, Je, qe) {
          if (le /= K, ye >= (J /= K) && Je < le) return He;
          if (Je < J || ye >= le) return null;
          const Be = [];
          for (const ze of He) {
            const ft = ze.geometry;
            let ct = ze.type;
            const Lt = be === 0 ? ze.minX : ze.minY, Nt = be === 0 ? ze.maxX : ze.maxY;
            if (Lt >= J && Nt < le) {
              Be.push(ze);
              continue;
            }
            if (Nt < J || Lt >= le) continue;
            let Wt = [];
            if (ct === "Point" || ct === "MultiPoint") Kt(ft, Wt, J, le, be);
            else if (ct === "LineString") gr(ft, Wt, J, le, be, !1, qe.lineMetrics);
            else if (ct === "MultiLineString") ri(ft, Wt, J, le, be, !1);
            else if (ct === "Polygon") ri(ft, Wt, J, le, be, !0);
            else if (ct === "MultiPolygon") for (const cr of ft) {
              const wr = [];
              ri(cr, wr, J, le, be, !0), wr.length && Wt.push(wr);
            }
            if (Wt.length) {
              if (qe.lineMetrics && ct === "LineString") {
                for (const cr of Wt) Be.push(Ue(ze.id, ct, cr, ze.tags));
                continue;
              }
              ct !== "LineString" && ct !== "MultiLineString" || (Wt.length === 1 ? (ct = "LineString", Wt = Wt[0]) : ct = "MultiLineString"), ct !== "Point" && ct !== "MultiPoint" || (ct = Wt.length === 3 ? "Point" : "MultiPoint"), Be.push(Ue(ze.id, ct, Wt, ze.tags));
            }
          }
          return Be.length ? Be : null;
        }
        function Kt(He, K, J, le, be) {
          for (let ye = 0; ye < He.length; ye += 3) {
            const Je = He[ye + be];
            Je >= J && Je <= le && lr(K, He[ye], He[ye + 1], He[ye + 2]);
          }
        }
        function gr(He, K, J, le, be, ye, Je) {
          let qe = Ze(He);
          const Be = be === 0 ? Ut : Me;
          let ze, ft, ct = He.start;
          for (let wr = 0; wr < He.length - 3; wr += 3) {
            const Xe = He[wr], Rr = He[wr + 1], Mn = He[wr + 2], qt = He[wr + 3], mt = He[wr + 4], fn = be === 0 ? Xe : Rr, Ir = be === 0 ? qt : mt;
            let Pr = !1;
            Je && (ze = Math.sqrt(Math.pow(Xe - qt, 2) + Math.pow(Rr - mt, 2))), fn < J ? Ir > J && (ft = Be(qe, Xe, Rr, qt, mt, J), Je && (qe.start = ct + ze * ft)) : fn > le ? Ir < le && (ft = Be(qe, Xe, Rr, qt, mt, le), Je && (qe.start = ct + ze * ft)) : lr(qe, Xe, Rr, Mn), Ir < J && fn >= J && (ft = Be(qe, Xe, Rr, qt, mt, J), Pr = !0), Ir > le && fn <= le && (ft = Be(qe, Xe, Rr, qt, mt, le), Pr = !0), !ye && Pr && (Je && (qe.end = ct + ze * ft), K.push(qe), qe = Ze(He)), Je && (ct += ze);
          }
          let Lt = He.length - 3;
          const Nt = He[Lt], Wt = He[Lt + 1], cr = be === 0 ? Nt : Wt;
          cr >= J && cr <= le && lr(qe, Nt, Wt, He[Lt + 2]), Lt = qe.length - 3, ye && Lt >= 3 && (qe[Lt] !== qe[0] || qe[Lt + 1] !== qe[1]) && lr(qe, qe[0], qe[1], qe[2]), qe.length && K.push(qe);
        }
        function Ze(He) {
          const K = [];
          return K.size = He.size, K.start = He.start, K.end = He.end, K;
        }
        function ri(He, K, J, le, be, ye) {
          for (const Je of He) gr(Je, K, J, le, be, ye, !1);
        }
        function lr(He, K, J, le) {
          He.push(K, J, le);
        }
        function Ut(He, K, J, le, be, ye) {
          const Je = (ye - K) / (le - K);
          return lr(He, ye, J + (be - J) * Je, 1), Je;
        }
        function Me(He, K, J, le, be, ye) {
          const Je = (ye - J) / (be - J);
          return lr(He, K + (le - K) * Je, ye, 1), Je;
        }
        function br(He, K) {
          const J = [];
          for (let le = 0; le < He.length; le++) {
            const be = He[le], ye = be.type;
            let Je;
            if (ye === "Point" || ye === "MultiPoint" || ye === "LineString") Je = ur(be.geometry, K);
            else if (ye === "MultiLineString" || ye === "Polygon") {
              Je = [];
              for (const qe of be.geometry) Je.push(ur(qe, K));
            } else if (ye === "MultiPolygon") {
              Je = [];
              for (const qe of be.geometry) {
                const Be = [];
                for (const ze of qe) Be.push(ur(ze, K));
                Je.push(Be);
              }
            }
            J.push(Ue(be.id, ye, Je, be.tags));
          }
          return J;
        }
        function ur(He, K) {
          const J = [];
          J.size = He.size, He.start !== void 0 && (J.start = He.start, J.end = He.end);
          for (let le = 0; le < He.length; le += 3) J.push(He[le] + K, He[le + 1], He[le + 2]);
          return J;
        }
        function tr(He, K) {
          if (He.transformed) return He;
          const J = 1 << He.z, le = He.x, be = He.y;
          for (const ye of He.features) {
            const Je = ye.geometry, qe = ye.type;
            if (ye.geometry = [], qe === 1) for (let Be = 0; Be < Je.length; Be += 2) ye.geometry.push(mi(Je[Be], Je[Be + 1], K, J, le, be));
            else for (let Be = 0; Be < Je.length; Be++) {
              const ze = [];
              for (let ft = 0; ft < Je[Be].length; ft += 2) ze.push(mi(Je[Be][ft], Je[Be][ft + 1], K, J, le, be));
              ye.geometry.push(ze);
            }
          }
          return He.transformed = !0, He;
        }
        function mi(He, K, J, le, be, ye) {
          return [Math.round(J * (He * le - be)), Math.round(J * (K * le - ye))];
        }
        function Nr(He, K, J, le, be) {
          const ye = K === be.maxZoom ? 0 : be.tolerance / ((1 << K) * be.extent), Je = { features: [], numPoints: 0, numSimplified: 0, numFeatures: He.length, source: null, x: J, y: le, z: K, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const qe of He) _i(Je, qe, ye, be);
          return Je;
        }
        function _i(He, K, J, le) {
          const be = K.geometry, ye = K.type, Je = [];
          if (He.minX = Math.min(He.minX, K.minX), He.minY = Math.min(He.minY, K.minY), He.maxX = Math.max(He.maxX, K.maxX), He.maxY = Math.max(He.maxY, K.maxY), ye === "Point" || ye === "MultiPoint") for (let qe = 0; qe < be.length; qe += 3) Je.push(be[qe], be[qe + 1]), He.numPoints++, He.numSimplified++;
          else if (ye === "LineString") St(Je, be, He, J, !1, !1);
          else if (ye === "MultiLineString" || ye === "Polygon") for (let qe = 0; qe < be.length; qe++) St(Je, be[qe], He, J, ye === "Polygon", qe === 0);
          else if (ye === "MultiPolygon") for (let qe = 0; qe < be.length; qe++) {
            const Be = be[qe];
            for (let ze = 0; ze < Be.length; ze++) St(Je, Be[ze], He, J, !0, ze === 0);
          }
          if (Je.length) {
            let qe = K.tags || null;
            if (ye === "LineString" && le.lineMetrics) {
              qe = {};
              for (const ze in K.tags) qe[ze] = K.tags[ze];
              qe.mapbox_clip_start = be.start / be.size, qe.mapbox_clip_end = be.end / be.size;
            }
            const Be = { geometry: Je, type: ye === "Polygon" || ye === "MultiPolygon" ? 3 : ye === "LineString" || ye === "MultiLineString" ? 2 : 1, tags: qe };
            K.id !== null && (Be.id = K.id), He.features.push(Be);
          }
        }
        function St(He, K, J, le, be, ye) {
          const Je = le * le;
          if (le > 0 && K.size < (be ? Je : le)) return void (J.numPoints += K.length / 3);
          const qe = [];
          for (let Be = 0; Be < K.length; Be += 3) (le === 0 || K[Be + 2] > Je) && (J.numSimplified++, qe.push(K[Be], K[Be + 1])), J.numPoints++;
          be && (function(Be, ze) {
            let ft = 0;
            for (let ct = 0, Lt = Be.length, Nt = Lt - 2; ct < Lt; Nt = ct, ct += 2) ft += (Be[ct] - Be[Nt]) * (Be[ct + 1] + Be[Nt + 1]);
            if (ft > 0 === ze) for (let ct = 0, Lt = Be.length; ct < Lt / 2; ct += 2) {
              const Nt = Be[ct], Wt = Be[ct + 1];
              Be[ct] = Be[Lt - 2 - ct], Be[ct + 1] = Be[Lt - 1 - ct], Be[Lt - 2 - ct] = Nt, Be[Lt - 1 - ct] = Wt;
            }
          })(qe, ye), He.push(qe);
        }
        const $i = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class Zi {
          constructor(K, J) {
            const le = (J = this.options = (function(ye, Je) {
              for (const qe in Je) ye[qe] = Je[qe];
              return ye;
            })(Object.create($i), J)).debug;
            if (le && console.time("preprocess data"), J.maxZoom < 0 || J.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (J.promoteId && J.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let be = (function(ye, Je) {
              const qe = [];
              if (ye.type === "FeatureCollection") for (let Be = 0; Be < ye.features.length; Be++) We(qe, ye.features[Be], Je, Be);
              else We(qe, ye.type === "Feature" ? ye : { geometry: ye }, Je);
              return qe;
            })(K, J);
            this.tiles = {}, this.tileCoords = [], le && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", J.indexMaxZoom, J.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), be = (function(ye, Je) {
              const qe = Je.buffer / Je.extent;
              let Be = ye;
              const ze = Mt(ye, 1, -1 - qe, qe, 0, -1, 2, Je), ft = Mt(ye, 1, 1 - qe, 2 + qe, 0, -1, 2, Je);
              return (ze || ft) && (Be = Mt(ye, 1, -qe, 1 + qe, 0, -1, 2, Je) || [], ze && (Be = br(ze, 1).concat(Be)), ft && (Be = Be.concat(br(ft, -1)))), Be;
            })(be, J), be.length && this.splitTile(be, 0, 0, 0), le && (be.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(K, J, le, be, ye, Je, qe) {
            const Be = [K, J, le, be], ze = this.options, ft = ze.debug;
            for (; Be.length; ) {
              be = Be.pop(), le = Be.pop(), J = Be.pop(), K = Be.pop();
              const ct = 1 << J, Lt = In(J, le, be);
              let Nt = this.tiles[Lt];
              if (!Nt && (ft > 1 && console.time("creation"), Nt = this.tiles[Lt] = Nr(K, J, le, be, ze), this.tileCoords.push({ z: J, x: le, y: be }), ft)) {
                ft > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", J, le, be, Nt.numFeatures, Nt.numPoints, Nt.numSimplified), console.timeEnd("creation"));
                const Pr = `z${J}`;
                this.stats[Pr] = (this.stats[Pr] || 0) + 1, this.total++;
              }
              if (Nt.source = K, ye == null) {
                if (J === ze.indexMaxZoom || Nt.numPoints <= ze.indexMaxPoints) continue;
              } else {
                if (J === ze.maxZoom || J === ye) continue;
                if (ye != null) {
                  const Pr = ye - J;
                  if (le !== Je >> Pr || be !== qe >> Pr) continue;
                }
              }
              if (Nt.source = null, K.length === 0) continue;
              ft > 1 && console.time("clipping");
              const Wt = 0.5 * ze.buffer / ze.extent, cr = 0.5 - Wt, wr = 0.5 + Wt, Xe = 1 + Wt;
              let Rr = null, Mn = null, qt = null, mt = null, fn = Mt(K, ct, le - Wt, le + wr, 0, Nt.minX, Nt.maxX, ze), Ir = Mt(K, ct, le + cr, le + Xe, 0, Nt.minX, Nt.maxX, ze);
              K = null, fn && (Rr = Mt(fn, ct, be - Wt, be + wr, 1, Nt.minY, Nt.maxY, ze), Mn = Mt(fn, ct, be + cr, be + Xe, 1, Nt.minY, Nt.maxY, ze), fn = null), Ir && (qt = Mt(Ir, ct, be - Wt, be + wr, 1, Nt.minY, Nt.maxY, ze), mt = Mt(Ir, ct, be + cr, be + Xe, 1, Nt.minY, Nt.maxY, ze), Ir = null), ft > 1 && console.timeEnd("clipping"), Be.push(Rr || [], J + 1, 2 * le, 2 * be), Be.push(Mn || [], J + 1, 2 * le, 2 * be + 1), Be.push(qt || [], J + 1, 2 * le + 1, 2 * be), Be.push(mt || [], J + 1, 2 * le + 1, 2 * be + 1);
            }
          }
          getTile(K, J, le) {
            K = +K, J = +J, le = +le;
            const be = this.options, { extent: ye, debug: Je } = be;
            if (K < 0 || K > 24) return null;
            const qe = 1 << K, Be = In(K, J = J + qe & qe - 1, le);
            if (this.tiles[Be]) return tr(this.tiles[Be], ye);
            Je > 1 && console.log("drilling down to z%d-%d-%d", K, J, le);
            let ze, ft = K, ct = J, Lt = le;
            for (; !ze && ft > 0; ) ft--, ct >>= 1, Lt >>= 1, ze = this.tiles[In(ft, ct, Lt)];
            return ze && ze.source ? (Je > 1 && (console.log("found parent tile z%d-%d-%d", ft, ct, Lt), console.time("drilling down")), this.splitTile(ze.source, ft, ct, Lt, K, J, le), Je > 1 && console.timeEnd("drilling down"), this.tiles[Be] ? tr(this.tiles[Be], ye) : null) : null;
          }
        }
        function In(He, K, J) {
          return 32 * ((1 << He) * J + K) + He;
        }
        class Ks extends re {
          constructor(K, J, le, be = er) {
            super(K, J, le), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = be;
          }
          loadVectorTile(K, J) {
            return T._(this, void 0, void 0, (function* () {
              const le = K.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const be = this._geoJSONIndex.getTile(le.z, le.x, le.y);
              return be ? ce(new T.d2(be.features, { version: 2, extent: T.a5 })) : null;
            }));
          }
          loadData(K) {
            return T._(this, void 0, void 0, (function* () {
              var J;
              (J = this._pendingRequest) === null || J === void 0 || J.abort();
              const le = this._startPerformance(K);
              this._pendingRequest = new AbortController();
              try {
                (!this._pendingData || K.request || K.data || K.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(K, this._pendingRequest));
                const be = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(be, K), this.loaded = {};
                const ye = {};
                return K.request && (ye.data = be), this._finishPerformance(le, K, ye), ye;
              } catch (be) {
                if (delete this._pendingRequest, T.Z(be)) return { abandoned: !0 };
                throw be;
              }
            }));
          }
          _startPerformance(K) {
            var J;
            if (!((J = K?.request) === null || J === void 0) && J.collectResourceTiming) return new T.c_(K.request);
          }
          _finishPerformance(K, J, le) {
            if (!K) return;
            const be = K.finish();
            be && (le.resourceTiming = {}, le.resourceTiming[J.source] = JSON.parse(JSON.stringify(be)));
          }
          getData() {
            return T._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(K) {
            const J = this.loaded;
            return J && J[K.uid] ? super.reloadTile(K) : this.loadTile(K);
          }
          loadAndProcessGeoJSON(K, J) {
            return T._(this, void 0, void 0, (function* () {
              let le;
              if (K.request ? le = yield this.loadGeoJSONFromUrl(K.request, K.promoteId, J) : K.data ? le = this._loadGeoJSONFromObject(K.data, K.promoteId) : K.dataDiff && (le = this._loadGeoJSONFromDiff(K.dataDiff, K.promoteId, K.source)), delete this._pendingRequest, typeof le != "object") throw new Error(`Input data given to '${K.source}' is not a valid GeoJSON object.`);
              return et(le, !0), K.filter && (le = this._filterGeoJSON(le, K.filter)), le;
            }));
          }
          loadGeoJSONFromUrl(K, J, le) {
            return T._(this, void 0, void 0, (function* () {
              const be = yield T.j(K, le);
              return this._dataUpdateable = T.a7(be.data, J), be.data;
            }));
          }
          _loadGeoJSONFromObject(K, J) {
            return this._dataUpdateable = T.a7(K, J), K;
          }
          _loadGeoJSONFromDiff(K, J, le) {
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${le}`);
            T.a8(this._dataUpdateable, K, J);
            const be = Array.from(this._dataUpdateable.values());
            return this._toFeatureCollection(be);
          }
          _filterGeoJSON(K, J) {
            const le = T.d3(J, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
            if (le.result === "error") throw new Error(le.value.map(((ye) => `${ye.key}: ${ye.message}`)).join(", "));
            const be = K.features.filter(((ye) => le.value.evaluate({ zoom: 0 }, ye)));
            return this._toFeatureCollection(be);
          }
          _toFeatureCollection(K) {
            return { type: "FeatureCollection", features: K };
          }
          removeSource(K) {
            return T._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(K) {
            return this._geoJSONIndex.getClusterExpansionZoom(K.clusterId);
          }
          getClusterChildren(K) {
            return this._geoJSONIndex.getChildren(K.clusterId);
          }
          getClusterLeaves(K) {
            return this._geoJSONIndex.getLeaves(K.clusterId, K.limit, K.offset);
          }
        }
        function er(He, K) {
          return K.cluster ? new ie((function({ superclusterOptions: J, clusterProperties: le }) {
            if (!le || !J) return J;
            const be = {}, ye = {}, Je = { accumulated: null, zoom: 0 }, qe = { properties: null }, Be = Object.keys(le);
            for (const ze of Be) {
              const [ft, ct] = le[ze], Lt = T.d3(ct), Nt = T.d3(typeof ft == "string" ? [ft, ["accumulated"], ["get", ze]] : ft);
              be[ze] = Lt.value, ye[ze] = Nt.value;
            }
            return J.map = (ze) => {
              qe.properties = ze;
              const ft = {};
              for (const ct of Be) ft[ct] = be[ct].evaluate(Je, qe);
              return ft;
            }, J.reduce = (ze, ft) => {
              qe.properties = ft;
              for (const ct of Be) Je.accumulated = ze[ct], ze[ct] = ye[ct].evaluate(Je, qe);
            }, J;
          })(K)).load(He.features) : (function(J, le) {
            return new Zi(J, le);
          })(He, K.geojsonVtOptions);
        }
        class Kr {
          constructor(K) {
            this.self = K, this.actor = new T.L(K), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (J, le) => {
              if (this.externalWorkerSourceTypes[J]) throw new Error(`Worker source with name "${J}" already registered.`);
              this.externalWorkerSourceTypes[J] = le;
            }, this.self.addProtocol = T.cJ, this.self.removeProtocol = T.cK, this.self.registerRTLTextPlugin = (J) => {
              T.d4.setMethods(J);
            }, this.actor.registerMessageHandler("LDT", ((J, le) => this._getDEMWorkerSource(J, le.source).loadTile(le))), this.actor.registerMessageHandler("RDT", ((J, le) => T._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(J, le.source).removeTile(le);
            })))), this.actor.registerMessageHandler("GCEZ", ((J, le) => T._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(J, le.type, le.source).getClusterExpansionZoom(le);
            })))), this.actor.registerMessageHandler("GCC", ((J, le) => T._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(J, le.type, le.source).getClusterChildren(le);
            })))), this.actor.registerMessageHandler("GCL", ((J, le) => T._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(J, le.type, le.source).getClusterLeaves(le);
            })))), this.actor.registerMessageHandler("LD", ((J, le) => this._getWorkerSource(J, le.type, le.source).loadData(le))), this.actor.registerMessageHandler("GD", ((J, le) => this._getWorkerSource(J, le.type, le.source).getData())), this.actor.registerMessageHandler("LT", ((J, le) => this._getWorkerSource(J, le.type, le.source).loadTile(le))), this.actor.registerMessageHandler("RT", ((J, le) => this._getWorkerSource(J, le.type, le.source).reloadTile(le))), this.actor.registerMessageHandler("AT", ((J, le) => this._getWorkerSource(J, le.type, le.source).abortTile(le))), this.actor.registerMessageHandler("RMT", ((J, le) => this._getWorkerSource(J, le.type, le.source).removeTile(le))), this.actor.registerMessageHandler("RS", ((J, le) => T._(this, void 0, void 0, (function* () {
              if (!this.workerSources[J] || !this.workerSources[J][le.type] || !this.workerSources[J][le.type][le.source]) return;
              const be = this.workerSources[J][le.type][le.source];
              delete this.workerSources[J][le.type][le.source], be.removeSource !== void 0 && be.removeSource(le);
            })))), this.actor.registerMessageHandler("RM", ((J) => T._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[J], delete this.availableImages[J], delete this.workerSources[J], delete this.demWorkerSources[J], this.globalStates.delete(J);
            })))), this.actor.registerMessageHandler("SR", ((J, le) => T._(this, void 0, void 0, (function* () {
              this.referrer = le;
            })))), this.actor.registerMessageHandler("SRPS", ((J, le) => this._syncRTLPluginState(J, le))), this.actor.registerMessageHandler("IS", ((J, le) => T._(this, void 0, void 0, (function* () {
              this.self.importScripts(le);
            })))), this.actor.registerMessageHandler("SI", ((J, le) => this._setImages(J, le))), this.actor.registerMessageHandler("UL", ((J, le) => T._(this, void 0, void 0, (function* () {
              this._getLayerIndex(J).update(le.layers, le.removedIds, this._getGlobalState(J));
            })))), this.actor.registerMessageHandler("UGS", ((J, le) => T._(this, void 0, void 0, (function* () {
              const be = this._getGlobalState(J);
              for (const ye in le) be[ye] = le[ye];
            })))), this.actor.registerMessageHandler("SL", ((J, le) => T._(this, void 0, void 0, (function* () {
              this._getLayerIndex(J).replace(le, this._getGlobalState(J));
            }))));
          }
          _getGlobalState(K) {
            let J = this.globalStates.get(K);
            return J || (J = {}, this.globalStates.set(K, J)), J;
          }
          _setImages(K, J) {
            return T._(this, void 0, void 0, (function* () {
              this.availableImages[K] = J;
              for (const le in this.workerSources[K]) {
                const be = this.workerSources[K][le];
                for (const ye in be) be[ye].availableImages = J;
              }
            }));
          }
          _syncRTLPluginState(K, J) {
            return T._(this, void 0, void 0, (function* () {
              return yield T.d4.syncState(J, this.self.importScripts);
            }));
          }
          _getAvailableImages(K) {
            let J = this.availableImages[K];
            return J || (J = []), J;
          }
          _getLayerIndex(K) {
            let J = this.layerIndexes[K];
            return J || (J = this.layerIndexes[K] = new u()), J;
          }
          _getWorkerSource(K, J, le) {
            if (this.workerSources[K] || (this.workerSources[K] = {}), this.workerSources[K][J] || (this.workerSources[K][J] = {}), !this.workerSources[K][J][le]) {
              const be = { sendAsync: (ye, Je) => (ye.targetMapId = K, this.actor.sendAsync(ye, Je)) };
              switch (J) {
                case "vector":
                  this.workerSources[K][J][le] = new re(be, this._getLayerIndex(K), this._getAvailableImages(K));
                  break;
                case "geojson":
                  this.workerSources[K][J][le] = new Ks(be, this._getLayerIndex(K), this._getAvailableImages(K));
                  break;
                default:
                  this.workerSources[K][J][le] = new this.externalWorkerSourceTypes[J](be, this._getLayerIndex(K), this._getAvailableImages(K));
              }
            }
            return this.workerSources[K][J][le];
          }
          _getDEMWorkerSource(K, J) {
            return this.demWorkerSources[K] || (this.demWorkerSources[K] = {}), this.demWorkerSources[K][J] || (this.demWorkerSources[K][J] = new Pe()), this.demWorkerSources[K][J];
          }
        }
        return T.i(self) && (self.worker = new Kr(self)), Kr;
      })), x("index", ["exports", "./shared"], (function(T, u) {
        var R = "5.16.0";
        function z() {
          var b = new u.A(4);
          return u.A != Float32Array && (b[1] = 0, b[2] = 0), b[0] = 1, b[3] = 1, b;
        }
        let U, $, ee;
        const oe = { frame(b, t, s) {
          const d = requestAnimationFrame(((w) => {
            g(), t(w);
          })), { unsubscribe: g } = u.s(b.signal, "abort", (() => {
            g(), cancelAnimationFrame(d), s(new u.a(b.signal.reason));
          }), !1);
        }, frameAsync(b) {
          return new Promise(((t, s) => {
            this.frame(b, t, s);
          }));
        }, getImageData(b, t = 0) {
          return this.getImageCanvasContext(b).getImageData(-t, -t, b.width + 2 * t, b.height + 2 * t);
        }, getImageCanvasContext(b) {
          const t = window.document.createElement("canvas"), s = t.getContext("2d", { willReadFrequently: !0 });
          if (!s) throw new Error("failed to create canvas 2d context");
          return t.width = b.width, t.height = b.height, s.drawImage(b, 0, 0, b.width, b.height), s;
        }, resolveURL: (b) => (U || (U = document.createElement("a")), U.href = b, U.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return ee !== void 0 ? ee : !!matchMedia && ($ == null && ($ = matchMedia("(prefers-reduced-motion: reduce)")), $.matches);
        }, set prefersReducedMotion(b) {
          ee = b;
        } }, ce = new class {
          constructor() {
            this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
          }
          getCurrentTime() {
            return this._frozenAt !== null ? this._frozenAt : this._realTime();
          }
          setNow(b) {
            this._frozenAt = b;
          }
          restoreNow() {
            this._frozenAt = null;
          }
          isFrozen() {
            return this._frozenAt !== null;
          }
        }();
        function me() {
          return ce.getCurrentTime();
        }
        class re {
          static testProp(t) {
            if (!re.docStyle) return t[0];
            for (let s = 0; s < t.length; s++) if (t[s] in re.docStyle) return t[s];
            return t[0];
          }
          static create(t, s, d) {
            const g = window.document.createElement(t);
            return s !== void 0 && (g.className = s), d && d.appendChild(g), g;
          }
          static createNS(t, s) {
            return window.document.createElementNS(t, s);
          }
          static disableDrag() {
            re.docStyle && re.selectProp && (re.userSelect = re.docStyle[re.selectProp], re.docStyle[re.selectProp] = "none");
          }
          static enableDrag() {
            re.docStyle && re.selectProp && (re.docStyle[re.selectProp] = re.userSelect);
          }
          static setTransform(t, s) {
            t.style[re.transformProp] = s;
          }
          static addEventListener(t, s, d, g = {}) {
            t.addEventListener(s, d, "passive" in g ? g : g.capture);
          }
          static removeEventListener(t, s, d, g = {}) {
            t.removeEventListener(s, d, "passive" in g ? g : g.capture);
          }
          static suppressClickInternal(t) {
            t.preventDefault(), t.stopPropagation(), window.removeEventListener("click", re.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", re.suppressClickInternal, !0), window.setTimeout((() => {
              window.removeEventListener("click", re.suppressClickInternal, !0);
            }), 0);
          }
          static getScale(t) {
            const s = t.getBoundingClientRect();
            return { x: s.width / t.offsetWidth || 1, y: s.height / t.offsetHeight || 1, boundingClientRect: s };
          }
          static getPoint(t, s, d) {
            const g = s.boundingClientRect;
            return new u.P((d.clientX - g.left) / s.x - t.clientLeft, (d.clientY - g.top) / s.y - t.clientTop);
          }
          static mousePos(t, s) {
            const d = re.getScale(t);
            return re.getPoint(t, d, s);
          }
          static touchPos(t, s) {
            const d = [], g = re.getScale(t);
            for (let w = 0; w < s.length; w++) d.push(re.getPoint(t, g, s[w]));
            return d;
          }
          static mouseButton(t) {
            return t.button;
          }
          static remove(t) {
            t.parentNode && t.parentNode.removeChild(t);
          }
          static sanitize(t) {
            const s = new DOMParser().parseFromString(t, "text/html").body || document.createElement("body"), d = s.querySelectorAll("script");
            for (const g of d) g.remove();
            return re.clean(s), s.innerHTML;
          }
          static isPossiblyDangerous(t, s) {
            const d = s.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(t) || !d.includes("javascript:") && !d.includes("data:")) || !!t.startsWith("on") || void 0;
          }
          static clean(t) {
            const s = t.children;
            for (const d of s) re.removeAttributes(d), re.clean(d);
          }
          static removeAttributes(t) {
            for (const { name: s, value: d } of t.attributes) re.isPossiblyDangerous(s, d) && t.removeAttribute(s);
          }
        }
        re.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, re.selectProp = re.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), re.transformProp = re.testProp(["transform", "WebkitTransform"]);
        const Pe = { supported: !1, testSupport: function(b) {
          !Qe && je && (et ? Ye(b) : _e = b);
        } };
        let _e, je, Qe = !1, et = !1;
        function Ye(b) {
          const t = b.createTexture();
          b.bindTexture(b.TEXTURE_2D, t);
          try {
            if (b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, je), b.isContextLost()) return;
            Pe.supported = !0;
          } catch {
          }
          b.deleteTexture(t), Qe = !0;
        }
        var ot;
        typeof document < "u" && (je = document.createElement("img"), je.onload = () => {
          _e && Ye(_e), _e = null, et = !0;
        }, je.onerror = () => {
          Qe = !0, _e = null;
        }, je.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(b) {
          let t, s, d, g;
          b.resetRequestQueue = () => {
            t = [], s = 0, d = 0, g = {};
          }, b.addThrottleControl = (A) => {
            const F = d++;
            return g[F] = A, F;
          }, b.removeThrottleControl = (A) => {
            delete g[A], S();
          }, b.getImage = (A, F, O = !0) => new Promise(((q, V) => {
            Pe.supported && (A.headers || (A.headers = {}), A.headers.accept = "image/webp,*/*"), u.e(A, { type: "image" }), t.push({ abortController: F, requestParameters: A, supportImageRefresh: O, state: "queued", onError: (W) => {
              V(W);
            }, onSuccess: (W) => {
              q(W);
            } }), S();
          }));
          const w = (A) => u._(this, void 0, void 0, (function* () {
            A.state = "running";
            const { requestParameters: F, supportImageRefresh: O, onError: q, onSuccess: V, abortController: W } = A, te = O === !1 && !u.i(self) && !u.g(F.url) && (!F.headers || Object.keys(F.headers).reduce(((fe, we) => fe && we === "accept"), !0));
            s++;
            const he = te ? C(F, W) : u.m(F, W);
            try {
              const fe = yield he;
              delete A.abortController, A.state = "completed", fe.data instanceof HTMLImageElement || u.b(fe.data) ? V(fe) : fe.data && V({ data: yield (pe = fe.data, typeof createImageBitmap == "function" ? u.f(pe) : u.h(pe)), cacheControl: fe.cacheControl, expires: fe.expires });
            } catch (fe) {
              delete A.abortController, q(fe);
            } finally {
              s--, S();
            }
            var pe;
          })), S = () => {
            const A = (() => {
              for (const F of Object.keys(g)) if (g[F]()) return !0;
              return !1;
            })() ? u.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : u.c.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let F = s; F < A && t.length > 0; F++) {
              const O = t.shift();
              O.abortController.signal.aborted ? F-- : w(O);
            }
          }, C = (A, F) => new Promise(((O, q) => {
            const V = new Image(), W = A.url, te = A.credentials;
            te && te === "include" ? V.crossOrigin = "use-credentials" : (te && te === "same-origin" || !u.d(W)) && (V.crossOrigin = "anonymous"), F.signal.addEventListener("abort", (() => {
              V.src = "", q(new u.a(F.signal.reason));
            })), V.fetchPriority = "high", V.onload = () => {
              V.onerror = V.onload = null, O({ data: V });
            }, V.onerror = () => {
              V.onerror = V.onload = null, F.signal.aborted || q(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, V.src = W;
          }));
        })(ot || (ot = {})), ot.resetRequestQueue();
        class Q {
          constructor(t) {
            this._transformRequestFn = t ?? null;
          }
          transformRequest(t, s) {
            return this._transformRequestFn && this._transformRequestFn(t, s) || { url: t };
          }
          setTransformRequest(t) {
            this._transformRequestFn = t;
          }
        }
        function ie(b) {
          const t = [];
          if (typeof b == "string") t.push({ id: "default", url: b });
          else if (b && b.length > 0) {
            const s = [];
            for (const { id: d, url: g } of b) {
              const w = `${d}${g}`;
              s.indexOf(w) === -1 && (s.push(w), t.push({ id: d, url: g }));
            }
          }
          return t;
        }
        function ge(b, t, s) {
          try {
            const d = new URL(b);
            return d.pathname += `${t}${s}`, d.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${b}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function Se(b) {
          const { userImage: t } = b;
          return !!(t && t.render && t.render()) && (b.data.replace(new Uint8Array(t.data.buffer)), !0);
        }
        class Ie extends u.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new u.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          destroy() {
            this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null);
            for (const t of Object.keys(this.images)) this.removeImage(t);
            this.patterns = {}, this.atlasImage = new u.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t) {
            if (this.loaded !== t && (this.loaded = t, t)) {
              for (const { ids: s, promiseResolve: d } of this.requestors) d(this._getImagesForIds(s));
              this.requestors = [];
            }
          }
          getImage(t) {
            const s = this.images[t];
            if (s && !s.data && s.spriteData) {
              const d = s.spriteData;
              s.data = new u.R({ width: d.width, height: d.height }, d.context.getImageData(d.x, d.y, d.width, d.height).data), s.spriteData = null;
            }
            return s;
          }
          addImage(t, s) {
            if (this.images[t]) throw new Error(`Image id ${t} already exist, use updateImage instead`);
            this._validate(t, s) && (this.images[t] = s);
          }
          _validate(t, s) {
            let d = !0;
            const g = s.data || s.spriteData;
            return this._validateStretch(s.stretchX, g && g.width) || (this.fire(new u.k(new Error(`Image "${t}" has invalid "stretchX" value`))), d = !1), this._validateStretch(s.stretchY, g && g.height) || (this.fire(new u.k(new Error(`Image "${t}" has invalid "stretchY" value`))), d = !1), this._validateContent(s.content, s) || (this.fire(new u.k(new Error(`Image "${t}" has invalid "content" value`))), d = !1), d;
          }
          _validateStretch(t, s) {
            if (!t) return !0;
            let d = 0;
            for (const g of t) {
              if (g[0] < d || g[1] < g[0] || s < g[1]) return !1;
              d = g[1];
            }
            return !0;
          }
          _validateContent(t, s) {
            if (!t) return !0;
            if (t.length !== 4) return !1;
            const d = s.spriteData, g = d && d.width || s.data.width, w = d && d.height || s.data.height;
            return !(t[0] < 0 || g < t[0] || t[1] < 0 || w < t[1] || t[2] < 0 || g < t[2] || t[3] < 0 || w < t[3] || t[2] < t[0] || t[3] < t[1]);
          }
          updateImage(t, s, d = !0) {
            const g = this.getImage(t);
            if (d && (g.data.width !== s.data.width || g.data.height !== s.data.height)) throw new Error(`size mismatch between old image (${g.data.width}x${g.data.height}) and new image (${s.data.width}x${s.data.height}).`);
            s.version = g.version + 1, this.images[t] = s, this.updatedImages[t] = !0;
          }
          removeImage(t) {
            const s = this.images[t];
            delete this.images[t], delete this.patterns[t], s.userImage && s.userImage.onRemove && s.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t) {
            return new Promise(((s, d) => {
              let g = !0;
              if (!this.isLoaded()) for (const w of t) this.images[w] || (g = !1);
              this.isLoaded() || g ? s(this._getImagesForIds(t)) : this.requestors.push({ ids: t, promiseResolve: s });
            }));
          }
          _getImagesForIds(t) {
            const s = {};
            for (const d of t) {
              let g = this.getImage(d);
              g || (this.fire(new u.l("styleimagemissing", { id: d })), g = this.getImage(d)), g ? s[d] = { data: g.data.clone(), pixelRatio: g.pixelRatio, sdf: g.sdf, version: g.version, stretchX: g.stretchX, stretchY: g.stretchY, content: g.content, textFitWidth: g.textFitWidth, textFitHeight: g.textFitHeight, hasRenderCallback: !!(g.userImage && g.userImage.render) } : u.w(`Image "${d}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return s;
          }
          getPixelSize() {
            const { width: t, height: s } = this.atlasImage;
            return { width: t, height: s };
          }
          getPattern(t) {
            const s = this.patterns[t], d = this.getImage(t);
            if (!d) return null;
            if (s && s.position.version === d.version) return s.position;
            if (s) s.position.version = d.version;
            else {
              const g = { w: d.data.width + 2, h: d.data.height + 2, x: 0, y: 0 }, w = new u.I(g, d);
              this.patterns[t] = { bin: g, position: w };
            }
            return this._updatePatternAtlas(), this.patterns[t].position;
          }
          bind(t) {
            const s = t.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new u.T(t, this.atlasImage, s.RGBA), this.atlasTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t = [];
            for (const w in this.patterns) t.push(this.patterns[w].bin);
            const { w: s, h: d } = u.p(t), g = this.atlasImage;
            g.resize({ width: s || 1, height: d || 1 });
            for (const w in this.patterns) {
              const { bin: S } = this.patterns[w], C = S.x + 1, A = S.y + 1, F = this.getImage(w).data, O = F.width, q = F.height;
              u.R.copy(F, g, { x: 0, y: 0 }, { x: C, y: A }, { width: O, height: q }), u.R.copy(F, g, { x: 0, y: q - 1 }, { x: C, y: A - 1 }, { width: O, height: 1 }), u.R.copy(F, g, { x: 0, y: 0 }, { x: C, y: A + q }, { width: O, height: 1 }), u.R.copy(F, g, { x: O - 1, y: 0 }, { x: C - 1, y: A }, { width: 1, height: q }), u.R.copy(F, g, { x: 0, y: 0 }, { x: C + O, y: A }, { width: 1, height: q });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(t) {
            for (const s of t) {
              if (this.callbackDispatchedThisFrame[s]) continue;
              this.callbackDispatchedThisFrame[s] = !0;
              const d = this.getImage(s);
              d || u.w(`Image with ID: "${s}" was not found`), Se(d) && this.updateImage(s, d);
            }
          }
          cloneImages() {
            const t = {};
            for (const s in this.images) {
              const d = this.images[s];
              t[s] = Object.assign(Object.assign({}, d), { data: d.data ? d.data.clone() : null });
            }
            return t;
          }
        }
        const Oe = 1e20;
        function Re(b, t, s, d, g, w, S, C, A) {
          for (let F = t; F < t + d; F++) De(b, s * w + F, w, g, S, C, A);
          for (let F = s; F < s + g; F++) De(b, F * w + t, 1, d, S, C, A);
        }
        function De(b, t, s, d, g, w, S) {
          w[0] = 0, S[0] = -Oe, S[1] = Oe, g[0] = b[t];
          for (let C = 1, A = 0, F = 0; C < d; C++) {
            g[C] = b[t + C * s];
            const O = C * C;
            do {
              const q = w[A];
              F = (g[C] - g[q] + O - q * q) / (C - q) / 2;
            } while (F <= S[A] && --A > -1);
            A++, w[A] = C, S[A] = F, S[A + 1] = Oe;
          }
          for (let C = 0, A = 0; C < d; C++) {
            for (; S[A + 1] < C; ) A++;
            const F = w[A], O = C - F;
            b[t + C * s] = g[F] + O * O;
          }
        }
        const Fe = u.v.layout_symbol["text-font"].default.join(",");
        class Ue {
          constructor(t, s, d) {
            this.requestManager = t, this.localIdeographFontFamily = s, this.entries = {}, this.lang = d;
          }
          setURL(t) {
            this.url = t;
          }
          getGlyphs(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = [];
              for (const w in t) for (const S of t[w]) s.push(this._getAndCacheGlyphsPromise(w, S));
              const d = yield Promise.all(s), g = {};
              for (const { stack: w, id: S, glyph: C } of d) g[w] || (g[w] = {}), g[w][S] = C && { id: C.id, bitmap: C.bitmap.clone(), metrics: C.metrics };
              return g;
            }));
          }
          _getAndCacheGlyphsPromise(t, s) {
            return u._(this, void 0, void 0, (function* () {
              let d = this.entries[t];
              d || (d = this.entries[t] = { glyphs: {}, requests: {}, ranges: {} });
              let g = d.glyphs[s];
              return g !== void 0 ? { stack: t, id: s, glyph: g } : !this.url || this._charUsesLocalIdeographFontFamily(s) ? (g = d.glyphs[s] = this._drawGlyph(d, t, s), { stack: t, id: s, glyph: g }) : yield this._downloadAndCacheRangePromise(t, s);
            }));
          }
          _downloadAndCacheRangePromise(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = this.entries[t], g = Math.floor(s / 256);
              if (d.ranges[g]) return { stack: t, id: s, glyph: null };
              if (!d.requests[g]) {
                const w = Ue.loadGlyphRange(t, g, this.url, this.requestManager);
                d.requests[g] = w;
              }
              try {
                const w = yield d.requests[g];
                for (const S in w) d.glyphs[+S] = w[+S];
                return d.ranges[g] = !0, { stack: t, id: s, glyph: w[s] || null };
              } catch (w) {
                const S = d.glyphs[s] = this._drawGlyph(d, t, s);
                return this._warnOnMissingGlyphRange(S, g, s, w), { stack: t, id: s, glyph: S };
              }
            }));
          }
          _warnOnMissingGlyphRange(t, s, d, g) {
            const w = 256 * s, S = w + 255, C = d.toString(16).padStart(4, "0").toUpperCase();
            u.w(`Unable to load glyph range ${s}, ${w}-${S}. Rendering codepoint U+${C} locally instead. ${g}`);
          }
          _charUsesLocalIdeographFontFamily(t) {
            return !!this.localIdeographFontFamily && u.q(t);
          }
          _drawGlyph(t, s, d) {
            const g = s === Fe && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(d), w = g ? "ideographTinySDF" : "tinySDF";
            t[w] || (t[w] = this._createTinySDF(g ? this.localIdeographFontFamily : s));
            const S = t[w].draw(String.fromCodePoint(d)), C = new RegExp("^\\p{gc=Cf}+$", "u").test(String.fromCodePoint(d));
            return { id: d, bitmap: new u.r({ width: S.width || 60, height: S.height || 60 }, S.data), metrics: { width: C ? 0 : S.glyphWidth / 2 || 24, height: S.glyphHeight / 2 || 24, left: S.glyphLeft / 2 + 0.5 || 0, top: S.glyphTop / 2 - 27.5 || -8, advance: C ? 0 : S.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
          _createTinySDF(t) {
            const s = t ? t.split(",") : [];
            s.push("sans-serif");
            const d = s.map(((g) => /[-\w]+/.test(g) ? g : `'${CSS.escape(g)}'`)).join(",");
            return new Ue.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: d, fontWeight: this._fontWeight(s[0]), fontStyle: this._fontStyle(s[0]), lang: this.lang });
          }
          _fontStyle(t) {
            return /italic/i.test(t) ? "italic" : /oblique/i.test(t) ? "oblique" : "normal";
          }
          _fontWeight(t) {
            const s = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 };
            let d;
            for (const [g, w] of Object.entries(s)) new RegExp(`\\b${g}\\b`, "i").test(t) && (d = `${w}`);
            return d;
          }
          destroy() {
            for (const t in this.entries) {
              const s = this.entries[t];
              s.tinySDF && (s.tinySDF = null), s.ideographTinySDF && (s.ideographTinySDF = null), s.glyphs = {}, s.requests = {}, s.ranges = {};
            }
            this.entries = {};
          }
        }
        Ue.loadGlyphRange = function(b, t, s, d) {
          return u._(this, void 0, void 0, (function* () {
            const g = 256 * t, w = g + 255, S = d.transformRequest(s.replace("{fontstack}", b).replace("{range}", `${g}-${w}`), "Glyphs"), C = yield u.n(S, new AbortController());
            if (!C || !C.data) throw new Error(`Could not load glyph range. range: ${t}, ${g}-${w}`);
            const A = {};
            for (const F of u.o(C.data)) A[F.id] = F;
            return A;
          }));
        }, Ue.TinySDF = class {
          constructor({ fontSize: b = 24, buffer: t = 3, radius: s = 8, cutoff: d = 0.25, fontFamily: g = "sans-serif", fontWeight: w = "normal", fontStyle: S = "normal", lang: C = null } = {}) {
            this.buffer = t, this.cutoff = d, this.radius = s, this.lang = C;
            const A = this.size = b + 4 * t, F = this._createCanvas(A), O = this.ctx = F.getContext("2d", { willReadFrequently: !0 });
            O.font = `${S} ${w} ${b}px ${g}`, O.textBaseline = "alphabetic", O.textAlign = "left", O.fillStyle = "black", this.gridOuter = new Float64Array(A * A), this.gridInner = new Float64Array(A * A), this.f = new Float64Array(A), this.z = new Float64Array(A + 1), this.v = new Uint16Array(A);
          }
          _createCanvas(b) {
            const t = document.createElement("canvas");
            return t.width = t.height = b, t;
          }
          draw(b) {
            const { width: t, actualBoundingBoxAscent: s, actualBoundingBoxDescent: d, actualBoundingBoxLeft: g, actualBoundingBoxRight: w } = this.ctx.measureText(b), S = Math.ceil(s), C = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(w - g))), A = Math.min(this.size - this.buffer, S + Math.ceil(d)), F = C + 2 * this.buffer, O = A + 2 * this.buffer, q = Math.max(F * O, 0), V = new Uint8ClampedArray(q), W = { data: V, width: F, height: O, glyphWidth: C, glyphHeight: A, glyphTop: S, glyphLeft: 0, glyphAdvance: t };
            if (C === 0 || A === 0) return W;
            const { ctx: te, buffer: he, gridInner: pe, gridOuter: fe } = this;
            this.lang && (te.lang = this.lang), te.clearRect(he, he, C, A), te.fillText(b, he, he + S);
            const we = te.getImageData(he, he, C, A);
            fe.fill(Oe, 0, q), pe.fill(0, 0, q);
            for (let Le = 0; Le < A; Le++) for (let ve = 0; ve < C; ve++) {
              const Ce = we.data[4 * (Le * C + ve) + 3] / 255;
              if (Ce === 0) continue;
              const Ne = (Le + he) * F + ve + he;
              if (Ce === 1) fe[Ne] = 0, pe[Ne] = Oe;
              else {
                const ke = 0.5 - Ce;
                fe[Ne] = ke > 0 ? ke * ke : 0, pe[Ne] = ke < 0 ? ke * ke : 0;
              }
            }
            Re(fe, 0, 0, F, O, F, this.f, this.v, this.z), Re(pe, he, he, C, A, F, this.f, this.v, this.z);
            for (let Le = 0; Le < q; Le++) {
              const ve = Math.sqrt(fe[Le]) - Math.sqrt(pe[Le]);
              V[Le] = Math.round(255 - 255 * (ve / this.radius + this.cutoff));
            }
            return W;
          }
        };
        class Ve {
          constructor() {
            this.specification = u.u.light.position;
          }
          possiblyEvaluate(t, s) {
            return u.F(t.expression.evaluate(s));
          }
          interpolate(t, s, d) {
            return { x: u.G.number(t.x, s.x, d), y: u.G.number(t.y, s.y, d), z: u.G.number(t.z, s.z, d) };
          }
        }
        let We;
        class dt extends u.E {
          constructor(t) {
            super(), We = We || new u.t({ anchor: new u.D(u.u.light.anchor), position: new Ve(), color: new u.D(u.u.light.color), intensity: new u.D(u.u.light.intensity) }), this._transitionable = new u.x(We, void 0), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t, s = {}) {
            if (!this._validate(u.y, t, s)) for (const d in t) {
              const g = t[d];
              d.endsWith(u.z) ? this._transitionable.setTransition(d.slice(0, -u.z.length), g) : this._transitionable.setValue(d, g);
            }
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, s, d) {
            return (!d || d.validate !== !1) && u.B(this, t.call(u.C, { value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: u.u }));
          }
        }
        const Tt = new u.t({ "sky-color": new u.D(u.u.sky["sky-color"]), "horizon-color": new u.D(u.u.sky["horizon-color"]), "fog-color": new u.D(u.u.sky["fog-color"]), "fog-ground-blend": new u.D(u.u.sky["fog-ground-blend"]), "horizon-fog-blend": new u.D(u.u.sky["horizon-fog-blend"]), "sky-horizon-blend": new u.D(u.u.sky["sky-horizon-blend"]), "atmosphere-blend": new u.D(u.u.sky["atmosphere-blend"]) });
        class Ht extends u.E {
          constructor(t) {
            super(), this._transitionable = new u.x(Tt, void 0), this.setSky(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new u.H(0));
          }
          setSky(t, s = {}) {
            if (!this._validate(u.J, t, s)) {
              t || (t = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const d in t) {
                const g = t[d];
                d.endsWith(u.z) ? this._transitionable.setTransition(d.slice(0, -u.z.length), g) : this._transitionable.setValue(d, g);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, s, d = {}) {
            return d?.validate !== !1 && u.B(this, t.call(u.C, u.e({ value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: u.u })));
          }
          calculateFogBlendOpacity(t) {
            return t < 60 ? 0 : t < 70 ? (t - 60) / 10 : 1;
          }
        }
        class Ot {
          constructor(t, s) {
            this.width = t, this.height = s, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t, s) {
            const d = t.join(",") + String(s);
            return this.dashEntry[d] || (this.dashEntry[d] = this.addDash(t, s)), this.dashEntry[d];
          }
          getDashRanges(t, s, d) {
            const g = [];
            let w = t.length % 2 == 1 ? -t[t.length - 1] * d : 0, S = t[0] * d, C = !0;
            g.push({ left: w, right: S, isDash: C, zeroLength: t[0] === 0 });
            let A = t[0];
            for (let F = 1; F < t.length; F++) {
              C = !C;
              const O = t[F];
              w = A * d, A += O, S = A * d, g.push({ left: w, right: S, isDash: C, zeroLength: O === 0 });
            }
            return g;
          }
          addRoundDash(t, s, d) {
            const g = s / 2;
            for (let w = -d; w <= d; w++) {
              const S = this.width * (this.nextRow + d + w);
              let C = 0, A = t[C];
              for (let F = 0; F < this.width; F++) {
                F / A.right > 1 && (A = t[++C]);
                const O = Math.abs(F - A.left), q = Math.abs(F - A.right), V = Math.min(O, q);
                let W;
                const te = w / d * (g + 1);
                if (A.isDash) {
                  const he = g - Math.abs(te);
                  W = Math.sqrt(V * V + he * he);
                } else W = g - Math.sqrt(V * V + te * te);
                this.data[S + F] = Math.max(0, Math.min(255, W + 128));
              }
            }
          }
          addRegularDash(t) {
            for (let C = t.length - 1; C >= 0; --C) {
              const A = t[C], F = t[C + 1];
              A.zeroLength ? t.splice(C, 1) : F && F.isDash === A.isDash && (F.left = A.left, t.splice(C, 1));
            }
            const s = t[0], d = t[t.length - 1];
            s.isDash === d.isDash && (s.left = d.left - this.width, d.right = s.right + this.width);
            const g = this.width * this.nextRow;
            let w = 0, S = t[w];
            for (let C = 0; C < this.width; C++) {
              C / S.right > 1 && (S = t[++w]);
              const A = Math.abs(C - S.left), F = Math.abs(C - S.right), O = Math.min(A, F);
              this.data[g + C] = Math.max(0, Math.min(255, (S.isDash ? O : -O) + 128));
            }
          }
          addDash(t, s) {
            const d = s ? 7 : 0, g = 2 * d + 1;
            if (this.nextRow + g > this.height) return u.w("LineAtlas out of space"), null;
            let w = 0;
            for (let C = 0; C < t.length; C++) w += t[C];
            if (w !== 0) {
              const C = this.width / w, A = this.getDashRanges(t, this.width, C);
              s ? this.addRoundDash(A, C, d) : this.addRegularDash(A);
            }
            const S = { y: this.nextRow + d, height: 2 * d, width: w };
            return this.nextRow += g, this.dirty = !0, S;
          }
          bind(t) {
            const s = t.gl;
            this.texture ? (s.bindTexture(s.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, this.width, this.height, s.ALPHA, s.UNSIGNED_BYTE, this.data))) : (this.texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this.texture), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texImage2D(s.TEXTURE_2D, 0, s.ALPHA, this.width, this.height, 0, s.ALPHA, s.UNSIGNED_BYTE, this.data));
          }
        }
        const Pt = "maplibre_preloaded_worker_pool";
        class Mt {
          constructor() {
            this.active = {};
          }
          acquire(t) {
            if (!this.workers) for (this.workers = []; this.workers.length < Mt.workerCount; ) this.workers.push(new Worker(u.c.WORKER_URL));
            return this.active[t] = !0, this.workers.slice();
          }
          release(t) {
            delete this.active[t], this.numActive() === 0 && (this.workers.forEach(((s) => {
              s.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Pt];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const Kt = Math.floor(oe.hardwareConcurrency / 2);
        let gr, Ze;
        function ri() {
          return gr || (gr = new Mt()), gr;
        }
        Mt.workerCount = u.K(globalThis) ? Math.max(Math.min(Kt, 3), 1) : 1;
        class lr {
          constructor(t, s) {
            this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = s;
            const d = this.workerPool.acquire(s);
            for (let g = 0; g < d.length; g++) {
              const w = new u.L(d[g], s);
              w.name = `Worker ${g}`, this.actors.push(w);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(t, s) {
            const d = [];
            for (const g of this.actors) d.push(g.sendAsync({ type: t, data: s }));
            return Promise.all(d);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(t = !0) {
            this.actors.forEach(((s) => {
              s.remove();
            })), this.actors = [], t && this.workerPool.release(this.id);
          }
          registerMessageHandler(t, s) {
            for (const d of this.actors) d.registerMessageHandler(t, s);
          }
          unregisterMessageHandler(t) {
            for (const s of this.actors) s.unregisterMessageHandler(t);
          }
        }
        function Ut() {
          return Ze || (Ze = new lr(ri(), u.M), Ze.registerMessageHandler("GR", ((b, t, s) => u.m(t, s)))), Ze;
        }
        function Me(b, t) {
          const s = u.N();
          return u.O(s, s, [1, 1, 0]), u.Q(s, s, [0.5 * b.width, 0.5 * b.height, 1]), b.calculatePosMatrix ? u.S(s, s, b.calculatePosMatrix(t.toUnwrapped())) : s;
        }
        function br(b, t, s, d, g, w, S) {
          var C;
          const A = (function(V, W, te) {
            if (V) for (const he of V) {
              const pe = W[he];
              if (pe && pe.source === te && pe.type === "fill-extrusion") return !0;
            }
            else for (const he in W) {
              const pe = W[he];
              if (pe.source === te && pe.type === "fill-extrusion") return !0;
            }
            return !1;
          })((C = g?.layers) !== null && C !== void 0 ? C : null, t, b.id), F = w.maxPitchScaleFactor(), O = b.tilesIn(d, F, A);
          O.sort(ur);
          const q = [];
          for (const V of O) q.push({ wrappedTileID: V.tileID.wrapped().key, queryResults: V.tile.queryRenderedFeatures(t, s, b.getState(), V.queryGeometry, V.cameraQueryGeometry, V.scale, g, w, F, Me(w, V.tileID), S ? (W, te) => S(V.tileID, W, te) : void 0) });
          return (function(V, W) {
            for (const te in V) for (const he of V[te]) tr(he, W);
            return V;
          })((function(V) {
            const W = {}, te = {};
            for (const he of V) {
              const pe = he.queryResults, fe = he.wrappedTileID, we = te[fe] = te[fe] || {};
              for (const Le in pe) {
                const ve = pe[Le], Ce = we[Le] = we[Le] || {}, Ne = W[Le] = W[Le] || [];
                for (const ke of ve) Ce[ke.featureIndex] || (Ce[ke.featureIndex] = !0, Ne.push(ke));
              }
            }
            return W;
          })(q), b);
        }
        function ur(b, t) {
          const s = b.tileID, d = t.tileID;
          return s.overscaledZ - d.overscaledZ || s.canonical.y - d.canonical.y || s.wrap - d.wrap || s.canonical.x - d.canonical.x;
        }
        function tr(b, t) {
          const s = b.feature, d = t.getFeatureState(s.layer["source-layer"], s.id);
          s.source = s.layer.source, s.layer["source-layer"] && (s.sourceLayer = s.layer["source-layer"]), s.state = d;
        }
        function mi(b, t, s) {
          return u._(this, void 0, void 0, (function* () {
            let d = b;
            if (b.url ? d = (yield u.j(t.transformRequest(b.url, "Source"), s)).data : yield oe.frameAsync(s), !d) return null;
            const g = u.U(u.e(d, b), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in d && d.vector_layers && (g.vectorLayerIds = d.vector_layers.map(((w) => w.id))), g;
          }));
        }
        class Nr {
          constructor(t, s) {
            t && (s ? this.setSouthWest(t).setNorthEast(s) : Array.isArray(t) && (t.length === 4 ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])));
          }
          setNorthEast(t) {
            return this._ne = t instanceof u.V ? new u.V(t.lng, t.lat) : u.V.convert(t), this;
          }
          setSouthWest(t) {
            return this._sw = t instanceof u.V ? new u.V(t.lng, t.lat) : u.V.convert(t), this;
          }
          extend(t) {
            const s = this._sw, d = this._ne;
            let g, w;
            if (t instanceof u.V) g = t, w = t;
            else {
              if (!(t instanceof Nr)) return Array.isArray(t) ? t.length === 4 || t.every(Array.isArray) ? this.extend(Nr.convert(t)) : this.extend(u.V.convert(t)) : t && ("lng" in t || "lon" in t) && "lat" in t ? this.extend(u.V.convert(t)) : this;
              if (g = t._sw, w = t._ne, !g || !w) return this;
            }
            return s || d ? (s.lng = Math.min(g.lng, s.lng), s.lat = Math.min(g.lat, s.lat), d.lng = Math.max(w.lng, d.lng), d.lat = Math.max(w.lat, d.lat)) : (this._sw = new u.V(g.lng, g.lat), this._ne = new u.V(w.lng, w.lat)), this;
          }
          getCenter() {
            return new u.V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new u.V(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new u.V(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t) {
            const { lng: s, lat: d } = u.V.convert(t);
            let g = this._sw.lng <= s && s <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (g = this._sw.lng >= s && s >= this._ne.lng), this._sw.lat <= d && d <= this._ne.lat && g;
          }
          intersects(t) {
            if (!((t = Nr.convert(t)).getNorth() >= this.getSouth() && t.getSouth() <= this.getNorth())) return !1;
            const s = Math.abs(this.getEast() - this.getWest()), d = Math.abs(t.getEast() - t.getWest());
            if (s >= 360 || d >= 360) return !0;
            const g = u.W(this.getWest(), -180, 180), w = u.W(this.getEast(), -180, 180), S = u.W(t.getWest(), -180, 180), C = u.W(t.getEast(), -180, 180), A = g >= w, F = S >= C;
            return !(!A || !F) || (A ? C >= g || S <= w : F ? w >= S || g <= C : S <= w && C >= g);
          }
          static convert(t) {
            return t instanceof Nr ? t : t && new Nr(t);
          }
          static fromLngLat(t, s = 0) {
            const d = 360 * s / 40075017, g = d / Math.cos(Math.PI / 180 * t.lat);
            return new Nr(new u.V(t.lng - g, t.lat - d), new u.V(t.lng + g, t.lat + d));
          }
          adjustAntiMeridian() {
            const t = new u.V(this._sw.lng, this._sw.lat), s = new u.V(this._ne.lng, this._ne.lat);
            return new Nr(t, t.lng > s.lng ? new u.V(s.lng + 360, s.lat) : s);
          }
        }
        class _i {
          constructor(t, s, d) {
            this.bounds = Nr.convert(this.validateBounds(t)), this.minzoom = s || 0, this.maxzoom = d || 24;
          }
          validateBounds(t) {
            return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
          }
          contains(t) {
            const s = Math.pow(2, t.z), d = Math.floor(u.Y(this.bounds.getWest()) * s), g = Math.floor(u.X(this.bounds.getNorth()) * s), w = Math.ceil(u.Y(this.bounds.getEast()) * s), S = Math.ceil(u.X(this.bounds.getSouth()) * s);
            return t.x >= d && t.x < w && t.y >= g && t.y < S;
          }
        }
        class St extends u.E {
          constructor(t, s, d, g) {
            if (super(), this.id = t, this.dispatcher = d, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, u.e(this, u.U(s, ["url", "scheme", "tileSize", "promoteId", "encoding"])), this._options = u.e({ type: "vector" }, s), this._collectResourceTiming = s.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(g);
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t = yield mi(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), t && (u.e(this, t), t.bounds && (this.tileBounds = new _i(t.bounds, this.minzoom, this.maxzoom)), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new u.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t) {
                this._tileJSONRequest = null, this._loaded = !0, u.Z(t) || this.fire(new u.k(t));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          setSourceProperty(t) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), t(), this.load();
          }
          setTiles(t) {
            return this.setSourceProperty((() => {
              this._options.tiles = t;
            })), this;
          }
          setUrl(t) {
            return this.setSourceProperty((() => {
              this.url = t, this._options.url = t;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return u.e({}, this._options);
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), d = { request: this.map._requestManager.transformRequest(s, "Tile"), uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, encoding: this.encoding, overzoomParameters: this._getOverzoomParameters(t) };
              d.request.collectResourceTiming = this._collectResourceTiming;
              let g = "RT";
              if (t.actor && t.state !== "expired") {
                if (t.state === "loading") return new Promise(((w, S) => {
                  t.reloadPromise = { resolve: w, reject: S };
                }));
              } else t.actor = this.dispatcher.getActor(), g = "LT";
              t.abortController = new AbortController();
              try {
                const w = yield t.actor.sendAsync({ type: g, data: d }, t.abortController);
                if (delete t.abortController, t.aborted) return;
                this._afterTileLoadWorkerResponse(t, w);
              } catch (w) {
                if (delete t.abortController, t.aborted) return;
                if (w && w.status !== 404) throw w;
                this._afterTileLoadWorkerResponse(t, null);
              }
            }));
          }
          _getOverzoomParameters(t) {
            if (t.tileID.canonical.z <= this.maxzoom || this.map._zoomLevelsToOverscale === void 0) return;
            const s = t.tileID.scaledTo(this.maxzoom).canonical, d = s.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            return { maxZoomTileID: s, overzoomRequest: this.map._requestManager.transformRequest(d, "Tile") };
          }
          _afterTileLoadWorkerResponse(t, s) {
            if (s && s.resourceTiming && (t.resourceTiming = s.resourceTiming), s && this.map._refreshExpiredTiles && t.setExpiryData(s), t.loadVectorData(s, this.map.painter), t.reloadPromise) {
              const d = t.reloadPromise;
              t.reloadPromise = null, this.loadTile(t).then(d.resolve).catch(d.reject);
            }
          }
          abortTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController), t.actor && (yield t.actor.sendAsync({ type: "AT", data: { uid: t.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.unloadVectorData(), t.actor && (yield t.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class $i extends u.E {
          constructor(t, s, d, g) {
            super(), this.id = t, this.dispatcher = d, this.setEventedParent(g), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = u.e({ type: "raster" }, s), u.e(this, u.U(s, ["url", "scheme", "tileSize"]));
          }
          load() {
            return u._(this, arguments, void 0, (function* (t = !1) {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const s = yield mi(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, s && (u.e(this, s), s.bounds && (this.tileBounds = new _i(s.bounds, this.minzoom, this.maxzoom)), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new u.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: t })));
              } catch (s) {
                this._tileJSONRequest = null, this._loaded = !0, u.Z(s) || this.fire(new u.k(s));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(t) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t(), this.load(!0);
          }
          setTiles(t) {
            return this.setSourceProperty((() => {
              this._options.tiles = t;
            })), this;
          }
          setUrl(t) {
            return this.setSourceProperty((() => {
              this.url = t, this._options.url = t;
            })), this;
          }
          serialize() {
            return u.e({}, this._options);
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              t.abortController = new AbortController();
              try {
                const d = yield ot.getImage(this.map._requestManager.transformRequest(s, "Tile"), t.abortController, this.map._refreshExpiredTiles);
                if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
                if (d && d.data) {
                  this.map._refreshExpiredTiles && (d.cacheControl || d.expires) && t.setExpiryData({ cacheControl: d.cacheControl, expires: d.expires });
                  const g = this.map.painter.context, w = g.gl, S = d.data;
                  t.texture = this.map.painter.getTileTexture(S.width), t.texture ? t.texture.update(S, { useMipmap: !0 }) : (t.texture = new u.T(g, S, w.RGBA, { useMipmap: !0 }), t.texture.bind(w.LINEAR, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST)), t.state = "loaded";
                }
              } catch (d) {
                if (delete t.abortController, t.aborted) t.state = "unloaded";
                else if (d) throw t.state = "errored", d;
              }
            }));
          }
          abortTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController);
            }));
          }
          unloadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.texture && this.map.painter.saveTileTexture(t.texture);
            }));
          }
          hasTransition() {
            return !1;
          }
        }
        class Zi extends $i {
          constructor(t, s, d, g) {
            super(t, s, d, g), this.type = "raster-dem", this.maxzoom = 22, this._options = u.e({ type: "raster-dem" }, s), this.encoding = s.encoding || "mapbox", this.redFactor = s.redFactor, this.greenFactor = s.greenFactor, this.blueFactor = s.blueFactor, this.baseShift = s.baseShift;
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), d = this.map._requestManager.transformRequest(s, "Tile");
              t.neighboringTiles = this._getNeighboringTiles(t.tileID), t.abortController = new AbortController();
              try {
                const g = yield ot.getImage(d, t.abortController, this.map._refreshExpiredTiles);
                if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
                if (g && g.data) {
                  const w = g.data;
                  this.map._refreshExpiredTiles && (g.cacheControl || g.expires) && t.setExpiryData({ cacheControl: g.cacheControl, expires: g.expires });
                  const S = u.b(w) && u.$() ? w : yield this.readImageNow(w), C = { type: this.type, uid: t.uid, source: this.id, rawImageData: S, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!t.actor || t.state === "expired") {
                    t.actor = this.dispatcher.getActor();
                    const A = yield t.actor.sendAsync({ type: "LDT", data: C });
                    t.dem = A, t.needsHillshadePrepare = !0, t.needsTerrainPrepare = !0, t.state = "loaded";
                  }
                }
              } catch (g) {
                if (delete t.abortController, t.aborted) t.state = "unloaded";
                else if (g) throw t.state = "errored", g;
              }
            }));
          }
          readImageNow(t) {
            return u._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && u.a0()) {
                const s = t.width + 2, d = t.height + 2;
                try {
                  return new u.R({ width: s, height: d }, yield u.a1(t, -1, -1, s, d));
                } catch {
                }
              }
              return oe.getImageData(t, 1);
            }));
          }
          _getNeighboringTiles(t) {
            const s = t.canonical, d = Math.pow(2, s.z), g = (s.x - 1 + d) % d, w = s.x === 0 ? t.wrap - 1 : t.wrap, S = (s.x + 1 + d) % d, C = s.x + 1 === d ? t.wrap + 1 : t.wrap, A = {};
            return A[new u.a2(t.overscaledZ, w, s.z, g, s.y).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, C, s.z, S, s.y).key] = { backfilled: !1 }, s.y > 0 && (A[new u.a2(t.overscaledZ, w, s.z, g, s.y - 1).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, t.wrap, s.z, s.x, s.y - 1).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, C, s.z, S, s.y - 1).key] = { backfilled: !1 }), s.y + 1 < d && (A[new u.a2(t.overscaledZ, w, s.z, g, s.y + 1).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, t.wrap, s.z, s.x, s.y + 1).key] = { backfilled: !1 }, A[new u.a2(t.overscaledZ, C, s.z, S, s.y + 1).key] = { backfilled: !1 }), A;
          }
          unloadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && (yield t.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t.uid, source: this.id } }));
            }));
          }
        }
        function In(b) {
          return b.type === "GeometryCollection" ? b.geometries.map(((t) => t.coordinates)).flat(1 / 0) : b.coordinates.flat(1 / 0);
        }
        function Ks(b) {
          const t = new Nr();
          let s;
          switch (b.type) {
            case "FeatureCollection":
              s = b.features.map(((d) => In(d.geometry))).flat(1 / 0);
              break;
            case "Feature":
              s = In(b.geometry);
              break;
            default:
              s = In(b);
          }
          if (s.length == 0) return t;
          for (let d = 0; d < s.length - 1; d += 2) t.extend([s[d], s[d + 1]]);
          return t;
        }
        class er extends u.E {
          constructor(t, s, d, g) {
            super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: s.data }, this.actor = d.getActor(), this.setEventedParent(g), this._data = typeof s.data == "string" ? { url: s.data } : { geojson: s.data }, this._options = u.e({}, s), this._collectResourceTiming = s.collectResourceTiming, s.maxzoom !== void 0 && (this.maxzoom = s.maxzoom), s.type && (this.type = s.type), s.attribution && (this.attribution = s.attribution), this.promoteId = s.promoteId, s.clusterMaxZoom !== void 0 && this.maxzoom <= s.clusterMaxZoom && u.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${s.clusterMaxZoom}".`), this.workerOptions = u.e({ source: this.id, cluster: s.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(s.buffer !== void 0 ? s.buffer : 128), tolerance: this._pixelsToTileUnits(s.tolerance !== void 0 ? s.tolerance : 0.375), extent: u.a5, maxZoom: this.maxzoom, lineMetrics: s.lineMetrics || !1, generateId: s.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(s.clusterMaxZoom), minPoints: Math.max(2, s.clusterMinPoints || 2), extent: u.a5, radius: this._pixelsToTileUnits(s.clusterRadius || 50), log: !1, generateId: s.generateId || !1 }, clusterProperties: s.clusterProperties, filter: s.filter }, s.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged;
          }
          _pixelsToTileUnits(t) {
            return t * (u.a5 / this.tileSize);
          }
          _getClusterMaxZoom(t) {
            const s = t ? Math.round(t) : this.maxzoom - 1;
            return Number.isInteger(t) || t === void 0 || u.w(`Integer expected for option 'clusterMaxZoom': provided value "${t}" rounded to "${s}"`), s;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          setData(t, s) {
            this._data = typeof t == "string" ? { url: t } : { geojson: t }, this._pendingWorkerUpdate = { data: t };
            const d = this._updateWorkerData();
            return s ? d : this;
          }
          updateData(t, s) {
            this._pendingWorkerUpdate.diff = u.a6(this._pendingWorkerUpdate.diff, t);
            const d = this._updateWorkerData();
            return s ? d : this;
          }
          getData() {
            return u._(this, void 0, void 0, (function* () {
              const t = u.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: t });
            }));
          }
          getBounds() {
            return u._(this, void 0, void 0, (function* () {
              return Ks(yield this.getData());
            }));
          }
          setClusterOptions(t) {
            return this.workerOptions.cluster = t.cluster, t.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(t.clusterRadius)), t.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(t.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(t) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t, source: this.id } });
          }
          getClusterChildren(t) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t, source: this.id } });
          }
          getClusterLeaves(t, s, d) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t, limit: s, offset: d } });
          }
          _updateWorkerData() {
            return u._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void u.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const { data: t, diff: s } = this._pendingWorkerUpdate, d = u.e({ type: this.type }, this.workerOptions);
              t !== void 0 ? (typeof t == "string" ? (d.request = this.map._requestManager.transformRequest(oe.resolveURL(t), "Source"), d.request.collectResourceTiming = this._collectResourceTiming) : d.data = t, this._pendingWorkerUpdate.data = void 0) : s && (d.dataDiff = s, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new u.l("dataloading", { dataType: "source" }));
              try {
                const g = yield this.actor.sendAsync({ type: "LD", data: d });
                if (this._isUpdatingWorker = !1, this._removed || g.abandoned) return void this.fire(new u.l("dataabort", { dataType: "source" }));
                g.data && (this._data = { geojson: g.data });
                const w = this._applyDiffToSource(s), S = this._getShouldReloadTileOptions(w);
                let C = null;
                g.resourceTiming && g.resourceTiming[this.id] && (C = g.resourceTiming[this.id].slice(0));
                const A = { dataType: "source" };
                this._collectResourceTiming && C && C.length > 0 && u.e(A, { resourceTiming: C }), this.fire(new u.l("data", Object.assign(Object.assign({}, A), { sourceDataType: "metadata" }))), this.fire(new u.l("data", Object.assign(Object.assign({}, A), { sourceDataType: "content", shouldReloadTileOptions: S })));
              } catch (g) {
                if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new u.l("dataabort", { dataType: "source" }));
                this.fire(new u.k(g));
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData();
              }
            }));
          }
          _applyDiffToSource(t) {
            if (!t) return;
            const s = typeof this.promoteId == "string" ? this.promoteId : void 0;
            if (!this._data.url && !this._data.updateable) {
              const g = u.a7(this._data.geojson, s);
              if (!g) throw new Error(`GeoJSONSource "${this.id}": GeoJSON data is not compatible with updateData`);
              this._data = { updateable: g };
            }
            if (!this._data.updateable) return;
            const d = u.a8(this._data.updateable, t, s);
            return t.removeAll || this._options.cluster ? void 0 : d;
          }
          _getShouldReloadTileOptions(t) {
            if (t) return { affectedBounds: t.filter(Boolean).map(((s) => Ks(s))) };
          }
          shouldReloadTile(t, { affectedBounds: s }) {
            if (t.state === "loading") return !0;
            if (t.state === "unloaded") return !1;
            const { buffer: d, extent: g } = this.workerOptions.geojsonVtOptions, w = (function({ x: S, y: C, z: A }, F = 0) {
              const O = u.a3((S - F) / Math.pow(2, A)), q = u.a4((C + 1 + F) / Math.pow(2, A)), V = u.a3((S + 1 + F) / Math.pow(2, A)), W = u.a4((C - F) / Math.pow(2, A));
              return new Nr([O, q], [V, W]);
            })(t.tileID.canonical, d / g);
            for (const S of s) if (w.intersects(S)) return !0;
            return !1;
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              const s = t.actor ? "RT" : "LT";
              t.actor = this.actor;
              const d = { type: this.type, uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              t.abortController = new AbortController();
              const g = yield this.actor.sendAsync({ type: s, data: d }, t.abortController);
              delete t.abortController, t.unloadVectorData(), t.aborted || t.loadVectorData(g, this.map.painter, s === "RT");
            }));
          }
          abortTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController), t.aborted = !0;
            }));
          }
          unloadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              t.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return u.e({}, this._options, { type: this.type, data: this._data.updateable ? { type: "FeatureCollection", features: Array.from(this._data.updateable.values()) } : this._data.url || this._data.geojson });
          }
          hasTransition() {
            return !1;
          }
        }
        class Kr extends u.E {
          constructor(t, s, d, g) {
            super(), this.flippedWindingOrder = !1, this.id = t, this.dispatcher = d, this.coordinates = s.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(g), this.options = s;
          }
          load(t) {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1, this.fire(new u.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const s = yield ot.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, s && s.data && (this.image = s.data, t && (this.coordinates = t), this._finishLoading());
              } catch (s) {
                this._request = null, this._loaded = !0, u.Z(s) || this.fire(new u.k(s));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t) {
            return t.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t.url, this.load(t.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new u.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(t) {
            this.coordinates = t;
            const s = t.map(u.a9.fromLngLat);
            var d;
            return this.tileID = (function(g) {
              const w = u.aa.fromPoints(g), S = w.width(), C = w.height(), A = Math.max(S, C), F = Math.max(0, Math.floor(-Math.log(A) / Math.LN2)), O = Math.pow(2, F);
              return new u.ac(F, Math.floor((w.minX + w.maxX) / 2 * O), Math.floor((w.minY + w.maxY) / 2 * O));
            })(s), this.terrainTileRanges = this._getOverlappingTileRanges(s), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = s.map(((g) => this.tileID.getTilePoint(g)._round())), this.flippedWindingOrder = ((d = this.tileCoords)[1].x - d[0].x) * (d[2].y - d[0].y) - (d[1].y - d[0].y) * (d[2].x - d[0].x) < 0, this.fire(new u.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const t = this.map.painter.context, s = t.gl;
            this.texture || (this.texture = new u.T(t, this.image, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
            let d = !1;
            for (const g in this.tiles) {
              const w = this.tiles[g];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, d = !0);
            }
            d && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(t) {
            return u._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}) : t.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          _getOverlappingTileRanges(t) {
            const { minX: s, minY: d, maxX: g, maxY: w } = u.aa.fromPoints(t), S = {};
            for (let C = 0; C <= u.ab; C++) {
              const A = Math.pow(2, C), F = Math.floor(s * A), O = Math.floor(d * A), q = Math.floor(g * A), V = Math.floor(w * A), W = (F % A + A) % A, te = q % A, he = Math.floor(F / A), pe = Math.floor(q / A);
              S[C] = { minWrap: he, maxWrap: pe, minTileXWrapped: W, maxTileXWrapped: te, minTileY: O, maxTileY: V };
            }
            return S;
          }
        }
        class He extends Kr {
          constructor(t, s, d, g) {
            super(t, s, d, g), this.roundZoom = !0, this.type = "video", this.options = s;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !1;
              const t = this.options;
              this.urls = [];
              for (const s of t.urls) this.urls.push(this.map._requestManager.transformRequest(s, "Source").url);
              try {
                const s = yield u.ad(this.urls);
                if (this._loaded = !0, !s) return;
                this.video = s, this.video.loop = !0, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (s) {
                this.fire(new u.k(s));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t) {
            if (this.video) {
              const s = this.video.seekable;
              t < s.start(0) || t > s.end(0) ? this.fire(new u.k(new u.ae(`sources.${this.id}`, null, `Playback for this video can be set only between the ${s.start(0)} and ${s.end(0)}-second mark.`))) : this.video.currentTime = t;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t) {
            this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const t = this.map.painter.context, s = t.gl;
            this.texture ? this.video.paused || (this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE), s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, s.RGBA, s.UNSIGNED_BYTE, this.video)) : (this.texture = new u.T(t, this.video, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
            let d = !1;
            for (const g in this.tiles) {
              const w = this.tiles[g];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, d = !0);
            }
            d && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class K extends Kr {
          constructor(t, s, d, g) {
            super(t, s, d, g), s.coordinates ? Array.isArray(s.coordinates) && s.coordinates.length === 4 && !s.coordinates.some(((w) => !Array.isArray(w) || w.length !== 2 || w.some(((S) => typeof S != "number")))) || this.fire(new u.k(new u.ae(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new u.k(new u.ae(`sources.${t}`, null, 'missing required property "coordinates"'))), s.animate && typeof s.animate != "boolean" && this.fire(new u.k(new u.ae(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), s.canvas ? typeof s.canvas == "string" || s.canvas instanceof HTMLCanvasElement || this.fire(new u.k(new u.ae(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new u.k(new u.ae(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = s, this.animate = s.animate === void 0 || s.animate;
          }
          load() {
            return u._(this, void 0, void 0, (function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new u.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t) {
            this.map = t, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const s = this.map.painter.context, d = s.gl;
            this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : (this.texture = new u.T(s, this.canvas, d.RGBA, { premultiply: !0 }), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE));
            let g = !1;
            for (const w in this.tiles) {
              const S = this.tiles[w];
              S.state !== "loaded" && (S.state = "loaded", S.texture = this.texture, g = !0);
            }
            g && this.fire(new u.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", animate: this.animate, canvas: this.options.canvas, coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t of [this.canvas.width, this.canvas.height]) if (isNaN(t) || t <= 0) return !0;
            return !1;
          }
        }
        const J = {}, le = (b) => {
          switch (b) {
            case "geojson":
              return er;
            case "image":
              return Kr;
            case "raster":
              return $i;
            case "raster-dem":
              return Zi;
            case "vector":
              return St;
            case "video":
              return He;
            case "canvas":
              return K;
          }
          return J[b];
        }, be = "RTLPluginLoaded";
        class ye extends u.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Ut();
          }
          _syncState(t) {
            return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch(((s) => {
              throw this.status = "error", s;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(t) {
            return u._(this, arguments, void 0, (function* (s, d = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = oe.resolveURL(s), !this.url) throw new Error(`requested url ${s} is invalid`);
              if (this.status === "unavailable") {
                if (!d) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return u._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new u.l(be));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let Je = null;
        function qe() {
          return Je || (Je = new ye()), Je;
        }
        var Be, ze;
        (function(b) {
          b[b.Base = 0] = "Base", b[b.Parent = 1] = "Parent";
        })(Be || (Be = {})), (function(b) {
          b[b.Departing = 0] = "Departing", b[b.Incoming = 1] = "Incoming";
        })(ze || (ze = {}));
        class ft {
          constructor(t, s) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = t, this.uid = u.af(), this.uses = 0, this.tileSize = s, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          isRenderable(t) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (t || !this.holdingForSymbolFade());
          }
          setCrossFadeLogic({ fadingRole: t, fadingDirection: s, fadingParentID: d, fadeEndTime: g }) {
            this.resetFadeLogic(), this.fadingRole = t, this.fadingDirection = s, this.fadingParentID = d, this.fadeEndTime = g;
          }
          setSelfFadeLogic(t) {
            this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = t;
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = me(), this.fadeEndTime = 0, this.fadeOpacity = 1;
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(t) {
            this.demTexture && t.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(t, s, d) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {
              t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData, this.latestFeatureIndex.encoding = t.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = (function(g, w) {
                const S = {};
                if (!w) return S;
                for (const C of g) {
                  const A = C.layerIds.map(((F) => w.getLayer(F))).filter(Boolean);
                  if (A.length !== 0) {
                    C.layers = A, C.stateDependentLayerIds && (C.stateDependentLayers = C.stateDependentLayerIds.map(((F) => A.filter(((O) => O.id === F))[0])));
                    for (const F of A) S[F.id] = C;
                  }
                }
                return S;
              })(t.buckets, s?.style), this.hasSymbolBuckets = !1;
              for (const g in this.buckets) {
                const w = this.buckets[g];
                if (w instanceof u.ah) {
                  if (this.hasSymbolBuckets = !0, !d) break;
                  w.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const g in this.buckets) {
                const w = this.buckets[g];
                if (w instanceof u.ah && w.hasRTLText) {
                  this.hasRTLText = !0, qe().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const g in this.buckets) {
                const w = this.buckets[g];
                this.queryPadding = Math.max(this.queryPadding, s.style.getLayer(g).queryRadius(w));
              }
              t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), this.dashPositions = t.dashPositions;
            } else this.collisionBoxArray = new u.ag();
          }
          unloadVectorData() {
            for (const t in this.buckets) this.buckets[t].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t) {
            return this.buckets[t.id];
          }
          upload(t) {
            for (const d in this.buckets) {
              const g = this.buckets[d];
              g.uploadPending() && g.upload(t);
            }
            const s = t.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new u.T(t, this.imageAtlas.image, s.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new u.T(t, this.glyphAtlasImage, s.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t, s, d, g, w, S, C, A, F, O, q) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: g, cameraQueryGeometry: w, scale: S, tileSize: this.tileSize, pixelPosMatrix: O, transform: A, params: C, queryPadding: this.queryPadding * F, getElevation: q }, t, s, d) : {};
          }
          querySourceFeatures(t, s) {
            const d = this.latestFeatureIndex;
            if (!d || !d.rawTileData) return;
            const g = d.loadVTLayers(), w = s && s.sourceLayer ? s.sourceLayer : "", S = g[u.ai] || g[w];
            if (!S) return;
            const C = u.aj(s?.filter, s?.globalState), { z: A, x: F, y: O } = this.tileID.canonical, q = { z: A, x: F, y: O };
            for (let V = 0; V < S.length; V++) {
              const W = S.feature(V);
              if (C.needGeometry) {
                const pe = u.ak(W, !0);
                if (!C.filter(new u.H(this.tileID.overscaledZ), pe, this.tileID.canonical)) continue;
              } else if (!C.filter(new u.H(this.tileID.overscaledZ), W)) continue;
              const te = d.getId(W, w), he = new u.al(W, A, F, O, te);
              he.tile = q, t.push(he);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t) {
            const s = this.expirationTime;
            if (t.cacheControl) {
              const d = u.am(t.cacheControl);
              d["max-age"] && (this.expirationTime = Date.now() + 1e3 * d["max-age"]);
            } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
            if (this.expirationTime) {
              const d = Date.now();
              let g = !1;
              if (this.expirationTime > d) g = !1;
              else if (s) if (this.expirationTime < s) g = !0;
              else {
                const w = this.expirationTime - s;
                w ? this.expirationTime = d + Math.max(w, 3e4) : g = !0;
              }
              else g = !0;
              g ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t, s) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t).length === 0) return;
            const d = this.latestFeatureIndex.loadVTLayers();
            for (const g in this.buckets) {
              if (!s.style.hasLayer(g)) continue;
              const w = this.buckets[g], S = w.layers[0].sourceLayer || u.ai, C = d[S], A = t[S];
              if (!C || !A || Object.keys(A).length === 0) continue;
              w.update(A, C, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const F = s && s.style && s.style.getLayer(g);
              F && (this.queryPadding = Math.max(this.queryPadding, F.queryRadius(w)));
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < me();
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setSymbolHoldDuration(t) {
            this.symbolFadeHoldUntil = me() + t;
          }
          setDependencies(t, s) {
            const d = {};
            for (const g of s) d[g] = !0;
            this.dependencies[t] = d;
          }
          hasDependency(t, s) {
            for (const d of t) {
              const g = this.dependencies[d];
              if (g) {
                for (const w of s) if (g[w]) return !0;
              }
            }
            return !1;
          }
        }
        class ct {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t, s, d) {
            const g = String(s);
            if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][g] = this.stateChanges[t][g] || {}, u.e(this.stateChanges[t][g], d), this.deletedStates[t] === null) {
              this.deletedStates[t] = {};
              for (const w in this.state[t]) w !== g && (this.deletedStates[t][w] = null);
            } else if (this.deletedStates[t] && this.deletedStates[t][g] === null) {
              this.deletedStates[t][g] = {};
              for (const w in this.state[t][g]) d[w] || (this.deletedStates[t][g][w] = null);
            } else for (const w in d) this.deletedStates[t] && this.deletedStates[t][g] && this.deletedStates[t][g][w] === null && delete this.deletedStates[t][g][w];
          }
          removeFeatureState(t, s, d) {
            if (this.deletedStates[t] === null) return;
            const g = String(s);
            if (this.deletedStates[t] = this.deletedStates[t] || {}, d && s !== void 0) this.deletedStates[t][g] !== null && (this.deletedStates[t][g] = this.deletedStates[t][g] || {}, this.deletedStates[t][g][d] = null);
            else if (s !== void 0) if (this.stateChanges[t] && this.stateChanges[t][g]) for (d in this.deletedStates[t][g] = {}, this.stateChanges[t][g]) this.deletedStates[t][g][d] = null;
            else this.deletedStates[t][g] = null;
            else this.deletedStates[t] = null;
          }
          getState(t, s) {
            const d = String(s), g = u.e({}, (this.state[t] || {})[d], (this.stateChanges[t] || {})[d]);
            if (this.deletedStates[t] === null) return {};
            if (this.deletedStates[t]) {
              const w = this.deletedStates[t][s];
              if (w === null) return {};
              for (const S in w) delete g[S];
            }
            return g;
          }
          initializeTileState(t, s) {
            t.setFeatureState(this.state, s);
          }
          coalesceChanges(t, s) {
            const d = {};
            for (const g in this.stateChanges) {
              this.state[g] = this.state[g] || {};
              const w = {};
              for (const S in this.stateChanges[g]) this.state[g][S] || (this.state[g][S] = {}), u.e(this.state[g][S], this.stateChanges[g][S]), w[S] = this.state[g][S];
              d[g] = w;
            }
            for (const g in this.deletedStates) {
              this.state[g] = this.state[g] || {};
              const w = {};
              if (this.deletedStates[g] === null) for (const S in this.state[g]) w[S] = {}, this.state[g][S] = {};
              else for (const S in this.deletedStates[g]) {
                if (this.deletedStates[g][S] === null) this.state[g][S] = {};
                else for (const C of Object.keys(this.deletedStates[g][S])) delete this.state[g][S][C];
                w[S] = this.state[g][S];
              }
              d[g] = d[g] || {}, u.e(d[g], w);
            }
            this.stateChanges = {}, this.deletedStates = {}, Object.keys(d).length !== 0 && t.setFeatureState(d, s);
          }
        }
        const Lt = 89.25;
        function Nt(b, t) {
          const s = u.an(t.lat, -u.ao, u.ao);
          return new u.P(u.Y(t.lng) * b, u.X(s) * b);
        }
        function Wt(b, t) {
          return new u.a9(t.x / b, t.y / b).toLngLat();
        }
        function cr(b) {
          return b.cameraToCenterDistance * Math.min(0.85 * Math.tan(u.ap(90 - b.pitch)), Math.tan(u.ap(Lt - b.pitch)));
        }
        function wr(b, t) {
          const s = b.canonical, d = t / u.aq(s.z), g = s.x + Math.pow(2, s.z) * b.wrap, w = u.ar(new Float64Array(16));
          return u.O(w, w, [g * d, s.y * d, 0]), u.Q(w, w, [d / u.a5, d / u.a5, 1]), w;
        }
        function Xe(b, t, s, d, g) {
          const w = u.a9.fromLngLat(b, t), S = g * u.as(1, b.lat), { x: C, y: A, z: F } = Rr(s, d);
          return new u.a9(w.x + S * -C, w.y + S * -A, w.z + S * -F);
        }
        function Rr(b, t) {
          const s = u.ap(b), d = u.ap(t), g = Math.cos(-s), w = Math.sin(s);
          return { x: w * Math.sin(d), y: -w * Math.cos(d), z: g };
        }
        function Mn(b, t, s) {
          const d = t.intersectsFrustum(b);
          if (!s || d === 0) return d;
          const g = t.intersectsPlane(s);
          return g === 0 ? 0 : d === 2 && g === 2 ? 2 : 1;
        }
        function qt(b, t, s) {
          let d = 0;
          const g = (s - t) / 10;
          for (let w = 0; w < 10; w++) d += g * Math.pow(Math.cos(t + (w + 0.5) / 10 * (s - t)), b);
          return d;
        }
        function mt(b, t) {
          return function(s, d, g, w, S) {
            const C = 2 * ((b - 1) / u.at(Math.cos(u.ap(Lt - S)) / Math.cos(u.ap(Lt))) - 1), A = Math.acos(g / w), F = 2 * qt(C - 1, 0, u.ap(S / 2)), O = Math.min(u.ap(Lt), A + u.ap(S / 2)), q = qt(C - 1, Math.min(O, A - u.ap(S / 2)), O), V = Math.atan(d / g), W = Math.hypot(d, g);
            let te = s;
            return te += u.at(w / W / Math.max(0.5, Math.cos(u.ap(S / 2)))), te += C * u.at(Math.cos(V)) / 2, te -= u.at(Math.max(1, q / F / t)) / 2, te;
          };
        }
        const fn = mt(9.314, 3);
        function Ir(b, t) {
          const s = (t.roundZoom ? Math.round : Math.floor)(b.zoom + u.at(b.tileSize / t.tileSize));
          return Math.max(0, s);
        }
        function Pr(b, t) {
          const s = b.getCameraFrustum(), d = b.getClippingPlane(), g = b.screenPointToMercatorCoordinate(b.getCameraPoint()), w = u.a9.fromLngLat(b.center, b.elevation);
          g.z = w.z + Math.cos(b.pitchInRadians) * b.cameraToCenterDistance / b.worldSize;
          const S = b.getCoveringTilesDetailsProvider(), C = S.allowVariableZoom(b, t), A = Ir(b, t), F = t.minzoom || 0, O = t.maxzoom !== void 0 ? t.maxzoom : b.maxZoom, q = Math.min(Math.max(0, A), O), V = Math.pow(2, q), W = [V * g.x, V * g.y, 0], te = [V * w.x, V * w.y, 0], he = Math.hypot(w.x - g.x, w.y - g.y), pe = Math.abs(w.z - g.z), fe = Math.hypot(he, pe), we = (Ce) => ({ zoom: 0, x: 0, y: 0, wrap: Ce, fullyVisible: !1 }), Le = [], ve = [];
          if (b.renderWorldCopies && S.allowWorldCopies()) for (let Ce = 1; Ce <= 3; Ce++) Le.push(we(-Ce)), Le.push(we(Ce));
          for (Le.push(we(0)); Le.length > 0; ) {
            const Ce = Le.pop(), Ne = Ce.x, ke = Ce.y;
            let Ge = Ce.fullyVisible;
            const at = { x: Ne, y: ke, z: Ce.zoom }, tt = S.getTileBoundingVolume(at, Ce.wrap, b.elevation, t);
            if (!Ge) {
              const kt = Mn(s, tt, d);
              if (kt === 0) continue;
              Ge = kt === 2;
            }
            const nt = S.distanceToTile2d(g.x, g.y, at, tt);
            let it = A;
            C && (it = (t.calculateTileZoom || fn)(b.zoom + u.at(b.tileSize / t.tileSize), nt, pe, fe, b.fov)), it = (t.roundZoom ? Math.round : Math.floor)(it), it = Math.max(0, it);
            const Et = Math.min(it, O);
            if (Ce.wrap = S.getWrap(w, at, Ce.wrap), Ce.zoom >= Et) {
              if (Ce.zoom < F) continue;
              const kt = q - Ce.zoom, gt = W[0] - 0.5 - (Ne << kt), At = W[1] - 0.5 - (ke << kt), ar = t.reparseOverscaled ? Math.max(Ce.zoom, it) : Ce.zoom;
              ve.push({ tileID: new u.a2(Ce.zoom === O ? ar : Ce.zoom, Ce.wrap, Ce.zoom, Ne, ke), distanceSq: u.au([te[0] - 0.5 - Ne, te[1] - 0.5 - ke]), tileDistanceToCamera: Math.sqrt(gt * gt + At * At) });
            } else for (let kt = 0; kt < 4; kt++) Le.push({ zoom: Ce.zoom + 1, x: (Ne << 1) + kt % 2, y: (ke << 1) + (kt >> 1), wrap: Ce.wrap, fullyVisible: Ge });
          }
          return ve.sort(((Ce, Ne) => Ce.distanceSq - Ne.distanceSq)).map(((Ce) => Ce.tileID));
        }
        const Mr = u.aa.fromPoints([new u.P(0, 0), new u.P(u.a5, u.a5)]);
        function Yr(b) {
          return b === "raster" || b === "image" || b === "video";
        }
        function Qs(b, t, s, d, g, w, S) {
          if (!t.hasData()) return !1;
          const { tileID: C, fadingRole: A, fadingDirection: F, fadingParentID: O } = t;
          if (A === Be.Base && F === ze.Incoming && O) return s[O.key] = O, !0;
          const q = Math.max(C.overscaledZ - g, w);
          for (let V = C.overscaledZ - 1; V >= q; V--) {
            const W = C.scaledTo(V), te = b.getLoadedTile(W);
            if (te) return t.setCrossFadeLogic({ fadingRole: Be.Base, fadingDirection: ze.Incoming, fadingParentID: te.tileID, fadeEndTime: d + S }), te.setCrossFadeLogic({ fadingRole: Be.Parent, fadingDirection: ze.Departing, fadeEndTime: d + S }), s[W.key] = W, !0;
          }
          return !1;
        }
        function Rn(b, t, s, d, g, w) {
          if (!t.hasData()) return !1;
          const S = t.tileID.children(g);
          let C = yt(b, t, S, s, d, g, w);
          if (C) return !0;
          for (const A of S) yt(b, t, A.children(g), s, d, g, w) && (C = !0);
          return C;
        }
        function yt(b, t, s, d, g, w, S) {
          if (s[0].overscaledZ >= w) return !1;
          let C = !1;
          for (const A of s) {
            const F = b.getLoadedTile(A);
            if (!F) continue;
            const { fadingRole: O, fadingDirection: q, fadingParentID: V } = F;
            O === Be.Base && q === ze.Departing && V || (F.setCrossFadeLogic({ fadingRole: Be.Base, fadingDirection: ze.Departing, fadingParentID: t.tileID, fadeEndTime: g + S }), t.setCrossFadeLogic({ fadingRole: Be.Parent, fadingDirection: ze.Incoming, fadeEndTime: g + S })), d[A.key] = A, C = !0;
          }
          return C;
        }
        function bn(b, t, s, d) {
          const g = b.tileID;
          return !!b.selfFading || !b.hasData() && !!t.has(g) && (b.setSelfFadeLogic(s + d), !0);
        }
        function Un(b, t) {
          var s;
          b.needsHillshadePrepare = !0, b.needsTerrainPrepare = !0;
          let d = t.tileID.canonical.x - b.tileID.canonical.x;
          const g = t.tileID.canonical.y - b.tileID.canonical.y, w = Math.pow(2, b.tileID.canonical.z), S = t.tileID.key;
          d === 0 && g === 0 || Math.abs(g) > 1 || (Math.abs(d) > 1 && (Math.abs(d + w) === 1 ? d += w : Math.abs(d - w) === 1 && (d -= w)), t.dem && b.dem && (b.dem.backfillBorder(t.dem, d, g), !((s = b.neighboringTiles) === null || s === void 0) && s[S] && (b.neighboringTiles[S].backfilled = !0)));
        }
        class Ps {
          constructor() {
            this._tiles = {};
          }
          handleWrapJump(t) {
            const s = {};
            for (const d in this._tiles) {
              const g = this._tiles[d];
              g.tileID = g.tileID.unwrapTo(g.tileID.wrap + t), s[g.tileID.key] = g;
            }
            this._tiles = s;
          }
          setFeatureState(t, s) {
            for (const d in this._tiles) this._tiles[d].setFeatureState(t, s);
          }
          getAllTiles() {
            return Object.values(this._tiles);
          }
          getAllIds(t = !1) {
            return t ? Object.values(this._tiles).map(((s) => s.tileID)).sort(u.aw).map(((s) => s.key)) : Object.keys(this._tiles);
          }
          getTileById(t) {
            return this._tiles[t];
          }
          setTile(t, s) {
            this._tiles[t] = s;
          }
          deleteTileById(t) {
            delete this._tiles[t];
          }
          getLoadedTile(t) {
            const s = this.getTileById(t.key);
            return s?.hasData() ? s : null;
          }
          isIdRenderable(t, s = !1) {
            var d;
            return (d = this.getTileById(t)) === null || d === void 0 ? void 0 : d.isRenderable(s);
          }
          getRenderableIds(t = 0, s) {
            const d = [];
            for (const g of this.getAllIds()) this.isIdRenderable(g, s) && d.push(this.getTileById(g));
            return s ? d.sort(((g, w) => {
              const S = g.tileID, C = w.tileID, A = new u.P(S.canonical.x, S.canonical.y)._rotate(-t), F = new u.P(C.canonical.x, C.canonical.y)._rotate(-t);
              return S.overscaledZ - C.overscaledZ || F.y - A.y || F.x - A.x;
            })).map(((g) => g.tileID.key)) : d.map(((g) => g.tileID)).sort(u.aw).map(((g) => g.key));
          }
        }
        class yi extends u.E {
          constructor(t, s, d) {
            super(), this.id = t, this.dispatcher = d, this.on("data", ((g) => this._dataHandler(g))), this.on("dataloading", (() => {
              this._sourceErrored = !1;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((g, w, S, C) => {
              const A = new (le(w.type))(g, w, S, C);
              if (A.id !== g) throw new Error(`Expected Source id to be ${g} instead of ${A.id}`);
              return A;
            })(t, s, d, this), this._inViewTiles = new Ps(), this._outOfViewCache = new u.ax(0, ((g) => this._unloadTile(g))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new ct(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(t) {
            this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t ? t._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t);
          }
          onRemove(t) {
            for (const s of this._inViewTiles.getAllTiles()) s.unloadVectorData();
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t), this._inViewTiles = new Ps();
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const t of this._inViewTiles.getAllTiles()) if (t.state !== "loaded" && t.state !== "errored") return !1;
            return !0;
          }
          getSource() {
            return this._source;
          }
          getState() {
            return this._state;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const t = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t, s, d) {
            return u._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(t), this._tileLoaded(t, s, d);
              } catch (g) {
                t.state = "errored", g.status !== 404 ? this._source.fire(new u.k(g, { tile: t })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(t) {
            this._source.unloadTile && this._source.unloadTile(t);
          }
          _abortTile(t) {
            this._source.abortTile && this._source.abortTile(t), this._source.fire(new u.l("dataabort", { tile: t, coord: t.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._inViewTiles, this.map ? this.map.painter : null);
            for (const s of this._inViewTiles.getAllTiles()) s.upload(t), s.prepare(this.map.style.imageManager);
          }
          getIds() {
            return this._inViewTiles.getAllIds(!0);
          }
          getRenderableIds(t) {
            var s;
            return this._inViewTiles.getRenderableIds((s = this.transform) === null || s === void 0 ? void 0 : s.bearingInRadians, t);
          }
          hasRenderableParent(t) {
            const s = t.overscaledZ - 1;
            if (s >= this._source.minzoom) {
              const d = this.getLoadedTile(t.scaledTo(s));
              if (d) return this._inViewTiles.isIdRenderable(d.tileID.key);
            }
            return !1;
          }
          reload(t, s = void 0) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._outOfViewCache.reset();
              for (const d of this._inViewTiles.getAllIds()) {
                const g = this._inViewTiles.getTileById(d);
                s && !this._source.shouldReloadTile(g, s) || (t ? this._reloadTile(d, "expired") : g.state !== "errored" && this._reloadTile(d, "reloading"));
              }
            }
          }
          _reloadTile(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = this._inViewTiles.getTileById(t);
              d && (d.state !== "loading" && (d.state = s), yield this._loadTile(d, t, s));
            }));
          }
          _tileLoaded(t, s, d) {
            t.timeAdded = me(), t.selfFading && (t.fadeEndTime = t.timeAdded + this._rasterFadeDuration), d === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(s, t), this.getSource().type === "raster-dem" && t.dem && (function(g, w) {
              var S, C;
              const A = w.getRenderableIds();
              for (const F of A) {
                if (!g.neighboringTiles || !g.neighboringTiles[F]) continue;
                const O = w.getTileById(F);
                g.neighboringTiles[F].backfilled || Un(g, O), !((C = (S = O.neighboringTiles) === null || S === void 0 ? void 0 : S[g.tileID.key]) === null || C === void 0) && C.backfilled || Un(O, g);
              }
            })(t, this._inViewTiles), this._state.initializeTileState(t, this.map ? this.map.painter : null), t.aborted || this._source.fire(new u.l("data", { dataType: "source", tile: t, coord: t.tileID }));
          }
          getTile(t) {
            return this.getTileByID(t.key);
          }
          getTileByID(t) {
            return this._inViewTiles.getTileById(t);
          }
          _retainLoadedChildren(t, s) {
            const d = this._getLoadedDescendents(s), g = /* @__PURE__ */ new Set();
            for (const w of s) {
              const S = d[w.key];
              if (!S?.length) {
                g.add(w);
                continue;
              }
              const C = w.overscaledZ + yi.maxOverzooming, A = S.filter(((q) => q.tileID.overscaledZ <= C));
              if (!A.length) {
                g.add(w);
                continue;
              }
              const F = Math.min(...A.map(((q) => q.tileID.overscaledZ))), O = A.filter(((q) => q.tileID.overscaledZ === F)).map(((q) => q.tileID));
              for (const q of O) t[q.key] = q;
              this._areDescendentsComplete(O, F, w.overscaledZ) || g.add(w);
            }
            return g;
          }
          _getLoadedDescendents(t) {
            var s;
            const d = {};
            for (const g of this._inViewTiles.getAllTiles().filter(((w) => w.hasData()))) for (const w of t) g.tileID.isChildOf(w) && (d[s = w.key] || (d[s] = [])).push(g);
            return d;
          }
          _areDescendentsComplete(t, s, d) {
            return t.length === 1 && t[0].isOverscaled() ? t[0].overscaledZ === s : Math.pow(4, s - d) === t.length;
          }
          getLoadedTile(t) {
            return this._inViewTiles.getLoadedTile(t);
          }
          updateCacheSize(t) {
            const s = Math.ceil(t.width / this._source.tileSize) + 1, d = Math.ceil(t.height / this._source.tileSize) + 1, g = Math.floor(s * d * (this._maxTileCacheZoomLevels === null ? u.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), w = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, g) : g;
            this._outOfViewCache.setMaxSize(w);
          }
          handleWrapJump(t) {
            const s = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
            this._prevLng = t, s && (this._inViewTiles.handleWrapJump(s), this._resetTileReloadTimers());
          }
          update(t, s) {
            if (!this._sourceLoaded || this._paused) return;
            let d;
            this.transform = t, this.terrain = s, this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? d = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(((A) => new u.a2(A.canonical.z, A.wrap, A.canonical.z, A.canonical.x, A.canonical.y))) : (d = Pr(t, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.type === "vector" && this.map._zoomLevelsToOverscale !== void 0 ? t.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: s, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (d = d.filter(((A) => this._source.hasTile(A))))) : d = [], this.usedForTerrain && (d = this._addTerrainIdealTiles(d));
            const g = d.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, g && this.fire(new u.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const w = Ir(t, this._source), S = this._updateRetainedTiles(d, w), C = Yr(this._source.type);
            C && this._rasterFadeDuration > 0 && !s && (function(A, F, O, q, V, W, te) {
              const he = me(), pe = u.av(F);
              for (const fe of F) {
                const we = A.getTileById(fe.key);
                we.fadingDirection !== ze.Departing && we.fadeOpacity !== 0 || we.resetFadeLogic(), Qs(A, we, O, he, q, V, te) || Rn(A, we, O, he, W, te) || bn(we, pe, he, te) || we.resetFadeLogic();
              }
            })(this._inViewTiles, d, S, this._maxFadingAncestorLevels, this._source.minzoom, this._source.maxzoom, this._rasterFadeDuration), C ? this._cleanUpRasterTiles(S) : this._cleanUpVectorTiles(S);
          }
          _cleanUpRasterTiles(t) {
            for (const s of this._inViewTiles.getAllIds()) t[s] || this._removeTile(s);
          }
          _cleanUpVectorTiles(t) {
            for (const s of this._inViewTiles.getAllIds()) {
              const d = this._inViewTiles.getTileById(s);
              t[s] ? d.clearSymbolFadeHold() : d.hasSymbolBuckets ? d.holdingForSymbolFade() ? d.symbolFadeFinished() && this._removeTile(s) : d.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(s);
            }
          }
          _addTerrainIdealTiles(t) {
            const s = [];
            for (const d of t) if (d.canonical.z > this._source.minzoom) {
              const g = d.scaledTo(d.canonical.z - 1);
              s.push(g);
              const w = d.scaledTo(Math.max(this._source.minzoom, Math.min(d.canonical.z, 5)));
              s.push(w);
            }
            return t.concat(s);
          }
          releaseSymbolFadeTiles() {
            for (const t of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(t).holdingForSymbolFade() && this._removeTile(t);
          }
          _updateRetainedTiles(t, s) {
            var d;
            const g = /* @__PURE__ */ new Set();
            for (const F of t) this._addTile(F).hasData() || g.add(F);
            const w = t.reduce(((F, O) => (F[O.key] = O, F)), {}), S = this._retainLoadedChildren(w, g), C = {}, A = Math.max(s - yi.maxUnderzooming, this._source.minzoom);
            for (const F of S) {
              let O = this._inViewTiles.getTileById(F.key), q = O?.wasRequested();
              for (let V = F.overscaledZ - 1; V >= A; --V) {
                const W = F.scaledTo(V);
                if (C[W.key]) break;
                if (C[W.key] = !0, O = this.getTile(W), !O && q && (O = this._addTile(W)), O) {
                  const te = O.hasData();
                  if ((te || !(!((d = this.map) === null || d === void 0) && d.cancelPendingTileRequestsWhileZooming) || q) && (w[W.key] = W), q = O.wasRequested(), te) break;
                }
              }
            }
            return w;
          }
          _addTile(t) {
            let s = this._inViewTiles.getTileById(t.key);
            if (s) return s;
            s = this._outOfViewCache.getAndRemove(t), s && (s.resetFadeLogic(), this._setTileReloadTimer(t.key, s), s.tileID = t, this._state.initializeTileState(s, this.map ? this.map.painter : null));
            const d = s;
            return s || (s = new ft(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(s, t.key, s.state)), s.uses++, this._inViewTiles.setTile(t.key, s), d || this._source.fire(new u.l("dataloading", { tile: s, coord: s.tileID, dataType: "source" })), s;
          }
          _setTileReloadTimer(t, s) {
            this._clearTileReloadTimer(t);
            const d = s.getExpiryTimeout();
            d && (this._timers[t] = setTimeout((() => {
              this._reloadTile(t, "expired"), delete this._timers[t];
            }), d));
          }
          _clearTileReloadTimer(t) {
            const s = this._timers[t];
            s && (clearTimeout(s), delete this._timers[t]);
          }
          _resetTileReloadTimers() {
            for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];
            for (const t of this._inViewTiles.getAllIds()) {
              const s = this._inViewTiles.getTileById(t);
              this._setTileReloadTimer(t, s);
            }
          }
          refreshTiles(t) {
            for (const s of this._inViewTiles.getAllIds()) {
              const d = this._inViewTiles.getTileById(s);
              (this._inViewTiles.isIdRenderable(s) || d.state == "errored") && t.some(((g) => g.equals(d.tileID.canonical))) && this._reloadTile(s, "expired");
            }
          }
          _removeTile(t) {
            const s = this._inViewTiles.getTileById(t);
            s && (s.uses--, this._inViewTiles.deleteTileById(t), this._clearTileReloadTimer(t), s.uses > 0 || (s.hasData() && s.state !== "reloading" ? this._outOfViewCache.add(s.tileID, s, s.getExpiryTimeout()) : (s.aborted = !0, this._abortTile(s), this._unloadTile(s))));
          }
          _dataHandler(t) {
            t.dataType === "source" && (t.sourceDataType !== "metadata" ? t.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(t.sourceDataChanged, t.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const t of this._inViewTiles.getAllIds()) this._removeTile(t);
            this._outOfViewCache.reset();
          }
          tilesIn(t, s, d) {
            const g = [], w = this.transform;
            if (!w) return g;
            const S = w.getCoveringTilesDetailsProvider().allowWorldCopies(), C = d ? w.getCameraQueryGeometry(t) : t, A = (W) => w.screenPointToMercatorCoordinate(W, this.terrain), F = this.transformBbox(t, A, !S), O = this.transformBbox(C, A, !S), q = this.getIds(), V = u.aa.fromPoints(O);
            for (let W = 0; W < q.length; W++) {
              const te = this._inViewTiles.getTileById(q[W]);
              if (te.holdingForSymbolFade()) continue;
              const he = S ? [te.tileID] : [te.tileID.unwrapTo(-1), te.tileID.unwrapTo(0)], pe = Math.pow(2, w.zoom - te.tileID.overscaledZ), fe = s * te.queryPadding * u.a5 / te.tileSize / pe;
              for (const we of he) {
                const Le = V.map(((ve) => we.getTilePoint(new u.a9(ve.x, ve.y))));
                if (Le.expandBy(fe), Le.intersects(Mr)) {
                  const ve = F.map(((Ne) => we.getTilePoint(Ne))), Ce = O.map(((Ne) => we.getTilePoint(Ne)));
                  g.push({ tile: te, tileID: S ? we : we.unwrapTo(0), queryGeometry: ve, cameraQueryGeometry: Ce, scale: pe });
                }
              }
            }
            return g;
          }
          transformBbox(t, s, d) {
            let g = t.map(s);
            if (d) {
              const w = u.aa.fromPoints(t);
              w.shrinkBy(1e-3 * Math.min(w.width(), w.height()));
              const S = w.map(s);
              u.aa.fromPoints(g).covers(S) || (g = g.map(((C) => C.x > 0.5 ? new u.a9(C.x - 1, C.y, C.z) : C)));
            }
            return g;
          }
          getVisibleCoordinates(t) {
            const s = this.getRenderableIds(t).map(((d) => this._inViewTiles.getTileById(d).tileID));
            return this.transform && this.transform.populateCache(s), s;
          }
          hasTransition() {
            return !!this._source.hasTransition() || !(!Yr(this._source.type) || !(function(t, s) {
              if (s <= 0) return !1;
              const d = me();
              for (const g of t.getAllTiles()) if (g.fadeEndTime >= d) return !0;
              return !1;
            })(this._inViewTiles, this._rasterFadeDuration));
          }
          setRasterFadeDuration(t) {
            this._rasterFadeDuration = t;
          }
          setFeatureState(t, s, d) {
            this._state.updateState(t = t || u.ai, s, d);
          }
          removeFeatureState(t, s, d) {
            this._state.removeFeatureState(t = t || u.ai, s, d);
          }
          getFeatureState(t, s) {
            return this._state.getState(t = t || u.ai, s);
          }
          setDependencies(t, s, d) {
            const g = this._inViewTiles.getTileById(t);
            g && g.setDependencies(s, d);
          }
          reloadTilesForDependencies(t, s) {
            for (const d of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(d).hasDependency(t, s) && this._reloadTile(d, "reloading");
            this._outOfViewCache.filter(((d) => !d.hasDependency(t, s)));
          }
          areTilesLoaded() {
            for (const t of this._inViewTiles.getAllTiles()) if (t.state !== "loaded" && t.state !== "errored") return !1;
            return !0;
          }
        }
        yi.maxUnderzooming = 10, yi.maxOverzooming = 3;
        class xt {
          constructor(t, s) {
            this.reset(t, s);
          }
          reset(t, s) {
            this.points = t || [], this._distances = [0];
            for (let d = 1; d < this.points.length; d++) this._distances[d] = this._distances[d - 1] + this.points[d].dist(this.points[d - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(s || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t) {
            if (this.points.length === 1) return this.points[0];
            t = u.an(t, 0, 1);
            let s = 1, d = this._distances[s];
            const g = t * this.paddedLength + this.padding;
            for (; d < g && s < this._distances.length; ) d = this._distances[++s];
            const w = s - 1, S = this._distances[w], C = d - S, A = C > 0 ? (g - S) / C : 0;
            return this.points[w].mult(1 - A).add(this.points[s].mult(A));
          }
        }
        function ir(b, t) {
          let s = !0;
          return b === "always" || b !== "never" && t !== "never" || (s = !1), s;
        }
        class rr {
          constructor(t, s, d) {
            const g = this.boxCells = [], w = this.circleCells = [];
            this.xCellCount = Math.ceil(t / d), this.yCellCount = Math.ceil(s / d);
            for (let S = 0; S < this.xCellCount * this.yCellCount; S++) g.push([]), w.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = s, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / s, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t, s, d, g, w) {
            this._forEachCell(s, d, g, w, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(s), this.bboxes.push(d), this.bboxes.push(g), this.bboxes.push(w);
          }
          insertCircle(t, s, d, g) {
            this._forEachCell(s - g, d - g, s + g, d + g, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(s), this.circles.push(d), this.circles.push(g);
          }
          _insertBoxCell(t, s, d, g, w, S) {
            this.boxCells[w].push(S);
          }
          _insertCircleCell(t, s, d, g, w, S) {
            this.circleCells[w].push(S);
          }
          _query(t, s, d, g, w, S, C) {
            if (d < 0 || t > this.width || g < 0 || s > this.height) return [];
            const A = [];
            if (t <= 0 && s <= 0 && this.width <= d && this.height <= g) {
              if (w) return [{ key: null, x1: t, y1: s, x2: d, y2: g }];
              for (let F = 0; F < this.boxKeys.length; F++) A.push({ key: this.boxKeys[F], x1: this.bboxes[4 * F], y1: this.bboxes[4 * F + 1], x2: this.bboxes[4 * F + 2], y2: this.bboxes[4 * F + 3] });
              for (let F = 0; F < this.circleKeys.length; F++) {
                const O = this.circles[3 * F], q = this.circles[3 * F + 1], V = this.circles[3 * F + 2];
                A.push({ key: this.circleKeys[F], x1: O - V, y1: q - V, x2: O + V, y2: q + V });
              }
            } else this._forEachCell(t, s, d, g, this._queryCell, A, { hitTest: w, overlapMode: S, seenUids: { box: {}, circle: {} } }, C);
            return A;
          }
          query(t, s, d, g) {
            return this._query(t, s, d, g, !1, null);
          }
          hitTest(t, s, d, g, w, S) {
            return this._query(t, s, d, g, !0, w, S).length > 0;
          }
          hitTestCircle(t, s, d, g, w) {
            const S = t - d, C = t + d, A = s - d, F = s + d;
            if (C < 0 || S > this.width || F < 0 || A > this.height) return !1;
            const O = [];
            return this._forEachCell(S, A, C, F, this._queryCellCircle, O, { hitTest: !0, overlapMode: g, circle: { x: t, y: s, radius: d }, seenUids: { box: {}, circle: {} } }, w), O.length > 0;
          }
          _queryCell(t, s, d, g, w, S, C, A) {
            const { seenUids: F, hitTest: O, overlapMode: q } = C, V = this.boxCells[w];
            if (V !== null) {
              const te = this.bboxes;
              for (const he of V) if (!F.box[he]) {
                F.box[he] = !0;
                const pe = 4 * he, fe = this.boxKeys[he];
                if (t <= te[pe + 2] && s <= te[pe + 3] && d >= te[pe + 0] && g >= te[pe + 1] && (!A || A(fe)) && (!O || !ir(q, fe.overlapMode)) && (S.push({ key: fe, x1: te[pe], y1: te[pe + 1], x2: te[pe + 2], y2: te[pe + 3] }), O)) return !0;
              }
            }
            const W = this.circleCells[w];
            if (W !== null) {
              const te = this.circles;
              for (const he of W) if (!F.circle[he]) {
                F.circle[he] = !0;
                const pe = 3 * he, fe = this.circleKeys[he];
                if (this._circleAndRectCollide(te[pe], te[pe + 1], te[pe + 2], t, s, d, g) && (!A || A(fe)) && (!O || !ir(q, fe.overlapMode))) {
                  const we = te[pe], Le = te[pe + 1], ve = te[pe + 2];
                  if (S.push({ key: fe, x1: we - ve, y1: Le - ve, x2: we + ve, y2: Le + ve }), O) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(t, s, d, g, w, S, C, A) {
            const { circle: F, seenUids: O, overlapMode: q } = C, V = this.boxCells[w];
            if (V !== null) {
              const te = this.bboxes;
              for (const he of V) if (!O.box[he]) {
                O.box[he] = !0;
                const pe = 4 * he, fe = this.boxKeys[he];
                if (this._circleAndRectCollide(F.x, F.y, F.radius, te[pe + 0], te[pe + 1], te[pe + 2], te[pe + 3]) && (!A || A(fe)) && !ir(q, fe.overlapMode)) return S.push(!0), !0;
              }
            }
            const W = this.circleCells[w];
            if (W !== null) {
              const te = this.circles;
              for (const he of W) if (!O.circle[he]) {
                O.circle[he] = !0;
                const pe = 3 * he, fe = this.circleKeys[he];
                if (this._circlesCollide(te[pe], te[pe + 1], te[pe + 2], F.x, F.y, F.radius) && (!A || A(fe)) && !ir(q, fe.overlapMode)) return S.push(!0), !0;
              }
            }
          }
          _forEachCell(t, s, d, g, w, S, C, A) {
            const F = this._convertToXCellCoord(t), O = this._convertToYCellCoord(s), q = this._convertToXCellCoord(d), V = this._convertToYCellCoord(g);
            for (let W = F; W <= q; W++) for (let te = O; te <= V; te++) if (w.call(this, t, s, d, g, this.xCellCount * te + W, S, C, A)) return;
          }
          _convertToXCellCoord(t) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
          }
          _convertToYCellCoord(t) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
          }
          _circlesCollide(t, s, d, g, w, S) {
            const C = g - t, A = w - s, F = d + S;
            return F * F > C * C + A * A;
          }
          _circleAndRectCollide(t, s, d, g, w, S, C) {
            const A = (S - g) / 2, F = Math.abs(t - (g + A));
            if (F > A + d) return !1;
            const O = (C - w) / 2, q = Math.abs(s - (w + O));
            if (q > O + d) return !1;
            if (F <= A || q <= O) return !0;
            const V = F - A, W = q - O;
            return V * V + W * W <= d * d;
          }
        }
        function pn(b, t, s) {
          const d = u.N();
          if (!b) {
            const { vecSouth: q, vecEast: V } = Bi(t), W = z();
            W[0] = V[0], W[1] = V[1], W[2] = q[0], W[3] = q[1], g = W, (O = (S = (w = W)[0]) * (F = w[3]) - (A = w[2]) * (C = w[1])) && (g[0] = F * (O = 1 / O), g[1] = -C * O, g[2] = -A * O, g[3] = S * O), d[0] = W[0], d[1] = W[1], d[4] = W[2], d[5] = W[3];
          }
          var g, w, S, C, A, F, O;
          return u.Q(d, d, [1 / s, 1 / s, 1]), d;
        }
        function zi(b, t, s, d) {
          if (b) {
            const g = u.N();
            if (!t) {
              const { vecSouth: w, vecEast: S } = Bi(s);
              g[0] = S[0], g[1] = S[1], g[4] = w[0], g[5] = w[1];
            }
            return u.Q(g, g, [d, d, 1]), g;
          }
          return s.pixelsToClipSpaceMatrix;
        }
        function Bi(b) {
          const t = Math.cos(b.rollInRadians), s = Math.sin(b.rollInRadians), d = Math.cos(b.pitchInRadians), g = Math.cos(b.bearingInRadians), w = Math.sin(b.bearingInRadians), S = u.aC();
          S[0] = -g * d * s - w * t, S[1] = -w * d * s + g * t;
          const C = u.aD(S);
          C < 1e-9 ? u.aE(S) : u.aF(S, S, 1 / C);
          const A = u.aC();
          A[0] = g * d * t - w * s, A[1] = w * d * t + g * s;
          const F = u.aD(A);
          return F < 1e-9 ? u.aE(A) : u.aF(A, A, 1 / F), { vecEast: A, vecSouth: S };
        }
        function Ee(b, t, s, d) {
          let g;
          d ? (g = [b, t, d(b, t), 1], u.aH(g, g, s)) : (g = [b, t, 0, 1], vl(g, g, s));
          const w = g[3];
          return { point: new u.P(g[0] / w, g[1] / w), signedDistanceFromCamera: w, isOccluded: !1 };
        }
        function zt(b, t) {
          return 0.5 + b / t * 0.5;
        }
        function bt(b, t) {
          return b.x >= -t[0] && b.x <= t[0] && b.y >= -t[1] && b.y <= t[1];
        }
        function Tr(b, t, s, d, g, w, S, C, A, F, O, q, V) {
          const W = s ? b.textSizeData : b.iconSizeData, te = u.ay(W, t.transform.zoom), he = [256 / t.width * 2 + 1, 256 / t.height * 2 + 1], pe = s ? b.text.dynamicLayoutVertexArray : b.icon.dynamicLayoutVertexArray;
          pe.clear();
          const fe = b.lineVertexArray, we = s ? b.text.placedSymbolArray : b.icon.placedSymbolArray, Le = t.transform.width / t.transform.height;
          let ve = !1;
          for (let Ce = 0; Ce < we.length; Ce++) {
            const Ne = we.get(Ce);
            if (Ne.hidden || Ne.writingMode === u.az.vertical && !ve) {
              ba(Ne.numGlyphs, pe);
              continue;
            }
            ve = !1;
            const ke = new u.P(Ne.anchorX, Ne.anchorY), Ge = { getElevation: V, pitchedLabelPlaneMatrix: d, lineVertexArray: fe, pitchWithMap: w, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: t.transform, tileAnchorPoint: ke, unwrappedTileID: A, width: F, height: O, translation: q }, at = Nn(Ne.anchorX, Ne.anchorY, Ge);
            if (!bt(at.point, he)) {
              ba(Ne.numGlyphs, pe);
              continue;
            }
            const tt = zt(t.transform.cameraToCenterDistance, at.signedDistanceFromCamera), nt = u.aA(W, te, Ne), it = w ? nt * t.transform.getPitchedTextCorrection(Ne.anchorX, Ne.anchorY, A) / tt : nt * tt, Et = Cn({ projectionContext: Ge, pitchedLabelPlaneMatrixInverse: g, symbol: Ne, fontSize: it, flip: !1, keepUpright: S, glyphOffsetArray: b.glyphOffsetArray, dynamicLayoutVertexArray: pe, aspectRatio: Le, rotateToLine: C });
            ve = Et.useVertical, (Et.notEnoughRoom || ve || Et.needsFlipping && Cn({ projectionContext: Ge, pitchedLabelPlaneMatrixInverse: g, symbol: Ne, fontSize: it, flip: !0, keepUpright: S, glyphOffsetArray: b.glyphOffsetArray, dynamicLayoutVertexArray: pe, aspectRatio: Le, rotateToLine: C }).notEnoughRoom) && ba(Ne.numGlyphs, pe);
          }
          s ? b.text.dynamicLayoutVertexBuffer.updateData(pe) : b.icon.dynamicLayoutVertexBuffer.updateData(pe);
        }
        function Qr(b, t, s, d, g, w, S, C) {
          const A = w.glyphStartIndex + w.numGlyphs, F = w.lineStartIndex, O = w.lineStartIndex + w.lineLength, q = t.getoffsetX(w.glyphStartIndex), V = t.getoffsetX(A - 1), W = ni(b * q, s, d, g, w.segment, F, O, C, S);
          if (!W) return null;
          const te = ni(b * V, s, d, g, w.segment, F, O, C, S);
          return te ? C.projectionCache.anyProjectionOccluded ? null : { first: W, last: te } : null;
        }
        function Cr(b, t, s, d) {
          return b === u.az.horizontal && Math.abs(s.y - t.y) > Math.abs(s.x - t.x) * d ? { useVertical: !0 } : (b === u.az.vertical ? t.y < s.y : t.x > s.x) ? { needsFlipping: !0 } : null;
        }
        function Cn(b) {
          const { projectionContext: t, pitchedLabelPlaneMatrixInverse: s, symbol: d, fontSize: g, flip: w, keepUpright: S, glyphOffsetArray: C, dynamicLayoutVertexArray: A, aspectRatio: F, rotateToLine: O } = b, q = g / 24, V = d.lineOffsetX * q, W = d.lineOffsetY * q;
          let te;
          if (d.numGlyphs > 1) {
            const he = d.glyphStartIndex + d.numGlyphs, pe = d.lineStartIndex, fe = d.lineStartIndex + d.lineLength, we = Qr(q, C, V, W, w, d, O, t);
            if (!we) return { notEnoughRoom: !0 };
            const Le = gn(we.first.point.x, we.first.point.y, t, s), ve = gn(we.last.point.x, we.last.point.y, t, s);
            if (S && !w) {
              const Ce = Cr(d.writingMode, Le, ve, F);
              if (Ce) return Ce;
            }
            te = [we.first];
            for (let Ce = d.glyphStartIndex + 1; Ce < he - 1; Ce++) {
              const Ne = ni(q * C.getoffsetX(Ce), V, W, w, d.segment, pe, fe, t, O);
              if (!Ne) return { notEnoughRoom: !0 };
              te.push(Ne);
            }
            te.push(we.last);
          } else {
            if (S && !w) {
              const pe = Er(t.tileAnchorPoint.x, t.tileAnchorPoint.y, t).point, fe = d.lineStartIndex + d.segment + 1, we = new u.P(t.lineVertexArray.getx(fe), t.lineVertexArray.gety(fe)), Le = Er(we.x, we.y, t), ve = Le.signedDistanceFromCamera > 0 ? Le.point : Fn(t.tileAnchorPoint, we, pe, 1, t), Ce = gn(pe.x, pe.y, t, s), Ne = gn(ve.x, ve.y, t, s), ke = Cr(d.writingMode, Ce, Ne, F);
              if (ke) return ke;
            }
            const he = ni(q * C.getoffsetX(d.glyphStartIndex), V, W, w, d.segment, d.lineStartIndex, d.lineStartIndex + d.lineLength, t, O);
            if (!he || t.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            te = [he];
          }
          for (const he of te) u.aG(A, he.point, he.angle);
          return {};
        }
        function Fn(b, t, s, d, g) {
          const w = b.add(b.sub(t)._unit()), S = Er(w.x, w.y, g).point, C = s.sub(S);
          return s.add(C._mult(d / C.mag()));
        }
        function Or(b, t, s) {
          const d = t.projectionCache;
          if (d.projections[b]) return d.projections[b];
          const g = new u.P(t.lineVertexArray.getx(b), t.lineVertexArray.gety(b)), w = Er(g.x, g.y, t);
          if (w.signedDistanceFromCamera > 0) return d.projections[b] = w.point, d.anyProjectionOccluded = d.anyProjectionOccluded || w.isOccluded, w.point;
          const S = b - s.direction;
          return Fn(s.distanceFromAnchor === 0 ? t.tileAnchorPoint : new u.P(t.lineVertexArray.getx(S), t.lineVertexArray.gety(S)), g, s.previousVertex, s.absOffsetX - s.distanceFromAnchor + 1, t);
        }
        function Er(b, t, s) {
          const d = b + s.translation[0], g = t + s.translation[1];
          let w;
          return s.pitchWithMap ? (w = Ee(d, g, s.pitchedLabelPlaneMatrix, s.getElevation), w.isOccluded = !1) : (w = s.transform.projectTileCoordinates(d, g, s.unwrappedTileID, s.getElevation), w.point.x = (0.5 * w.point.x + 0.5) * s.width, w.point.y = (0.5 * -w.point.y + 0.5) * s.height), w;
        }
        function gn(b, t, s, d) {
          if (s.pitchWithMap) {
            const g = [b, t, 0, 1];
            return u.aH(g, g, d), s.transform.projectTileCoordinates(g[0] / g[3], g[1] / g[3], s.unwrappedTileID, s.getElevation).point;
          }
          return { x: b / s.width * 2 - 1, y: 1 - t / s.height * 2 };
        }
        function Nn(b, t, s) {
          return s.transform.projectTileCoordinates(b, t, s.unwrappedTileID, s.getElevation);
        }
        function Hi(b, t, s) {
          return b._unit()._perp()._mult(t * s);
        }
        function As(b, t, s, d, g, w, S, C, A) {
          if (C.projectionCache.offsets[b]) return C.projectionCache.offsets[b];
          const F = s.add(t);
          if (b + A.direction < d || b + A.direction >= g) return C.projectionCache.offsets[b] = F, F;
          const O = Or(b + A.direction, C, A), q = Hi(O.sub(s), S, A.direction), V = s.add(q), W = O.add(q);
          return C.projectionCache.offsets[b] = u.aI(w, F, V, W) || F, C.projectionCache.offsets[b];
        }
        function ni(b, t, s, d, g, w, S, C, A) {
          const F = d ? b - t : b + t;
          let O = F > 0 ? 1 : -1, q = 0;
          d && (O *= -1, q = Math.PI), O < 0 && (q += Math.PI);
          let V, W = O > 0 ? w + g : w + g + 1;
          C.projectionCache.cachedAnchorPoint ? V = C.projectionCache.cachedAnchorPoint : (V = Er(C.tileAnchorPoint.x, C.tileAnchorPoint.y, C).point, C.projectionCache.cachedAnchorPoint = V);
          let te, he, pe = V, fe = V, we = 0, Le = 0;
          const ve = Math.abs(F), Ce = [];
          let Ne;
          for (; we + Le <= ve; ) {
            if (W += O, W < w || W >= S) return null;
            we += Le, fe = pe, he = te;
            const at = { absOffsetX: ve, direction: O, distanceFromAnchor: we, previousVertex: fe };
            if (pe = Or(W, C, at), s === 0) Ce.push(fe), Ne = pe.sub(fe);
            else {
              let tt;
              const nt = pe.sub(fe);
              tt = nt.mag() === 0 ? Hi(Or(W + O, C, at).sub(pe), s, O) : Hi(nt, s, O), he || (he = fe.add(tt)), te = As(W, tt, pe, w, S, he, s, C, at), Ce.push(he), Ne = te.sub(he);
            }
            Le = Ne.mag();
          }
          const ke = Ne._mult((ve - we) / Le)._add(he || fe), Ge = q + Math.atan2(pe.y - fe.y, pe.x - fe.x);
          return Ce.push(ke), { point: ke, angle: A ? Ge : 0, path: Ce };
        }
        const yl = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function ba(b, t) {
          for (let s = 0; s < b; s++) {
            const d = t.length;
            t.resize(d + 4), t.float32.set(yl, 3 * d);
          }
        }
        function vl(b, t, s) {
          const d = t[0], g = t[1];
          return b[0] = s[0] * d + s[4] * g + s[12], b[1] = s[1] * d + s[5] * g + s[13], b[3] = s[3] * d + s[7] * g + s[15], b;
        }
        const on = 100;
        class su {
          constructor(t, s = new rr(t.width + 200, t.height + 200, 25), d = new rr(t.width + 200, t.height + 200, 25)) {
            this.transform = t, this.grid = s, this.ignoredGrid = d, this.pitchFactor = Math.cos(t.pitch * Math.PI / 180) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + on, this.screenBottomBoundary = t.height + on, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t, s, d, g, w, S, C, A, F, O, q, V) {
            const W = this.projectAndGetPerspectiveRatio(t.anchorPointX + A[0], t.anchorPointY + A[1], w, O, V), te = d * W.perspectiveRatio;
            let he;
            if (S || C) he = this._projectCollisionBox(t, te, g, w, S, C, A, W, O, q, V);
            else {
              const Ne = W.x + (q ? q.x * te : 0), ke = W.y + (q ? q.y * te : 0);
              he = { allPointsOccluded: !1, box: [Ne + t.x1 * te, ke + t.y1 * te, Ne + t.x2 * te, ke + t.y2 * te] };
            }
            const [pe, fe, we, Le] = he.box, ve = S ? he.allPointsOccluded : W.isOccluded;
            let Ce = ve;
            return Ce || (Ce = W.perspectiveRatio < this.perspectiveRatioCutoff), Ce || (Ce = !this.isInsideGrid(pe, fe, we, Le)), Ce || s !== "always" && this.grid.hitTest(pe, fe, we, Le, s, F) ? { box: [pe, fe, we, Le], placeable: !1, offscreen: !1, occluded: ve } : { box: [pe, fe, we, Le], placeable: !0, offscreen: this.isOffscreen(pe, fe, we, Le), occluded: ve };
          }
          placeCollisionCircles(t, s, d, g, w, S, C, A, F, O, q, V, W, te) {
            const he = [], pe = new u.P(s.anchorX, s.anchorY), fe = this.getPerspectiveRatio(pe.x, pe.y, S, te), we = (F ? w * this.transform.getPitchedTextCorrection(s.anchorX, s.anchorY, S) / fe : w * fe) / u.aM, Le = { getElevation: te, pitchedLabelPlaneMatrix: C, lineVertexArray: d, pitchWithMap: F, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: pe, unwrappedTileID: S, width: this.transform.width, height: this.transform.height, translation: W }, ve = Qr(we, g, s.lineOffsetX * we, s.lineOffsetY * we, !1, s, !1, Le);
            let Ce = !1, Ne = !1, ke = !0;
            if (ve) {
              const Ge = 0.5 * q * fe + V, at = new u.P(-100, -100), tt = new u.P(this.screenRightBoundary, this.screenBottomBoundary), nt = new xt(), it = ve.first, Et = ve.last;
              let kt = [];
              for (let ar = it.path.length - 1; ar >= 1; ar--) kt.push(it.path[ar]);
              for (let ar = 1; ar < Et.path.length; ar++) kt.push(Et.path[ar]);
              const gt = 2.5 * Ge;
              if (F) {
                const ar = this.projectPathToScreenSpace(kt, Le);
                kt = ar.some(((zr) => zr.signedDistanceFromCamera <= 0)) ? [] : ar.map(((zr) => zr.point));
              }
              let At = [];
              if (kt.length > 0) {
                const ar = kt[0].clone(), zr = kt[0].clone();
                for (let sn = 1; sn < kt.length; sn++) ar.x = Math.min(ar.x, kt[sn].x), ar.y = Math.min(ar.y, kt[sn].y), zr.x = Math.max(zr.x, kt[sn].x), zr.y = Math.max(zr.y, kt[sn].y);
                At = ar.x >= at.x && zr.x <= tt.x && ar.y >= at.y && zr.y <= tt.y ? [kt] : zr.x < at.x || ar.x > tt.x || zr.y < at.y || ar.y > tt.y ? [] : u.aJ([kt], at.x, at.y, tt.x, tt.y);
              }
              for (const ar of At) {
                nt.reset(ar, 0.25 * Ge);
                let zr = 0;
                zr = nt.length <= 0.5 * Ge ? 1 : Math.ceil(nt.paddedLength / gt) + 1;
                for (let sn = 0; sn < zr; sn++) {
                  const qr = sn / Math.max(zr - 1, 1), ln = nt.lerp(qr), $r = ln.x + on, En = ln.y + on;
                  he.push($r, En, Ge, 0);
                  const un = $r - Ge, ui = En - Ge, On = $r + Ge, Ln = En + Ge;
                  if (ke = ke && this.isOffscreen(un, ui, On, Ln), Ne = Ne || this.isInsideGrid(un, ui, On, Ln), t !== "always" && this.grid.hitTestCircle($r, En, Ge, t, O) && (Ce = !0, !A)) return { circles: [], offscreen: !1, collisionDetected: Ce };
                }
              }
            }
            return { circles: !A && Ce || !Ne || fe < this.perspectiveRatioCutoff ? [] : he, offscreen: ke, collisionDetected: Ce };
          }
          projectPathToScreenSpace(t, s) {
            const d = (function(g, w) {
              const S = u.N();
              return u.aB(S, w.pitchedLabelPlaneMatrix), g.map(((C) => {
                const A = Ee(C.x, C.y, S, w.getElevation), F = w.transform.projectTileCoordinates(A.point.x, A.point.y, w.unwrappedTileID, w.getElevation);
                return F.point.x = (0.5 * F.point.x + 0.5) * w.width, F.point.y = (0.5 * -F.point.y + 0.5) * w.height, F;
              }));
            })(t, s);
            return (function(g) {
              let w = 0, S = 0, C = 0, A = 0;
              for (let F = 0; F < g.length; F++) g[F].isOccluded ? (C = F + 1, A = 0) : (A++, A > S && (S = A, w = C));
              return g.slice(w, w + S);
            })(d);
          }
          queryRenderedSymbols(t) {
            if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const s = [], d = new u.aa();
            for (const q of t) {
              const V = new u.P(q.x + on, q.y + on);
              d.extend(V), s.push(V);
            }
            const { minX: g, minY: w, maxX: S, maxY: C } = d, A = this.grid.query(g, w, S, C).concat(this.ignoredGrid.query(g, w, S, C)), F = {}, O = {};
            for (const q of A) {
              const V = q.key;
              if (F[V.bucketInstanceId] === void 0 && (F[V.bucketInstanceId] = {}), F[V.bucketInstanceId][V.featureIndex]) continue;
              const W = [new u.P(q.x1, q.y1), new u.P(q.x2, q.y1), new u.P(q.x2, q.y2), new u.P(q.x1, q.y2)];
              u.aK(s, W) && (F[V.bucketInstanceId][V.featureIndex] = !0, O[V.bucketInstanceId] === void 0 && (O[V.bucketInstanceId] = []), O[V.bucketInstanceId].push(V.featureIndex));
            }
            return O;
          }
          insertCollisionBox(t, s, d, g, w, S) {
            (d ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: g, featureIndex: w, collisionGroupID: S, overlapMode: s }, t[0], t[1], t[2], t[3]);
          }
          insertCollisionCircles(t, s, d, g, w, S) {
            const C = d ? this.ignoredGrid : this.grid, A = { bucketInstanceId: g, featureIndex: w, collisionGroupID: S, overlapMode: s };
            for (let F = 0; F < t.length; F += 4) C.insertCircle(A, t[F], t[F + 1], t[F + 2]);
          }
          projectAndGetPerspectiveRatio(t, s, d, g, w) {
            if (w) {
              let S;
              g ? (S = [t, s, g(t, s), 1], u.aH(S, S, w)) : (S = [t, s, 0, 1], vl(S, S, w));
              const C = S[3];
              return { x: (S[0] / C + 1) / 2 * this.transform.width + on, y: (-S[1] / C + 1) / 2 * this.transform.height + on, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / C * 0.5, isOccluded: !1, signedDistanceFromCamera: C };
            }
            {
              const S = this.transform.projectTileCoordinates(t, s, d, g);
              return { x: (S.point.x + 1) / 2 * this.transform.width + on, y: (1 - S.point.y) / 2 * this.transform.height + on, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / S.signedDistanceFromCamera * 0.5, isOccluded: S.isOccluded, signedDistanceFromCamera: S.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(t, s, d, g) {
            const w = this.transform.projectTileCoordinates(t, s, d, g);
            return 0.5 + this.transform.cameraToCenterDistance / w.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(t, s, d, g) {
            return d < on || t >= this.screenRightBoundary || g < on || s > this.screenBottomBoundary;
          }
          isInsideGrid(t, s, d, g) {
            return d >= 0 && t < this.gridRightBoundary && g >= 0 && s < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t = u.ar([]);
            return u.O(t, t, [-100, -100, 0]), t;
          }
          _projectCollisionBox(t, s, d, g, w, S, C, A, F, O, q) {
            let V = 1, W = 0, te = 0, he = 1;
            const pe = t.anchorPointX + C[0], fe = t.anchorPointY + C[1];
            if (S && !w) {
              const kt = this.projectAndGetPerspectiveRatio(pe + 1, fe, g, F, q), gt = kt.x - A.x, At = Math.atan((kt.y - A.y) / gt) + (gt < 0 ? Math.PI : 0), ar = Math.sin(At), zr = Math.cos(At);
              V = zr, W = ar, te = -ar, he = zr;
            } else if (!S && w) {
              const kt = Bi(this.transform);
              V = kt.vecEast[0], W = kt.vecEast[1], te = kt.vecSouth[0], he = kt.vecSouth[1];
            }
            let we = A.x, Le = A.y, ve = s;
            w && (we = pe, Le = fe, ve = Math.pow(2, -(this.transform.zoom - d.overscaledZ)), ve *= this.transform.getPitchedTextCorrection(pe, fe, g), O || (ve *= u.an(0.5 + A.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), O && (we += V * O.x * ve + te * O.y * ve, Le += W * O.x * ve + he * O.y * ve);
            const Ce = t.x1 * ve, Ne = t.x2 * ve, ke = (Ce + Ne) / 2, Ge = t.y1 * ve, at = t.y2 * ve, tt = (Ge + at) / 2, nt = [{ offsetX: Ce, offsetY: Ge }, { offsetX: ke, offsetY: Ge }, { offsetX: Ne, offsetY: Ge }, { offsetX: Ne, offsetY: tt }, { offsetX: Ne, offsetY: at }, { offsetX: ke, offsetY: at }, { offsetX: Ce, offsetY: at }, { offsetX: Ce, offsetY: tt }];
            let it = [];
            for (const { offsetX: kt, offsetY: gt } of nt) it.push(new u.P(we + V * kt + te * gt, Le + W * kt + he * gt));
            let Et = !1;
            if (w) {
              const kt = it.map(((gt) => this.projectAndGetPerspectiveRatio(gt.x, gt.y, g, F, q)));
              Et = kt.some(((gt) => !gt.isOccluded)), it = kt.map(((gt) => new u.P(gt.x, gt.y)));
            } else Et = !0;
            return { box: u.aL(it), allPointsOccluded: !Et };
          }
        }
        class au {
          constructor(t, s, d, g) {
            this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? s : -s))) : g && d ? 1 : 0, this.placed = d;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class ea {
          constructor(t, s, d, g, w) {
            this.text = new au(t ? t.text : null, s, d, w), this.icon = new au(t ? t.icon : null, s, g, w);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class vs {
          constructor(t, s, d) {
            this.text = t, this.icon = s, this.skipFade = d;
          }
        }
        class Ls {
          constructor(t, s, d, g, w) {
            this.bucketInstanceId = t, this.featureIndex = s, this.sourceLayerIndex = d, this.bucketIndex = g, this.tileID = w;
          }
        }
        class ou {
          constructor(t) {
            this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[t]) {
              const s = ++this.maxGroupID;
              this.collisionGroups[t] = { ID: s, predicate: (d) => d.collisionGroupID === s };
            }
            return this.collisionGroups[t];
          }
        }
        function Ds(b, t, s, d, g) {
          const { horizontalAlign: w, verticalAlign: S } = u.aS(b);
          return new u.P(-(w - 0.5) * t + d[0] * g, -(S - 0.5) * s + d[1] * g);
        }
        class lu {
          constructor(t, s, d, g, w) {
            this.transform = t.clone(), this.terrain = s, this.collisionIndex = new su(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = d, this.retainedQueryData = {}, this.collisionGroups = new ou(g), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = w, w && (w.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(t) {
            const s = this.terrain;
            return s ? (d, g) => s.getElevation(t, d, g) : null;
          }
          getBucketParts(t, s, d, g) {
            const w = d.getBucket(s), S = d.latestFeatureIndex;
            if (!w || !S || s.id !== w.layerIds[0]) return;
            const C = d.collisionBoxArray, A = w.layers[0].layout, F = w.layers[0].paint, O = Math.pow(2, this.transform.zoom - d.tileID.overscaledZ), q = d.tileSize / u.a5, V = d.tileID.toUnwrapped(), W = A.get("text-rotation-alignment") === "map", te = u.aN(d, 1, this.transform.zoom), he = u.aO(this.collisionIndex.transform, d, F.get("text-translate"), F.get("text-translate-anchor")), pe = u.aO(this.collisionIndex.transform, d, F.get("icon-translate"), F.get("icon-translate-anchor")), fe = pn(W, this.transform, te);
            this.retainedQueryData[w.bucketInstanceId] = new Ls(w.bucketInstanceId, S, w.sourceLayerIndex, w.index, d.tileID);
            const we = { bucket: w, layout: A, translationText: he, translationIcon: pe, unwrappedTileID: V, pitchedLabelPlaneMatrix: fe, scale: O, textPixelRatio: q, holdingForFade: d.holdingForSymbolFade(), collisionBoxArray: C, partiallyEvaluatedTextSize: u.ay(w.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(w.sourceID) };
            if (g) for (const Le of w.sortKeyRanges) {
              const { sortKey: ve, symbolInstanceStart: Ce, symbolInstanceEnd: Ne } = Le;
              t.push({ sortKey: ve, symbolInstanceStart: Ce, symbolInstanceEnd: Ne, parameters: we });
            }
            else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: w.symbolInstances.length, parameters: we });
          }
          attemptAnchorPlacement(t, s, d, g, w, S, C, A, F, O, q, V, W, te, he, pe, fe, we, Le, ve) {
            const Ce = u.aP[t.textAnchor], Ne = [t.textOffset0, t.textOffset1], ke = Ds(Ce, d, g, Ne, w), Ge = this.collisionIndex.placeCollisionBox(s, V, A, F, O, C, S, pe, q.predicate, Le, ke, ve);
            if ((!we || this.collisionIndex.placeCollisionBox(we, V, A, F, O, C, S, fe, q.predicate, Le, ke, ve).placeable) && Ge.placeable) {
              let at;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[W.crossTileID] && this.prevPlacement.placements[W.crossTileID] && this.prevPlacement.placements[W.crossTileID].text && (at = this.prevPlacement.variableOffsets[W.crossTileID].anchor), W.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[W.crossTileID] = { textOffset: Ne, width: d, height: g, anchor: Ce, textBoxScale: w, prevAnchor: at }, this.markUsedJustification(te, Ce, W, he), te.allowVerticalPlacement && (this.markUsedOrientation(te, he, W), this.placedOrientations[W.crossTileID] = he), { shift: ke, placedGlyphBoxes: Ge };
            }
          }
          placeLayerBucketPart(t, s, d) {
            const { bucket: g, layout: w, translationText: S, translationIcon: C, unwrappedTileID: A, pitchedLabelPlaneMatrix: F, textPixelRatio: O, holdingForFade: q, collisionBoxArray: V, partiallyEvaluatedTextSize: W, collisionGroup: te } = t.parameters, he = w.get("text-optional"), pe = w.get("icon-optional"), fe = u.aQ(w, "text-overlap", "text-allow-overlap"), we = fe === "always", Le = u.aQ(w, "icon-overlap", "icon-allow-overlap"), ve = Le === "always", Ce = w.get("text-rotation-alignment") === "map", Ne = w.get("text-pitch-alignment") === "map", ke = w.get("icon-text-fit") !== "none", Ge = w.get("symbol-z-order") === "viewport-y", at = we && (ve || !g.hasIconData() || pe), tt = ve && (we || !g.hasTextData() || he);
            !g.collisionArrays && V && g.deserializeCollisionBoxes(V);
            const nt = this.retainedQueryData[g.bucketInstanceId].tileID, it = this._getTerrainElevationFunc(nt), Et = this.transform.getFastPathSimpleProjectionMatrix(nt), kt = (gt, At, ar) => {
              var zr, sn;
              if (s[gt.crossTileID]) return;
              if (q) return void (this.placements[gt.crossTileID] = new vs(!1, !1, !1));
              let qr = !1, ln = !1, $r = !0, En = null, un = { box: null, placeable: !1, offscreen: null, occluded: !1 }, ui = { placeable: !1 }, On = null, Ln = null, Ei = null, ho = 0, Da = 0, oa = 0;
              At.textFeatureIndex ? ho = At.textFeatureIndex : gt.useRuntimeCollisionCircles && (ho = gt.featureIndex), At.verticalTextFeatureIndex && (Da = At.verticalTextFeatureIndex);
              const Ji = At.textBox;
              if (Ji) {
                const Ts = (Xr) => {
                  let Zr = u.az.horizontal;
                  if (g.allowVerticalPlacement && !Xr && this.prevPlacement) {
                    const Kn = this.prevPlacement.placedOrientations[gt.crossTileID];
                    Kn && (this.placedOrientations[gt.crossTileID] = Kn, Zr = Kn, this.markUsedOrientation(g, Zr, gt));
                  }
                  return Zr;
                }, la = (Xr, Zr) => {
                  if (g.allowVerticalPlacement && gt.numVerticalGlyphVertices > 0 && At.verticalTextBox) {
                    for (const Kn of g.writingModes) if (Kn === u.az.vertical ? (un = Zr(), ui = un) : un = Xr(), un && un.placeable) break;
                  } else un = Xr();
                }, js = gt.textAnchorOffsetStartIndex, Vs = gt.textAnchorOffsetEndIndex;
                if (Vs === js) {
                  const Xr = (Zr, Kn) => {
                    const Qn = this.collisionIndex.placeCollisionBox(Zr, fe, O, nt, A, Ne, Ce, S, te.predicate, it, void 0, Et);
                    return Qn && Qn.placeable && (this.markUsedOrientation(g, Kn, gt), this.placedOrientations[gt.crossTileID] = Kn), Qn;
                  };
                  la((() => Xr(Ji, u.az.horizontal)), (() => {
                    const Zr = At.verticalTextBox;
                    return g.allowVerticalPlacement && gt.numVerticalGlyphVertices > 0 && Zr ? Xr(Zr, u.az.vertical) : { box: null, offscreen: null };
                  })), Ts(un && un.placeable);
                } else {
                  let Xr = u.aP[(sn = (zr = this.prevPlacement) === null || zr === void 0 ? void 0 : zr.variableOffsets[gt.crossTileID]) === null || sn === void 0 ? void 0 : sn.anchor];
                  const Zr = (Qn, _p, yp) => {
                    const Jo = Qn.x2 - Qn.x1, mm = Qn.y2 - Qn.y1, vp = gt.textBoxScale, kd = ke && Le === "never" ? _p : null;
                    let fo = null, po = fe === "never" ? 1 : 2, go = "never";
                    Xr && po++;
                    for (let Id = 0; Id < po; Id++) {
                      for (let Md = js; Md < Vs; Md++) {
                        const th = g.textAnchorOffsets.get(Md);
                        if (Xr && th.textAnchor !== Xr) continue;
                        const rh = this.attemptAnchorPlacement(th, Qn, Jo, mm, vp, Ce, Ne, O, nt, A, te, go, gt, g, yp, S, C, kd, it);
                        if (rh && (fo = rh.placedGlyphBoxes, fo && fo.placeable)) return qr = !0, En = rh.shift, fo;
                      }
                      Xr ? Xr = null : go = fe;
                    }
                    return d && !fo && (fo = { box: this.collisionIndex.placeCollisionBox(Ji, "always", O, nt, A, Ne, Ce, S, te.predicate, it, void 0, Et).box, offscreen: !1, placeable: !1, occluded: !1 }), fo;
                  };
                  la((() => Zr(Ji, At.iconBox, u.az.horizontal)), (() => {
                    const Qn = At.verticalTextBox;
                    return g.allowVerticalPlacement && (!un || !un.placeable) && gt.numVerticalGlyphVertices > 0 && Qn ? Zr(Qn, At.verticalIconBox, u.az.vertical) : { box: null, occluded: !0, offscreen: null };
                  })), un && (qr = un.placeable, $r = un.offscreen);
                  const Kn = Ts(un && un.placeable);
                  if (!qr && this.prevPlacement) {
                    const Qn = this.prevPlacement.variableOffsets[gt.crossTileID];
                    Qn && (this.variableOffsets[gt.crossTileID] = Qn, this.markUsedJustification(g, Qn.anchor, gt, Kn));
                  }
                }
              }
              if (On = un, qr = On && On.placeable, $r = On && On.offscreen, gt.useRuntimeCollisionCircles && gt.centerJustifiedTextSymbolIndex >= 0) {
                const Ts = g.text.placedSymbolArray.get(gt.centerJustifiedTextSymbolIndex), la = u.aA(g.textSizeData, W, Ts), js = w.get("text-padding");
                Ln = this.collisionIndex.placeCollisionCircles(fe, Ts, g.lineVertexArray, g.glyphOffsetArray, la, A, F, d, Ne, te.predicate, gt.collisionCircleDiameter, js, S, it), Ln.circles.length && Ln.collisionDetected && !d && u.w("Collisions detected, but collision boxes are not shown"), qr = we || Ln.circles.length > 0 && !Ln.collisionDetected, $r = $r && Ln.offscreen;
              }
              if (At.iconFeatureIndex && (oa = At.iconFeatureIndex), At.iconBox) {
                const Ts = (la) => this.collisionIndex.placeCollisionBox(la, Le, O, nt, A, Ne, Ce, C, te.predicate, it, ke && En ? En : void 0, Et);
                ui && ui.placeable && At.verticalIconBox ? (Ei = Ts(At.verticalIconBox), ln = Ei.placeable) : (Ei = Ts(At.iconBox), ln = Ei.placeable), $r = $r && Ei.offscreen;
              }
              const Wo = he || gt.numHorizontalGlyphVertices === 0 && gt.numVerticalGlyphVertices === 0, Yu = pe || gt.numIconVertices === 0;
              Wo || Yu ? Yu ? Wo || (ln = ln && qr) : qr = ln && qr : ln = qr = ln && qr;
              const Xo = ln && Ei.placeable;
              if (qr && On.placeable && this.collisionIndex.insertCollisionBox(On.box, fe, w.get("text-ignore-placement"), g.bucketInstanceId, ui && ui.placeable && Da ? Da : ho, te.ID), Xo && this.collisionIndex.insertCollisionBox(Ei.box, Le, w.get("icon-ignore-placement"), g.bucketInstanceId, oa, te.ID), Ln && qr && this.collisionIndex.insertCollisionCircles(Ln.circles, fe, w.get("text-ignore-placement"), g.bucketInstanceId, ho, te.ID), d && this.storeCollisionData(g.bucketInstanceId, ar, At, On, Ei, Ln), gt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (g.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[gt.crossTileID] = new vs((qr || at) && !On?.occluded, (ln || tt) && !Ei?.occluded, $r || g.justReloaded), s[gt.crossTileID] = !0;
            };
            if (Ge) {
              if (t.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const gt = g.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let At = gt.length - 1; At >= 0; --At) {
                const ar = gt[At];
                kt(g.symbolInstances.get(ar), g.collisionArrays[ar], ar);
              }
            } else for (let gt = t.symbolInstanceStart; gt < t.symbolInstanceEnd; gt++) kt(g.symbolInstances.get(gt), g.collisionArrays[gt], gt);
            g.justReloaded = !1;
          }
          storeCollisionData(t, s, d, g, w, S) {
            if (d.textBox || d.iconBox) {
              let C, A;
              this.collisionBoxArrays.has(t) ? C = this.collisionBoxArrays.get(t) : (C = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(t, C)), C.has(s) ? A = C.get(s) : (A = { text: null, icon: null }, C.set(s, A)), d.textBox && (A.text = g.box), d.iconBox && (A.icon = w.box);
            }
            if (S) {
              let C = this.collisionCircleArrays[t];
              C === void 0 && (C = this.collisionCircleArrays[t] = []);
              for (let A = 0; A < S.circles.length; A += 4) C.push(S.circles[A + 0] - on), C.push(S.circles[A + 1] - on), C.push(S.circles[A + 2]), C.push(S.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(t, s, d, g) {
            let w;
            w = g === u.az.vertical ? d.verticalPlacedTextSymbolIndex : { left: d.leftJustifiedTextSymbolIndex, center: d.centerJustifiedTextSymbolIndex, right: d.rightJustifiedTextSymbolIndex }[u.aR(s)];
            const S = [d.leftJustifiedTextSymbolIndex, d.centerJustifiedTextSymbolIndex, d.rightJustifiedTextSymbolIndex, d.verticalPlacedTextSymbolIndex];
            for (const C of S) C >= 0 && (t.text.placedSymbolArray.get(C).crossTileID = w >= 0 && C !== w ? 0 : d.crossTileID);
          }
          markUsedOrientation(t, s, d) {
            const g = s === u.az.horizontal || s === u.az.horizontalOnly ? s : 0, w = s === u.az.vertical ? s : 0, S = [d.leftJustifiedTextSymbolIndex, d.centerJustifiedTextSymbolIndex, d.rightJustifiedTextSymbolIndex];
            for (const C of S) t.text.placedSymbolArray.get(C).placedOrientation = g;
            d.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(d.verticalPlacedTextSymbolIndex).placedOrientation = w);
          }
          commit(t) {
            this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const s = this.prevPlacement;
            let d = !1;
            this.prevZoomAdjustment = s ? s.zoomAdjustment(this.transform.zoom) : 0;
            const g = s ? s.symbolFadeChange(t) : 1, w = s ? s.opacities : {}, S = s ? s.variableOffsets : {}, C = s ? s.placedOrientations : {};
            for (const A in this.placements) {
              const F = this.placements[A], O = w[A];
              O ? (this.opacities[A] = new ea(O, g, F.text, F.icon), d = d || F.text !== O.text.placed || F.icon !== O.icon.placed) : (this.opacities[A] = new ea(null, g, F.text, F.icon, F.skipFade), d = d || F.text || F.icon);
            }
            for (const A in w) {
              const F = w[A];
              if (!this.opacities[A]) {
                const O = new ea(F, g, !1, !1);
                O.isHidden() || (this.opacities[A] = O, d = d || F.text.placed || F.icon.placed);
              }
            }
            for (const A in S) this.variableOffsets[A] || !this.opacities[A] || this.opacities[A].isHidden() || (this.variableOffsets[A] = S[A]);
            for (const A in C) this.placedOrientations[A] || !this.opacities[A] || this.opacities[A].isHidden() || (this.placedOrientations[A] = C[A]);
            if (s && s.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            d ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = s ? s.lastPlacementChangeTime : t);
          }
          updateLayerOpacities(t, s) {
            const d = {};
            for (const g of s) {
              const w = g.getBucket(t);
              w && g.latestFeatureIndex && t.id === w.layerIds[0] && this.updateBucketOpacities(w, g.tileID, d, g.collisionBoxArray);
            }
          }
          updateBucketOpacities(t, s, d, g) {
            t.hasTextData() && (t.text.opacityVertexArray.clear(), t.text.hasVisibleVertices = !1), t.hasIconData() && (t.icon.opacityVertexArray.clear(), t.icon.hasVisibleVertices = !1), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
            const w = t.layers[0], S = w.layout, C = new ea(null, 0, !1, !1, !0), A = S.get("text-allow-overlap"), F = S.get("icon-allow-overlap"), O = w._unevaluatedLayout.hasValue("text-variable-anchor") || w._unevaluatedLayout.hasValue("text-variable-anchor-offset"), q = S.get("text-rotation-alignment") === "map", V = S.get("text-pitch-alignment") === "map", W = S.get("icon-text-fit") !== "none", te = new ea(null, 0, A && (F || !t.hasIconData() || S.get("icon-optional")), F && (A || !t.hasTextData() || S.get("text-optional")), !0);
            !t.collisionArrays && g && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(g);
            const he = (fe, we, Le) => {
              for (let ve = 0; ve < we / 4; ve++) fe.opacityVertexArray.emplaceBack(Le);
              fe.hasVisibleVertices = fe.hasVisibleVertices || Le !== Ea;
            }, pe = this.collisionBoxArrays.get(t.bucketInstanceId);
            for (let fe = 0; fe < t.symbolInstances.length; fe++) {
              const we = t.symbolInstances.get(fe), { numHorizontalGlyphVertices: Le, numVerticalGlyphVertices: ve, crossTileID: Ce } = we;
              let Ne = this.opacities[Ce];
              d[Ce] ? Ne = C : Ne || (Ne = te, this.opacities[Ce] = Ne), d[Ce] = !0;
              const ke = we.numIconVertices > 0, Ge = this.placedOrientations[we.crossTileID], at = Ge === u.az.vertical, tt = Ge === u.az.horizontal || Ge === u.az.horizontalOnly;
              if (Le > 0 || ve > 0) {
                const it = du(Ne.text);
                he(t.text, Le, at ? Ea : it), he(t.text, ve, tt ? Ea : it);
                const Et = Ne.text.isHidden();
                [we.rightJustifiedTextSymbolIndex, we.centerJustifiedTextSymbolIndex, we.leftJustifiedTextSymbolIndex].forEach(((At) => {
                  At >= 0 && (t.text.placedSymbolArray.get(At).hidden = Et || at ? 1 : 0);
                })), we.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(we.verticalPlacedTextSymbolIndex).hidden = Et || tt ? 1 : 0);
                const kt = this.variableOffsets[we.crossTileID];
                kt && this.markUsedJustification(t, kt.anchor, we, Ge);
                const gt = this.placedOrientations[we.crossTileID];
                gt && (this.markUsedJustification(t, "left", we, gt), this.markUsedOrientation(t, gt, we));
              }
              if (ke) {
                const it = du(Ne.icon), Et = !(W && we.verticalPlacedIconSymbolIndex && at);
                we.placedIconSymbolIndex >= 0 && (he(t.icon, we.numIconVertices, Et ? it : Ea), t.icon.placedSymbolArray.get(we.placedIconSymbolIndex).hidden = Ne.icon.isHidden()), we.verticalPlacedIconSymbolIndex >= 0 && (he(t.icon, we.numVerticalIconVertices, Et ? Ea : it), t.icon.placedSymbolArray.get(we.verticalPlacedIconSymbolIndex).hidden = Ne.icon.isHidden());
              }
              const nt = pe && pe.has(fe) ? pe.get(fe) : { text: null, icon: null };
              if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                const it = t.collisionArrays[fe];
                if (it) {
                  let Et = new u.P(0, 0);
                  if (it.textBox || it.verticalTextBox) {
                    let kt = !0;
                    if (O) {
                      const gt = this.variableOffsets[Ce];
                      gt ? (Et = Ds(gt.anchor, gt.width, gt.height, gt.textOffset, gt.textBoxScale), q && Et._rotate(V ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : kt = !1;
                    }
                    if (it.textBox || it.verticalTextBox) {
                      let gt;
                      it.textBox && (gt = at), it.verticalTextBox && (gt = tt), uu(t.textCollisionBox.collisionVertexArray, Ne.text.placed, !kt || gt, nt.text, Et.x, Et.y);
                    }
                  }
                  if (it.iconBox || it.verticalIconBox) {
                    const kt = !!(!tt && it.verticalIconBox);
                    let gt;
                    it.iconBox && (gt = kt), it.verticalIconBox && (gt = !kt), uu(t.iconCollisionBox.collisionVertexArray, Ne.icon.placed, gt, nt.icon, W ? Et.x : 0, W ? Et.y : 0);
                  }
                }
              }
            }
            if (t.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.text.opacityVertexArray.length !== t.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`);
            if (t.icon.opacityVertexArray.length !== t.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`);
            t.bucketInstanceId in this.collisionCircleArrays && (t.collisionCircleArray = this.collisionCircleArrays[t.bucketInstanceId], delete this.collisionCircleArrays[t.bucketInstanceId]);
          }
          symbolFadeChange(t) {
            return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t) {
            return Math.max(0, (this.transform.zoom - t) / 1.5);
          }
          hasTransitions(t) {
            return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t, s) {
            const d = this.zoomAtLastRecencyCheck === s ? 1 - this.zoomAdjustment(s) : 1;
            return this.zoomAtLastRecencyCheck = s, this.commitTime + this.fadeDuration * d > t;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function uu(b, t, s, d, g, w) {
          d && d.length !== 0 || (d = [0, 0, 0, 0]);
          const S = d[0] - on, C = d[1] - on, A = d[2] - on, F = d[3] - on;
          b.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, w || 0, S, C), b.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, w || 0, A, C), b.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, w || 0, A, F), b.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, w || 0, S, F);
        }
        const cu = Math.pow(2, 25), hu = Math.pow(2, 24), wc = Math.pow(2, 17), Rs = Math.pow(2, 16), Ao = Math.pow(2, 9), Ec = Math.pow(2, 8), wa = Math.pow(2, 1);
        function du(b) {
          if (b.opacity === 0 && !b.placed) return 0;
          if (b.opacity === 1 && b.placed) return 4294967295;
          const t = b.placed ? 1 : 0, s = Math.floor(127 * b.opacity);
          return s * cu + t * hu + s * wc + t * Rs + s * Ao + t * Ec + s * wa + t;
        }
        const Ea = 0;
        class Ar {
          constructor(t) {
            this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t, s, d, g, w) {
            const S = this._bucketParts;
            for (; this._currentTileIndex < t.length; ) if (s.getBucketParts(S, g, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, w()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, S.sort(((C, A) => C.sortKey - A.sortKey))); this._currentPartIndex < S.length; ) if (s.placeLayerBucketPart(S[this._currentPartIndex], this._seenCrossTileIDs, d), this._currentPartIndex++, w()) return !0;
            return !1;
          }
        }
        class Yi {
          constructor(t, s, d, g, w, S, C, A) {
            this.placement = new lu(t, s, S, C, A), this._currentPlacementIndex = d.length - 1, this._forceFullPlacement = g, this._showCollisionBoxes = w, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t, s, d) {
            const g = me(), w = () => !this._forceFullPlacement && me() - g > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const S = s[t[this._currentPlacementIndex]], C = this.placement.collisionIndex.transform.zoom;
              if (S.type === "symbol" && (!S.minzoom || S.minzoom <= C) && (!S.maxzoom || S.maxzoom > C)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ar(S)), this._inProgressLayer.continuePlacement(d[S.source], this.placement, this._showCollisionBoxes, S, w)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(t) {
            return this.placement.commit(t), this.placement;
          }
        }
        const hr = 512 / u.a5 / 2;
        class Lo {
          constructor(t, s, d) {
            this.tileID = t, this.bucketInstanceId = d, this._symbolsByKey = {};
            const g = /* @__PURE__ */ new Map();
            for (let w = 0; w < s.length; w++) {
              const S = s.get(w), C = S.key, A = g.get(C);
              A ? A.push(S) : g.set(C, [S]);
            }
            for (const [w, S] of g) {
              const C = { positions: S.map(((A) => ({ x: Math.floor(A.anchorX * hr), y: Math.floor(A.anchorY * hr) }))), crossTileIDs: S.map(((A) => A.crossTileID)) };
              if (C.positions.length > 128) {
                const A = new u.aT(C.positions.length, 16, Uint16Array);
                for (const { x: F, y: O } of C.positions) A.add(F, O);
                A.finish(), delete C.positions, C.index = A;
              }
              this._symbolsByKey[w] = C;
            }
          }
          getScaledCoordinates(t, s) {
            const { x: d, y: g, z: w } = this.tileID.canonical, { x: S, y: C, z: A } = s.canonical, F = hr / Math.pow(2, A - w), O = (C * u.a5 + t.anchorY) * F, q = g * u.a5 * hr;
            return { x: Math.floor((S * u.a5 + t.anchorX) * F - d * u.a5 * hr), y: Math.floor(O - q) };
          }
          findMatches(t, s, d) {
            const g = this.tileID.canonical.z < s.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - s.canonical.z);
            for (let w = 0; w < t.length; w++) {
              const S = t.get(w);
              if (S.crossTileID) continue;
              const C = this._symbolsByKey[S.key];
              if (!C) continue;
              const A = this.getScaledCoordinates(S, s);
              if (C.index) {
                const F = C.index.range(A.x - g, A.y - g, A.x + g, A.y + g).sort();
                for (const O of F) {
                  const q = C.crossTileIDs[O];
                  if (!d[q]) {
                    d[q] = !0, S.crossTileID = q;
                    break;
                  }
                }
              } else if (C.positions) for (let F = 0; F < C.positions.length; F++) {
                const O = C.positions[F], q = C.crossTileIDs[F];
                if (Math.abs(O.x - A.x) <= g && Math.abs(O.y - A.y) <= g && !d[q]) {
                  d[q] = !0, S.crossTileID = q;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: t }) => t));
          }
        }
        class Wi {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Si {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t) {
            const s = Math.round((t - this.lng) / 360);
            if (s !== 0) for (const d in this.indexes) {
              const g = this.indexes[d], w = {};
              for (const S in g) {
                const C = g[S];
                C.tileID = C.tileID.unwrapTo(C.tileID.wrap + s), w[C.tileID.key] = C;
              }
              this.indexes[d] = w;
            }
            this.lng = t;
          }
          addBucket(t, s, d) {
            if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
              if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === s.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
            }
            for (let w = 0; w < s.symbolInstances.length; w++) s.symbolInstances.get(w).crossTileID = 0;
            this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});
            const g = this.usedCrossTileIDs[t.overscaledZ];
            for (const w in this.indexes) {
              const S = this.indexes[w];
              if (Number(w) > t.overscaledZ) for (const C in S) {
                const A = S[C];
                A.tileID.isChildOf(t) && A.findMatches(s.symbolInstances, t, g);
              }
              else {
                const C = S[t.scaledTo(Number(w)).key];
                C && C.findMatches(s.symbolInstances, t, g);
              }
            }
            for (let w = 0; w < s.symbolInstances.length; w++) {
              const S = s.symbolInstances.get(w);
              S.crossTileID || (S.crossTileID = d.generate(), g[S.crossTileID] = !0);
            }
            return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new Lo(t, s.symbolInstances, s.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(t, s) {
            for (const d of s.getCrossTileIDsLists()) for (const g of d) delete this.usedCrossTileIDs[t][g];
          }
          removeStaleBuckets(t) {
            let s = !1;
            for (const d in this.indexes) {
              const g = this.indexes[d];
              for (const w in g) t[g[w].bucketInstanceId] || (this.removeBucketCrossTileIDs(d, g[w]), delete g[w], s = !0);
            }
            return s;
          }
        }
        class Wn {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Wi(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t, s, d) {
            let g = this.layerIndexes[t.id];
            g === void 0 && (g = this.layerIndexes[t.id] = new Si());
            let w = !1;
            const S = {};
            g.handleWrapJump(d);
            for (const C of s) {
              const A = C.getBucket(t);
              A && t.id === A.layerIds[0] && (A.bucketInstanceId || (A.bucketInstanceId = ++this.maxBucketInstanceId), g.addBucket(C.tileID, A, this.crossTileIDs) && (w = !0), S[A.bucketInstanceId] = !0);
            }
            return g.removeStaleBuckets(S) && (w = !0), w;
          }
          pruneUnusedLayers(t) {
            const s = {};
            t.forEach(((d) => {
              s[d] = !0;
            }));
            for (const d in this.layerIndexes) s[d] || delete this.layerIndexes[d];
          }
        }
        var ii = "void main() {fragColor=vec4(1.0);}";
        const en = { prelude: Qt(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Qt("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Qt("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Qt(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Qt(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Qt(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Qt(ii, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Qt(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Qt(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Qt("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Qt("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Qt(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Qt("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Qt(ii, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Qt(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Qt(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Qt(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Qt(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Qt(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Qt(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Qt(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Qt(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Qt(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Qt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Qt(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Qt(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), lineGradientSDF: Qt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: Qt(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Qt(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Qt(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Qt(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Qt("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Qt("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Qt("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Qt("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Qt(`#ifdef GL_ES
precision highp float;
#endif
in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Qt("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Qt(b, t) {
          const s = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, d = t.match(/in ([\w]+) ([\w]+)/g), g = b.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), S = w ? w.concat(g) : g, C = {};
          return { fragmentSource: b = b.replace(s, ((A, F, O, q, V) => (C[V] = !0, F === "define" ? `
#ifndef HAS_UNIFORM_u_${V}
in ${O} ${q} ${V};
#else
uniform ${O} ${q} u_${V};
#endif
` : `
#ifdef HAS_UNIFORM_u_${V}
    ${O} ${q} ${V} = u_${V};
#endif
`))), vertexSource: t = t.replace(s, ((A, F, O, q, V) => {
            const W = q === "float" ? "vec2" : "vec4", te = V.match(/color/) ? "color" : W;
            return C[V] ? F === "define" ? `
#ifndef HAS_UNIFORM_u_${V}
uniform lowp float u_${V}_t;
in ${O} ${W} a_${V};
out ${O} ${q} ${V};
#else
uniform ${O} ${q} u_${V};
#endif
` : te === "vec4" ? `
#ifndef HAS_UNIFORM_u_${V}
    ${V} = a_${V};
#else
    ${O} ${q} ${V} = u_${V};
#endif
` : `
#ifndef HAS_UNIFORM_u_${V}
    ${V} = unpack_mix_${te}(a_${V}, u_${V}_t);
#else
    ${O} ${q} ${V} = u_${V};
#endif
` : F === "define" ? `
#ifndef HAS_UNIFORM_u_${V}
uniform lowp float u_${V}_t;
in ${O} ${W} a_${V};
#else
uniform ${O} ${q} u_${V};
#endif
` : te === "vec4" ? `
#ifndef HAS_UNIFORM_u_${V}
    ${O} ${q} ${V} = a_${V};
#else
    ${O} ${q} ${V} = u_${V};
#endif
` : `
#ifndef HAS_UNIFORM_u_${V}
    ${O} ${q} ${V} = unpack_mix_${te}(a_${V}, u_${V}_t);
#else
    ${O} ${q} ${V} = u_${V};
#endif
`;
          })), staticAttributes: d, staticUniforms: S };
        }
        class Lr {
          constructor(t, s, d) {
            this.vertexBuffer = t, this.indexBuffer = s, this.segments = d;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var ta = u.aU([{ name: "a_pos", type: "Int16", components: 2 }]);
        const si = "#define PROJECTION_MERCATOR", dr = "mercator";
        class tn {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return dr;
          }
          get shaderDefine() {
            return si;
          }
          get shaderPreludeCode() {
            return en.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return en.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return u.aV.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(t) {
          }
          getMeshFromTileID(t, s, d, g, w) {
            if (this._cachedMesh) return this._cachedMesh;
            const S = new u.aW();
            S.emplaceBack(0, 0), S.emplaceBack(u.a5, 0), S.emplaceBack(0, u.a5), S.emplaceBack(u.a5, u.a5);
            const C = t.createVertexBuffer(S, ta.members), A = u.aX.simpleSegment(0, 0, 4, 2), F = new u.aY();
            F.emplaceBack(1, 0, 2), F.emplaceBack(1, 2, 3);
            const O = t.createIndexBuffer(F);
            return this._cachedMesh = new Lr(C, O, A), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(t) {
          }
        }
        class ra {
          constructor(t = 0, s = 0, d = 0, g = 0) {
            if (isNaN(t) || t < 0 || isNaN(s) || s < 0 || isNaN(d) || d < 0 || isNaN(g) || g < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t, this.bottom = s, this.left = d, this.right = g;
          }
          interpolate(t, s, d) {
            return s.top != null && t.top != null && (this.top = u.G.number(t.top, s.top, d)), s.bottom != null && t.bottom != null && (this.bottom = u.G.number(t.bottom, s.bottom, d)), s.left != null && t.left != null && (this.left = u.G.number(t.left, s.left, d)), s.right != null && t.right != null && (this.right = u.G.number(t.right, s.right, d)), this;
          }
          getCenter(t, s) {
            const d = u.an((this.left + t - this.right) / 2, 0, t), g = u.an((this.top + s - this.bottom) / 2, 0, s);
            return new u.P(d, g);
          }
          equals(t) {
            return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
          }
          clone() {
            return new ra(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Fs(b, t) {
          if (!b.renderWorldCopies || b.lngRange) return;
          const s = t.lng - b.center.lng;
          t.lng += s > 180 ? -360 : s < -180 ? 360 : 0;
        }
        function Ur(b) {
          return Math.max(0, Math.floor(b));
        }
        class na {
          constructor(t, s) {
            var d;
            this.applyConstrain = (g, w) => this._constrainOverride !== null ? this._constrainOverride(g, w) : this._callbacks.defaultConstrain(g, w), this._callbacks = t, this._tileSize = 512, this._renderWorldCopies = s?.renderWorldCopies === void 0 || !!s?.renderWorldCopies, this._minZoom = s?.minZoom || 0, this._maxZoom = s?.maxZoom || 22, this._minPitch = s?.minPitch == null ? 0 : s?.minPitch, this._maxPitch = s?.maxPitch == null ? 60 : s?.maxPitch, this._constrainOverride = (d = s?.constrainOverride) !== null && d !== void 0 ? d : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new u.V(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ur(this._zoom), this._scale = u.aq(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new ra(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(t, s, d) {
            this._constrainOverride = t.constrainOverride, this._latRange = t.latRange, this._lngRange = t.lngRange, this._width = t.width, this._height = t.height, this._center = t.center, this._elevation = t.elevation, this._minElevationForCurrentTile = t.minElevationForCurrentTile, this._zoom = t.zoom, this._tileZoom = Ur(this._zoom), this._scale = u.aq(this._zoom), this._bearingInRadians = t.bearingInRadians, this._fovInRadians = t.fovInRadians, this._pitchInRadians = t.pitchInRadians, this._rollInRadians = t.rollInRadians, this._unmodified = t.unmodified, this._edgeInsets = new ra(t.padding.top, t.padding.bottom, t.padding.left, t.padding.right), this._minZoom = t.minZoom, this._maxZoom = t.maxZoom, this._minPitch = t.minPitch, this._maxPitch = t.maxPitch, this._renderWorldCopies = t.renderWorldCopies, this._cameraToCenterDistance = t.cameraToCenterDistance, this._nearZ = t.nearZ, this._farZ = t.farZ, this._autoCalculateNearFarZ = !d && t.autoCalculateNearFarZ, s && this.constrainInternal(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(t) {
            this._minElevationForCurrentTile = t;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(t) {
            this._minZoom !== t && (this._minZoom = t, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(t) {
            this._maxZoom !== t && (this._maxZoom = t, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(t) {
            this._minPitch !== t && (this._minPitch = t, this.setPitch(Math.max(this.pitch, t)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(t) {
            this._maxPitch !== t && (this._maxPitch = t, this.setPitch(Math.min(this.pitch, t)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(t) {
            t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
          }
          get constrainOverride() {
            return this._constrainOverride;
          }
          setConstrainOverride(t) {
            t === void 0 && (t = null), this._constrainOverride !== t && (this._constrainOverride = t, this.constrainInternal(), this._calcMatrices());
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new u.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(t) {
            const s = u.W(t, -180, 180) * Math.PI / 180;
            var d, g, w, S, C, A, F, O, q;
            this._bearingInRadians !== s && (this._unmodified = !1, this._bearingInRadians = s, this._calcMatrices(), this._rotationMatrix = z(), d = this._rotationMatrix, w = -this._bearingInRadians, S = (g = this._rotationMatrix)[0], C = g[1], A = g[2], F = g[3], O = Math.sin(w), q = Math.cos(w), d[0] = S * q + A * O, d[1] = C * q + F * O, d[2] = S * -O + A * q, d[3] = C * -O + F * q);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(t) {
            const s = u.an(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== s && (this._unmodified = !1, this._pitchInRadians = s, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(t) {
            const s = t / 180 * Math.PI;
            this._rollInRadians !== s && (this._unmodified = !1, this._rollInRadians = s, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return u.aZ(this._fovInRadians);
          }
          setFov(t) {
            t = u.an(t, 0.1, 150), this.fov !== t && (this._unmodified = !1, this._fovInRadians = u.ap(t), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(t) {
            const s = this.applyConstrain(this._center, t).zoom;
            this._zoom !== s && (this._unmodified = !1, this._zoom = s, this._tileZoom = Math.max(0, Math.floor(s)), this._scale = u.aq(s), this.constrainInternal(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(t) {
            t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this.constrainInternal(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(t) {
            t !== this._elevation && (this._elevation = t, this.constrainInternal(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(t) {
            this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(t, s) {
            this._autoCalculateNearFarZ = !1, this._nearZ = t, this._farZ = s, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(t) {
            return this._edgeInsets.equals(t);
          }
          interpolatePadding(t, s, d) {
            this._unmodified = !1, this._edgeInsets.interpolate(t, s, d), this.constrainInternal(), this._calcMatrices();
          }
          resize(t, s, d = !0) {
            this._width = t, this._height = s, d && this.constrainInternal(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Nr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(t) {
            t ? (this._lngRange = [t.getWest(), t.getEast()], this._latRange = [t.getSouth(), t.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-u.ao, u.ao]);
          }
          getCameraQueryGeometry(t, s) {
            if (s.length === 1) return [s[0], t];
            {
              const { minX: d, minY: g, maxX: w, maxY: S } = u.aa.fromPoints(s).extend(t);
              return [new u.P(d, g), new u.P(w, g), new u.P(w, S), new u.P(d, S), new u.P(d, g)];
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const t = this._unmodified, { center: s, zoom: d } = this.applyConstrain(this.center, this.zoom);
            this.setCenter(s), this.setZoom(d), this._unmodified = t, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let t = u.ar(new Float64Array(16));
              u.Q(t, t, [this._width / 2, -this._height / 2, 1]), u.O(t, t, [1, -1, 0]), this._clipSpaceToPixelsMatrix = t, t = u.ar(new Float64Array(16)), u.Q(t, t, [1, -1, 1]), u.O(t, t, [-1, -1, 0]), u.Q(t, t, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = t, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(t, s, d, g) {
            const w = d !== void 0 ? d : this.bearing, S = g = g !== void 0 ? g : this.pitch, { distanceToCenter: C, clampedElevation: A } = this._distanceToCenterFromAltElevationPitch(s, this.elevation, S), { x: F, y: O } = Rr(S, w), q = u.a9.fromLngLat(t, s);
            let V, W, te = u.a_(1, q.y), he = 0;
            do {
              if (he += 1, he > 10) break;
              W = C / te, V = new u.a9(q.x + F * W, q.y + O * W), te = 1 / V.meterInMercatorCoordinateUnits();
            } while (Math.abs(C - W * te) > 1e-12);
            return { center: V.toLngLat(), elevation: A, zoom: u.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / W / this.tileSize) };
          }
          recalculateZoomAndCenter(t) {
            if (this.elevation - t == 0) return;
            const s = 1 / this.worldSize, d = u.as(1, this.center.lat) * this.worldSize, g = u.a9.fromLngLat(this.center, this.elevation), w = g.x / s, S = g.y / s, C = g.z / s, A = this.pitch, F = this.bearing, { x: O, y: q, z: V } = Rr(A, F), W = this.cameraToCenterDistance, te = w + W * -O, he = S + W * -q, pe = C + W * V, { distanceToCenter: fe, clampedElevation: we } = this._distanceToCenterFromAltElevationPitch(pe / d, t, A), Le = fe * d, ve = new u.a9((te + O * Le) * s, (he + q * Le) * s, 0).toLngLat(), Ce = u.as(1, ve.lat), Ne = u.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / fe / Ce / this.tileSize);
            this._elevation = we, this._center = ve, this.setZoom(Ne);
          }
          _distanceToCenterFromAltElevationPitch(t, s, d) {
            const g = -Math.cos(u.ap(d)), w = t - s;
            let S, C = s;
            return g * w >= 0 || Math.abs(g) < 0.1 ? (S = 1e4, C = t + S * g) : S = -w / g, { distanceToCenter: S, clampedElevation: C };
          }
          getCameraPoint() {
            const t = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new u.P(t * Math.sin(this.rollInRadians), t * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const t = u.as(1, this.center.lat) * this.worldSize;
            return Xe(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / t).toLngLat();
          }
          getMercatorTileCoordinates(t) {
            if (!t) return [0, 0, 1, 1];
            const s = t.canonical.z >= 0 ? 1 << t.canonical.z : Math.pow(2, t.canonical.z);
            return [t.canonical.x / s, t.canonical.y / s, 1 / s / u.a5, 1 / s / u.a5];
          }
        }
        class rn {
          constructor(t, s) {
            this.min = t, this.max = s, this.center = u.a$([], u.b0([], this.min, this.max), 0.5);
          }
          quadrant(t) {
            const s = [t % 2 == 0, t < 2], d = u.b1(this.min), g = u.b1(this.max);
            for (let w = 0; w < s.length; w++) d[w] = s[w] ? this.min[w] : this.center[w], g[w] = s[w] ? this.center[w] : this.max[w];
            return g[2] = this.max[2], new rn(d, g);
          }
          distanceX(t) {
            return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
          }
          distanceY(t) {
            return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
          }
          intersectsFrustum(t) {
            let s = !0;
            for (let d = 0; d < t.planes.length; d++) {
              const g = this.intersectsPlane(t.planes[d]);
              if (g === 0) return 0;
              g === 1 && (s = !1);
            }
            return s ? 2 : t.aabb.min[0] > this.max[0] || t.aabb.min[1] > this.max[1] || t.aabb.min[2] > this.max[2] || t.aabb.max[0] < this.min[0] || t.aabb.max[1] < this.min[1] || t.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(t) {
            let s = t[3], d = t[3];
            for (let g = 0; g < 3; g++) t[g] > 0 ? (s += t[g] * this.min[g], d += t[g] * this.max[g]) : (d += t[g] * this.min[g], s += t[g] * this.max[g]);
            return s >= 0 ? 2 : d < 0 ? 0 : 1;
          }
        }
        class Do {
          distanceToTile2d(t, s, d, g) {
            const w = g.distanceX([t, s]), S = g.distanceY([t, s]);
            return Math.hypot(w, S);
          }
          getWrap(t, s, d) {
            return d;
          }
          getTileBoundingVolume(t, s, d, g) {
            var w, S;
            let C = 0, A = 0;
            if (g?.terrain) {
              const O = new u.a2(t.z, s, t.z, t.x, t.y), q = g.terrain.getMinMaxElevation(O);
              C = (w = q.minElevation) !== null && w !== void 0 ? w : Math.min(0, d), A = (S = q.maxElevation) !== null && S !== void 0 ? S : Math.max(0, d);
            }
            const F = 1 << t.z;
            return new rn([s + t.x / F, t.y / F, C], [s + (t.x + 1) / F, (t.y + 1) / F, A]);
          }
          allowVariableZoom(t, s) {
            const d = t.fov * (Math.abs(Math.cos(t.rollInRadians)) * t.height + Math.abs(Math.sin(t.rollInRadians)) * t.width) / t.height, g = u.an(78.5 - d / 2, 0, 60);
            return !!s.terrain || t.pitch > g;
          }
          allowWorldCopies() {
            return !0;
          }
          prepareNextFrame() {
          }
        }
        class ai {
          constructor(t, s, d) {
            this.points = t, this.planes = s, this.aabb = d;
          }
          static fromInvProjectionMatrix(t, s = 1, d = 0, g, w) {
            const S = w ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], C = Math.pow(2, d), A = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((V) => (function(W, te, he, pe) {
              const fe = u.aH([], W, te), we = 1 / fe[3] / he * pe;
              return u.b6(fe, fe, [we, we, 1 / fe[3], we]);
            })(V, t, s, C)));
            g && (function(V, W, te, he) {
              const pe = he ? 4 : 0, fe = he ? 0 : 4;
              let we = 0;
              const Le = [], ve = [];
              for (let ke = 0; ke < 4; ke++) {
                const Ge = u.b2([], V[ke + fe], V[ke + pe]), at = u.b7(Ge);
                u.a$(Ge, Ge, 1 / at), Le.push(at), ve.push(Ge);
              }
              for (let ke = 0; ke < 4; ke++) {
                const Ge = u.b8(V[ke + pe], ve[ke], te);
                we = Ge !== null && Ge >= 0 ? Math.max(we, Ge) : Math.max(we, Le[ke]);
              }
              const Ce = (function(ke, Ge) {
                const at = u.b2([], ke[Ge[0]], ke[Ge[1]]), tt = u.b2([], ke[Ge[2]], ke[Ge[1]]), nt = [0, 0, 0, 0];
                return u.b3(nt, u.b4([], at, tt)), nt[3] = -u.b5(nt, ke[Ge[0]]), nt;
              })(V, W), Ne = (function(ke, Ge) {
                const at = u.b9(ke), tt = u.ba([], ke, 1 / at), nt = u.b2([], Ge, u.a$([], tt, u.b5(Ge, tt))), it = u.b9(nt);
                if (it > 0) {
                  const Et = Math.sqrt(1 - tt[3] * tt[3]), kt = u.a$([], tt, -tt[3]), gt = u.b0([], kt, u.a$([], nt, Et / it));
                  return u.bb(Ge, gt);
                }
                return null;
              })(te, Ce);
              if (Ne !== null) {
                const ke = Ne / u.b5(ve[0], Ce);
                we = Math.min(we, ke);
              }
              for (let ke = 0; ke < 4; ke++) {
                const Ge = Math.min(we, Le[ke]);
                V[ke + fe] = [V[ke + pe][0] + ve[ke][0] * Ge, V[ke + pe][1] + ve[ke][1] * Ge, V[ke + pe][2] + ve[ke][2] * Ge, 1];
              }
            })(A, S[0], g, w);
            const F = S.map(((V) => {
              const W = u.b2([], A[V[0]], A[V[1]]), te = u.b2([], A[V[2]], A[V[1]]), he = u.b3([], u.b4([], W, te)), pe = -u.b5(he, A[V[1]]);
              return he.concat(pe);
            })), O = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], q = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const V of A) for (let W = 0; W < 3; W++) O[W] = Math.min(O[W], V[W]), q[W] = Math.max(q[W], V[W]);
            return new ai(A, F, new rn(O, q));
          }
        }
        class ia {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, s, d) {
            return this._helper.interpolatePadding(t, s, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, s, d = !0) {
            this._helper.resize(t, s, d);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, s) {
            this._helper.overrideNearFarZ(t, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(t, s) {
          }
          constructor(t) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (s, d) => {
              d = u.an(+d, this.minZoom, this.maxZoom);
              const g = { center: new u.V(s.lng, s.lat), zoom: d };
              let w = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && w === null) {
                const ve = 179.9999999999;
                w = [-ve, ve];
              }
              const S = this.tileSize * u.aq(g.zoom);
              let C = 0, A = S, F = 0, O = S, q = 0, V = 0;
              const { x: W, y: te } = this.size;
              if (this._helper._latRange) {
                const ve = this._helper._latRange;
                C = u.X(ve[1]) * S, A = u.X(ve[0]) * S, A - C < te && (q = te / (A - C));
              }
              w && (F = u.W(u.Y(w[0]) * S, 0, S), O = u.W(u.Y(w[1]) * S, 0, S), O < F && (O += S), O - F < W && (V = W / (O - F)));
              const { x: he, y: pe } = Nt(S, s);
              let fe, we;
              const Le = Math.max(V || 0, q || 0);
              if (Le) {
                const ve = new u.P(V ? (O + F) / 2 : he, q ? (A + C) / 2 : pe);
                return g.center = Wt(S, ve).wrap(), g.zoom += u.at(Le), g;
              }
              if (this._helper._latRange) {
                const ve = te / 2;
                pe - ve < C && (we = C + ve), pe + ve > A && (we = A - ve);
              }
              if (w) {
                const ve = (F + O) / 2;
                let Ce = he;
                this._helper._renderWorldCopies && (Ce = u.W(he, ve - S / 2, ve + S / 2));
                const Ne = W / 2;
                Ce - Ne < F && (fe = F + Ne), Ce + Ne > O && (fe = O - Ne);
              }
              if (fe !== void 0 || we !== void 0) {
                const ve = new u.P(fe ?? he, we ?? pe);
                g.center = Wt(S, ve).wrap();
              }
              return g;
            }, this.applyConstrain = (s, d) => this._helper.applyConstrain(s, d), this._helper = new na({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (s, d) => this.defaultConstrain(s, d) }, t), this._coveringTilesDetailsProvider = new Do();
          }
          clone() {
            const t = new ia();
            return t.apply(this, !1), t;
          }
          apply(t, s, d) {
            this._helper.apply(t, s, d);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(t) {
            const s = [new u.bc(0, t)];
            if (this._helper._renderWorldCopies) {
              const d = this.screenPointToMercatorCoordinate(new u.P(0, 0)), g = this.screenPointToMercatorCoordinate(new u.P(this._helper._width, 0)), w = this.screenPointToMercatorCoordinate(new u.P(this._helper._width, this._helper._height)), S = this.screenPointToMercatorCoordinate(new u.P(0, this._helper._height)), C = Math.floor(Math.min(d.x, g.x, w.x, S.x)), A = Math.floor(Math.max(d.x, g.x, w.x, S.x)), F = 1;
              for (let O = C - F; O <= A + F; O++) O !== 0 && s.push(new u.bc(O, t));
            }
            return s;
          }
          getCameraFrustum() {
            return ai.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(t) {
            const s = this.screenPointToLocation(this.centerPoint, t), d = t ? t.getElevationForLngLatZoom(s, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(d);
          }
          setLocationAtPoint(t, s) {
            const d = u.as(this.elevation, this.center.lat), g = this.screenPointToMercatorCoordinateAtZ(s, d), w = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, d), S = u.a9.fromLngLat(t), C = new u.a9(S.x - (g.x - w.x), S.y - (g.y - w.y));
            this.setCenter(C?.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(t, s) {
            return s ? this.coordinatePoint(u.a9.fromLngLat(t), s.getElevationForLngLat(t, this), this._pixelMatrix3D) : this.coordinatePoint(u.a9.fromLngLat(t));
          }
          screenPointToLocation(t, s) {
            var d;
            return (d = this.screenPointToMercatorCoordinate(t, s)) === null || d === void 0 ? void 0 : d.toLngLat();
          }
          screenPointToMercatorCoordinate(t, s) {
            if (s) {
              const d = s.pointCoordinate(t);
              if (d != null) return d;
            }
            return this.screenPointToMercatorCoordinateAtZ(t);
          }
          screenPointToMercatorCoordinateAtZ(t, s) {
            const d = s || 0, g = [t.x, t.y, 0, 1], w = [t.x, t.y, 1, 1];
            u.aH(g, g, this._pixelMatrixInverse), u.aH(w, w, this._pixelMatrixInverse);
            const S = g[3], C = w[3], A = g[1] / S, F = w[1] / C, O = g[2] / S, q = w[2] / C, V = O === q ? 0 : (d - O) / (q - O);
            return new u.a9(u.G.number(g[0] / S, w[0] / C, V) / this.worldSize, u.G.number(A, F, V) / this.worldSize, d);
          }
          coordinatePoint(t, s = 0, d = this._pixelMatrix) {
            const g = [t.x * this.worldSize, t.y * this.worldSize, s, 1];
            return u.aH(g, g, d), new u.P(g[0] / g[3], g[1] / g[3]);
          }
          getBounds() {
            const t = Math.max(0, this._helper._height / 2 - cr(this));
            return new Nr().extend(this.screenPointToLocation(new u.P(0, t))).extend(this.screenPointToLocation(new u.P(this._helper._width, t))).extend(this.screenPointToLocation(new u.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new u.P(0, this._helper._height)));
          }
          isPointOnMapSurface(t, s) {
            return s ? s.pointCoordinate(t) != null : t.y > this.height / 2 - cr(this);
          }
          calculatePosMatrix(t, s = !1, d) {
            var g;
            const w = (g = t.key) !== null && g !== void 0 ? g : u.bd(t.wrap, t.canonical.z, t.canonical.z, t.canonical.x, t.canonical.y), S = s ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (S.has(w)) {
              const F = S.get(w);
              return d ? F.f32 : F.f64;
            }
            const C = wr(t, this.worldSize);
            u.S(C, s ? this._alignedProjMatrix : this._viewProjMatrix, C);
            const A = { f64: C, f32: new Float32Array(C) };
            return S.set(w, A), d ? A.f32 : A.f64;
          }
          calculateFogMatrix(t) {
            const s = t.key, d = this._fogMatrixCacheF32;
            if (d.has(s)) return d.get(s);
            const g = wr(t, this.worldSize);
            return u.S(g, this._fogMatrix, g), d.set(s, new Float32Array(g)), d.get(s);
          }
          calculateCenterFromCameraLngLatAlt(t, s, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, s, d, g);
          }
          _calculateNearFarZIfNeeded(t, s, d) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const g = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), w = t - g * this._helper._pixelPerMeter / Math.cos(s), S = g < 0 ? w : t, C = Math.PI / 2 + this.pitchInRadians, A = u.ap(this.fov) * (Math.abs(Math.cos(u.ap(this.roll))) * this.height + Math.abs(Math.sin(u.ap(this.roll))) * this.width) / this.height * (0.5 + d.y / this.height), F = Math.sin(A) * S / Math.sin(u.an(Math.PI - C - A, 0.01, Math.PI - 0.01)), O = cr(this), q = Math.atan(O / this._helper.cameraToCenterDistance), V = u.ap(0.75), W = q > V ? 2 * q * (0.5 + d.y / (2 * O)) : V, te = Math.sin(W) * S / Math.sin(u.an(Math.PI - C - W, 0.01, Math.PI - 0.01)), he = Math.min(F, te);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - s) * he + S), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const t = this.centerOffset, s = Nt(this.worldSize, this.center), d = s.x, g = s.y;
            this._helper._pixelPerMeter = u.as(1, this.center.lat) * this.worldSize;
            const w = u.ap(Math.min(this.pitch, Lt)), S = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(w));
            let C;
            this._calculateNearFarZIfNeeded(S, w, t), C = new Float64Array(16), u.be(C, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), u.aB(this._invProjMatrix, C), C[8] = 2 * -t.x / this._helper._width, C[9] = 2 * t.y / this._helper._height, this._projectionMatrix = u.bf(C), u.Q(C, C, [1, -1, 1]), u.O(C, C, [0, 0, -this._helper.cameraToCenterDistance]), u.bg(C, C, -this.rollInRadians), u.bh(C, C, this.pitchInRadians), u.bg(C, C, -this.bearingInRadians), u.O(C, C, [-d, -g, 0]), this._mercatorMatrix = u.Q([], C, [this.worldSize, this.worldSize, this.worldSize]), u.Q(C, C, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = u.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, C), u.O(C, C, [0, 0, -this.elevation]), this._viewProjMatrix = C, this._invViewProjMatrix = u.aB([], C);
            const A = [0, 0, -1, 1];
            u.aH(A, A, this._invViewProjMatrix), this._cameraPosition = [A[0] / A[3], A[1] / A[3], A[2] / A[3]], this._fogMatrix = new Float64Array(16), u.be(this._fogMatrix, this.fovInRadians, this.width / this.height, S, this._helper._farZ), this._fogMatrix[8] = 2 * -t.x / this.width, this._fogMatrix[9] = 2 * t.y / this.height, u.Q(this._fogMatrix, this._fogMatrix, [1, -1, 1]), u.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), u.bg(this._fogMatrix, this._fogMatrix, -this.rollInRadians), u.bh(this._fogMatrix, this._fogMatrix, this.pitchInRadians), u.bg(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), u.O(this._fogMatrix, this._fogMatrix, [-d, -g, 0]), u.Q(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), u.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = u.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, C);
            const F = this._helper._width % 2 / 2, O = this._helper._height % 2 / 2, q = Math.cos(this.bearingInRadians), V = Math.sin(-this.bearingInRadians), W = d - Math.round(d) + q * F + V * O, te = g - Math.round(g) + q * O + V * F, he = new Float64Array(C);
            if (u.O(he, he, [W > 0.5 ? W - 1 : W, te > 0.5 ? te - 1 : te, 0]), this._alignedProjMatrix = he, C = u.aB(new Float64Array(16), this._pixelMatrix), !C) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = C, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const t = this.screenPointToMercatorCoordinate(new u.P(0, 0)), s = [t.x * this.worldSize, t.y * this.worldSize, 0, 1];
            return u.aH(s, s, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const t = u.as(1, this.center.lat) * this.worldSize;
            return Xe(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / t).toLngLat();
          }
          lngLatToCameraDepth(t, s) {
            const d = u.a9.fromLngLat(t), g = [d.x * this.worldSize, d.y * this.worldSize, s, 1];
            return u.aH(g, g, this._viewProjMatrix), g[2] / g[3];
          }
          getProjectionData(t) {
            const { overscaledTileID: s, aligned: d, applyTerrainMatrix: g } = t, w = this._helper.getMercatorTileCoordinates(s), S = s ? this.calculatePosMatrix(s, d, !0) : null;
            let C;
            return C = s && s.terrainRttPosMatrix32f && g ? s.terrainRttPosMatrix32f : S || u.bi(), { mainMatrix: C, tileMercatorCoords: w, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: C };
          }
          isLocationOccluded(t) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(t, s, d) {
            return 1;
          }
          transformLightDirection(t) {
            return u.b1(t);
          }
          getRayDirectionFromPixel(t) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(t, s, d, g) {
            const w = this.calculatePosMatrix(d);
            let S;
            g ? (S = [t, s, g(t, s), 1], u.aH(S, S, w)) : (S = [t, s, 0, 1], vl(S, S, w));
            const C = S[3];
            return { point: new u.P(S[0] / C, S[1] / C), signedDistanceFromCamera: C, isOccluded: !1 };
          }
          populateCache(t) {
            for (const s of t) this.calculatePosMatrix(s);
          }
          getMatrixForModel(t, s) {
            const d = u.a9.fromLngLat(t, s), g = d.meterInMercatorCoordinateUnits(), w = u.bj();
            return u.O(w, w, [d.x, d.y, d.z]), u.bg(w, w, Math.PI), u.bh(w, w, Math.PI / 2), u.Q(w, w, [-g, g, g]), w;
          }
          getProjectionDataForCustomLayer(t = !0) {
            const s = new u.a2(0, 0, 0, 0, 0), d = this.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: t }), g = wr(s, this.worldSize);
            u.S(g, this._viewProjMatrix, g), d.tileMercatorCoords = [0, 0, 1, 1];
            const w = [u.a5, u.a5, this.worldSize / this._helper.pixelsPerMeter], S = u.bk();
            return u.Q(S, g, w), d.fallbackMatrix = S, d.mainMatrix = S, d;
          }
          getFastPathSimpleProjectionMatrix(t) {
            return this.calculatePosMatrix(t);
          }
        }
        function xs() {
          u.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function Tc(b) {
          if (b.useSlerp) if (b.k < 1) {
            const t = u.bl(b.startEulerAngles.roll, b.startEulerAngles.pitch, b.startEulerAngles.bearing), s = u.bl(b.endEulerAngles.roll, b.endEulerAngles.pitch, b.endEulerAngles.bearing), d = new Float64Array(4);
            u.bm(d, t, s, b.k);
            const g = u.bn(d);
            b.tr.setRoll(g.roll), b.tr.setPitch(g.pitch), b.tr.setBearing(g.bearing);
          } else b.tr.setRoll(b.endEulerAngles.roll), b.tr.setPitch(b.endEulerAngles.pitch), b.tr.setBearing(b.endEulerAngles.bearing);
          else b.tr.setRoll(u.G.number(b.startEulerAngles.roll, b.endEulerAngles.roll, b.k)), b.tr.setPitch(u.G.number(b.startEulerAngles.pitch, b.endEulerAngles.pitch, b.k)), b.tr.setBearing(u.G.number(b.startEulerAngles.bearing, b.endEulerAngles.bearing, b.k));
        }
        function xl(b, t, s, d, g) {
          const w = g.padding, S = Nt(g.worldSize, s.getNorthWest()), C = Nt(g.worldSize, s.getNorthEast()), A = Nt(g.worldSize, s.getSouthEast()), F = Nt(g.worldSize, s.getSouthWest()), O = u.ap(-d), q = S.rotate(O), V = C.rotate(O), W = A.rotate(O), te = F.rotate(O), he = new u.P(Math.max(q.x, V.x, te.x, W.x), Math.max(q.y, V.y, te.y, W.y)), pe = new u.P(Math.min(q.x, V.x, te.x, W.x), Math.min(q.y, V.y, te.y, W.y)), fe = he.sub(pe), we = (g.width - (w.left + w.right + t.left + t.right)) / fe.x, Le = (g.height - (w.top + w.bottom + t.top + t.bottom)) / fe.y;
          if (Le < 0 || we < 0) return void xs();
          const ve = Math.min(u.at(g.scale * Math.min(we, Le)), b.maxZoom), Ce = u.P.convert(b.offset), Ne = new u.P((t.left - t.right) / 2, (t.top - t.bottom) / 2).rotate(u.ap(d)), ke = Ce.add(Ne).mult(g.scale / u.aq(ve));
          return { center: Wt(g.worldSize, S.add(A).div(2).sub(ke)), zoom: ve, bearing: d };
        }
        class vi {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(t, s) {
            const d = t.mag(), g = Math.abs(cr(s));
            return { easingOffset: t.mult(Math.min(0.75 * g / d, 1)), easingCenter: s.center };
          }
          handleMapControlsRollPitchBearingZoom(t, s) {
            t.bearingDelta && s.setBearing(s.bearing + t.bearingDelta), t.pitchDelta && s.setPitch(s.pitch + t.pitchDelta), t.rollDelta && s.setRoll(s.roll + t.rollDelta), t.zoomDelta && s.setZoom(s.zoom + t.zoomDelta);
          }
          handleMapControlsPan(t, s, d) {
            t.around.distSqr(s.centerPoint) < 0.01 || s.setLocationAtPoint(d, t.around);
          }
          cameraForBoxAndBearing(t, s, d, g, w) {
            return xl(t, s, d, g, w);
          }
          handleJumpToCenterZoom(t, s) {
            t.zoom !== (s.zoom !== void 0 ? +s.zoom : t.zoom) && t.setZoom(+s.zoom), s.center !== void 0 && t.setCenter(u.V.convert(s.center));
          }
          handleEaseTo(t, s) {
            const d = t.zoom, g = t.padding, w = { roll: t.roll, pitch: t.pitch, bearing: t.bearing }, S = { roll: s.roll === void 0 ? t.roll : s.roll, pitch: s.pitch === void 0 ? t.pitch : s.pitch, bearing: s.bearing === void 0 ? t.bearing : s.bearing }, C = s.zoom !== void 0, A = !t.isPaddingEqual(s.padding);
            let F = !1;
            const O = C ? +s.zoom : t.zoom;
            let q = t.centerPoint.add(s.offsetAsPoint);
            const V = t.screenPointToLocation(q), { center: W, zoom: te } = t.applyConstrain(u.V.convert(s.center || V), O ?? d);
            Fs(t, W);
            const he = Nt(t.worldSize, V), pe = Nt(t.worldSize, W).sub(he), fe = u.aq(te - d);
            return F = te !== d, { easeFunc: (we) => {
              if (F && t.setZoom(u.G.number(d, te, we)), u.bo(w, S) || Tc({ startEulerAngles: w, endEulerAngles: S, tr: t, k: we, useSlerp: w.roll != S.roll }), A && (t.interpolatePadding(g, s.padding, we), q = t.centerPoint.add(s.offsetAsPoint)), s.around) t.setLocationAtPoint(s.around, s.aroundPoint);
              else {
                const Le = u.aq(t.zoom - d), ve = te > d ? Math.min(2, fe) : Math.max(0.5, fe), Ce = Math.pow(ve, 1 - we), Ne = Wt(t.worldSize, he.add(pe.mult(we * Ce)).mult(Le));
                t.setLocationAtPoint(t.renderWorldCopies ? Ne.wrap() : Ne, q);
              }
            }, isZooming: F, elevationCenter: W };
          }
          handleFlyTo(t, s) {
            const d = s.zoom !== void 0, g = t.zoom, w = t.applyConstrain(u.V.convert(s.center || s.locationAtOffset), d ? +s.zoom : g), S = w.center, C = w.zoom;
            Fs(t, S);
            const A = Nt(t.worldSize, s.locationAtOffset), F = Nt(t.worldSize, S).sub(A), O = F.mag(), q = u.aq(C - g);
            let V;
            if (s.minZoom !== void 0) {
              const W = Math.min(+s.minZoom, g, C), te = t.applyConstrain(S, W).zoom;
              V = u.aq(te - g);
            }
            return { easeFunc: (W, te, he, pe) => {
              t.setZoom(W === 1 ? C : g + u.at(te));
              const fe = W === 1 ? S : Wt(t.worldSize, A.add(F.mult(he)).mult(te));
              t.setLocationAtPoint(t.renderWorldCopies ? fe.wrap() : fe, pe);
            }, scaleOfZoom: q, targetCenter: S, scaleOfMinZoom: V, pixelPathLength: O };
          }
        }
        class Dr {
          constructor(t, s, d) {
            this.blendFunction = t, this.blendColor = s, this.mask = d;
          }
        }
        Dr.Replace = [1, 0], Dr.disabled = new Dr(Dr.Replace, u.bp.transparent, [!1, !1, !1, !1]), Dr.unblended = new Dr(Dr.Replace, u.bp.transparent, [!0, !0, !0, !0]), Dr.alphaBlended = new Dr([1, 771], u.bp.transparent, [!0, !0, !0, !0]);
        const Qa = 2305;
        class sr {
          constructor(t, s, d) {
            this.enable = t, this.mode = s, this.frontFace = d;
          }
        }
        sr.disabled = new sr(!1, 1029, Qa), sr.backCCW = new sr(!0, 1029, Qa), sr.frontCCW = new sr(!0, 1028, Qa);
        class nr {
          constructor(t, s, d) {
            this.func = t, this.mask = s, this.range = d;
          }
        }
        nr.ReadOnly = !1, nr.ReadWrite = !0, nr.disabled = new nr(519, nr.ReadOnly, [0, 1]);
        const eo = 7680;
        class pr {
          constructor(t, s, d, g, w, S) {
            this.test = t, this.ref = s, this.mask = d, this.fail = g, this.depthFail = w, this.pass = S;
          }
        }
        pr.disabled = new pr({ func: 519, mask: 0 }, 0, 0, eo, eo, eo);
        const to = /* @__PURE__ */ new WeakMap();
        function Xn(b) {
          var t;
          if (to.has(b)) return to.get(b);
          {
            const s = (t = b.getParameter(b.VERSION)) === null || t === void 0 ? void 0 : t.startsWith("WebGL 2.0");
            return to.set(b, s), s;
          }
        }
        class ro {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(t) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = t;
            const s = t.context, d = s.gl;
            this._texFormat = d.RGBA, this._texType = d.UNSIGNED_BYTE;
            const g = new u.aW();
            g.emplaceBack(-1, -1), g.emplaceBack(2, -1), g.emplaceBack(-1, 2);
            const w = new u.aY();
            w.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Lr(s.createVertexBuffer(g, ta.members), s.createIndexBuffer(w), u.aX.simpleSegment(0, 0, g.length, w.length)), this._resultBuffer = new Uint8Array(4), s.activeTexture.set(d.TEXTURE1);
            const S = d.createTexture();
            d.bindTexture(d.TEXTURE_2D, S), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.NEAREST), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST), d.texImage2D(d.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = s.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(S), Xn(d) && (this._pbo = d.createBuffer(), d.bindBuffer(d.PIXEL_PACK_BUFFER, this._pbo), d.bufferData(d.PIXEL_PACK_BUFFER, 4, d.STREAM_READ), d.bindBuffer(d.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const t = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), t.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(t, s) {
            const d = this._updateCount;
            return this._readbackQueue ? d >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : d >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(t, s), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const t = this._cachedRenderContext.context, s = t.gl;
            t.activeTexture.set(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, this._fbo.colorAttachment.get()), t.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(t, s) {
            const d = this._cachedRenderContext.context, g = d.gl;
            if (this._bindFramebuffer(), d.viewport.set([0, 0, this._texWidth, this._texHeight]), d.clear({ color: u.bp.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(d, g.TRIANGLES, nr.disabled, pr.disabled, Dr.unblended, sr.disabled, /* @__PURE__ */ ((w, S) => ({ u_input: w, u_output_expected: S }))(t, s), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Xn(g)) {
              g.bindBuffer(g.PIXEL_PACK_BUFFER, this._pbo), g.readBuffer(g.COLOR_ATTACHMENT0), g.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), g.bindBuffer(g.PIXEL_PACK_BUFFER, null);
              const w = g.fenceSync(g.SYNC_GPU_COMMANDS_COMPLETE, 0);
              g.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: w };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const t = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Xn(t)) {
              const s = t.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (s === t.WAIT_FAILED) return u.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (s === t.TIMEOUT_EXPIRED) return;
              t.bindBuffer(t.PIXEL_PACK_BUFFER, this._pbo), t.getBufferSubData(t.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), t.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = ro._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(t) {
            let s = 0;
            return s += t[0] / 256, s += t[1] / 65536, s += t[2] / 16777216, t[3] < 127 && (s = -s), s / 128;
          }
        }
        const Jn = u.a5 / 128;
        function fu(b, t) {
          const s = b.granularity !== void 0 ? Math.max(b.granularity, 1) : 1, d = s + (b.generateBorders ? 2 : 0), g = s + (b.extendToNorthPole || b.generateBorders ? 1 : 0) + (b.extendToSouthPole || b.generateBorders ? 1 : 0), w = d + 1, S = g + 1, C = b.generateBorders ? -1 : 0, A = b.generateBorders || b.extendToNorthPole ? -1 : 0, F = s + (b.generateBorders ? 1 : 0), O = s + (b.generateBorders || b.extendToSouthPole ? 1 : 0), q = w * S, V = d * g * 6, W = w * S > 65536;
          if (W && t === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const te = W || t === "32bit", he = new Int16Array(2 * q);
          let pe = 0;
          for (let Le = A; Le <= O; Le++) for (let ve = C; ve <= F; ve++) {
            let Ce = ve / s * u.a5;
            ve === -1 && (Ce = -Jn), ve === s + 1 && (Ce = u.a5 + Jn);
            let Ne = Le / s * u.a5;
            Le === -1 && (Ne = b.extendToNorthPole ? u.br : -Jn), Le === s + 1 && (Ne = b.extendToSouthPole ? u.bs : u.a5 + Jn), he[pe++] = Ce, he[pe++] = Ne;
          }
          const fe = te ? new Uint32Array(V) : new Uint16Array(V);
          let we = 0;
          for (let Le = 0; Le < g; Le++) for (let ve = 0; ve < d; ve++) {
            const Ce = ve + 1 + Le * w, Ne = ve + (Le + 1) * w, ke = ve + 1 + (Le + 1) * w;
            fe[we++] = ve + Le * w, fe[we++] = Ne, fe[we++] = Ce, fe[we++] = Ce, fe[we++] = Ne, fe[we++] = ke;
          }
          return { vertices: he.buffer.slice(0), indices: fe.buffer.slice(0), uses32bitIndices: te };
        }
        const Ro = new u.aV({ fill: new u.bt(128, 2), line: new u.bt(512, 0), tile: new u.bt(128, 32), stencil: new u.bt(128, 1), circle: 3 });
        class pu {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return en.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return en.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Ro;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(t) {
            this._errorMeasurement || (this._errorMeasurement = new ro(t));
            const s = u.X(this._errorQueryLatitudeDegrees), d = 2 * Math.atan(Math.exp(Math.PI - s * Math.PI * 2)) - 0.5 * Math.PI, g = this._errorMeasurement.updateErrorLoop(s, d), w = me();
            g !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = g, this._errorMeasurementLastChangeTime = w);
            const S = Math.min(Math.max((w - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = u.bu(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, u.bv(S));
          }
          _getMeshKey(t) {
            return `${t.granularity.toString(36)}_${t.generateBorders ? "b" : ""}${t.extendToNorthPole ? "n" : ""}${t.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(t, s, d, g, w) {
            const S = (w === "stencil" ? Ro.stencil : Ro.tile).getGranularityForZoomLevel(s.z);
            return this._getMesh(t, { granularity: S, generateBorders: d, extendToNorthPole: s.y === 0 && g, extendToSouthPole: s.y === (1 << s.z) - 1 && g });
          }
          _getMesh(t, s) {
            const d = this._getMeshKey(s);
            if (d in this._tileMeshCache) return this._tileMeshCache[d];
            const g = (function(w, S) {
              const C = fu(S, "16bit"), A = u.aW.deserialize({ arrayBuffer: C.vertices, length: C.vertices.byteLength / 2 / 2 }), F = u.aY.deserialize({ arrayBuffer: C.indices, length: C.indices.byteLength / 2 / 3 });
              return new Lr(w.createVertexBuffer(A, ta.members), w.createIndexBuffer(F), u.aX.simpleSegment(0, 0, A.length, F.length));
            })(t, s);
            return this._tileMeshCache[d] = g, g;
          }
          recalculate(t) {
          }
          hasTransition() {
            const t = me();
            let s = !1;
            return s = s || (t - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, s = s || this._errorMeasurement && this._errorMeasurement.awaitingQuery, s;
          }
          setErrorQueryLatitudeDegrees(t) {
            this._errorQueryLatitudeDegrees = t;
          }
        }
        const Kh = new u.t({ type: new u.D(u.u.projection.type) });
        class Sc extends u.E {
          constructor(t) {
            super(), this._transitionable = new u.x(Kh, void 0), this.setProjection(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new u.H(0)), this._mercatorProjection = new tn(), this._verticalPerspectiveProjection = new pu();
          }
          get transitionState() {
            const t = this.properties.get("type");
            if (typeof t == "string" && t === "mercator") return 0;
            if (typeof t == "string" && t === "vertical-perspective") return 1;
            if (t instanceof u.bw) {
              if (t.from === "vertical-perspective" && t.to === "mercator") return 1 - t.transition;
              if (t.from === "mercator" && t.to === "vertical-perspective") return t.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(t) {
            this._mercatorProjection.updateGPUdependent(t), this._verticalPerspectiveProjection.updateGPUdependent(t);
          }
          getMeshFromTileID(t, s, d, g, w) {
            return this.currentProjection.getMeshFromTileID(t, s, d, g, w);
          }
          setProjection(t) {
            this._transitionable.setValue("type", t?.type || "mercator");
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          setErrorQueryLatitudeDegrees(t) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(t), this._mercatorProjection.setErrorQueryLatitudeDegrees(t);
          }
        }
        function xi(b) {
          const t = Gi(b.worldSize, b.center.lat);
          return 2 * Math.PI * t;
        }
        function bs(b, t, s, d, g) {
          const w = 1 / (1 << g), S = t / u.a5 * w + d * w, C = u.by((b / u.a5 * w + s * w) * Math.PI * 2 + Math.PI, 2 * Math.PI), A = 2 * Math.atan(Math.exp(Math.PI - S * Math.PI * 2)) - 0.5 * Math.PI, F = Math.cos(A), O = new Float64Array(3);
          return O[0] = Math.sin(C) * F, O[1] = Math.sin(A), O[2] = Math.cos(C) * F, O;
        }
        function Wr(b) {
          return (function(t, s) {
            const d = Math.cos(s), g = new Float64Array(3);
            return g[0] = Math.sin(t) * d, g[1] = Math.sin(s), g[2] = Math.cos(t) * d, g;
          })(b.lng * Math.PI / 180, b.lat * Math.PI / 180);
        }
        function Gi(b, t) {
          return b / (2 * Math.PI) / Math.cos(t * Math.PI / 180);
        }
        function bi(b) {
          const t = Math.asin(b[1]) / Math.PI * 180, s = Math.sqrt(b[0] * b[0] + b[2] * b[2]);
          if (s > 1e-6) {
            const d = b[0] / s, g = Math.acos(b[2] / s), w = (d > 0 ? g : -g) / Math.PI * 180;
            return new u.V(u.W(w, -180, 180), t);
          }
          return new u.V(0, t);
        }
        function Fo(b) {
          return Math.cos(b * Math.PI / 180);
        }
        function nn(b, t) {
          const s = Fo(b), d = Fo(t);
          return u.at(d / s);
        }
        function kc(b, t) {
          const s = b.rotate(t.bearingInRadians), d = t.zoom + nn(t.center.lat, 0), g = u.bu(1 / Fo(t.center.lat), 1 / Fo(Math.min(Math.abs(t.center.lat), 60)), u.bx(d, 7, 3, 0, 1)), w = 360 / xi({ worldSize: t.worldSize, center: { lat: t.center.lat } });
          return new u.V(t.center.lng - s.x * w * g, u.an(t.center.lat + s.y * w, -u.ao, u.ao));
        }
        function No(b) {
          const t = 0.5 * b, s = Math.sin(t), d = Math.cos(t);
          return Math.log(s + d) - Math.log(d - s);
        }
        function gu(b, t, s, d) {
          const g = b.lat + s * d;
          if (Math.abs(s) > 1) {
            const w = (Math.sign(b.lat + s) !== Math.sign(b.lat) ? -Math.abs(b.lat) : Math.abs(b.lat)) * Math.PI / 180, S = Math.abs(b.lat + s) * Math.PI / 180, C = No(w + d * (S - w)), A = No(w), F = No(S);
            return new u.V(b.lng + t * ((C - A) / (F - A)), g);
          }
          return new u.V(b.lng + t * d, g);
        }
        class mu {
          constructor(t) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = t;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const t = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = t, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileBoundingVolume(t, s, d, g) {
            const w = `${t.z}_${t.x}_${t.y}_${g?.terrain ? "t" : ""}`, S = this._cache.get(w);
            if (S) return S;
            const C = this._cachePrevious.get(w);
            if (C) return this._cache.set(w, C), C;
            const A = this._boundingVolumeFactory(t, s, d, g);
            return this._cache.set(w, A), this._hadAnyChanges = !0, A;
          }
        }
        class Ta {
          constructor(t, s, d, g) {
            this.min = d, this.max = g, this.points = t, this.planes = s;
          }
          static fromAabb(t, s) {
            const d = [];
            for (let g = 0; g < 8; g++) d.push([1 & ~g ? t[0] : s[0], (g >> 1 & 1) == 1 ? s[1] : t[1], (g >> 2 & 1) == 1 ? s[2] : t[2]]);
            return new Ta(d, [[-1, 0, 0, s[0]], [1, 0, 0, -t[0]], [0, -1, 0, s[1]], [0, 1, 0, -t[1]], [0, 0, -1, s[2]], [0, 0, 1, -t[2]]], t, s);
          }
          static fromCenterSizeAngles(t, s, d) {
            const g = u.bB([], d[0], d[1], d[2]), w = u.bC([], [s[0], 0, 0], g), S = u.bC([], [0, s[1], 0], g), C = u.bC([], [0, 0, s[2]], g), A = [...t], F = [...t];
            for (let q = 0; q < 8; q++) for (let V = 0; V < 3; V++) {
              const W = t[V] + w[V] * (1 & ~q ? -1 : 1) + S[V] * ((q >> 1 & 1) == 1 ? 1 : -1) + C[V] * ((q >> 2 & 1) == 1 ? 1 : -1);
              A[V] = Math.min(A[V], W), F[V] = Math.max(F[V], W);
            }
            const O = [];
            for (let q = 0; q < 8; q++) {
              const V = [...t];
              u.b0(V, V, u.a$([], w, 1 & ~q ? -1 : 1)), u.b0(V, V, u.a$([], S, (q >> 1 & 1) == 1 ? 1 : -1)), u.b0(V, V, u.a$([], C, (q >> 2 & 1) == 1 ? 1 : -1)), O.push(V);
            }
            return new Ta(O, [[...w, -u.b5(w, O[0])], [...S, -u.b5(S, O[0])], [...C, -u.b5(C, O[0])], [-w[0], -w[1], -w[2], -u.b5(w, O[7])], [-S[0], -S[1], -S[2], -u.b5(S, O[7])], [-C[0], -C[1], -C[2], -u.b5(C, O[7])]], A, F);
          }
          intersectsFrustum(t) {
            let s = !0;
            const d = this.points.length, g = this.planes.length, w = t.planes.length, S = t.points.length;
            for (let C = 0; C < w; C++) {
              const A = t.planes[C];
              let F = 0;
              for (let O = 0; O < d; O++) {
                const q = this.points[O];
                A[0] * q[0] + A[1] * q[1] + A[2] * q[2] + A[3] >= 0 && F++;
              }
              if (F === 0) return 0;
              F < d && (s = !1);
            }
            if (s) return 2;
            for (let C = 0; C < g; C++) {
              const A = this.planes[C];
              let F = 0;
              for (let O = 0; O < S; O++) {
                const q = t.points[O];
                A[0] * q[0] + A[1] * q[1] + A[2] * q[2] + A[3] >= 0 && F++;
              }
              if (F === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(t) {
            const s = this.points.length;
            let d = 0;
            for (let g = 0; g < s; g++) {
              const w = this.points[g];
              t[0] * w[0] + t[1] * w[1] + t[2] * w[2] + t[3] >= 0 && d++;
            }
            return d === s ? 2 : d === 0 ? 0 : 1;
          }
        }
        function ki(b, t, s) {
          const d = b - t;
          return d < 0 ? -d : Math.max(0, d - s);
        }
        function Sa(b, t, s, d, g) {
          const w = b - s;
          let S;
          return S = w < 0 ? Math.min(-w, 1 + w - g) : w > 1 ? Math.min(Math.max(w - g, 0), 1 - w) : 0, Math.max(S, ki(t, d, g));
        }
        class wi {
          constructor() {
            this._boundingVolumeCache = new mu(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(t, s, d, g) {
            const w = 1 << d.z, S = 1 / w, C = d.x / w, A = d.y / w;
            let F = 2;
            return F = Math.min(F, Sa(t, s, C, A, S)), F = Math.min(F, Sa(t, s, C + 0.5, -A - S, S)), F = Math.min(F, Sa(t, s, C + 0.5, 2 - A - S, S)), F;
          }
          getWrap(t, s, d) {
            const g = 1 << s.z, w = 1 / g, S = s.x / g, C = ki(t.x, S, w), A = ki(t.x, S - 1, w), F = ki(t.x, S + 1, w), O = Math.min(C, A, F);
            return O === F ? 1 : O === A ? -1 : 0;
          }
          allowVariableZoom(t, s) {
            return Ir(t, s) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileBoundingVolume(t, s, d, g) {
            return this._boundingVolumeCache.getTileBoundingVolume(t, s, d, g);
          }
          _computeTileBoundingVolume(t, s, d, g) {
            var w, S;
            let C = 0, A = 0;
            if (g?.terrain) {
              const F = new u.a2(t.z, s, t.z, t.x, t.y), O = g.terrain.getMinMaxElevation(F);
              C = (w = O.minElevation) !== null && w !== void 0 ? w : Math.min(0, d), A = (S = O.maxElevation) !== null && S !== void 0 ? S : Math.max(0, d);
            }
            if (C /= u.bE, A /= u.bE, C += 1, A += 1, t.z <= 0) return Ta.fromAabb([-A, -A, -A], [A, A, A]);
            if (t.z === 1) return Ta.fromAabb([t.x === 0 ? -A : 0, t.y === 0 ? 0 : -A, -A], [t.x === 0 ? 0 : A, t.y === 0 ? A : 0, A]);
            {
              const F = [bs(0, 0, t.x, t.y, t.z), bs(u.a5, 0, t.x, t.y, t.z), bs(u.a5, u.a5, t.x, t.y, t.z), bs(0, u.a5, t.x, t.y, t.z)], O = [];
              for (const nt of F) O.push(u.a$([], nt, A));
              if (A !== C) for (const nt of F) O.push(u.a$([], nt, C));
              t.y === 0 && O.push([0, 1, 0]), t.y === (1 << t.z) - 1 && O.push([0, -1, 0]);
              const q = [1, 1, 1], V = [-1, -1, -1];
              for (const nt of O) for (let it = 0; it < 3; it++) q[it] = Math.min(q[it], nt[it]), V[it] = Math.max(V[it], nt[it]);
              const W = bs(u.a5 / 2, u.a5 / 2, t.x, t.y, t.z), te = u.b4([], [0, 1, 0], W);
              u.b3(te, te);
              const he = u.b4([], W, te);
              u.b3(he, he);
              const pe = u.b4([], F[2], F[1]);
              u.b3(pe, pe);
              const fe = u.b4([], F[0], F[3]);
              u.b3(fe, fe), O.push(u.a$([], W, A)), t.y >= (1 << t.z) / 2 && O.push(u.a$([], bs(u.a5 / 2, 0, t.x, t.y, t.z), A)), t.y < (1 << t.z) / 2 && O.push(u.a$([], bs(u.a5 / 2, u.a5, t.x, t.y, t.z), A));
              const we = Ns(W, O), Le = Ns(he, O), ve = [-W[0], -W[1], -W[2], we.max], Ce = [W[0], W[1], W[2], -we.min], Ne = [-he[0], -he[1], -he[2], Le.max], ke = [he[0], he[1], he[2], -Le.min], Ge = [...pe, 0], at = [...fe, 0], tt = [];
              return t.y === 0 ? tt.push(u.bD(at, Ge, ve), u.bD(at, Ge, Ce)) : tt.push(u.bD(Ne, Ge, ve), u.bD(Ne, Ge, Ce), u.bD(Ne, at, ve), u.bD(Ne, at, Ce)), t.y === (1 << t.z) - 1 ? tt.push(u.bD(at, Ge, ve), u.bD(at, Ge, Ce)) : tt.push(u.bD(ke, Ge, ve), u.bD(ke, Ge, Ce), u.bD(ke, at, ve), u.bD(ke, at, Ce)), new Ta(tt, [ve, Ce, Ne, ke, Ge, at], q, V);
            }
          }
        }
        function Ns(b, t) {
          let s = 1 / 0, d = -1 / 0;
          for (const g of t) {
            const w = u.b5(b, g);
            s = Math.min(s, w), d = Math.max(d, w);
          }
          return { min: s, max: d };
        }
        class no {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, s, d) {
            return this._helper.interpolatePadding(t, s, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, s) {
            this._helper.resize(t, s);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, s) {
            this._helper.overrideNearFarZ(t, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(t) {
          }
          constructor(t) {
            this._cachedClippingPlane = u.bF(), this._projectionMatrix = u.bj(), this._globeViewProjMatrix32f = u.bi(), this._globeViewProjMatrixNoCorrection = u.bj(), this._globeViewProjMatrixNoCorrectionInverted = u.bj(), this._globeProjMatrixInverted = u.bj(), this._cameraPosition = u.bz(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (s, d) => {
              const g = u.an(s.lat, -u.ao, u.ao), w = u.an(+d, this.minZoom + nn(0, g), this.maxZoom);
              return { center: new u.V(s.lng, g), zoom: w };
            }, this.applyConstrain = (s, d) => this._helper.applyConstrain(s, d), this._helper = new na({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (s, d) => this.defaultConstrain(s, d) }, t), this._coveringTilesDetailsProvider = new wi();
          }
          clone() {
            const t = new no();
            return t.apply(this, !1), t;
          }
          apply(t, s, d) {
            this._globeLatitudeErrorCorrectionRadians = d || 0, this._helper.apply(t, s);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const t = u.bz();
            return t[0] = this._cameraPosition[0], t[1] = this._cameraPosition[1], t[2] = this._cameraPosition[2], t;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(t) {
            const { overscaledTileID: s, applyGlobeMatrix: d } = t, g = this._helper.getMercatorTileCoordinates(s);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: g, clippingPlane: this._cachedClippingPlane, projectionTransition: d ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(t) {
            const s = this.pitchInRadians, d = this.cameraToCenterDistance / t, g = Math.sin(s) * d, w = Math.cos(s) * d + 1, S = 1 / Math.sqrt(g * g + w * w) * 1;
            let C = -g, A = w;
            const F = Math.sqrt(C * C + A * A);
            C /= F, A /= F;
            const O = [0, C, A];
            u.bG(O, O, [0, 0, 0], -this.bearingInRadians), u.bH(O, O, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), u.bI(O, O, [0, 0, 0], this.center.lng * Math.PI / 180);
            const q = 1 / u.b7(O);
            return u.a$(O, O, q), [...O, -S * q];
          }
          isLocationOccluded(t) {
            return !this.isSurfacePointVisible(Wr(t));
          }
          transformLightDirection(t) {
            const s = this._helper._center.lng * Math.PI / 180, d = this._helper._center.lat * Math.PI / 180, g = Math.cos(d), w = [Math.sin(s) * g, Math.sin(d), Math.cos(s) * g], S = [w[2], 0, -w[0]], C = [0, 0, 0];
            u.b4(C, S, w), u.b3(S, S), u.b3(C, C);
            const A = [0, 0, 0];
            return u.b3(A, [S[0] * t[0] + C[0] * t[1] + w[0] * t[2], S[1] * t[0] + C[1] * t[1] + w[1] * t[2], S[2] * t[0] + C[2] * t[1] + w[2] * t[2]]), A;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(t, s, d) {
            const g = (function(C, A, F) {
              const O = 1 / (1 << F.z);
              return new u.a9(C / u.a5 * O + F.x * O, A / u.a5 * O + F.y * O);
            })(t, s, d.canonical), w = (S = g.y, [u.by(g.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - S * Math.PI * 2)) - 0.5 * Math.PI]);
            var S;
            return this.getCircleRadiusCorrection() / Math.cos(w[1]);
          }
          projectTileCoordinates(t, s, d, g) {
            const w = d.canonical, S = bs(t, s, w.x, w.y, w.z), C = 1 + (g ? g(t, s) : 0) / u.bE, A = [S[0] * C, S[1] * C, S[2] * C, 1];
            u.aH(A, A, this._globeViewProjMatrixNoCorrection);
            const F = this._cachedClippingPlane, O = F[0] * S[0] + F[1] * S[1] + F[2] * S[2] + F[3] < 0;
            return { point: new u.P(A[0] / A[3], A[1] / A[3]), signedDistanceFromCamera: A[3], isOccluded: O };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const t = Gi(this.worldSize, this.center.lat), s = u.bk(), d = u.bk();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * t), u.be(s, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const g = this.centerOffset;
            s[8] = 2 * -g.x / this._helper._width, s[9] = 2 * g.y / this._helper._height, this._projectionMatrix = u.bf(s), this._globeProjMatrixInverted = u.bk(), u.aB(this._globeProjMatrixInverted, s), u.O(s, s, [0, 0, -this.cameraToCenterDistance]), u.bg(s, s, this.rollInRadians), u.bh(s, s, -this.pitchInRadians), u.bg(s, s, this.bearingInRadians), u.O(s, s, [0, 0, -t]);
            const w = u.bz();
            w[0] = t, w[1] = t, w[2] = t, u.bh(d, s, this.center.lat * Math.PI / 180), u.bJ(d, d, -this.center.lng * Math.PI / 180), u.Q(d, d, w), this._globeViewProjMatrixNoCorrection = d, u.bh(s, s, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), u.bJ(s, s, -this.center.lng * Math.PI / 180), u.Q(s, s, w), this._globeViewProjMatrix32f = new Float32Array(s), this._globeViewProjMatrixNoCorrectionInverted = u.bk(), u.aB(this._globeViewProjMatrixNoCorrectionInverted, d);
            const S = u.bz();
            this._cameraPosition = u.bz(), this._cameraPosition[2] = this.cameraToCenterDistance / t, u.bG(this._cameraPosition, this._cameraPosition, S, -this.rollInRadians), u.bH(this._cameraPosition, this._cameraPosition, S, this.pitchInRadians), u.bG(this._cameraPosition, this._cameraPosition, S, -this.bearingInRadians), u.b0(this._cameraPosition, this._cameraPosition, [0, 0, 1]), u.bH(this._cameraPosition, this._cameraPosition, S, -this.center.lat * Math.PI / 180), u.bI(this._cameraPosition, this._cameraPosition, S, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(t);
            const C = u.bf(this._globeViewProjMatrixNoCorrectionInverted);
            u.Q(C, C, [1, 1, -1]), this._cachedFrustum = ai.fromInvProjectionMatrix(C, 1, 0, this._cachedClippingPlane, !0);
          }
          calculateFogMatrix(t) {
            u.w("calculateFogMatrix is not supported on globe projection.");
            const s = u.bk();
            return u.ar(s), s;
          }
          getVisibleUnwrappedCoordinates(t) {
            return [new u.bc(0, t)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(t) {
            t && u.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(t, s) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const d = Wr(t);
            u.a$(d, d, 1 + s / u.bE);
            const g = u.bF();
            return u.aH(g, [d[0], d[1], d[2], 1], this._globeViewProjMatrixNoCorrection), g[2] / g[3];
          }
          populateCache(t) {
          }
          getBounds() {
            const t = 0.5 * this.width, s = 0.5 * this.height, d = [new u.P(0, 0), new u.P(t, 0), new u.P(this.width, 0), new u.P(this.width, s), new u.P(this.width, this.height), new u.P(t, this.height), new u.P(0, this.height), new u.P(0, s)], g = [];
            for (const q of d) g.push(this.unprojectScreenPoint(q));
            let w = 0, S = 0, C = 0, A = 0;
            const F = this.center;
            for (const q of g) {
              const V = u.bK(F.lng, q.lng), W = u.bK(F.lat, q.lat);
              V < S && (S = V), V > w && (w = V), W < A && (A = W), W > C && (C = W);
            }
            const O = [F.lng + S, F.lat + A, F.lng + w, F.lat + C];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (O[3] = 90, O[0] = -180, O[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (O[1] = -90, O[0] = -180, O[2] = 180), new Nr(O);
          }
          calculateCenterFromCameraLngLatAlt(t, s, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, s, d, g);
          }
          setLocationAtPoint(t, s) {
            const d = Wr(this.unprojectScreenPoint(s)), g = Wr(t), w = u.bz();
            u.bL(w);
            const S = u.bz();
            u.bI(S, d, w, -this.center.lng * Math.PI / 180), u.bH(S, S, w, this.center.lat * Math.PI / 180);
            const C = g[0] * g[0] + g[2] * g[2], A = S[0] * S[0];
            if (C < A) return;
            const F = Math.sqrt(C - A), O = -F, q = u.bM(g[0], g[2], S[0], F), V = u.bM(g[0], g[2], S[0], O), W = u.bz();
            u.bI(W, g, w, -q);
            const te = u.bM(W[1], W[2], S[1], S[2]), he = u.bz();
            u.bI(he, g, w, -V);
            const pe = u.bM(he[1], he[2], S[1], S[2]), fe = 0.5 * Math.PI, we = te >= -fe && te <= fe, Le = pe >= -fe && pe <= fe;
            let ve, Ce;
            if (we && Le) {
              const at = this.center.lng * Math.PI / 180, tt = this.center.lat * Math.PI / 180;
              u.bN(q, at) + u.bN(te, tt) < u.bN(V, at) + u.bN(pe, tt) ? (ve = q, Ce = te) : (ve = V, Ce = pe);
            } else if (we) ve = q, Ce = te;
            else {
              if (!Le) return;
              ve = V, Ce = pe;
            }
            const Ne = ve / Math.PI * 180, ke = Ce / Math.PI * 180, Ge = this.center.lat;
            this.setCenter(new u.V(Ne, u.an(ke, -90, 90))), this.setZoom(this.zoom + nn(Ge, this.center.lat));
          }
          locationToScreenPoint(t, s) {
            const d = Wr(t);
            if (s) {
              const g = s.getElevationForLngLatZoom(t, this._helper._tileZoom);
              u.a$(d, d, 1 + g / u.bE);
            }
            return this._projectSurfacePointToScreen(d);
          }
          _projectSurfacePointToScreen(t) {
            const s = u.bF();
            return u.aH(s, [...t, 1], this._globeViewProjMatrixNoCorrection), s[0] /= s[3], s[1] /= s[3], new u.P((0.5 * s[0] + 0.5) * this.width, (0.5 * -s[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(t, s) {
            if (s) {
              const d = s.pointCoordinate(t);
              if (d) return d;
            }
            return u.a9.fromLngLat(this.unprojectScreenPoint(t));
          }
          screenPointToLocation(t, s) {
            var d;
            return (d = this.screenPointToMercatorCoordinate(t, s)) === null || d === void 0 ? void 0 : d.toLngLat();
          }
          isPointOnMapSurface(t, s) {
            const d = this._cameraPosition, g = this.getRayDirectionFromPixel(t);
            return !!this.rayPlanetIntersection(d, g);
          }
          getRayDirectionFromPixel(t) {
            const s = u.bF();
            s[0] = t.x / this.width * 2 - 1, s[1] = -1 * (t.y / this.height * 2 - 1), s[2] = 1, s[3] = 1, u.aH(s, s, this._globeViewProjMatrixNoCorrectionInverted), s[0] /= s[3], s[1] /= s[3], s[2] /= s[3];
            const d = u.bz();
            d[0] = s[0] - this._cameraPosition[0], d[1] = s[1] - this._cameraPosition[1], d[2] = s[2] - this._cameraPosition[2];
            const g = u.bz();
            return u.b3(g, d), g;
          }
          isSurfacePointVisible(t) {
            const s = this._cachedClippingPlane;
            return s[0] * t[0] + s[1] * t[1] + s[2] * t[2] + s[3] >= 0;
          }
          isSurfacePointOnScreen(t) {
            if (!this.isSurfacePointVisible(t)) return !1;
            const s = u.bF();
            return u.aH(s, [...t, 1], this._globeViewProjMatrixNoCorrection), s[0] /= s[3], s[1] /= s[3], s[2] /= s[3], s[0] > -1 && s[0] < 1 && s[1] > -1 && s[1] < 1 && s[2] > -1 && s[2] < 1;
          }
          rayPlanetIntersection(t, s) {
            const d = u.b5(t, s), g = u.bz(), w = u.bz();
            u.a$(w, s, d), u.b2(g, t, w);
            const S = 1 - u.b5(g, g);
            if (S < 0) return null;
            const C = u.b5(t, t) - 1, A = -d + (d < 0 ? 1 : -1) * Math.sqrt(S), F = C / A, O = A;
            return { tMin: Math.min(F, O), tMax: Math.max(F, O) };
          }
          unprojectScreenPoint(t) {
            const s = this._cameraPosition, d = this.getRayDirectionFromPixel(t), g = this.rayPlanetIntersection(s, d);
            if (g) {
              const O = u.bz();
              u.b0(O, s, [d[0] * g.tMin, d[1] * g.tMin, d[2] * g.tMin]);
              const q = u.bz();
              return u.b3(q, O), bi(q);
            }
            const w = this._cachedClippingPlane, S = w[0] * d[0] + w[1] * d[1] + w[2] * d[2], C = -u.bb(w, s) / S, A = u.bz();
            if (C > 0) u.b0(A, s, [d[0] * C, d[1] * C, d[2] * C]);
            else {
              const O = u.bz();
              u.b0(O, s, [2 * d[0], 2 * d[1], 2 * d[2]]);
              const q = u.bb(this._cachedClippingPlane, O);
              u.b2(A, O, [this._cachedClippingPlane[0] * q, this._cachedClippingPlane[1] * q, this._cachedClippingPlane[2] * q]);
            }
            const F = (function(O) {
              const q = u.bz();
              return q[0] = O[0] * -O[3], q[1] = O[1] * -O[3], q[2] = O[2] * -O[3], { center: q, radius: Math.sqrt(1 - O[3] * O[3]) };
            })(w);
            return bi((function(O, q, V) {
              const W = u.bz();
              u.b2(W, V, O);
              const te = u.bz();
              return u.bA(te, O, W, q / u.b9(W)), te;
            })(F.center, F.radius, A));
          }
          getMatrixForModel(t, s) {
            const d = u.V.convert(t), g = 1 / u.bE, w = u.bj();
            return u.bJ(w, w, d.lng / 180 * Math.PI), u.bh(w, w, -d.lat / 180 * Math.PI), u.O(w, w, [0, 0, 1 + s / u.bE]), u.bh(w, w, 0.5 * Math.PI), u.Q(w, w, [g, g, g]), w;
          }
          getProjectionDataForCustomLayer(t = !0) {
            const s = this.getProjectionData({ overscaledTileID: new u.a2(0, 0, 0, 0, 0), applyGlobeMatrix: t });
            return s.tileMercatorCoords = [0, 0, 1, 1], s;
          }
          getFastPathSimpleProjectionMatrix(t) {
          }
        }
        class ka {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, s, d) {
            return this._helper.interpolatePadding(t, s, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, s, d = !0) {
            this._helper.resize(t, s, d);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, s) {
            this._helper.overrideNearFarZ(t, s);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(t, s) {
            this._globeness = t, this._globeLatitudeErrorCorrectionRadians = s, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor(t) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (s, d) => this.currentTransform.defaultConstrain(s, d), this.applyConstrain = (s, d) => this._helper.applyConstrain(s, d), this._helper = new na({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (s, d) => this.defaultConstrain(s, d) }, t), this._globeness = 1, this._mercatorTransform = new ia(), this._verticalPerspectiveTransform = new no();
          }
          clone() {
            const t = new ka();
            return t._globeness = this._globeness, t._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, t.apply(this, !1), t;
          }
          apply(t, s) {
            this._helper.apply(t, s), this._mercatorTransform.apply(this, !1), this._verticalPerspectiveTransform.apply(this, !1, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(t) {
            const s = this._mercatorTransform.getProjectionData(t), d = this._verticalPerspectiveTransform.getProjectionData(t);
            return { mainMatrix: this.isGlobeRendering ? d.mainMatrix : s.mainMatrix, clippingPlane: d.clippingPlane, tileMercatorCoords: d.tileMercatorCoords, projectionTransition: t.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: s.fallbackMatrix };
          }
          isLocationOccluded(t) {
            return this.currentTransform.isLocationOccluded(t);
          }
          transformLightDirection(t) {
            return this.currentTransform.transformLightDirection(t);
          }
          getPixelScale() {
            return u.bu(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return u.bu(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(t, s, d) {
            const g = this._mercatorTransform.getPitchedTextCorrection(t, s, d), w = this._verticalPerspectiveTransform.getPitchedTextCorrection(t, s, d);
            return u.bu(g, w, this._globeness);
          }
          projectTileCoordinates(t, s, d, g) {
            return this.currentTransform.projectTileCoordinates(t, s, d, g);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, !1, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(t) {
            return this.currentTransform.calculateFogMatrix(t);
          }
          getVisibleUnwrappedCoordinates(t) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(t);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(t) {
            this._mercatorTransform.recalculateZoomAndCenter(t), this._verticalPerspectiveTransform.recalculateZoomAndCenter(t);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(t, s) {
            return this.currentTransform.lngLatToCameraDepth(t, s);
          }
          populateCache(t) {
            this._mercatorTransform.populateCache(t), this._verticalPerspectiveTransform.populateCache(t);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          calculateCenterFromCameraLngLatAlt(t, s, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, s, d, g);
          }
          setLocationAtPoint(t, s) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(t, s), void this.apply(this._mercatorTransform, !1);
            this._verticalPerspectiveTransform.setLocationAtPoint(t, s), this.apply(this._verticalPerspectiveTransform, !1);
          }
          locationToScreenPoint(t, s) {
            return this.currentTransform.locationToScreenPoint(t, s);
          }
          screenPointToMercatorCoordinate(t, s) {
            return this.currentTransform.screenPointToMercatorCoordinate(t, s);
          }
          screenPointToLocation(t, s) {
            return this.currentTransform.screenPointToLocation(t, s);
          }
          isPointOnMapSurface(t, s) {
            return this.currentTransform.isPointOnMapSurface(t, s);
          }
          getRayDirectionFromPixel(t) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(t);
          }
          getMatrixForModel(t, s) {
            return this.currentTransform.getMatrixForModel(t, s);
          }
          getProjectionDataForCustomLayer(t = !0) {
            const s = this._mercatorTransform.getProjectionDataForCustomLayer(t);
            if (!this.isGlobeRendering) return s;
            const d = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(t);
            return d.fallbackMatrix = s.mainMatrix, d;
          }
          getFastPathSimpleProjectionMatrix(t) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(t);
          }
        }
        class wn {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(t, s) {
            const d = kc(t, s);
            return Math.abs(d.lng - s.center.lng) > 180 && (d.lng = s.center.lng + 179.5 * Math.sign(d.lng - s.center.lng)), { easingCenter: d, easingOffset: new u.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(t, s) {
            const d = t.around, g = s.screenPointToLocation(d);
            t.bearingDelta && s.setBearing(s.bearing + t.bearingDelta), t.pitchDelta && s.setPitch(s.pitch + t.pitchDelta), t.rollDelta && s.setRoll(s.roll + t.rollDelta);
            const w = s.zoom;
            t.zoomDelta && s.setZoom(s.zoom + t.zoomDelta);
            const S = s.zoom - w;
            if (S === 0) return;
            const C = u.bK(s.center.lng, g.lng), A = C / (Math.abs(C / 180) + 1), F = u.bK(s.center.lat, g.lat), O = s.getRayDirectionFromPixel(d), q = s.cameraPosition, V = -1 * u.b5(q, O), W = u.bz();
            u.b0(W, q, [O[0] * V, O[1] * V, O[2] * V]);
            const te = u.b7(W) - 1, he = Math.exp(0.5 * -Math.max(te - 0.3, 0)), pe = Gi(s.worldSize, s.center.lat) / Math.min(s.width, s.height), fe = u.bx(pe, 0.9, 0.5, 1, 0.25), we = (1 - u.aq(-S)) * Math.min(he, fe), Le = s.center.lat, ve = s.zoom, Ce = new u.V(s.center.lng + A * we, u.an(s.center.lat + F * we, -u.ao, u.ao));
            s.setLocationAtPoint(g, d);
            const Ne = s.center, ke = u.bx(Math.abs(C), 45, 85, 0, 1), Ge = u.bx(pe, 0.75, 0.35, 0, 1), at = Math.pow(Math.max(ke, Ge), 0.25), tt = u.bK(Ne.lng, Ce.lng), nt = u.bK(Ne.lat, Ce.lat);
            s.setCenter(new u.V(Ne.lng + tt * at, Ne.lat + nt * at).wrap()), s.setZoom(ve + nn(Le, s.center.lat));
          }
          handleMapControlsPan(t, s, d) {
            if (!t.panDelta) return;
            const g = s.center.lat, w = s.zoom;
            s.setCenter(kc(t.panDelta, s).wrap()), s.setZoom(w + nn(g, s.center.lat));
          }
          cameraForBoxAndBearing(t, s, d, g, w) {
            const S = xl(t, s, d, g, w), C = s.left / w.width * 2 - 1, A = (w.width - s.right) / w.width * 2 - 1, F = s.top / w.height * -2 + 1, O = (w.height - s.bottom) / w.height * -2 + 1, q = u.bK(d.getWest(), d.getEast()) < 0, V = q ? d.getEast() : d.getWest(), W = q ? d.getWest() : d.getEast(), te = Math.max(d.getNorth(), d.getSouth()), he = Math.min(d.getNorth(), d.getSouth()), pe = V + 0.5 * u.bK(V, W), fe = te + 0.5 * u.bK(te, he), we = w.clone();
            we.setCenter(S.center), we.setBearing(S.bearing), we.setPitch(0), we.setRoll(0), we.setZoom(S.zoom);
            const Le = we.modelViewProjectionMatrix, ve = [Wr(d.getNorthWest()), Wr(d.getNorthEast()), Wr(d.getSouthWest()), Wr(d.getSouthEast()), Wr(new u.V(W, fe)), Wr(new u.V(V, fe)), Wr(new u.V(pe, te)), Wr(new u.V(pe, he))], Ce = Wr(S.center);
            let Ne = Number.POSITIVE_INFINITY;
            for (const ke of ve) C < 0 && (Ne = wn.getLesserNonNegativeNonNull(Ne, wn.solveVectorScale(ke, Ce, Le, "x", C))), A > 0 && (Ne = wn.getLesserNonNegativeNonNull(Ne, wn.solveVectorScale(ke, Ce, Le, "x", A))), F > 0 && (Ne = wn.getLesserNonNegativeNonNull(Ne, wn.solveVectorScale(ke, Ce, Le, "y", F))), O < 0 && (Ne = wn.getLesserNonNegativeNonNull(Ne, wn.solveVectorScale(ke, Ce, Le, "y", O)));
            if (Number.isFinite(Ne) && Ne !== 0) return S.zoom = we.zoom + u.at(Ne), S;
            xs();
          }
          handleJumpToCenterZoom(t, s) {
            const d = t.center.lat, g = t.applyConstrain(s.center ? u.V.convert(s.center) : t.center, t.zoom).center;
            t.setCenter(g.wrap());
            const w = s.zoom !== void 0 ? +s.zoom : t.zoom + nn(d, g.lat);
            t.zoom !== w && t.setZoom(w);
          }
          handleEaseTo(t, s) {
            const d = t.zoom, g = t.center, w = t.padding, S = { roll: t.roll, pitch: t.pitch, bearing: t.bearing }, C = { roll: s.roll === void 0 ? t.roll : s.roll, pitch: s.pitch === void 0 ? t.pitch : s.pitch, bearing: s.bearing === void 0 ? t.bearing : s.bearing }, A = s.zoom !== void 0, F = !t.isPaddingEqual(s.padding);
            let O = !1;
            const q = s.center ? u.V.convert(s.center) : g, V = t.applyConstrain(q, d).center;
            Fs(t, V);
            const W = t.clone();
            W.setCenter(V), W.setZoom(A ? +s.zoom : d + nn(g.lat, q.lat)), W.setBearing(s.bearing);
            const te = new u.P(u.an(t.centerPoint.x + s.offsetAsPoint.x, 0, t.width), u.an(t.centerPoint.y + s.offsetAsPoint.y, 0, t.height));
            W.setLocationAtPoint(V, te);
            const he = (s.offset && s.offsetAsPoint.mag()) > 0 ? W.center : V, pe = A ? +s.zoom : d + nn(g.lat, he.lat), fe = d + nn(g.lat, 0), we = pe + nn(he.lat, 0), Le = u.bK(g.lng, he.lng), ve = u.bK(g.lat, he.lat), Ce = u.aq(we - fe);
            return O = pe !== d, { easeFunc: (Ne) => {
              if (u.bo(S, C) || Tc({ startEulerAngles: S, endEulerAngles: C, tr: t, k: Ne, useSlerp: S.roll != C.roll }), F && t.interpolatePadding(w, s.padding, Ne), s.around) u.w("Easing around a point is not supported under globe projection."), t.setLocationAtPoint(s.around, s.aroundPoint);
              else {
                const ke = we > fe ? Math.min(2, Ce) : Math.max(0.5, Ce), Ge = Math.pow(ke, 1 - Ne), at = gu(g, Le, ve, Ne * Ge);
                t.setCenter(at.wrap());
              }
              if (O) {
                const ke = u.G.number(fe, we, Ne) + nn(0, t.center.lat);
                t.setZoom(ke);
              }
            }, isZooming: O, elevationCenter: he };
          }
          handleFlyTo(t, s) {
            const d = s.zoom !== void 0, g = t.center, w = t.zoom, S = t.padding, C = !t.isPaddingEqual(s.padding), A = t.applyConstrain(u.V.convert(s.center || s.locationAtOffset), w).center, F = d ? +s.zoom : t.zoom + nn(t.center.lat, A.lat), O = t.clone();
            O.setCenter(A), O.setZoom(F), O.setBearing(s.bearing);
            const q = new u.P(u.an(t.centerPoint.x + s.offsetAsPoint.x, 0, t.width), u.an(t.centerPoint.y + s.offsetAsPoint.y, 0, t.height));
            O.setLocationAtPoint(A, q);
            const V = O.center;
            Fs(t, V);
            const W = (function(ve, Ce, Ne) {
              const ke = Wr(Ce), Ge = Wr(Ne), at = u.b5(ke, Ge), tt = Math.acos(at), nt = xi(ve);
              return tt / (2 * Math.PI) * nt;
            })(t, g, V), te = w + nn(g.lat, 0), he = F + nn(V.lat, 0), pe = u.aq(he - te);
            let fe;
            if (typeof s.minZoom == "number") {
              const ve = +s.minZoom + nn(V.lat, 0), Ce = Math.min(ve, te, he) + nn(0, V.lat), Ne = t.applyConstrain(V, Ce).zoom + nn(V.lat, 0);
              fe = u.aq(Ne - te);
            }
            const we = u.bK(g.lng, V.lng), Le = u.bK(g.lat, V.lat);
            return { easeFunc: (ve, Ce, Ne, ke) => {
              const Ge = gu(g, we, Le, Ne);
              C && t.interpolatePadding(S, s.padding, ve);
              const at = ve === 1 ? V : Ge;
              t.setCenter(at.wrap());
              const tt = te + u.at(Ce);
              t.setZoom(ve === 1 ? F : tt + nn(0, at.lat));
            }, scaleOfZoom: pe, targetCenter: V, scaleOfMinZoom: fe, pixelPathLength: W };
          }
          static solveVectorScale(t, s, d, g, w) {
            const S = g === "x" ? [d[0], d[4], d[8], d[12]] : [d[1], d[5], d[9], d[13]], C = [d[3], d[7], d[11], d[15]], A = t[0] * S[0] + t[1] * S[1] + t[2] * S[2], F = t[0] * C[0] + t[1] * C[1] + t[2] * C[2], O = s[0] * S[0] + s[1] * S[1] + s[2] * S[2], q = s[0] * C[0] + s[1] * C[1] + s[2] * C[2];
            return O + w * F === A + w * q || C[3] * (A - O) + S[3] * (q - F) + A * q == O * F ? null : (O + S[3] - w * q - w * C[3]) / (O - A - w * q + w * F);
          }
          static getLesserNonNegativeNonNull(t, s) {
            return s !== null && s >= 0 && s < t ? s : t;
          }
        }
        class _u {
          constructor(t) {
            this._globe = t, this._mercatorCameraHelper = new vi(), this._verticalPerspectiveCameraHelper = new wn();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(t, s) {
            return this.currentHelper.handlePanInertia(t, s);
          }
          handleMapControlsRollPitchBearingZoom(t, s) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(t, s);
          }
          handleMapControlsPan(t, s, d) {
            this.currentHelper.handleMapControlsPan(t, s, d);
          }
          cameraForBoxAndBearing(t, s, d, g, w) {
            return this.currentHelper.cameraForBoxAndBearing(t, s, d, g, w);
          }
          handleJumpToCenterZoom(t, s) {
            this.currentHelper.handleJumpToCenterZoom(t, s);
          }
          handleEaseTo(t, s) {
            return this.currentHelper.handleEaseTo(t, s);
          }
          handleFlyTo(t, s) {
            return this.currentHelper.handleFlyTo(t, s);
          }
        }
        const sa = (b, t) => u.B(b, t && t.filter(((s) => s.identifier !== "source.canvas"))), Oo = u.bO();
        class Ia extends u.E {
          constructor(t, s = {}) {
            var d, g;
            super(), this._rtlPluginLoaded = () => {
              for (const S in this.tileManagers) {
                const C = this.tileManagers[S].getSource().type;
                C !== "vector" && C !== "geojson" || this.tileManagers[S].reload();
              }
            }, this.map = t, this.dispatcher = new lr(ri(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", ((S, C) => this.getGlyphs(S, C))), this.dispatcher.registerMessageHandler("GI", ((S, C) => this.getImages(S, C))), this.dispatcher.registerMessageHandler("GDA", ((S, C) => this.getDashes(S, C))), this.imageManager = new Ie(), this.imageManager.setEventedParent(this);
            const w = ((d = t._container) === null || d === void 0 ? void 0 : d.lang) || typeof document < "u" && ((g = document.documentElement) === null || g === void 0 ? void 0 : g.lang) || void 0;
            this.glyphManager = new Ue(t._requestManager, s.localIdeographFontFamily, w), this.lineAtlas = new Ot(256, 512), this.crossTileSymbolIndex = new Wn(), this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", u.bP()), qe().on(be, this._rtlPluginLoaded), this.on("data", ((S) => {
              if (S.dataType !== "source" || S.sourceDataType !== "metadata") return;
              const C = this.tileManagers[S.sourceId];
              if (!C) return;
              const A = C.getSource();
              if (A && A.vectorLayerIds) for (const F in this._layers) {
                const O = this._layers[F];
                O.source === A.id && this._validateLayer(O);
              }
            }));
          }
          _setInitialValues() {
            var t;
            this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new u.bQ(), this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = !1, this._changed = !1, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = !1, this._updatedPaintProps = {}, this._layerOrderChanged = !1, this.crossTileSymbolIndex = new (((t = this.crossTileSymbolIndex) === null || t === void 0 ? void 0 : t.constructor) || Object)(), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0;
          }
          setGlobalStateProperty(t, s) {
            var d, g, w;
            this._checkLoaded();
            const S = s === null ? (w = (g = (d = this.stylesheet.state) === null || d === void 0 ? void 0 : d[t]) === null || g === void 0 ? void 0 : g.default) !== null && w !== void 0 ? w : null : s;
            if (u.bR(S, this._globalState[t])) return this;
            this._globalState[t] = S, this._applyGlobalStateChanges([t]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(t) {
            this._checkLoaded();
            const s = [];
            for (const d in t) !u.bR(this._globalState[d], t[d].default) && (s.push(d), this._globalState[d] = t[d].default);
            this._applyGlobalStateChanges(s);
          }
          _applyGlobalStateChanges(t) {
            if (t.length === 0) return;
            const s = /* @__PURE__ */ new Set(), d = {};
            for (const g of t) {
              d[g] = this._globalState[g];
              for (const w in this._layers) {
                const S = this._layers[w], C = S.getLayoutAffectingGlobalStateRefs(), A = S.getPaintAffectingGlobalStateRefs(), F = S.getVisibilityAffectingGlobalStateRefs();
                if (C.has(g) && s.add(S.source), A.has(g)) for (const { name: O, value: q } of A.get(g)) this._updatePaintProperty(S, O, q);
                F?.has(g) && (S.recalculateVisibility(), this._updateLayer(S));
              }
            }
            this.dispatcher.broadcast("UGS", d);
            for (const g in this.tileManagers) s.has(g) && (this._reloadSource(g), this._changed = !0);
          }
          loadURL(t, s = {}, d) {
            this.fire(new u.l("dataloading", { dataType: "style" })), s.validate = typeof s.validate != "boolean" || s.validate;
            const g = this.map._requestManager.transformRequest(t, "Style");
            this._loadStyleRequest = new AbortController();
            const w = this._loadStyleRequest;
            u.j(g, this._loadStyleRequest).then(((S) => {
              this._loadStyleRequest = null, this._load(S.data, s, d);
            })).catch(((S) => {
              this._loadStyleRequest = null, S && !w.signal.aborted && this.fire(new u.k(S));
            }));
          }
          loadJSON(t, s = {}, d) {
            this.fire(new u.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), oe.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, s.validate = s.validate !== !1, this._load(t, s, d);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new u.l("dataloading", { dataType: "style" })), this._load(Oo, { validate: !1 });
          }
          _load(t, s, d) {
            var g, w;
            let S = s.transformStyle ? s.transformStyle(d, t) : t;
            if (!s.validate || !sa(this, u.C(S))) {
              S = Object.assign({}, S), this._loaded = !0, this.stylesheet = S;
              for (const C in S.sources) this.addSource(C, S.sources[C], { validate: !1 });
              S.sprite ? this._loadSprite(S.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(S.glyphs), this._createLayers(), this.light = new dt(this.stylesheet.light), this._setProjectionInternal(((g = this.stylesheet.projection) === null || g === void 0 ? void 0 : g.type) || "mercator"), this.sky = new Ht(this.stylesheet.sky), this.map.setTerrain((w = this.stylesheet.terrain) !== null && w !== void 0 ? w : null), this.fire(new u.l("data", { dataType: "style" })), this.fire(new u.l("style.load"));
            }
          }
          _createLayers() {
            var t, s, d;
            const g = u.bS(this.stylesheet.layers);
            this.setGlobalState((t = this.stylesheet.state) !== null && t !== void 0 ? t : null), this.dispatcher.broadcast("SL", g), this._order = g.map(((w) => w.id)), this._layers = {}, this._serializedLayers = null;
            for (const w of g) {
              const S = u.bT(w, this._globalState);
              if (S.setEventedParent(this, { layer: { id: w.id } }), this._layers[w.id] = S, u.bU(S) && this.tileManagers[S.source]) {
                const C = (d = (s = w.paint) === null || s === void 0 ? void 0 : s["raster-fade-duration"]) !== null && d !== void 0 ? d : S.paint.get("raster-fade-duration");
                this.tileManagers[S.source].setRasterFadeDuration(C);
              }
            }
          }
          _loadSprite(t, s = !1, d = void 0) {
            this.imageManager.setLoaded(!1);
            const g = new AbortController();
            let w;
            this._spriteRequest = g, (function(S, C, A, F) {
              return u._(this, void 0, void 0, (function* () {
                const O = ie(S), q = A > 1 ? "@2x" : "", V = {}, W = {};
                for (const { id: te, url: he } of O) {
                  const pe = C.transformRequest(ge(he, q, ".json"), "SpriteJSON");
                  V[te] = u.j(pe, F);
                  const fe = C.transformRequest(ge(he, q, ".png"), "SpriteImage");
                  W[te] = ot.getImage(fe, F);
                }
                return yield Promise.all([...Object.values(V), ...Object.values(W)]), (function(te, he) {
                  return u._(this, void 0, void 0, (function* () {
                    const pe = {};
                    for (const fe in te) {
                      pe[fe] = {};
                      const we = oe.getImageCanvasContext((yield he[fe]).data), Le = (yield te[fe]).data;
                      for (const ve in Le) {
                        const { width: Ce, height: Ne, x: ke, y: Ge, sdf: at, pixelRatio: tt, stretchX: nt, stretchY: it, content: Et, textFitWidth: kt, textFitHeight: gt } = Le[ve];
                        pe[fe][ve] = { data: null, pixelRatio: tt, sdf: at, stretchX: nt, stretchY: it, content: Et, textFitWidth: kt, textFitHeight: gt, spriteData: { width: Ce, height: Ne, x: ke, y: Ge, context: we } };
                      }
                    }
                    return pe;
                  }));
                })(V, W);
              }));
            })(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((S) => {
              if (this._spriteRequest = null, S) for (const C in S) {
                this._spritesImagesIds[C] = [];
                const A = this._spritesImagesIds[C] ? this._spritesImagesIds[C].filter(((F) => !(F in S))) : [];
                for (const F of A) this.imageManager.removeImage(F), this._changedImages[F] = !0;
                for (const F in S[C]) {
                  const O = C === "default" ? F : `${C}:${F}`;
                  this._spritesImagesIds[C].push(O), O in this.imageManager.images ? this.imageManager.updateImage(O, S[C][F], !1) : this.imageManager.addImage(O, S[C][F]), s && (this._changedImages[O] = !0);
                }
              }
            })).catch(((S) => {
              this._spriteRequest = null, w = S, g.signal.aborted || this.fire(new u.k(w));
            })).finally((() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), s && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" })), d && d(w);
            }));
          }
          _unloadSprite() {
            for (const t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
          }
          _validateLayer(t) {
            const s = this.tileManagers[t.source];
            if (!s) return;
            const d = t.sourceLayer;
            if (!d) return;
            const g = s.getSource();
            (g.type === "geojson" || g.vectorLayerIds && g.vectorLayerIds.indexOf(d) === -1) && this.fire(new u.k(new Error(`Source layer "${d}" does not exist on source "${g.id}" as specified by style layer "${t.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const t in this.tileManagers) if (!this.tileManagers[t].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t, s = !1) {
            const d = this._serializedAllLayers();
            if (!t || t.length === 0) return Object.values(s ? u.bV(d) : d);
            const g = [];
            for (const w of t) if (d[w]) {
              const S = s ? u.bV(d[w]) : d[w];
              g.push(S);
            }
            return g;
          }
          _serializedAllLayers() {
            let t = this._serializedLayers;
            if (t) return t;
            t = this._serializedLayers = {};
            const s = Object.keys(this._layers);
            for (const d of s) {
              const g = this._layers[d];
              g.type !== "custom" && (t[d] = g.serialize());
            }
            return t;
          }
          hasTransitions() {
            var t, s, d;
            if (!((t = this.light) === null || t === void 0) && t.hasTransition() || !((s = this.sky) === null || s === void 0) && s.hasTransition() || !((d = this.projection) === null || d === void 0) && d.hasTransition()) return !0;
            for (const g in this.tileManagers) if (this.tileManagers[g].hasTransition()) return !0;
            for (const g in this._layers) if (this._layers[g].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(t) {
            if (!this._loaded) return;
            const s = this._changed;
            if (s) {
              const g = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              (g.length || w.length) && this._updateWorkerLayers(g, w);
              for (const S in this._updatedSources) {
                const C = this._updatedSources[S];
                if (C === "reload") this._reloadSource(S);
                else {
                  if (C !== "clear") throw new Error(`Invalid action ${C}`);
                  this._clearSource(S);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const S in this._updatedPaintProps) this._layers[S].updateTransitions(t);
              this.light.updateTransitions(t), this.sky.updateTransitions(t), this._resetUpdates();
            }
            const d = {};
            for (const g in this.tileManagers) {
              const w = this.tileManagers[g];
              d[g] = w.used, w.used = !1;
            }
            for (const g of this._order) {
              const w = this._layers[g];
              w.recalculate(t, this._availableImages), !w.isHidden(t.zoom) && w.source && (this.tileManagers[w.source].used = !0);
            }
            for (const g in d) {
              const w = this.tileManagers[g];
              !!d[g] != !!w.used && w.fire(new u.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: g }));
            }
            this.light.recalculate(t), this.sky.recalculate(t), this.projection.recalculate(t), this.z = t.zoom, s && this.fire(new u.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t = Object.keys(this._changedImages);
            if (t.length) {
              for (const s in this.tileManagers) this.tileManagers[s].reloadTilesForDependencies(["icons", "patterns"], t);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t in this.tileManagers) this.tileManagers[t].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(t, s) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t, !1), removedIds: s });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(t, s = {}) {
            var d;
            this._checkLoaded();
            const g = this.serialize();
            if (t = s.transformStyle ? s.transformStyle(g, t) : t, ((d = s.validate) === null || d === void 0 || d) && sa(this, u.C(t))) return !1;
            (t = u.bV(t)).layers = u.bS(t.layers);
            const w = u.bW(g, t), S = this._getOperationsToPerform(w);
            if (S.unimplemented.length > 0) throw new Error(`Unimplemented: ${S.unimplemented.join(", ")}.`);
            if (S.operations.length === 0) return !1;
            for (const C of S.operations) C();
            return this.stylesheet = t, this._serializedLayers = null, this.fire(new u.l("style.load", { style: this })), !0;
          }
          _getOperationsToPerform(t) {
            const s = [], d = [];
            for (const g of t) switch (g.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                s.push((() => this.addLayer.apply(this, g.args)));
                break;
              case "removeLayer":
                s.push((() => this.removeLayer.apply(this, g.args)));
                break;
              case "setPaintProperty":
                s.push((() => this.setPaintProperty.apply(this, g.args)));
                break;
              case "setLayoutProperty":
                s.push((() => this.setLayoutProperty.apply(this, g.args)));
                break;
              case "setFilter":
                s.push((() => this.setFilter.apply(this, g.args)));
                break;
              case "addSource":
                s.push((() => this.addSource.apply(this, g.args)));
                break;
              case "removeSource":
                s.push((() => this.removeSource.apply(this, g.args)));
                break;
              case "setLayerZoomRange":
                s.push((() => this.setLayerZoomRange.apply(this, g.args)));
                break;
              case "setLight":
                s.push((() => this.setLight.apply(this, g.args)));
                break;
              case "setGeoJSONSourceData":
                s.push((() => this.setGeoJSONSourceData.apply(this, g.args)));
                break;
              case "setGlyphs":
                s.push((() => this.setGlyphs.apply(this, g.args)));
                break;
              case "setSprite":
                s.push((() => this.setSprite.apply(this, g.args)));
                break;
              case "setTerrain":
                s.push((() => this.map.setTerrain.apply(this, g.args)));
                break;
              case "setSky":
                s.push((() => this.setSky.apply(this, g.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, g.args);
                break;
              case "setGlobalState":
                s.push((() => this.setGlobalState.apply(this, g.args)));
                break;
              case "setTransition":
                s.push((() => {
                }));
                break;
              default:
                d.push(g.command);
            }
            return { operations: s, unimplemented: d };
          }
          addImage(t, s) {
            if (this.getImage(t)) return this.fire(new u.k(new Error(`An image named "${t}" already exists.`)));
            this.imageManager.addImage(t, s), this._afterImageUpdated(t);
          }
          updateImage(t, s) {
            this.imageManager.updateImage(t, s);
          }
          getImage(t) {
            return this.imageManager.getImage(t);
          }
          removeImage(t) {
            if (!this.getImage(t)) return this.fire(new u.k(new Error(`An image named "${t}" does not exist.`)));
            this.imageManager.removeImage(t), this._afterImageUpdated(t);
          }
          _afterImageUpdated(t) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(t, s, d = {}) {
            if (this._checkLoaded(), this.tileManagers[t] !== void 0) throw new Error(`Source "${t}" already exists.`);
            if (!s.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(s.type) >= 0 && this._validate(u.C.source, `sources.${t}`, s, null, d)) return;
            this.map && this.map._collectResourceTiming && (s.collectResourceTiming = !0);
            const g = this.tileManagers[t] = new yi(t, s, this.dispatcher);
            g.style = this, g.setEventedParent(this, (() => ({ isSourceLoaded: g.loaded(), source: g.serialize(), sourceId: t }))), g.onAdd(this.map), this._changed = !0;
          }
          removeSource(t) {
            if (this._checkLoaded(), this.tileManagers[t] === void 0) throw new Error("There is no source with this ID");
            for (const d in this._layers) if (this._layers[d].source === t) return this.fire(new u.k(new Error(`Source "${t}" cannot be removed while layer "${d}" is using it.`)));
            const s = this.tileManagers[t];
            delete this.tileManagers[t], delete this._updatedSources[t], s.fire(new u.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), s.setEventedParent(null), s.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(t, s) {
            if (this._checkLoaded(), this.tileManagers[t] === void 0) throw new Error(`There is no source with this ID=${t}`);
            const d = this.tileManagers[t].getSource();
            if (d.type !== "geojson") throw new Error(`geojsonSource.type is ${d.type}, which is !== 'geojson`);
            d.setData(s), this._changed = !0;
          }
          getSource(t) {
            return this.tileManagers[t] && this.tileManagers[t].getSource();
          }
          addLayer(t, s, d = {}) {
            this._checkLoaded();
            const g = t.id;
            if (this.getLayer(g)) return void this.fire(new u.k(new Error(`Layer "${g}" already exists on this map.`)));
            let w;
            if (t.type === "custom") {
              if (sa(this, u.bX(t))) return;
              w = u.bT(t, this._globalState);
            } else {
              if ("source" in t && typeof t.source == "object" && (this.addSource(g, t.source), t = u.bV(t), t = u.e(t, { source: g })), this._validate(u.C.layer, `layers.${g}`, t, { arrayIndex: -1 }, d)) return;
              w = u.bT(t, this._globalState), this._validateLayer(w), w.setEventedParent(this, { layer: { id: g } });
            }
            const S = s ? this._order.indexOf(s) : this._order.length;
            if (s && S === -1) this.fire(new u.k(new Error(`Cannot add layer "${g}" before non-existing layer "${s}".`)));
            else {
              if (this._order.splice(S, 0, g), this._layerOrderChanged = !0, this._layers[g] = w, this._removedLayers[g] && w.source && w.type !== "custom") {
                const C = this._removedLayers[g];
                delete this._removedLayers[g], C.type !== w.type ? this._updatedSources[w.source] = "clear" : (this._updatedSources[w.source] = "reload", this.tileManagers[w.source].pause());
              }
              this._updateLayer(w), w.onAdd && w.onAdd(this.map);
            }
          }
          moveLayer(t, s) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new u.k(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
            if (t === s) return;
            const d = this._order.indexOf(t);
            this._order.splice(d, 1);
            const g = s ? this._order.indexOf(s) : this._order.length;
            s && g === -1 ? this.fire(new u.k(new Error(`Cannot move layer "${t}" before non-existing layer "${s}".`))) : (this._order.splice(g, 0, t), this._layerOrderChanged = !0);
          }
          removeLayer(t) {
            this._checkLoaded();
            const s = this._layers[t];
            if (!s) return void this.fire(new u.k(new Error(`Cannot remove non-existing layer "${t}".`)));
            s.setEventedParent(null);
            const d = this._order.indexOf(t);
            this._order.splice(d, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = s, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], s.onRemove && s.onRemove(this.map);
          }
          getLayer(t) {
            return this._layers[t];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t) {
            return t in this._layers;
          }
          setLayerZoomRange(t, s, d) {
            this._checkLoaded();
            const g = this.getLayer(t);
            g ? g.minzoom === s && g.maxzoom === d || (s != null && (g.minzoom = s), d != null && (g.maxzoom = d), this._updateLayer(g)) : this.fire(new u.k(new Error(`Cannot set the zoom range of non-existing layer "${t}".`)));
          }
          setFilter(t, s, d = {}) {
            this._checkLoaded();
            const g = this.getLayer(t);
            if (g) {
              if (!u.bR(g.filter, s)) return s == null ? (g.setFilter(void 0), void this._updateLayer(g)) : void (this._validate(u.C.filter, `layers.${g.id}.filter`, s, null, d) || (g.setFilter(u.bV(s)), this._updateLayer(g)));
            } else this.fire(new u.k(new Error(`Cannot filter non-existing layer "${t}".`)));
          }
          getFilter(t) {
            return u.bV(this.getLayer(t).filter);
          }
          setLayoutProperty(t, s, d, g = {}) {
            this._checkLoaded();
            const w = this.getLayer(t);
            w ? u.bR(w.getLayoutProperty(s), d) || (w.setLayoutProperty(s, d, g), this._updateLayer(w)) : this.fire(new u.k(new Error(`Cannot style non-existing layer "${t}".`)));
          }
          getLayoutProperty(t, s) {
            const d = this.getLayer(t);
            if (d) return d.getLayoutProperty(s);
            this.fire(new u.k(new Error(`Cannot get style of non-existing layer "${t}".`)));
          }
          setPaintProperty(t, s, d, g = {}) {
            this._checkLoaded();
            const w = this.getLayer(t);
            w ? u.bR(w.getPaintProperty(s), d) || this._updatePaintProperty(w, s, d, g) : this.fire(new u.k(new Error(`Cannot style non-existing layer "${t}".`)));
          }
          _updatePaintProperty(t, s, d, g = {}) {
            t.setPaintProperty(s, d, g) && this._updateLayer(t), u.bU(t) && s === "raster-fade-duration" && this.tileManagers[t.source].setRasterFadeDuration(d), this._changed = !0, this._updatedPaintProps[t.id] = !0, this._serializedLayers = null;
          }
          getPaintProperty(t, s) {
            return this.getLayer(t).getPaintProperty(s);
          }
          setFeatureState(t, s) {
            this._checkLoaded();
            const d = t.source, g = t.sourceLayer, w = this.tileManagers[d];
            if (w === void 0) return void this.fire(new u.k(new Error(`The source '${d}' does not exist in the map's style.`)));
            const S = w.getSource().type;
            S === "geojson" && g ? this.fire(new u.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : S !== "vector" || g ? (t.id === void 0 && this.fire(new u.k(new Error("The feature id parameter must be provided."))), w.setFeatureState(g, t.id, s)) : this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(t, s) {
            this._checkLoaded();
            const d = t.source, g = this.tileManagers[d];
            if (g === void 0) return void this.fire(new u.k(new Error(`The source '${d}' does not exist in the map's style.`)));
            const w = g.getSource().type, S = w === "vector" ? t.sourceLayer : void 0;
            w !== "vector" || S ? s && typeof t.id != "string" && typeof t.id != "number" ? this.fire(new u.k(new Error("A feature id is required to remove its specific state property."))) : g.removeFeatureState(S, t.id, s) : this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(t) {
            this._checkLoaded();
            const s = t.source, d = t.sourceLayer, g = this.tileManagers[s];
            if (g !== void 0) return g.getSource().type !== "vector" || d ? (t.id === void 0 && this.fire(new u.k(new Error("The feature id parameter must be provided."))), g.getFeatureState(d, t.id)) : void this.fire(new u.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new u.k(new Error(`The source '${s}' does not exist in the map's style.`)));
          }
          getTransition() {
            return u.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const t = u.bY(this.tileManagers, ((w) => w.serialize())), s = this._serializeByIds(this._order, !0), d = this.map.getTerrain() || void 0, g = this.stylesheet;
            return u.bZ({ version: g.version, name: g.name, metadata: g.metadata, light: g.light, sky: g.sky, center: g.center, zoom: g.zoom, bearing: g.bearing, pitch: g.pitch, sprite: g.sprite, glyphs: g.glyphs, transition: g.transition, projection: g.projection, sources: t, layers: s, terrain: d }, ((w) => w !== void 0));
          }
          _updateLayer(t) {
            this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && this.tileManagers[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.tileManagers[t.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(t) {
            const s = (S) => this._layers[S].type === "fill-extrusion", d = {}, g = [];
            for (let S = this._order.length - 1; S >= 0; S--) {
              const C = this._order[S];
              if (s(C)) {
                d[C] = S;
                for (const A of t) {
                  const F = A[C];
                  if (F) for (const O of F) g.push(O);
                }
              }
            }
            g.sort(((S, C) => C.intersectionZ - S.intersectionZ));
            const w = [];
            for (let S = this._order.length - 1; S >= 0; S--) {
              const C = this._order[S];
              if (s(C)) for (let A = g.length - 1; A >= 0; A--) {
                const F = g[A].feature;
                if (d[F.layer.id] < S) break;
                w.push(F), g.pop();
              }
              else for (const A of t) {
                const F = A[C];
                if (F) for (const O of F) w.push(O.feature);
              }
            }
            return w;
          }
          queryRenderedFeatures(t, s, d) {
            s && s.filter && this._validate(u.C.filter, "queryRenderedFeatures.filter", s.filter, null, s);
            const g = {};
            if (s && s.layers) {
              if (!(Array.isArray(s.layers) || s.layers instanceof Set)) return this.fire(new u.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const F of s.layers) {
                const O = this._layers[F];
                if (!O) return this.fire(new u.k(new Error(`The layer '${F}' does not exist in the map's style and cannot be queried for features.`))), [];
                g[O.source] = !0;
              }
            }
            const w = [];
            s.availableImages = this._availableImages;
            const S = this._serializedAllLayers(), C = s.layers instanceof Set ? s.layers : Array.isArray(s.layers) ? new Set(s.layers) : null, A = Object.assign(Object.assign({}, s), { layers: C, globalState: this._globalState });
            for (const F in this.tileManagers) s.layers && !g[F] || w.push(br(this.tileManagers[F], this._layers, S, t, A, d, this.map.terrain ? (O, q, V) => this.map.terrain.getElevation(O, q, V) : void 0));
            return this.placement && w.push((function(F, O, q, V, W, te, he) {
              const pe = {}, fe = te.queryRenderedSymbols(V), we = [];
              for (const Le of Object.keys(fe).map(Number)) we.push(he[Le]);
              we.sort(ur);
              for (const Le of we) {
                const ve = Le.featureIndex.lookupSymbolFeatures(fe[Le.bucketInstanceId], O, Le.bucketIndex, Le.sourceLayerIndex, { filterSpec: W.filter, globalState: W.globalState }, W.layers, W.availableImages, F);
                for (const Ce in ve) {
                  const Ne = pe[Ce] = pe[Ce] || [], ke = ve[Ce];
                  ke.sort(((Ge, at) => {
                    const tt = Le.featureSortOrder;
                    if (tt) {
                      const nt = tt.indexOf(Ge.featureIndex);
                      return tt.indexOf(at.featureIndex) - nt;
                    }
                    return at.featureIndex - Ge.featureIndex;
                  }));
                  for (const Ge of ke) Ne.push(Ge);
                }
              }
              return (function(Le, ve, Ce) {
                for (const Ne in Le) for (const ke of Le[Ne]) tr(ke, Ce[ve[Ne].source]);
                return Le;
              })(pe, F, q);
            })(this._layers, S, this.tileManagers, t, A, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(w);
          }
          querySourceFeatures(t, s) {
            s?.filter && this._validate(u.C.filter, "querySourceFeatures.filter", s.filter, null, s);
            const d = this.tileManagers[t];
            return d ? (function(g, w) {
              const S = g.getRenderableIds().map(((F) => g.getTileByID(F))), C = [], A = {};
              for (let F = 0; F < S.length; F++) {
                const O = S[F], q = O.tileID.canonical.key;
                A[q] || (A[q] = !0, O.querySourceFeatures(C, w));
              }
              return C;
            })(d, s ? Object.assign(Object.assign({}, s), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(t, s = {}) {
            this._checkLoaded();
            const d = this.light.getLight();
            let g = !1;
            for (const S in t) if (!u.bR(t[S], d[S])) {
              g = !0;
              break;
            }
            if (!g) return;
            const w = { now: me(), transition: u.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(t, s), this.light.updateTransitions(w);
          }
          getProjection() {
            var t;
            return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.projection;
          }
          setProjection(t) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === t.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = t, this._setProjectionInternal(t.type);
          }
          getSky() {
            var t;
            return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.sky;
          }
          setSky(t, s = {}) {
            this._checkLoaded();
            const d = this.getSky();
            let g = !1;
            if (!t && !d) return;
            if (t && !d) g = !0;
            else if (!t && d) g = !0;
            else for (const S in t) if (!u.bR(t[S], d[S])) {
              g = !0;
              break;
            }
            if (!g) return;
            const w = { now: me(), transition: u.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = t, this.sky.setSky(t, s), this.sky.updateTransitions(w);
          }
          _setProjectionInternal(t) {
            const s = (function(d, g) {
              const w = { constrainOverride: g };
              if (Array.isArray(d)) {
                const S = new Sc({ type: d });
                return { projection: S, transform: new ka(w), cameraHelper: new _u(S) };
              }
              switch (d) {
                case "mercator":
                  return { projection: new tn(), transform: new ia(w), cameraHelper: new vi() };
                case "globe": {
                  const S = new Sc({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: S, transform: new ka(w), cameraHelper: new _u(S) };
                }
                case "vertical-perspective":
                  return { projection: new pu(), transform: new no(w), cameraHelper: new wn() };
                default:
                  return u.w(`Unknown projection name: ${d}. Falling back to mercator projection.`), { projection: new tn(), transform: new ia(w), cameraHelper: new vi() };
              }
            })(t, this.map.transformConstrain);
            this.projection = s.projection, this.map.migrateProjection(s.transform, s.cameraHelper);
            for (const d in this.tileManagers) this.tileManagers[d].reload();
          }
          _validate(t, s, d, g, w = {}) {
            return (!w || w.validate !== !1) && sa(this, t.call(u.C, u.e({ key: s, style: this.serialize(), value: d, styleSpec: u.u }, g)));
          }
          _remove(t = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), qe().off(be, this._rtlPluginLoaded);
            for (const s in this._layers) this._layers[s].setEventedParent(null);
            for (const s in this.tileManagers) {
              const d = this.tileManagers[s];
              d.setEventedParent(null), d.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t);
          }
          _clearSource(t) {
            this.tileManagers[t].clearTiles();
          }
          _reloadSource(t) {
            this.tileManagers[t].resume(), this.tileManagers[t].reload();
          }
          _updateSources(t) {
            for (const s in this.tileManagers) this.tileManagers[s].update(t, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t in this.tileManagers) this._reloadSource(t);
          }
          _updatePlacement(t, s, d, g, w = !1) {
            let S = !1, C = !1;
            const A = {};
            for (const F of this._order) {
              const O = this._layers[F];
              if (O.type !== "symbol") continue;
              if (!A[O.source]) {
                const V = this.tileManagers[O.source];
                A[O.source] = V.getRenderableIds(!0).map(((W) => V.getTileByID(W))).sort(((W, te) => te.tileID.overscaledZ - W.tileID.overscaledZ || (W.tileID.isLessThan(te.tileID) ? -1 : 1)));
              }
              const q = this.crossTileSymbolIndex.addLayer(O, A[O.source], t.center.lng);
              S = S || q;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((w = w || this._layerOrderChanged || d === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(me(), t.zoom)) && (this.pauseablePlacement = new Yi(t, this.map.terrain, this._order, w, s, d, g, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, A), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(me()), C = !0), S && this.pauseablePlacement.placement.setStale()), C || S) for (const F of this._order) {
              const O = this._layers[F];
              O.type === "symbol" && this.placement.updateLayerOpacities(O, A[O.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(me());
          }
          _releaseSymbolFadeTiles() {
            for (const t in this.tileManagers) this.tileManagers[t].releaseSymbolFadeTiles();
          }
          getImages(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = yield this.imageManager.getImages(s.icons);
              this._updateTilesForChangedImages();
              const g = this.tileManagers[s.source];
              return g && g.setDependencies(s.tileID.key, s.type, s.icons), d;
            }));
          }
          getGlyphs(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = yield this.glyphManager.getGlyphs(s.stacks), g = this.tileManagers[s.source];
              return g && g.setDependencies(s.tileID.key, s.type, [""]), d;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(t, s = {}) {
            this._checkLoaded(), t && this._validate(u.C.glyphs, "glyphs", t, null, s) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t));
          }
          getDashes(t, s) {
            return u._(this, void 0, void 0, (function* () {
              const d = {};
              for (const [g, w] of Object.entries(s.dashes)) d[g] = this.lineAtlas.getDash(w.dasharray, w.round);
              return d;
            }));
          }
          addSprite(t, s, d = {}, g) {
            this._checkLoaded();
            const w = [{ id: t, url: s }], S = [...ie(this.stylesheet.sprite), ...w];
            this._validate(u.C.sprite, "sprite", S, null, d) || (this.stylesheet.sprite = S, this._loadSprite(w, !0, g));
          }
          removeSprite(t) {
            this._checkLoaded();
            const s = ie(this.stylesheet.sprite);
            if (s.find(((d) => d.id === t))) {
              if (this._spritesImagesIds[t]) for (const d of this._spritesImagesIds[t]) this.imageManager.removeImage(d), this._changedImages[d] = !0;
              s.splice(s.findIndex(((d) => d.id === t)), 1), this.stylesheet.sprite = s.length > 0 ? s : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new u.l("data", { dataType: "style" }));
            } else this.fire(new u.k(new Error(`Sprite "${t}" doesn't exists on this map.`)));
          }
          getSprite() {
            return ie(this.stylesheet.sprite);
          }
          setSprite(t, s = {}, d) {
            this._checkLoaded(), t && this._validate(u.C.sprite, "sprite", t, null, s) || (this.stylesheet.sprite = t, t ? this._loadSprite(t, !0, d) : (this._unloadSprite(), d && d(null)));
          }
          destroy() {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null);
            for (const t in this.tileManagers) {
              const s = this.tileManagers[t];
              s.setEventedParent(null), s.onRemove(this.map);
            }
            this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy();
            for (const t in this._layers) {
              const s = this._layers[t];
              s.setEventedParent(null), s.onRemove && s.onRemove(this.map);
            }
            this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(!0), this._listeners = {}, this._oneTimeListeners = {};
          }
        }
        var Qh = u.aU([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class bl {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t, s, d, g, w, S, C, A, F) {
            this.context = t;
            let O = this.boundPaintVertexBuffers.length !== g.length;
            for (let q = 0; !O && q < g.length; q++) this.boundPaintVertexBuffers[q] !== g[q] && (O = !0);
            !this.vao || this.boundProgram !== s || this.boundLayoutVertexBuffer !== d || O || this.boundIndexBuffer !== w || this.boundVertexOffset !== S || this.boundDynamicVertexBuffer !== C || this.boundDynamicVertexBuffer2 !== A || this.boundDynamicVertexBuffer3 !== F ? this.freshBind(s, d, g, w, S, C, A, F) : (t.bindVertexArray.set(this.vao), C && C.bind(), w && w.dynamicDraw && w.bind(), A && A.bind(), F && F.bind());
          }
          freshBind(t, s, d, g, w, S, C, A) {
            const F = t.numAttributes, O = this.context, q = O.gl;
            this.vao && this.destroy(), this.vao = O.createVertexArray(), O.bindVertexArray.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = s, this.boundPaintVertexBuffers = d, this.boundIndexBuffer = g, this.boundVertexOffset = w, this.boundDynamicVertexBuffer = S, this.boundDynamicVertexBuffer2 = C, this.boundDynamicVertexBuffer3 = A, s.enableAttributes(q, t);
            for (const V of d) V.enableAttributes(q, t);
            S && S.enableAttributes(q, t), C && C.enableAttributes(q, t), A && A.enableAttributes(q, t), s.bind(), s.setVertexAttribPointers(q, t, w);
            for (const V of d) V.bind(), V.setVertexAttribPointers(q, t, w);
            S && (S.bind(), S.setVertexAttribPointers(q, t, w)), g && g.bind(), C && (C.bind(), C.setVertexAttribPointers(q, t, w)), A && (A.bind(), A.setVertexAttribPointers(q, t, w)), O.currentNumAttributes = F;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const ed = (b, t, s, d, g) => ({ u_texture: 0, u_ele_delta: b, u_fog_matrix: t, u_fog_color: s ? s.properties.get("fog-color") : u.bp.white, u_fog_ground_blend: s ? s.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: g ? 0 : s ? s.calculateFogBlendOpacity(d) : 0, u_horizon_color: s ? s.properties.get("horizon-color") : u.bp.white, u_horizon_fog_blend: s ? s.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: g ? 1 : 0 }), io = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function wl(b) {
          const t = [];
          for (let s = 0; s < b.length; s++) {
            if (b[s] === null) continue;
            const d = b[s].split(" ");
            t.push(d.pop());
          }
          return t;
        }
        class Ic {
          constructor(t, s, d, g, w, S, C, A, F = []) {
            const O = t.gl;
            this.program = O.createProgram();
            const q = wl(s.staticAttributes), V = d ? d.getBinderAttributes() : [], W = q.concat(V), te = en.prelude.staticUniforms ? wl(en.prelude.staticUniforms) : [], he = C.staticUniforms ? wl(C.staticUniforms) : [], pe = s.staticUniforms ? wl(s.staticUniforms) : [], fe = d ? d.getBinderUniforms() : [], we = te.concat(he).concat(pe).concat(fe), Le = [];
            for (const tt of we) Le.indexOf(tt) < 0 && Le.push(tt);
            const ve = d ? d.defines() : [];
            Xn(O) && ve.unshift("#version 300 es"), w && ve.push("#define OVERDRAW_INSPECTOR;"), S && ve.push("#define TERRAIN3D;"), A && ve.push(A), F && ve.push(...F);
            let Ce = ve.concat(en.prelude.fragmentSource, C.fragmentSource, s.fragmentSource).join(`
`), Ne = ve.concat(en.prelude.vertexSource, C.vertexSource, s.vertexSource).join(`
`);
            Xn(O) || (Ce = (function(tt) {
              return tt.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(Ce), Ne = (function(tt) {
              return tt.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(Ne));
            const ke = O.createShader(O.FRAGMENT_SHADER);
            if (O.isContextLost()) return void (this.failedToCreate = !0);
            if (O.shaderSource(ke, Ce), O.compileShader(ke), !O.getShaderParameter(ke, O.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${O.getShaderInfoLog(ke)}`);
            O.attachShader(this.program, ke);
            const Ge = O.createShader(O.VERTEX_SHADER);
            if (O.isContextLost()) return void (this.failedToCreate = !0);
            if (O.shaderSource(Ge, Ne), O.compileShader(Ge), !O.getShaderParameter(Ge, O.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${O.getShaderInfoLog(Ge)}`);
            O.attachShader(this.program, Ge), this.attributes = {};
            const at = {};
            this.numAttributes = W.length;
            for (let tt = 0; tt < this.numAttributes; tt++) W[tt] && (O.bindAttribLocation(this.program, tt, W[tt]), this.attributes[W[tt]] = tt);
            if (O.linkProgram(this.program), !O.getProgramParameter(this.program, O.LINK_STATUS)) throw new Error(`Program failed to link: ${O.getProgramInfoLog(this.program)}`);
            O.deleteShader(Ge), O.deleteShader(ke);
            for (let tt = 0; tt < Le.length; tt++) {
              const nt = Le[tt];
              if (nt && !at[nt]) {
                const it = O.getUniformLocation(this.program, nt);
                it && (at[nt] = it);
              }
            }
            this.fixedUniforms = g(t, at), this.terrainUniforms = ((tt, nt) => ({ u_depth: new u.b_(tt, nt.u_depth), u_terrain: new u.b_(tt, nt.u_terrain), u_terrain_dim: new u.bq(tt, nt.u_terrain_dim), u_terrain_matrix: new u.c0(tt, nt.u_terrain_matrix), u_terrain_unpack: new u.c1(tt, nt.u_terrain_unpack), u_terrain_exaggeration: new u.bq(tt, nt.u_terrain_exaggeration) }))(t, at), this.projectionUniforms = ((tt, nt) => ({ u_projection_matrix: new u.c0(tt, nt.u_projection_matrix), u_projection_tile_mercator_coords: new u.c1(tt, nt.u_projection_tile_mercator_coords), u_projection_clipping_plane: new u.c1(tt, nt.u_projection_clipping_plane), u_projection_transition: new u.bq(tt, nt.u_projection_transition), u_projection_fallback_matrix: new u.c0(tt, nt.u_projection_fallback_matrix) }))(t, at), this.binderUniforms = d ? d.getUniforms(t, at) : [];
          }
          draw(t, s, d, g, w, S, C, A, F, O, q, V, W, te, he, pe, fe, we, Le) {
            const ve = t.gl;
            if (this.failedToCreate) return;
            if (t.program.set(this.program), t.setDepthMode(d), t.setStencilMode(g), t.setColorMode(w), t.setCullFace(S), A) {
              t.activeTexture.set(ve.TEXTURE2), ve.bindTexture(ve.TEXTURE_2D, A.depthTexture), t.activeTexture.set(ve.TEXTURE3), ve.bindTexture(ve.TEXTURE_2D, A.texture);
              for (const Ne in this.terrainUniforms) this.terrainUniforms[Ne].set(A[Ne]);
            }
            if (F) for (const Ne in F) this.projectionUniforms[io[Ne]].set(F[Ne]);
            if (C) for (const Ne in this.fixedUniforms) this.fixedUniforms[Ne].set(C[Ne]);
            pe && pe.setUniforms(t, this.binderUniforms, te, { zoom: he });
            let Ce = 0;
            switch (s) {
              case ve.LINES:
                Ce = 2;
                break;
              case ve.TRIANGLES:
                Ce = 3;
                break;
              case ve.LINE_STRIP:
                Ce = 1;
            }
            for (const Ne of W.get()) {
              const ke = Ne.vaos || (Ne.vaos = {});
              (ke[O] || (ke[O] = new bl())).bind(t, this, q, pe ? pe.getPaintVertexBuffers() : [], V, Ne.vertexOffset, fe, we, Le), ve.drawElements(s, Ne.primitiveLength * Ce, ve.UNSIGNED_SHORT, Ne.primitiveOffset * Ce * 2);
            }
          }
        }
        function yu(b, t, s) {
          const d = 1 / u.aN(s, 1, t.transform.tileZoom), g = Math.pow(2, s.tileID.overscaledZ), w = s.tileSize * Math.pow(2, t.transform.tileZoom) / g, S = w * (s.tileID.canonical.x + s.tileID.wrap * g), C = w * s.tileID.canonical.y;
          return { u_image: 0, u_texsize: s.imageAtlasTexture.size, u_scale: [d, b.fromScale, b.toScale], u_fade: b.t, u_pixel_coord_upper: [S >> 16, C >> 16], u_pixel_coord_lower: [65535 & S, 65535 & C] };
        }
        const vu = (b, t, s, d) => {
          const g = b.style.light, w = g.properties.get("position"), S = [w.x, w.y, w.z], C = u.c4();
          g.properties.get("anchor") === "viewport" && u.c5(C, b.transform.bearingInRadians), u.c6(S, S, C);
          const A = b.transform.transformLightDirection(S), F = g.properties.get("color");
          return { u_lightpos: S, u_lightpos_globe: A, u_lightintensity: g.properties.get("intensity"), u_lightcolor: [F.r, F.g, F.b], u_vertical_gradient: +t, u_opacity: s, u_fill_translate: d };
        }, El = (b, t, s, d, g, w, S) => u.e(vu(b, t, s, d), yu(w, b, S), { u_height_factor: -Math.pow(2, g.overscaledZ) / S.tileSize / 8 }), xu = (b, t, s, d) => u.e(yu(t, b, s), { u_fill_translate: d }), Mc = (b, t) => ({ u_world: b, u_fill_translate: t }), Cc = (b, t, s, d, g) => u.e(xu(b, t, s, g), { u_world: d }), Pc = (b, t, s, d, g) => {
          const w = b.transform;
          let S, C, A = 0;
          if (s.paint.get("circle-pitch-alignment") === "map") {
            const F = u.aN(t, 1, w.zoom);
            S = !0, C = [F, F], A = F / (u.a5 * Math.pow(2, t.tileID.overscaledZ)) * 2 * Math.PI * g;
          } else S = !1, C = w.pixelsToGLUnits;
          return { u_camera_to_center_distance: w.cameraToCenterDistance, u_scale_with_map: +(s.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +S, u_device_pixel_ratio: b.pixelRatio, u_extrude_scale: C, u_globe_extrude_scale: A, u_translate: d };
        }, Ma = (b) => ({ u_pixel_extrude_scale: [1 / b.width, 1 / b.height] }), Ac = (b) => ({ u_viewport_size: [b.width, b.height] }), bu = (b, t = 1) => ({ u_color: b, u_overlay: 0, u_overlay_scale: t }), Ca = (b, t, s, d) => {
          const g = u.aN(b, 1, t) / (u.a5 * Math.pow(2, b.tileID.overscaledZ)) * 2 * Math.PI * d;
          return { u_extrude_scale: u.aN(b, 1, t), u_intensity: s, u_globe_extrude_scale: g };
        }, wu = (b, t, s, d) => {
          const g = u.N();
          u.c7(g, 0, b.width, b.height, 0, 0, 1);
          const w = b.context.gl;
          return { u_matrix: g, u_world: [w.drawingBufferWidth, w.drawingBufferHeight], u_image: s, u_color_ramp: d, u_opacity: t.paint.get("heatmap-opacity") };
        }, zo = (b, t, s) => {
          const d = s.paint.get("hillshade-accent-color");
          let g;
          switch (s.paint.get("hillshade-method")) {
            case "basic":
              g = 4;
              break;
            case "combined":
              g = 1;
              break;
            case "igor":
              g = 2;
              break;
            case "multidirectional":
              g = 3;
              break;
            default:
              g = 0;
          }
          const w = s.getIlluminationProperties();
          for (let S = 0; S < w.directionRadians.length; S++) s.paint.get("hillshade-illumination-anchor") === "viewport" && (w.directionRadians[S] += b.transform.bearingInRadians);
          return { u_image: 0, u_latrange: Lc(0, t.tileID), u_exaggeration: s.paint.get("hillshade-exaggeration"), u_altitudes: w.altitudeRadians, u_azimuths: w.directionRadians, u_accent: d, u_method: g, u_highlights: w.highlightColor, u_shadows: w.shadowColor };
        }, td = (b, t) => {
          const s = t.stride, d = u.N();
          return u.c7(d, 0, u.a5, -u.a5, 0, 0, 1), u.O(d, d, [0, -u.a5, 0]), { u_matrix: d, u_image: 1, u_dimension: [s, s], u_zoom: b.overscaledZ, u_unpack: t.getUnpackVector() };
        };
        function Lc(b, t) {
          const s = Math.pow(2, t.canonical.z), d = t.canonical.y;
          return [new u.a9(0, d / s).toLngLat().lat, new u.a9(0, (d + 1) / s).toLngLat().lat];
        }
        const Tl = (b, t, s = 0) => ({ u_image: 0, u_unpack: t.getUnpackVector(), u_dimension: [t.stride, t.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: s, u_opacity: b.paint.get("color-relief-opacity") }), Bo = (b, t, s, d) => {
          const g = b.transform;
          return { u_translation: Il(b, t, s), u_ratio: d / u.aN(t, 1, g.zoom), u_device_pixel_ratio: b.pixelRatio, u_units_to_pixels: [1 / g.pixelsToGLUnits[0], 1 / g.pixelsToGLUnits[1]] };
        }, Eu = (b, t, s, d, g) => u.e(Bo(b, t, s, d), { u_image: 0, u_image_height: g }), Sl = (b, t, s, d, g) => {
          const w = b.transform, S = oi(t, w);
          return { u_translation: Il(b, t, s), u_texsize: t.imageAtlasTexture.size, u_ratio: d / u.aN(t, 1, w.zoom), u_device_pixel_ratio: b.pixelRatio, u_image: 0, u_scale: [S, g.fromScale, g.toScale], u_fade: g.t, u_units_to_pixels: [1 / w.pixelsToGLUnits[0], 1 / w.pixelsToGLUnits[1]] };
        }, Dc = (b, t, s, d, g) => {
          const w = oi(t, b.transform);
          return u.e(Bo(b, t, s, d), { u_tileratio: w, u_crossfade_from: g.fromScale, u_crossfade_to: g.toScale, u_image: 0, u_mix: g.t, u_lineatlas_width: b.lineAtlas.width, u_lineatlas_height: b.lineAtlas.height });
        }, kl = (b, t, s, d, g, w) => {
          const S = oi(t, b.transform);
          return u.e(Bo(b, t, s, d), { u_image: 0, u_image_height: w, u_tileratio: S, u_crossfade_from: g.fromScale, u_crossfade_to: g.toScale, u_image_dash: 1, u_mix: g.t, u_lineatlas_width: b.lineAtlas.width, u_lineatlas_height: b.lineAtlas.height });
        };
        function oi(b, t) {
          return 1 / u.aN(b, 1, t.tileZoom);
        }
        function Il(b, t, s) {
          return u.aO(b.transform, t, s.paint.get("line-translate"), s.paint.get("line-translate-anchor"));
        }
        const Ml = (b, t, s, d, g) => {
          return { u_tl_parent: b, u_scale_parent: t, u_buffer_scale: 1, u_fade_t: s.mix, u_opacity: s.opacity * d.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d.paint.get("raster-brightness-min"), u_brightness_high: d.paint.get("raster-brightness-max"), u_saturation_factor: (S = d.paint.get("raster-saturation"), S > 0 ? 1 - 1 / (1.001 - S) : -S), u_contrast_factor: (w = d.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: Ii(d.paint.get("raster-hue-rotate")), u_coords_top: [g[0].x, g[0].y, g[1].x, g[1].y], u_coords_bottom: [g[3].x, g[3].y, g[2].x, g[2].y] };
          var w, S;
        };
        function Ii(b) {
          b *= Math.PI / 180;
          const t = Math.sin(b), s = Math.cos(b);
          return [(2 * s + 1) / 3, (-Math.sqrt(3) * t - s + 1) / 3, (Math.sqrt(3) * t - s + 1) / 3];
        }
        const Xi = (b, t, s, d, g, w, S, C, A, F, O, q, V) => {
          const W = S.transform;
          return { u_is_size_zoom_constant: +(b === "constant" || b === "source"), u_is_size_feature_constant: +(b === "constant" || b === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: W.cameraToCenterDistance, u_pitch: W.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +s, u_aspect_ratio: W.width / W.height, u_fade_change: S.options.fadeDuration ? S.symbolFadeChange : 1, u_label_plane_matrix: C, u_coord_matrix: A, u_is_text: +O, u_pitch_with_map: +d, u_is_along_line: g, u_is_variable_anchor: w, u_texsize: q, u_texture: 0, u_translation: F, u_pitched_scale: V };
        }, y = (b, t, s, d, g, w, S, C, A, F, O, q, V, W) => {
          const te = S.transform;
          return u.e(Xi(b, t, s, d, g, w, S, C, A, F, O, q, W), { u_gamma_scale: d ? Math.cos(te.pitch * Math.PI / 180) * te.cameraToCenterDistance : 1, u_device_pixel_ratio: S.pixelRatio, u_is_halo: 1 });
        }, o = (b, t, s, d, g, w, S, C, A, F, O, q, V) => u.e(y(b, t, s, d, g, w, S, C, A, F, !0, O, 0, V), { u_texsize_icon: q, u_texture_icon: 1 }), h = (b, t) => ({ u_opacity: b, u_color: t }), _ = (b, t, s, d, g) => u.e((function(w, S, C, A) {
          const F = C.imageManager.getPattern(w.from.toString()), O = C.imageManager.getPattern(w.to.toString()), { width: q, height: V } = C.imageManager.getPixelSize(), W = Math.pow(2, A.tileID.overscaledZ), te = A.tileSize * Math.pow(2, C.transform.tileZoom) / W, he = te * (A.tileID.canonical.x + A.tileID.wrap * W), pe = te * A.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: F.tl, u_pattern_br_a: F.br, u_pattern_tl_b: O.tl, u_pattern_br_b: O.br, u_texsize: [q, V], u_mix: S.t, u_pattern_size_a: F.displaySize, u_pattern_size_b: O.displaySize, u_scale_a: S.fromScale, u_scale_b: S.toScale, u_tile_units_to_pixels: 1 / u.aN(A, 1, C.transform.tileZoom), u_pixel_coord_upper: [he >> 16, pe >> 16], u_pixel_coord_lower: [65535 & he, 65535 & pe] };
        })(s, g, t, d), { u_opacity: b }), I = (b, t) => {
        }, D = { fillExtrusion: (b, t) => ({ u_lightpos: new u.c2(b, t.u_lightpos), u_lightpos_globe: new u.c2(b, t.u_lightpos_globe), u_lightintensity: new u.bq(b, t.u_lightintensity), u_lightcolor: new u.c2(b, t.u_lightcolor), u_vertical_gradient: new u.bq(b, t.u_vertical_gradient), u_opacity: new u.bq(b, t.u_opacity), u_fill_translate: new u.c3(b, t.u_fill_translate) }), fillExtrusionPattern: (b, t) => ({ u_lightpos: new u.c2(b, t.u_lightpos), u_lightpos_globe: new u.c2(b, t.u_lightpos_globe), u_lightintensity: new u.bq(b, t.u_lightintensity), u_lightcolor: new u.c2(b, t.u_lightcolor), u_vertical_gradient: new u.bq(b, t.u_vertical_gradient), u_height_factor: new u.bq(b, t.u_height_factor), u_opacity: new u.bq(b, t.u_opacity), u_fill_translate: new u.c3(b, t.u_fill_translate), u_image: new u.b_(b, t.u_image), u_texsize: new u.c3(b, t.u_texsize), u_pixel_coord_upper: new u.c3(b, t.u_pixel_coord_upper), u_pixel_coord_lower: new u.c3(b, t.u_pixel_coord_lower), u_scale: new u.c2(b, t.u_scale), u_fade: new u.bq(b, t.u_fade) }), fill: (b, t) => ({ u_fill_translate: new u.c3(b, t.u_fill_translate) }), fillPattern: (b, t) => ({ u_image: new u.b_(b, t.u_image), u_texsize: new u.c3(b, t.u_texsize), u_pixel_coord_upper: new u.c3(b, t.u_pixel_coord_upper), u_pixel_coord_lower: new u.c3(b, t.u_pixel_coord_lower), u_scale: new u.c2(b, t.u_scale), u_fade: new u.bq(b, t.u_fade), u_fill_translate: new u.c3(b, t.u_fill_translate) }), fillOutline: (b, t) => ({ u_world: new u.c3(b, t.u_world), u_fill_translate: new u.c3(b, t.u_fill_translate) }), fillOutlinePattern: (b, t) => ({ u_world: new u.c3(b, t.u_world), u_image: new u.b_(b, t.u_image), u_texsize: new u.c3(b, t.u_texsize), u_pixel_coord_upper: new u.c3(b, t.u_pixel_coord_upper), u_pixel_coord_lower: new u.c3(b, t.u_pixel_coord_lower), u_scale: new u.c2(b, t.u_scale), u_fade: new u.bq(b, t.u_fade), u_fill_translate: new u.c3(b, t.u_fill_translate) }), circle: (b, t) => ({ u_camera_to_center_distance: new u.bq(b, t.u_camera_to_center_distance), u_scale_with_map: new u.b_(b, t.u_scale_with_map), u_pitch_with_map: new u.b_(b, t.u_pitch_with_map), u_extrude_scale: new u.c3(b, t.u_extrude_scale), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_globe_extrude_scale: new u.bq(b, t.u_globe_extrude_scale), u_translate: new u.c3(b, t.u_translate) }), collisionBox: (b, t) => ({ u_pixel_extrude_scale: new u.c3(b, t.u_pixel_extrude_scale) }), collisionCircle: (b, t) => ({ u_viewport_size: new u.c3(b, t.u_viewport_size) }), debug: (b, t) => ({ u_color: new u.b$(b, t.u_color), u_overlay: new u.b_(b, t.u_overlay), u_overlay_scale: new u.bq(b, t.u_overlay_scale) }), depth: I, clippingMask: I, heatmap: (b, t) => ({ u_extrude_scale: new u.bq(b, t.u_extrude_scale), u_intensity: new u.bq(b, t.u_intensity), u_globe_extrude_scale: new u.bq(b, t.u_globe_extrude_scale) }), heatmapTexture: (b, t) => ({ u_matrix: new u.c0(b, t.u_matrix), u_world: new u.c3(b, t.u_world), u_image: new u.b_(b, t.u_image), u_color_ramp: new u.b_(b, t.u_color_ramp), u_opacity: new u.bq(b, t.u_opacity) }), hillshade: (b, t) => ({ u_image: new u.b_(b, t.u_image), u_latrange: new u.c3(b, t.u_latrange), u_exaggeration: new u.bq(b, t.u_exaggeration), u_altitudes: new u.c9(b, t.u_altitudes), u_azimuths: new u.c9(b, t.u_azimuths), u_accent: new u.b$(b, t.u_accent), u_method: new u.b_(b, t.u_method), u_shadows: new u.c8(b, t.u_shadows), u_highlights: new u.c8(b, t.u_highlights) }), hillshadePrepare: (b, t) => ({ u_matrix: new u.c0(b, t.u_matrix), u_image: new u.b_(b, t.u_image), u_dimension: new u.c3(b, t.u_dimension), u_zoom: new u.bq(b, t.u_zoom), u_unpack: new u.c1(b, t.u_unpack) }), colorRelief: (b, t) => ({ u_image: new u.b_(b, t.u_image), u_unpack: new u.c1(b, t.u_unpack), u_dimension: new u.c3(b, t.u_dimension), u_elevation_stops: new u.b_(b, t.u_elevation_stops), u_color_stops: new u.b_(b, t.u_color_stops), u_color_ramp_size: new u.b_(b, t.u_color_ramp_size), u_opacity: new u.bq(b, t.u_opacity) }), line: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels) }), lineGradient: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels), u_image: new u.b_(b, t.u_image), u_image_height: new u.bq(b, t.u_image_height) }), linePattern: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_texsize: new u.c3(b, t.u_texsize), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_image: new u.b_(b, t.u_image), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels), u_scale: new u.c2(b, t.u_scale), u_fade: new u.bq(b, t.u_fade) }), lineSDF: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels), u_image: new u.b_(b, t.u_image), u_mix: new u.bq(b, t.u_mix), u_tileratio: new u.bq(b, t.u_tileratio), u_crossfade_from: new u.bq(b, t.u_crossfade_from), u_crossfade_to: new u.bq(b, t.u_crossfade_to), u_lineatlas_width: new u.bq(b, t.u_lineatlas_width), u_lineatlas_height: new u.bq(b, t.u_lineatlas_height) }), lineGradientSDF: (b, t) => ({ u_translation: new u.c3(b, t.u_translation), u_ratio: new u.bq(b, t.u_ratio), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_units_to_pixels: new u.c3(b, t.u_units_to_pixels), u_image: new u.b_(b, t.u_image), u_image_height: new u.bq(b, t.u_image_height), u_tileratio: new u.bq(b, t.u_tileratio), u_crossfade_from: new u.bq(b, t.u_crossfade_from), u_crossfade_to: new u.bq(b, t.u_crossfade_to), u_image_dash: new u.b_(b, t.u_image_dash), u_mix: new u.bq(b, t.u_mix), u_lineatlas_width: new u.bq(b, t.u_lineatlas_width), u_lineatlas_height: new u.bq(b, t.u_lineatlas_height) }), raster: (b, t) => ({ u_tl_parent: new u.c3(b, t.u_tl_parent), u_scale_parent: new u.bq(b, t.u_scale_parent), u_buffer_scale: new u.bq(b, t.u_buffer_scale), u_fade_t: new u.bq(b, t.u_fade_t), u_opacity: new u.bq(b, t.u_opacity), u_image0: new u.b_(b, t.u_image0), u_image1: new u.b_(b, t.u_image1), u_brightness_low: new u.bq(b, t.u_brightness_low), u_brightness_high: new u.bq(b, t.u_brightness_high), u_saturation_factor: new u.bq(b, t.u_saturation_factor), u_contrast_factor: new u.bq(b, t.u_contrast_factor), u_spin_weights: new u.c2(b, t.u_spin_weights), u_coords_top: new u.c1(b, t.u_coords_top), u_coords_bottom: new u.c1(b, t.u_coords_bottom) }), symbolIcon: (b, t) => ({ u_is_size_zoom_constant: new u.b_(b, t.u_is_size_zoom_constant), u_is_size_feature_constant: new u.b_(b, t.u_is_size_feature_constant), u_size_t: new u.bq(b, t.u_size_t), u_size: new u.bq(b, t.u_size), u_camera_to_center_distance: new u.bq(b, t.u_camera_to_center_distance), u_pitch: new u.bq(b, t.u_pitch), u_rotate_symbol: new u.b_(b, t.u_rotate_symbol), u_aspect_ratio: new u.bq(b, t.u_aspect_ratio), u_fade_change: new u.bq(b, t.u_fade_change), u_label_plane_matrix: new u.c0(b, t.u_label_plane_matrix), u_coord_matrix: new u.c0(b, t.u_coord_matrix), u_is_text: new u.b_(b, t.u_is_text), u_pitch_with_map: new u.b_(b, t.u_pitch_with_map), u_is_along_line: new u.b_(b, t.u_is_along_line), u_is_variable_anchor: new u.b_(b, t.u_is_variable_anchor), u_texsize: new u.c3(b, t.u_texsize), u_texture: new u.b_(b, t.u_texture), u_translation: new u.c3(b, t.u_translation), u_pitched_scale: new u.bq(b, t.u_pitched_scale) }), symbolSDF: (b, t) => ({ u_is_size_zoom_constant: new u.b_(b, t.u_is_size_zoom_constant), u_is_size_feature_constant: new u.b_(b, t.u_is_size_feature_constant), u_size_t: new u.bq(b, t.u_size_t), u_size: new u.bq(b, t.u_size), u_camera_to_center_distance: new u.bq(b, t.u_camera_to_center_distance), u_pitch: new u.bq(b, t.u_pitch), u_rotate_symbol: new u.b_(b, t.u_rotate_symbol), u_aspect_ratio: new u.bq(b, t.u_aspect_ratio), u_fade_change: new u.bq(b, t.u_fade_change), u_label_plane_matrix: new u.c0(b, t.u_label_plane_matrix), u_coord_matrix: new u.c0(b, t.u_coord_matrix), u_is_text: new u.b_(b, t.u_is_text), u_pitch_with_map: new u.b_(b, t.u_pitch_with_map), u_is_along_line: new u.b_(b, t.u_is_along_line), u_is_variable_anchor: new u.b_(b, t.u_is_variable_anchor), u_texsize: new u.c3(b, t.u_texsize), u_texture: new u.b_(b, t.u_texture), u_gamma_scale: new u.bq(b, t.u_gamma_scale), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_is_halo: new u.b_(b, t.u_is_halo), u_translation: new u.c3(b, t.u_translation), u_pitched_scale: new u.bq(b, t.u_pitched_scale) }), symbolTextAndIcon: (b, t) => ({ u_is_size_zoom_constant: new u.b_(b, t.u_is_size_zoom_constant), u_is_size_feature_constant: new u.b_(b, t.u_is_size_feature_constant), u_size_t: new u.bq(b, t.u_size_t), u_size: new u.bq(b, t.u_size), u_camera_to_center_distance: new u.bq(b, t.u_camera_to_center_distance), u_pitch: new u.bq(b, t.u_pitch), u_rotate_symbol: new u.b_(b, t.u_rotate_symbol), u_aspect_ratio: new u.bq(b, t.u_aspect_ratio), u_fade_change: new u.bq(b, t.u_fade_change), u_label_plane_matrix: new u.c0(b, t.u_label_plane_matrix), u_coord_matrix: new u.c0(b, t.u_coord_matrix), u_is_text: new u.b_(b, t.u_is_text), u_pitch_with_map: new u.b_(b, t.u_pitch_with_map), u_is_along_line: new u.b_(b, t.u_is_along_line), u_is_variable_anchor: new u.b_(b, t.u_is_variable_anchor), u_texsize: new u.c3(b, t.u_texsize), u_texsize_icon: new u.c3(b, t.u_texsize_icon), u_texture: new u.b_(b, t.u_texture), u_texture_icon: new u.b_(b, t.u_texture_icon), u_gamma_scale: new u.bq(b, t.u_gamma_scale), u_device_pixel_ratio: new u.bq(b, t.u_device_pixel_ratio), u_is_halo: new u.b_(b, t.u_is_halo), u_translation: new u.c3(b, t.u_translation), u_pitched_scale: new u.bq(b, t.u_pitched_scale) }), background: (b, t) => ({ u_opacity: new u.bq(b, t.u_opacity), u_color: new u.b$(b, t.u_color) }), backgroundPattern: (b, t) => ({ u_opacity: new u.bq(b, t.u_opacity), u_image: new u.b_(b, t.u_image), u_pattern_tl_a: new u.c3(b, t.u_pattern_tl_a), u_pattern_br_a: new u.c3(b, t.u_pattern_br_a), u_pattern_tl_b: new u.c3(b, t.u_pattern_tl_b), u_pattern_br_b: new u.c3(b, t.u_pattern_br_b), u_texsize: new u.c3(b, t.u_texsize), u_mix: new u.bq(b, t.u_mix), u_pattern_size_a: new u.c3(b, t.u_pattern_size_a), u_pattern_size_b: new u.c3(b, t.u_pattern_size_b), u_scale_a: new u.bq(b, t.u_scale_a), u_scale_b: new u.bq(b, t.u_scale_b), u_pixel_coord_upper: new u.c3(b, t.u_pixel_coord_upper), u_pixel_coord_lower: new u.c3(b, t.u_pixel_coord_lower), u_tile_units_to_pixels: new u.bq(b, t.u_tile_units_to_pixels) }), terrain: (b, t) => ({ u_texture: new u.b_(b, t.u_texture), u_ele_delta: new u.bq(b, t.u_ele_delta), u_fog_matrix: new u.c0(b, t.u_fog_matrix), u_fog_color: new u.b$(b, t.u_fog_color), u_fog_ground_blend: new u.bq(b, t.u_fog_ground_blend), u_fog_ground_blend_opacity: new u.bq(b, t.u_fog_ground_blend_opacity), u_horizon_color: new u.b$(b, t.u_horizon_color), u_horizon_fog_blend: new u.bq(b, t.u_horizon_fog_blend), u_is_globe_mode: new u.bq(b, t.u_is_globe_mode) }), terrainDepth: (b, t) => ({ u_ele_delta: new u.bq(b, t.u_ele_delta) }), terrainCoords: (b, t) => ({ u_texture: new u.b_(b, t.u_texture), u_terrain_coords_id: new u.bq(b, t.u_terrain_coords_id), u_ele_delta: new u.bq(b, t.u_ele_delta) }), projectionErrorMeasurement: (b, t) => ({ u_input: new u.bq(b, t.u_input), u_output_expected: new u.bq(b, t.u_output_expected) }), atmosphere: (b, t) => ({ u_sun_pos: new u.c2(b, t.u_sun_pos), u_atmosphere_blend: new u.bq(b, t.u_atmosphere_blend), u_globe_position: new u.c2(b, t.u_globe_position), u_globe_radius: new u.bq(b, t.u_globe_radius), u_inv_proj_matrix: new u.c0(b, t.u_inv_proj_matrix) }), sky: (b, t) => ({ u_sky_color: new u.b$(b, t.u_sky_color), u_horizon_color: new u.b$(b, t.u_horizon_color), u_horizon: new u.c3(b, t.u_horizon), u_horizon_normal: new u.c3(b, t.u_horizon_normal), u_sky_horizon_blend: new u.bq(b, t.u_sky_horizon_blend), u_sky_blend: new u.bq(b, t.u_sky_blend) }) };
        class B {
          constructor(t, s, d) {
            this.context = t;
            const g = t.gl;
            this.buffer = g.createBuffer(), this.dynamicDraw = !!d, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), g.bufferData(g.ELEMENT_ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t) {
            const s = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const H = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class se {
          constructor(t, s, d, g) {
            this.length = s.length, this.attributes = d, this.itemSize = s.bytesPerElement, this.dynamicDraw = g, this.context = t;
            const w = t.gl;
            this.buffer = w.createBuffer(), t.bindVertexBuffer.set(this.buffer), w.bufferData(w.ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? w.DYNAMIC_DRAW : w.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t) {
            if (t.length !== this.length) throw new Error(`Length of new data is ${t.length}, which doesn't match current length of ${this.length}`);
            const s = this.context.gl;
            this.bind(), s.bufferSubData(s.ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          enableAttributes(t, s) {
            for (let d = 0; d < this.attributes.length; d++) {
              const g = s.attributes[this.attributes[d].name];
              g !== void 0 && t.enableVertexAttribArray(g);
            }
          }
          setVertexAttribPointers(t, s, d) {
            for (let g = 0; g < this.attributes.length; g++) {
              const w = this.attributes[g], S = s.attributes[w.name];
              S !== void 0 && t.vertexAttribPointer(S, w.components, t[H[w.type]], !1, this.itemSize, w.offset + this.itemSize * (d || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class de {
          constructor(t) {
            this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(t) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class $e extends de {
          getDefault() {
            return u.bp.transparent;
          }
          set(t) {
            const s = this.current;
            (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
          }
        }
        class rt extends de {
          getDefault() {
            return 1;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
          }
        }
        class vt extends de {
          getDefault() {
            return 0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
          }
        }
        class Gt extends de {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class $t extends de {
          getDefault() {
            return !0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
          }
        }
        class Xt extends de {
          getDefault() {
            return 255;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
          }
        }
        class _r extends de {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t) {
            const s = this.current;
            (t.func !== s.func || t.ref !== s.ref || t.mask !== s.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
          }
        }
        class or extends de {
          getDefault() {
            const t = this.gl;
            return [t.KEEP, t.KEEP, t.KEEP];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
          }
        }
        class Gr extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            t ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST), this.current = t, this.dirty = !1;
          }
        }
        class qn extends de {
          getDefault() {
            return [0, 1];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
          }
        }
        class $n extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            t ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST), this.current = t, this.dirty = !1;
          }
        }
        class ji extends de {
          getDefault() {
            return this.gl.LESS;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
          }
        }
        class aa extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            t ? s.enable(s.BLEND) : s.disable(s.BLEND), this.current = t, this.dirty = !1;
          }
        }
        class Go extends de {
          getDefault() {
            const t = this.gl;
            return [t.ONE, t.ZERO];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);
          }
        }
        class so extends de {
          getDefault() {
            return u.bp.transparent;
          }
          set(t) {
            const s = this.current;
            (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
          }
        }
        class jo extends de {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);
          }
        }
        class Tu extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            t ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE), this.current = t, this.dirty = !1;
          }
        }
        class Pa extends de {
          getDefault() {
            return this.gl.BACK;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
          }
        }
        class Aa extends de {
          getDefault() {
            return this.gl.CCW;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
          }
        }
        class Cl extends de {
          getDefault() {
            return null;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);
          }
        }
        class Vo extends de {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
          }
        }
        class mr extends de {
          getDefault() {
            const t = this.gl;
            return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
          }
          set(t) {
            const s = this.current;
            (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class Rc extends de {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindFramebuffer(s.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class nm extends de {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindRenderbuffer(s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class Zf extends de {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindTexture(s.TEXTURE_2D, t), this.current = t, this.dirty = !1;
          }
        }
        class Su extends de {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.bindBuffer(s.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class im extends de {
          getDefault() {
            return null;
          }
          set(t) {
            const s = this.gl;
            s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class sm extends de {
          getDefault() {
            return null;
          }
          set(t) {
            var s;
            if (t === this.current && !this.dirty) return;
            const d = this.gl;
            Xn(d) ? d.bindVertexArray(t) : (s = d.getExtension("OES_vertex_array_object")) === null || s === void 0 || s.bindVertexArrayOES(t), this.current = t, this.dirty = !1;
          }
        }
        class Hf extends de {
          getDefault() {
            return 4;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
          }
        }
        class am extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
          }
        }
        class rd extends de {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const s = this.gl;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
          }
        }
        class Pl extends de {
          constructor(t, s) {
            super(t), this.context = t, this.parent = s;
          }
          getDefault() {
            return null;
          }
        }
        class ku extends Pl {
          setDirty() {
            this.dirty = !0;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
          }
        }
        class Fc extends Pl {
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class nd extends Pl {
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const s = this.gl;
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        const id = "Framebuffer is not complete";
        class Nc {
          constructor(t, s, d, g, w) {
            this.context = t, this.width = s, this.height = d;
            const S = t.gl, C = this.framebuffer = S.createFramebuffer();
            if (this.colorAttachment = new ku(t, C), g) this.depthAttachment = w ? new nd(t, C) : new Fc(t, C);
            else if (w) throw new Error("Stencil cannot be set without depth");
            if (S.checkFramebufferStatus(S.FRAMEBUFFER) !== S.FRAMEBUFFER_COMPLETE) throw new Error(id);
          }
          destroy() {
            const t = this.context.gl, s = this.colorAttachment.get();
            if (s && t.deleteTexture(s), this.depthAttachment) {
              const d = this.depthAttachment.get();
              d && t.deleteRenderbuffer(d);
            }
            t.deleteFramebuffer(this.framebuffer);
          }
        }
        class Oc {
          constructor(t) {
            var s, d;
            if (this.gl = t, this.clearColor = new $e(this), this.clearDepth = new rt(this), this.clearStencil = new vt(this), this.colorMask = new Gt(this), this.depthMask = new $t(this), this.stencilMask = new Xt(this), this.stencilFunc = new _r(this), this.stencilOp = new or(this), this.stencilTest = new Gr(this), this.depthRange = new qn(this), this.depthTest = new $n(this), this.depthFunc = new ji(this), this.blend = new aa(this), this.blendFunc = new Go(this), this.blendColor = new so(this), this.blendEquation = new jo(this), this.cullFace = new Tu(this), this.cullFaceSide = new Pa(this), this.frontFace = new Aa(this), this.program = new Cl(this), this.activeTexture = new Vo(this), this.viewport = new mr(this), this.bindFramebuffer = new Rc(this), this.bindRenderbuffer = new nm(this), this.bindTexture = new Zf(this), this.bindVertexBuffer = new Su(this), this.bindElementBuffer = new im(this), this.bindVertexArray = new sm(this), this.pixelStoreUnpack = new Hf(this), this.pixelStoreUnpackPremultiplyAlpha = new am(this), this.pixelStoreUnpackFlipY = new rd(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), Xn(t)) {
              this.HALF_FLOAT = t.HALF_FLOAT;
              const g = t.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (s = t.RGBA16F) !== null && s !== void 0 ? s : g?.RGBA16F_EXT, this.RGB16F = (d = t.RGB16F) !== null && d !== void 0 ? d : g?.RGB16F_EXT, t.getExtension("EXT_color_buffer_float");
            } else {
              t.getExtension("EXT_color_buffer_half_float"), t.getExtension("OES_texture_half_float_linear");
              const g = t.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = g?.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(t, s) {
            return new B(this, t, s);
          }
          createVertexBuffer(t, s, d) {
            return new se(this, t, s, d);
          }
          createRenderbuffer(t, s, d) {
            const g = this.gl, w = g.createRenderbuffer();
            return this.bindRenderbuffer.set(w), g.renderbufferStorage(g.RENDERBUFFER, t, s, d), this.bindRenderbuffer.set(null), w;
          }
          createFramebuffer(t, s, d, g) {
            return new Nc(this, t, s, d, g);
          }
          clear({ color: t, depth: s, stencil: d }) {
            const g = this.gl;
            let w = 0;
            t && (w |= g.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([!0, !0, !0, !0])), s !== void 0 && (w |= g.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(s), this.depthMask.set(!0)), d !== void 0 && (w |= g.STENCIL_BUFFER_BIT, this.clearStencil.set(d), this.stencilMask.set(255)), g.clear(w);
          }
          setCullFace(t) {
            t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
          }
          setDepthMode(t) {
            t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
          }
          setStencilMode(t) {
            t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(t) {
            u.bR(t.blendFunction, Dr.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);
          }
          createVertexArray() {
            var t;
            return Xn(this.gl) ? this.gl.createVertexArray() : (t = this.gl.getExtension("OES_vertex_array_object")) === null || t === void 0 ? void 0 : t.createVertexArrayOES();
          }
          deleteVertexArray(t) {
            var s;
            return Xn(this.gl) ? this.gl.deleteVertexArray(t) : (s = this.gl.getExtension("OES_vertex_array_object")) === null || s === void 0 ? void 0 : s.deleteVertexArrayOES(t);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let ao;
        function Uo(b, t, s, d, g) {
          const w = b.context, S = b.transform, C = w.gl, A = b.useProgram("collisionBox"), F = [];
          let O = 0, q = 0;
          for (let fe = 0; fe < d.length; fe++) {
            const we = d[fe], Le = t.getTile(we).getBucket(s);
            if (!Le) continue;
            const ve = g ? Le.textCollisionBox : Le.iconCollisionBox, Ce = Le.collisionCircleArray;
            Ce.length > 0 && (F.push({ circleArray: Ce, circleOffset: q, coord: we }), O += Ce.length / 4, q = O), ve && A.draw(w, C.LINES, nr.disabled, pr.disabled, b.colorModeForRenderPass(), sr.disabled, Ma(b.transform), b.style.map.terrain && b.style.map.terrain.getTerrainData(we), S.getProjectionData({ overscaledTileID: we, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), s.id, ve.layoutVertexBuffer, ve.indexBuffer, ve.segments, null, b.transform.zoom, null, null, ve.collisionVertexBuffer);
          }
          if (!g || !F.length) return;
          const V = b.useProgram("collisionCircle"), W = new u.ca();
          W.resize(4 * O), W._trim();
          let te = 0;
          for (const fe of F) for (let we = 0; we < fe.circleArray.length / 4; we++) {
            const Le = 4 * we, ve = fe.circleArray[Le + 0], Ce = fe.circleArray[Le + 1], Ne = fe.circleArray[Le + 2], ke = fe.circleArray[Le + 3];
            W.emplace(te++, ve, Ce, Ne, ke, 0), W.emplace(te++, ve, Ce, Ne, ke, 1), W.emplace(te++, ve, Ce, Ne, ke, 2), W.emplace(te++, ve, Ce, Ne, ke, 3);
          }
          (!ao || ao.length < 2 * O) && (ao = (function(fe) {
            const we = 2 * fe, Le = new u.cc();
            Le.resize(we), Le._trim();
            for (let ve = 0; ve < we; ve++) {
              const Ce = 6 * ve;
              Le.uint16[Ce + 0] = 4 * ve + 0, Le.uint16[Ce + 1] = 4 * ve + 1, Le.uint16[Ce + 2] = 4 * ve + 2, Le.uint16[Ce + 3] = 4 * ve + 2, Le.uint16[Ce + 4] = 4 * ve + 3, Le.uint16[Ce + 5] = 4 * ve + 0;
            }
            return Le;
          })(O));
          const he = w.createIndexBuffer(ao, !0), pe = w.createVertexBuffer(W, u.cb.members, !0);
          for (const fe of F) {
            const we = Ac(b.transform);
            V.draw(w, C.TRIANGLES, nr.disabled, pr.disabled, b.colorModeForRenderPass(), sr.disabled, we, b.style.map.terrain && b.style.map.terrain.getTerrainData(fe.coord), null, s.id, pe, he, u.aX.simpleSegment(0, 2 * fe.circleOffset, fe.circleArray.length, fe.circleArray.length / 2), null, b.transform.zoom, null, null, null);
          }
          pe.destroy(), he.destroy();
        }
        const sd = u.ar(new Float32Array(16));
        function om(b, t, s, d, g, w) {
          const { horizontalAlign: S, verticalAlign: C } = u.aS(b);
          return new u.P((-(S - 0.5) * t / g + d[0]) * w, (-(C - 0.5) * s / g + d[1]) * w);
        }
        function Iu(b, t, s, d, g, w) {
          const S = t.tileAnchorPoint.add(new u.P(t.translation[0], t.translation[1]));
          if (t.pitchWithMap) {
            let C = d.mult(w);
            s || (C = C.rotate(-g));
            const A = S.add(C);
            return Ee(A.x, A.y, t.pitchedLabelPlaneMatrix, t.getElevation).point;
          }
          if (s) {
            const C = Er(t.tileAnchorPoint.x + 1, t.tileAnchorPoint.y, t).point.sub(b), A = Math.atan(C.y / C.x) + (C.x < 0 ? Math.PI : 0);
            return b.add(d.rotate(A));
          }
          return b.add(d);
        }
        function lm(b, t, s, d, g, w, S, C, A, F, O, q) {
          const V = b.text.placedSymbolArray, W = b.text.dynamicLayoutVertexArray, te = b.icon.dynamicLayoutVertexArray, he = {};
          W.clear();
          for (let pe = 0; pe < V.length; pe++) {
            const fe = V.get(pe), we = fe.hidden || !fe.crossTileID || b.allowVerticalPlacement && !fe.placedOrientation ? null : d[fe.crossTileID];
            if (we) {
              const Le = new u.P(fe.anchorX, fe.anchorY), ve = { getElevation: q, width: g.width, height: g.height, pitchedLabelPlaneMatrix: w, pitchWithMap: s, transform: g, tileAnchorPoint: Le, translation: F, unwrappedTileID: O }, Ce = s ? Nn(Le.x, Le.y, ve) : Er(Le.x, Le.y, ve), Ne = zt(g.cameraToCenterDistance, Ce.signedDistanceFromCamera);
              let ke = u.aA(b.textSizeData, C, fe) * Ne / u.aM;
              s && (ke *= b.tilePixelRatio / S);
              const { width: Ge, height: at, anchor: tt, textOffset: nt, textBoxScale: it } = we, Et = om(tt, Ge, at, nt, it, ke), kt = g.getPitchedTextCorrection(Le.x + F[0], Le.y + F[1], O), gt = Iu(Ce.point, ve, t, Et, -g.bearingInRadians, kt), At = b.allowVerticalPlacement && fe.placedOrientation === u.az.vertical ? Math.PI / 2 : 0;
              for (let ar = 0; ar < fe.numGlyphs; ar++) u.aG(W, gt, At);
              A && fe.associatedIconIndex >= 0 && (he[fe.associatedIconIndex] = { shiftedAnchor: gt, angle: At });
            } else ba(fe.numGlyphs, W);
          }
          if (A) {
            te.clear();
            const pe = b.icon.placedSymbolArray;
            for (let fe = 0; fe < pe.length; fe++) {
              const we = pe.get(fe);
              if (we.hidden) ba(we.numGlyphs, te);
              else {
                const Le = he[fe];
                if (Le) for (let ve = 0; ve < we.numGlyphs; ve++) u.aG(te, Le.shiftedAnchor, Le.angle);
                else ba(we.numGlyphs, te);
              }
            }
            b.icon.dynamicLayoutVertexBuffer.updateData(te);
          }
          b.text.dynamicLayoutVertexBuffer.updateData(W);
        }
        function Yf(b, t, s) {
          return s.iconsInText && t ? "symbolTextAndIcon" : b ? "symbolSDF" : "symbolIcon";
        }
        function Mu(b, t, s, d, g, w, S, C, A, F, O, q, V) {
          const W = b.context, te = W.gl, he = b.transform, pe = C === "map", fe = A === "map", we = C !== "viewport" && s.layout.get("symbol-placement") !== "point", Le = pe && !fe && !we, ve = !s.layout.get("symbol-sort-key").isConstant();
          let Ce = !1;
          const Ne = b.getDepthModeForSublayer(0, nr.ReadOnly), ke = s._unevaluatedLayout.hasValue("text-variable-anchor") || s._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Ge = [], at = he.getCircleRadiusCorrection();
          for (const tt of d) {
            const nt = t.getTile(tt), it = nt.getBucket(s);
            if (!it) continue;
            const Et = g ? it.text : it.icon;
            if (!Et || !Et.segments.get().length || !Et.hasVisibleVertices) continue;
            const kt = Et.programConfigurations.get(s.id), gt = g || it.sdfIcons, At = g ? it.textSizeData : it.iconSizeData, ar = fe || he.pitch !== 0, zr = b.useProgram(Yf(gt, g, it), kt), sn = u.ay(At, he.zoom), qr = b.style.map.terrain && b.style.map.terrain.getTerrainData(tt);
            let ln, $r, En, un, ui = [0, 0], On = null;
            if (g) $r = nt.glyphAtlasTexture, En = te.LINEAR, ln = nt.glyphAtlasTexture.size, it.iconsInText && (ui = nt.imageAtlasTexture.size, On = nt.imageAtlasTexture, un = ar || b.options.rotating || b.options.zooming || At.kind === "composite" || At.kind === "camera" ? te.LINEAR : te.NEAREST);
            else {
              const Xr = s.layout.get("icon-size").constantOr(0) !== 1 || it.iconsNeedLinear;
              $r = nt.imageAtlasTexture, En = gt || b.options.rotating || b.options.zooming || Xr || ar ? te.LINEAR : te.NEAREST, ln = nt.imageAtlasTexture.size;
            }
            const Ln = u.aN(nt, 1, b.transform.zoom), Ei = pn(pe, b.transform, Ln), ho = u.N();
            u.aB(ho, Ei);
            const Da = zi(fe, pe, b.transform, Ln), oa = u.aO(he, nt, w, S), Ji = he.getProjectionData({ overscaledTileID: tt, applyGlobeMatrix: !V, applyTerrainMatrix: !0 }), Wo = ke && it.hasTextData(), Yu = s.layout.get("icon-text-fit") !== "none" && Wo && it.hasIconData();
            if (we) {
              const Xr = b.style.map.terrain ? (Kn, Qn) => b.style.map.terrain.getElevation(tt, Kn, Qn) : null, Zr = s.layout.get("text-rotation-alignment") === "map";
              Tr(it, b, g, Ei, ho, fe, F, Zr, tt.toUnwrapped(), he.width, he.height, oa, Xr);
            }
            const Xo = g && ke || Yu, Ts = we || Xo ? sd : fe ? Ei : b.transform.clipSpaceToPixelsMatrix, la = gt && s.paint.get(g ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let js;
            js = gt ? it.iconsInText ? o(At.kind, sn, Le, fe, we, Xo, b, Ts, Da, oa, ln, ui, at) : y(At.kind, sn, Le, fe, we, Xo, b, Ts, Da, oa, g, ln, 0, at) : Xi(At.kind, sn, Le, fe, we, Xo, b, Ts, Da, oa, g, ln, at);
            const Vs = { program: zr, buffers: Et, uniformValues: js, projectionData: Ji, atlasTexture: $r, atlasTextureIcon: On, atlasInterpolation: En, atlasInterpolationIcon: un, isSDF: gt, hasHalo: la };
            if (ve && it.canOverlap) {
              Ce = !0;
              const Xr = Et.segments.get();
              for (const Zr of Xr) Ge.push({ segments: new u.aX([Zr]), sortKey: Zr.sortKey, state: Vs, terrainData: qr });
            } else Ge.push({ segments: Et.segments, sortKey: 0, state: Vs, terrainData: qr });
          }
          Ce && Ge.sort(((tt, nt) => tt.sortKey - nt.sortKey));
          for (const tt of Ge) {
            const nt = tt.state;
            if (W.activeTexture.set(te.TEXTURE0), nt.atlasTexture.bind(nt.atlasInterpolation, te.CLAMP_TO_EDGE), nt.atlasTextureIcon && (W.activeTexture.set(te.TEXTURE1), nt.atlasTextureIcon && nt.atlasTextureIcon.bind(nt.atlasInterpolationIcon, te.CLAMP_TO_EDGE)), nt.isSDF) {
              const it = nt.uniformValues;
              nt.hasHalo && (it.u_is_halo = 1, zc(nt.buffers, tt.segments, s, b, nt.program, Ne, O, q, it, nt.projectionData, tt.terrainData)), it.u_is_halo = 0;
            }
            zc(nt.buffers, tt.segments, s, b, nt.program, Ne, O, q, nt.uniformValues, nt.projectionData, tt.terrainData);
          }
        }
        function zc(b, t, s, d, g, w, S, C, A, F, O) {
          const q = d.context;
          g.draw(q, q.gl.TRIANGLES, w, S, C, sr.backCCW, A, O, F, s.id, b.layoutVertexBuffer, b.indexBuffer, t, s.paint, d.transform.zoom, b.programConfigurations.get(s.id), b.dynamicLayoutVertexBuffer, b.opacityVertexBuffer);
        }
        function Wf(b, t, s, d, g) {
          const w = b.context, S = w.gl, C = pr.disabled, A = new Dr([S.ONE, S.ONE], u.bp.transparent, [!0, !0, !0, !0]), F = t.getBucket(s);
          if (!F) return;
          const O = d.key;
          let q = s.heatmapFbos.get(O);
          q || (q = Cu(w, t.tileSize, t.tileSize), s.heatmapFbos.set(O, q)), w.bindFramebuffer.set(q.framebuffer), w.viewport.set([0, 0, t.tileSize, t.tileSize]), w.clear({ color: u.bp.transparent });
          const V = F.programConfigurations.get(s.id), W = b.useProgram("heatmap", V, !g), te = b.transform.getProjectionData({ overscaledTileID: t.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), he = b.style.map.terrain.getTerrainData(d);
          W.draw(w, S.TRIANGLES, nr.disabled, C, A, sr.disabled, Ca(t, b.transform.zoom, s.paint.get("heatmap-intensity"), 1), he, te, s.id, F.layoutVertexBuffer, F.indexBuffer, F.segments, s.paint, b.transform.zoom, V);
        }
        function Xf(b, t, s, d, g) {
          const w = b.context, S = w.gl, C = b.transform;
          w.setColorMode(b.colorModeForRenderPass());
          const A = Bc(w, t), F = s.key, O = t.heatmapFbos.get(F);
          if (!O) return;
          w.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, O.colorAttachment.get()), w.activeTexture.set(S.TEXTURE1), A.bind(S.LINEAR, S.CLAMP_TO_EDGE);
          const q = C.getProjectionData({ overscaledTileID: s, applyTerrainMatrix: g, applyGlobeMatrix: !d });
          b.useProgram("heatmapTexture").draw(w, S.TRIANGLES, nr.disabled, pr.disabled, b.colorModeForRenderPass(), sr.disabled, wu(b, t, 0, 1), null, q, t.id, b.rasterBoundsBuffer, b.quadTriangleIndexBuffer, b.rasterBoundsSegments, t.paint, C.zoom), O.destroy(), t.heatmapFbos.delete(F);
        }
        function Cu(b, t, s) {
          var d, g;
          const w = b.gl, S = w.createTexture();
          w.bindTexture(w.TEXTURE_2D, S), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_S, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_T, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, w.LINEAR), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, w.LINEAR);
          const C = (d = b.HALF_FLOAT) !== null && d !== void 0 ? d : w.UNSIGNED_BYTE, A = (g = b.RGBA16F) !== null && g !== void 0 ? g : w.RGBA;
          w.texImage2D(w.TEXTURE_2D, 0, A, t, s, 0, w.RGBA, C, null);
          const F = b.createFramebuffer(t, s, !1, !1);
          return F.colorAttachment.set(S), F;
        }
        function Bc(b, t) {
          return t.colorRampTexture || (t.colorRampTexture = new u.T(b, t.colorRamp, b.gl.RGBA)), t.colorRampTexture;
        }
        function Jf(b, t, s, d, g, w, S, C) {
          let A = 256;
          if (g.stepInterpolant) {
            const F = t.getSource().maxzoom, O = S.canonical.z === F ? Math.ceil(1 << b.transform.maxZoom - S.canonical.z) : 1;
            A = u.an(u.ce(w.maxLineLength / u.a5 * 1024 * O), 256, s.maxTextureSize);
          }
          return C.gradient = u.cf({ expression: g.gradientExpression(), evaluationKey: "lineProgress", resolution: A, image: C.gradient || void 0, clips: w.lineClipsArray }), C.texture ? C.texture.update(C.gradient) : C.texture = new u.T(s, C.gradient, d.RGBA), C.version = g.gradientVersion, C.texture;
        }
        function Kf(b, t, s, d, g) {
          b.activeTexture.set(t.TEXTURE0), s.imageAtlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE), d.updatePaintBuffers(g);
        }
        function Pn(b, t, s, d, g, w) {
          (g || b.lineAtlas.dirty) && (t.activeTexture.set(s.TEXTURE0), b.lineAtlas.bind(t)), d.updatePaintBuffers(w);
        }
        function qo(b, t, s, d, g, w, S) {
          const C = w.gradients[g.id];
          let A = C.texture;
          g.gradientVersion !== C.version && (A = Jf(b, t, s, d, g, w, S, C)), s.activeTexture.set(d.TEXTURE0), A.bind(g.stepInterpolant ? d.NEAREST : d.LINEAR, d.CLAMP_TO_EDGE);
        }
        function as(b, t, s, d, g, w, S, C, A) {
          const F = w.gradients[g.id];
          let O = F.texture;
          g.gradientVersion !== F.version && (O = Jf(b, t, s, d, g, w, S, F)), s.activeTexture.set(d.TEXTURE0), O.bind(g.stepInterpolant ? d.NEAREST : d.LINEAR, d.CLAMP_TO_EDGE), s.activeTexture.set(d.TEXTURE1), b.lineAtlas.bind(s), C.updatePaintBuffers(A);
        }
        function Gc(b, t, s, d, g) {
          if (!s || !d || !d.imageAtlas) return;
          const w = d.imageAtlas.patternPositions;
          let S = w[s.to.toString()], C = w[s.from.toString()];
          if (!S && C && (S = C), !C && S && (C = S), !S || !C) {
            const A = g.getPaintProperty(t);
            S = w[A], C = w[A];
          }
          S && C && b.setConstantPatternPositions(S, C);
        }
        function Pu(b, t, s, d, g, w, S, C) {
          const A = b.context.gl, F = "fill-pattern", O = s.paint.get(F), q = O && O.constantOr(1), V = s.getCrossfadeParameters();
          let W, te, he, pe, fe;
          const we = b.transform, Le = s.paint.get("fill-translate"), ve = s.paint.get("fill-translate-anchor");
          S ? (te = q && !s.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", W = A.LINES) : (te = q ? "fillPattern" : "fill", W = A.TRIANGLES);
          const Ce = O.constantOr(null);
          for (const Ne of d) {
            const ke = t.getTile(Ne);
            if (q && !ke.patternsLoaded()) continue;
            const Ge = ke.getBucket(s);
            if (!Ge) continue;
            const at = Ge.programConfigurations.get(s.id), tt = b.useProgram(te, at), nt = b.style.map.terrain && b.style.map.terrain.getTerrainData(Ne);
            q && (b.context.activeTexture.set(A.TEXTURE0), ke.imageAtlasTexture.bind(A.LINEAR, A.CLAMP_TO_EDGE), at.updatePaintBuffers(V)), Gc(at, F, Ce, ke, s);
            const it = we.getProjectionData({ overscaledTileID: Ne, applyGlobeMatrix: !C, applyTerrainMatrix: !0 }), Et = u.aO(we, ke, Le, ve);
            if (S) {
              pe = Ge.indexBuffer2, fe = Ge.segments2;
              const gt = [A.drawingBufferWidth, A.drawingBufferHeight];
              he = te === "fillOutlinePattern" && q ? Cc(b, V, ke, gt, Et) : Mc(gt, Et);
            } else pe = Ge.indexBuffer, fe = Ge.segments, he = q ? xu(b, V, ke, Et) : { u_fill_translate: Et };
            const kt = b.stencilModeForClipping(Ne);
            tt.draw(b.context, W, g, kt, w, sr.backCCW, he, nt, it, s.id, Ge.layoutVertexBuffer, pe, fe, s.paint, b.transform.zoom, at);
          }
        }
        function jc(b, t, s, d, g, w, S, C) {
          const A = b.context, F = A.gl, O = "fill-extrusion-pattern", q = s.paint.get(O), V = q.constantOr(1), W = s.getCrossfadeParameters(), te = s.paint.get("fill-extrusion-opacity"), he = q.constantOr(null), pe = b.transform;
          for (const fe of d) {
            const we = t.getTile(fe), Le = we.getBucket(s);
            if (!Le) continue;
            const ve = b.style.map.terrain && b.style.map.terrain.getTerrainData(fe), Ce = Le.programConfigurations.get(s.id), Ne = b.useProgram(V ? "fillExtrusionPattern" : "fillExtrusion", Ce);
            V && (b.context.activeTexture.set(F.TEXTURE0), we.imageAtlasTexture.bind(F.LINEAR, F.CLAMP_TO_EDGE), Ce.updatePaintBuffers(W));
            const ke = pe.getProjectionData({ overscaledTileID: fe, applyGlobeMatrix: !C, applyTerrainMatrix: !0 });
            Gc(Ce, O, he, we, s);
            const Ge = u.aO(pe, we, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), at = s.paint.get("fill-extrusion-vertical-gradient"), tt = V ? El(b, at, te, Ge, fe, W, we) : vu(b, at, te, Ge);
            Ne.draw(A, A.gl.TRIANGLES, g, w, S, sr.backCCW, tt, ve, ke, s.id, Le.layoutVertexBuffer, Le.indexBuffer, Le.segments, s.paint, b.transform.zoom, Ce, b.style.map.terrain && Le.centroidVertexBuffer);
          }
        }
        function oo(b, t, s, d, g, w, S, C, A) {
          var F;
          const O = b.style.projection, q = b.context, V = b.transform, W = q.gl, te = [`#define NUM_ILLUMINATION_SOURCES ${s.paint.get("hillshade-highlight-color").values.length}`], he = b.useProgram("hillshade", null, !1, te), pe = !b.options.moving;
          for (const fe of d) {
            const we = t.getTile(fe), Le = we.fbo;
            if (!Le) continue;
            const ve = O.getMeshFromTileID(q, fe.canonical, C, !0, "raster"), Ce = (F = b.style.map.terrain) === null || F === void 0 ? void 0 : F.getTerrainData(fe);
            q.activeTexture.set(W.TEXTURE0), W.bindTexture(W.TEXTURE_2D, Le.colorAttachment.get());
            const Ne = V.getProjectionData({ overscaledTileID: fe, aligned: pe, applyGlobeMatrix: !A, applyTerrainMatrix: !0 });
            he.draw(q, W.TRIANGLES, w, g[fe.overscaledZ], S, sr.backCCW, zo(b, we, s), Ce, Ne, s.id, ve.vertexBuffer, ve.indexBuffer, ve.segments);
          }
        }
        function Au(b, t, s, d, g, w, S, C, A) {
          var F;
          const O = b.style.projection, q = b.context, V = b.transform, W = q.gl, te = b.useProgram("colorRelief"), he = !b.options.moving;
          let pe = !0, fe = 0;
          for (const we of d) {
            const Le = t.getTile(we), ve = Le.dem;
            if (pe) {
              const tt = W.getParameter(W.MAX_TEXTURE_SIZE), { elevationTexture: nt, colorTexture: it } = s.getColorRampTextures(q, tt, ve.getUnpackVector());
              q.activeTexture.set(W.TEXTURE1), nt.bind(W.NEAREST, W.CLAMP_TO_EDGE), q.activeTexture.set(W.TEXTURE4), it.bind(W.LINEAR, W.CLAMP_TO_EDGE), pe = !1, fe = nt.size[0];
            }
            if (!ve || !ve.data) continue;
            const Ce = ve.stride, Ne = ve.getPixels();
            if (q.activeTexture.set(W.TEXTURE0), q.pixelStoreUnpackPremultiplyAlpha.set(!1), Le.demTexture = Le.demTexture || b.getTileTexture(Ce), Le.demTexture) {
              const tt = Le.demTexture;
              tt.update(Ne, { premultiply: !1 }), tt.bind(W.LINEAR, W.CLAMP_TO_EDGE);
            } else Le.demTexture = new u.T(q, Ne, W.RGBA, { premultiply: !1 }), Le.demTexture.bind(W.LINEAR, W.CLAMP_TO_EDGE);
            const ke = O.getMeshFromTileID(q, we.canonical, C, !0, "raster"), Ge = (F = b.style.map.terrain) === null || F === void 0 ? void 0 : F.getTerrainData(we), at = V.getProjectionData({ overscaledTileID: we, aligned: he, applyGlobeMatrix: !A, applyTerrainMatrix: !0 });
            te.draw(q, W.TRIANGLES, w, g[we.overscaledZ], S, sr.backCCW, Tl(s, Le.dem, fe), Ge, at, s.id, ke.vertexBuffer, ke.indexBuffer, ke.segments);
          }
        }
        const $o = [new u.P(0, 0), new u.P(u.a5, 0), new u.P(u.a5, u.a5), new u.P(0, u.a5)];
        function Al(b, t, s, d, g, w, S, C, A = !1, F = !1) {
          const O = d[d.length - 1].overscaledZ, q = b.context, V = q.gl, W = b.useProgram("raster"), te = b.transform, he = b.style.projection, pe = b.colorModeForRenderPass(), fe = !b.options.moving, we = s.paint.get("raster-opacity"), Le = s.paint.get("raster-resampling"), ve = s.paint.get("raster-fade-duration"), Ce = !!b.style.map.terrain;
          for (const Ne of d) {
            const ke = b.getDepthModeForSublayer(Ne.overscaledZ - O, we === 1 ? nr.ReadWrite : nr.ReadOnly, V.LESS), Ge = t.getTile(Ne), at = Le === "nearest" ? V.NEAREST : V.LINEAR;
            q.activeTexture.set(V.TEXTURE0), Ge.texture.bind(at, V.CLAMP_TO_EDGE, V.LINEAR_MIPMAP_NEAREST), q.activeTexture.set(V.TEXTURE1);
            const { parentTile: tt, parentScaleBy: nt, parentTopLeft: it, fadeValues: Et } = Qf(Ge, t, ve, Ce);
            Ge.fadeOpacity = Et.tileOpacity, tt ? (tt.fadeOpacity = Et.parentTileOpacity, tt.texture.bind(at, V.CLAMP_TO_EDGE, V.LINEAR_MIPMAP_NEAREST)) : Ge.texture.bind(at, V.CLAMP_TO_EDGE, V.LINEAR_MIPMAP_NEAREST), Ge.texture.useMipmap && q.extTextureFilterAnisotropic && b.transform.pitch > 20 && V.texParameterf(V.TEXTURE_2D, q.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, q.extTextureFilterAnisotropicMax);
            const kt = b.style.map.terrain && b.style.map.terrain.getTerrainData(Ne), gt = te.getProjectionData({ overscaledTileID: Ne, aligned: fe, applyGlobeMatrix: !F, applyTerrainMatrix: !0 }), At = Ml(it, nt, Et.fadeMix, s, C), ar = he.getMeshFromTileID(q, Ne.canonical, w, S, "raster");
            W.draw(q, V.TRIANGLES, ke, g ? g[Ne.overscaledZ] : pr.disabled, pe, A ? sr.frontCCW : sr.backCCW, At, kt, gt, s.id, ar.vertexBuffer, ar.indexBuffer, ar.segments);
          }
        }
        function Qf(b, t, s, d) {
          const g = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
          if (s === 0 || d) return g;
          if (b.fadingParentID) {
            const w = t.getLoadedTile(b.fadingParentID);
            if (!w) return g;
            const S = Math.pow(2, w.tileID.overscaledZ - b.tileID.overscaledZ), C = [b.tileID.canonical.x * S % 1, b.tileID.canonical.y * S % 1], A = (function(F, O, q) {
              const V = me(), W = (V - O.timeAdded) / q, te = F.fadingDirection === ze.Incoming, he = u.an((V - F.timeAdded) / q, 0, 1), pe = u.an(1 - W, 0, 1), fe = te ? he : pe;
              return { tileOpacity: fe, parentTileOpacity: te ? pe : he, fadeMix: { opacity: 1, mix: 1 - fe } };
            })(b, w, s);
            return { parentTile: w, parentScaleBy: S, parentTopLeft: C, fadeValues: A };
          }
          if (b.selfFading) {
            const w = (function(S, C) {
              const A = (me() - S.timeAdded) / C, F = u.an(A, 0, 1);
              return { tileOpacity: F, fadeMix: { opacity: F, mix: 0 } };
            })(b, s);
            return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: w };
          }
          return g;
        }
        const ep = new u.bp(1, 0, 0, 1), tp = new u.bp(0, 1, 0, 1), rp = new u.bp(0, 0, 1, 1), np = new u.bp(1, 0, 1, 1), lo = new u.bp(0, 1, 1, 1);
        function ad(b, t, s, d) {
          Lu(b, 0, t + s / 2, b.transform.width, s, d);
        }
        function od(b, t, s, d) {
          Lu(b, t - s / 2, 0, s, b.transform.height, d);
        }
        function Lu(b, t, s, d, g, w) {
          const S = b.context, C = S.gl;
          C.enable(C.SCISSOR_TEST), C.scissor(t * b.pixelRatio, s * b.pixelRatio, d * b.pixelRatio, g * b.pixelRatio), S.clear({ color: w }), C.disable(C.SCISSOR_TEST);
        }
        function ip(b, t, s) {
          const d = b.context, g = d.gl, w = b.useProgram("debug"), S = nr.disabled, C = pr.disabled, A = b.colorModeForRenderPass(), F = "$debug", O = b.style.map.terrain && b.style.map.terrain.getTerrainData(s);
          d.activeTexture.set(g.TEXTURE0);
          const q = t.getTileByID(s.key).latestRawTileData, V = Math.floor((q && q.byteLength || 0) / 1024), W = t.getTile(s).tileSize, te = 512 / Math.min(W, 512) * (s.overscaledZ / b.transform.zoom) * 0.5;
          let he = s.canonical.toString();
          s.overscaledZ !== s.canonical.z && (he += ` => ${s.overscaledZ}`), (function(fe, we) {
            fe.initDebugOverlayCanvas();
            const Le = fe.debugOverlayCanvas, ve = fe.context.gl, Ce = fe.debugOverlayCanvas.getContext("2d");
            Ce.clearRect(0, 0, Le.width, Le.height), Ce.shadowColor = "white", Ce.shadowBlur = 2, Ce.lineWidth = 1.5, Ce.strokeStyle = "white", Ce.textBaseline = "top", Ce.font = "bold 36px Open Sans, sans-serif", Ce.fillText(we, 5, 5), Ce.strokeText(we, 5, 5), fe.debugOverlayTexture.update(Le), fe.debugOverlayTexture.bind(ve.LINEAR, ve.CLAMP_TO_EDGE);
          })(b, `${he} ${V}kB`);
          const pe = b.transform.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          w.draw(d, g.TRIANGLES, S, C, Dr.alphaBlended, sr.disabled, bu(u.bp.transparent, te), null, pe, F, b.debugBuffer, b.quadTriangleIndexBuffer, b.debugSegments), w.draw(d, g.LINE_STRIP, S, C, A, sr.disabled, bu(u.bp.red), O, pe, F, b.debugBuffer, b.tileBorderIndexBuffer, b.debugSegments);
        }
        function ld(b, t, s, d) {
          const { isRenderingGlobe: g } = d, w = b.context, S = w.gl, C = b.transform, A = b.colorModeForRenderPass(), F = b.getDepthModeFor3D(), O = b.useProgram("terrain");
          w.bindFramebuffer.set(null), w.viewport.set([0, 0, b.width, b.height]);
          for (const q of s) {
            const V = t.getTerrainMesh(q.tileID), W = b.renderToTexture.getTexture(q), te = t.getTerrainData(q.tileID);
            w.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, W.texture);
            const he = t.getMeshFrameDelta(C.zoom), pe = C.calculateFogMatrix(q.tileID.toUnwrapped()), fe = ed(he, pe, b.style.sky, C.pitch, g), we = C.getProjectionData({ overscaledTileID: q.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            O.draw(w, S.TRIANGLES, F, pr.disabled, A, sr.backCCW, fe, te, we, "terrain", V.vertexBuffer, V.indexBuffer, V.segments);
          }
        }
        function ud(b, t) {
          if (!t.mesh) {
            const s = new u.aW();
            s.emplaceBack(-1, -1), s.emplaceBack(1, -1), s.emplaceBack(1, 1), s.emplaceBack(-1, 1);
            const d = new u.aY();
            d.emplaceBack(0, 1, 2), d.emplaceBack(0, 2, 3), t.mesh = new Lr(b.createVertexBuffer(s, ta.members), b.createIndexBuffer(d), u.aX.simpleSegment(0, 0, s.length, d.length));
          }
          return t.mesh;
        }
        class sp {
          constructor(t, s) {
            this.context = new Oc(t), this.transform = s, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: u.ar(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = yi.maxOverzooming + yi.maxUnderzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Wn();
          }
          resize(t, s, d) {
            if (this.width = Math.floor(t * d), this.height = Math.floor(s * d), this.pixelRatio = d, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const g of this.style._order) this.style._layers[g].resize();
          }
          setup() {
            const t = this.context, s = new u.aW();
            s.emplaceBack(0, 0), s.emplaceBack(u.a5, 0), s.emplaceBack(0, u.a5), s.emplaceBack(u.a5, u.a5), this.tileExtentBuffer = t.createVertexBuffer(s, ta.members), this.tileExtentSegments = u.aX.simpleSegment(0, 0, 4, 2);
            const d = new u.aW();
            d.emplaceBack(0, 0), d.emplaceBack(u.a5, 0), d.emplaceBack(0, u.a5), d.emplaceBack(u.a5, u.a5), this.debugBuffer = t.createVertexBuffer(d, ta.members), this.debugSegments = u.aX.simpleSegment(0, 0, 4, 5);
            const g = new u.ch();
            g.emplaceBack(0, 0, 0, 0), g.emplaceBack(u.a5, 0, u.a5, 0), g.emplaceBack(0, u.a5, 0, u.a5), g.emplaceBack(u.a5, u.a5, u.a5, u.a5), this.rasterBoundsBuffer = t.createVertexBuffer(g, Qh.members), this.rasterBoundsSegments = u.aX.simpleSegment(0, 0, 4, 2);
            const w = new u.aW();
            w.emplaceBack(0, 0), w.emplaceBack(u.a5, 0), w.emplaceBack(0, u.a5), w.emplaceBack(u.a5, u.a5), this.rasterBoundsBufferPosOnly = t.createVertexBuffer(w, ta.members), this.rasterBoundsSegmentsPosOnly = u.aX.simpleSegment(0, 0, 4, 5);
            const S = new u.aW();
            S.emplaceBack(0, 0), S.emplaceBack(1, 0), S.emplaceBack(0, 1), S.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(S, ta.members), this.viewportSegments = u.aX.simpleSegment(0, 0, 4, 2);
            const C = new u.ci();
            C.emplaceBack(0), C.emplaceBack(1), C.emplaceBack(3), C.emplaceBack(2), C.emplaceBack(0), this.tileBorderIndexBuffer = t.createIndexBuffer(C);
            const A = new u.aY();
            A.emplaceBack(1, 0, 2), A.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(A);
            const F = this.context.gl;
            this.stencilClearMode = new pr({ func: F.ALWAYS, mask: 0 }, 0, 255, F.ZERO, F.ZERO, F.ZERO), this.tileExtentMesh = new Lr(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const t = this.context, s = t.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const d = u.N();
            u.c7(d, 0, this.width, this.height, 0, 0, 1), u.Q(d, d, [s.drawingBufferWidth, s.drawingBufferHeight, 0]);
            const g = { mainMatrix: d, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: d };
            this.useProgram("clippingMask", null, !0).draw(t, s.TRIANGLES, nr.disabled, this.stencilClearMode, Dr.disabled, sr.disabled, null, null, g, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t, s, d) {
            if (this.currentStencilSource === t.source || !t.isTileClipped() || !s || !s.length) return;
            this.currentStencilSource = t.source, this.nextStencilID + s.length > 256 && this.clearStencil();
            const g = this.context;
            g.setColorMode(Dr.disabled), g.setDepthMode(nr.disabled);
            const w = {};
            for (const S of s) w[S.key] = this.nextStencilID++;
            this._renderTileMasks(w, s, d, !0), this._renderTileMasks(w, s, d, !1), this._tileClippingMaskIDs = w;
          }
          _renderTileMasks(t, s, d, g) {
            const w = this.context, S = w.gl, C = this.style.projection, A = this.transform, F = this.useProgram("clippingMask");
            for (const O of s) {
              const q = t[O.key], V = this.style.map.terrain && this.style.map.terrain.getTerrainData(O), W = C.getMeshFromTileID(this.context, O.canonical, g, !0, "stencil"), te = A.getProjectionData({ overscaledTileID: O, applyGlobeMatrix: !d, applyTerrainMatrix: !0 });
              F.draw(w, S.TRIANGLES, nr.disabled, new pr({ func: S.ALWAYS, mask: 0 }, q, 255, S.KEEP, S.KEEP, S.REPLACE), Dr.disabled, d ? sr.disabled : sr.backCCW, null, V, te, "$clipping", W.vertexBuffer, W.indexBuffer, W.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const t = this.context, s = t.gl, d = this.style.projection, g = this.transform, w = this.useProgram("depth"), S = this.getDepthModeFor3D(), C = Pr(g, { tileSize: g.tileSize });
            for (const A of C) {
              const F = this.style.map.terrain && this.style.map.terrain.getTerrainData(A), O = d.getMeshFromTileID(this.context, A.canonical, !0, !0, "raster"), q = g.getProjectionData({ overscaledTileID: A, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              w.draw(t, s.TRIANGLES, S, pr.disabled, Dr.disabled, sr.backCCW, null, F, q, "$clipping", O.vertexBuffer, O.indexBuffer, O.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t = this.nextStencilID++, s = this.context.gl;
            return new pr({ func: s.NOTEQUAL, mask: 255 }, t, 255, s.KEEP, s.KEEP, s.REPLACE);
          }
          stencilModeForClipping(t) {
            const s = this.context.gl;
            return new pr({ func: s.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, s.KEEP, s.KEEP, s.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(t) {
            const s = this.context.gl, d = t.sort(((S, C) => C.overscaledZ - S.overscaledZ)), g = d[d.length - 1].overscaledZ, w = d[0].overscaledZ - g + 1;
            if (w > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
              const S = {};
              for (let C = 0; C < w; C++) S[C + g] = new pr({ func: s.GEQUAL, mask: 255 }, C + this.nextStencilID, 255, s.KEEP, s.KEEP, s.REPLACE);
              return this.nextStencilID += w, [S, d];
            }
            return [{ [g]: pr.disabled }, d];
          }
          stencilConfigForOverlapTwoPass(t) {
            const s = this.context.gl, d = t.sort(((S, C) => C.overscaledZ - S.overscaledZ)), g = d[d.length - 1].overscaledZ, w = d[0].overscaledZ - g + 1;
            if (this.clearStencil(), w > 1) {
              const S = {}, C = {};
              for (let A = 0; A < w; A++) S[A + g] = new pr({ func: s.GREATER, mask: 255 }, w + 1 + A, 255, s.KEEP, s.KEEP, s.REPLACE), C[A + g] = new pr({ func: s.GREATER, mask: 255 }, 1 + A, 255, s.KEEP, s.KEEP, s.REPLACE);
              return this.nextStencilID = 2 * w + 1, [S, C, d];
            }
            return this.nextStencilID = 3, [{ [g]: new pr({ func: s.GREATER, mask: 255 }, 2, 255, s.KEEP, s.KEEP, s.REPLACE) }, { [g]: new pr({ func: s.GREATER, mask: 255 }, 1, 255, s.KEEP, s.KEEP, s.REPLACE) }, d];
          }
          colorModeForRenderPass() {
            const t = this.context.gl;
            return this._showOverdrawInspector ? new Dr([t.CONSTANT_COLOR, t.ONE], new u.bp(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Dr.unblended : Dr.alphaBlended;
          }
          getDepthModeForSublayer(t, s, d) {
            if (!this.opaquePassEnabledForLayer()) return nr.disabled;
            const g = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
            return new nr(d || this.context.gl.LEQUAL, s, [g, g]);
          }
          getDepthModeFor3D() {
            return new nr(this.context.gl.LEQUAL, nr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t, s) {
            var d, g;
            this.style = t, this.options = s, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(me()), this.imageManager.beginFrame();
            const w = this.style._order, S = this.style.tileManagers, C = {}, A = {}, F = {}, O = { isRenderingToTexture: !1, isRenderingGlobe: ((d = t.projection) === null || d === void 0 ? void 0 : d.transitionState) > 0 };
            for (const V in S) {
              const W = S[V];
              W.used && W.prepare(this.context), C[V] = W.getVisibleCoordinates(!1), A[V] = C[V].slice().reverse(), F[V] = W.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let V = 0; V < w.length; V++) if (this.style._layers[w[V]].is3D()) {
              this.opaquePassCutoff = V;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const V of w) {
              const W = this.style._layers[V];
              if (!W.hasOffscreenPass() || W.isHidden(this.transform.zoom)) continue;
              const te = A[W.source];
              (W.type === "custom" || te.length) && this.renderLayer(this, S[W.source], W, te, O);
            }
            if ((g = this.style.projection) === null || g === void 0 || g.updateGPUdependent({ context: this.context, useProgram: (V) => this.useProgram(V) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: s.showOverdrawInspector ? u.bp.black : u.bp.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(V, W) {
              const te = V.context, he = te.gl, pe = ((Ne, ke, Ge) => {
                const at = Math.cos(ke.rollInRadians), tt = Math.sin(ke.rollInRadians), nt = cr(ke), it = ke.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: Ne.properties.get("sky-color"), u_horizon_color: Ne.properties.get("horizon-color"), u_horizon: [(ke.width / 2 - nt * tt) * Ge, (ke.height / 2 + nt * at) * Ge], u_horizon_normal: [-tt, at], u_sky_horizon_blend: Ne.properties.get("sky-horizon-blend") * ke.height / 2 * Ge, u_sky_blend: it };
              })(W, V.style.map.transform, V.pixelRatio), fe = new nr(he.LEQUAL, nr.ReadWrite, [0, 1]), we = pr.disabled, Le = V.colorModeForRenderPass(), ve = V.useProgram("sky"), Ce = ud(te, W);
              ve.draw(te, he.TRIANGLES, fe, we, Le, sr.disabled, pe, null, void 0, "sky", Ce.vertexBuffer, Ce.indexBuffer, Ce.segments);
            })(this, this.style.sky), this._showOverdrawInspector = s.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = w.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const V = this.style._layers[w[this.currentLayer]], W = S[V.source], te = C[V.source];
              this._renderTileClippingMasks(V, te, !1), this.renderLayer(this, W, V, te, O);
            }
            this.renderPass = "translucent";
            let q = !1;
            for (this.currentLayer = 0; this.currentLayer < w.length; this.currentLayer++) {
              const V = this.style._layers[w[this.currentLayer]], W = S[V.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(V, O)) continue;
              this.opaquePassEnabledForLayer() || q || (q = !0, O.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const te = (V.type === "symbol" ? F : A)[V.source];
              this._renderTileClippingMasks(V, C[V.source], !!this.renderToTexture), this.renderLayer(this, W, V, te, O);
            }
            if (O.isRenderingGlobe && (function(V, W, te) {
              const he = V.context, pe = he.gl, fe = V.useProgram("atmosphere"), we = new nr(pe.LEQUAL, nr.ReadOnly, [0, 1]), Le = V.transform, ve = (function(it, Et) {
                const kt = it.properties.get("position"), gt = [-kt.x, -kt.y, -kt.z], At = u.ar(new Float64Array(16));
                return it.properties.get("anchor") === "map" && (u.bg(At, At, Et.rollInRadians), u.bh(At, At, -Et.pitchInRadians), u.bg(At, At, Et.bearingInRadians), u.bh(At, At, Et.center.lat * Math.PI / 180), u.bJ(At, At, -Et.center.lng * Math.PI / 180)), u.cg(gt, gt, At), gt;
              })(te, V.transform), Ce = Le.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Ne = W.properties.get("atmosphere-blend") * Ce.projectionTransition;
              if (Ne === 0) return;
              const ke = Gi(Le.worldSize, Le.center.lat), Ge = Le.inverseProjectionMatrix, at = new Float64Array(4);
              at[3] = 1, u.aH(at, at, Le.modelViewProjectionMatrix), at[0] /= at[3], at[1] /= at[3], at[2] /= at[3], at[3] = 1, u.aH(at, at, Ge), at[0] /= at[3], at[1] /= at[3], at[2] /= at[3], at[3] = 1;
              const tt = /* @__PURE__ */ ((it, Et, kt, gt, At) => ({ u_sun_pos: it, u_atmosphere_blend: Et, u_globe_position: kt, u_globe_radius: gt, u_inv_proj_matrix: At }))(ve, Ne, [at[0], at[1], at[2]], ke, Ge), nt = ud(he, W);
              fe.draw(he, pe.TRIANGLES, we, pr.disabled, Dr.alphaBlended, sr.disabled, tt, null, null, "atmosphere", nt.vertexBuffer, nt.indexBuffer, nt.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const V = (function(W, te) {
                let he = null;
                const pe = Object.values(W._layers).flatMap(((ve) => ve.source && !ve.isHidden(te) ? [W.tileManagers[ve.source]] : [])), fe = pe.filter(((ve) => ve.getSource().type === "vector")), we = pe.filter(((ve) => ve.getSource().type !== "vector")), Le = (ve) => {
                  (!he || he.getSource().maxzoom < ve.getSource().maxzoom) && (he = ve);
                };
                return fe.forEach(((ve) => Le(ve))), he || we.forEach(((ve) => Le(ve))), he;
              })(this.style, this.transform.zoom);
              V && (function(W, te, he) {
                for (let pe = 0; pe < he.length; pe++) ip(W, te, he[pe]);
              })(this, V, V.getVisibleCoordinates());
            }
            this.options.showPadding && (function(V) {
              const W = V.transform.padding;
              ad(V, V.transform.height - (W.top || 0), 3, ep), ad(V, W.bottom || 0, 3, tp), od(V, W.left || 0, 3, rp), od(V, V.transform.width - (W.right || 0), 3, np);
              const te = V.transform.centerPoint;
              (function(he, pe, fe, we) {
                Lu(he, pe - 1, fe - 10, 2, 20, we), Lu(he, pe - 10, fe - 1, 20, 2, we);
              })(V, te.x, V.transform.height - te.y, lo);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(t) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const s = this.terrainFacilitator.matrix, d = this.transform.modelViewProjectionMatrix;
            let g = this.terrainFacilitator.dirty;
            g || (g = t ? !u.cj(s, d) : !u.ck(s, d)), g || (g = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), g && (u.cl(s, d), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, (function(w, S) {
              const C = w.context, A = C.gl, F = w.transform, O = Dr.unblended, q = new nr(A.LEQUAL, nr.ReadWrite, [0, 1]), V = S.tileManager.getRenderableTiles(), W = w.useProgram("terrainDepth");
              C.bindFramebuffer.set(S.getFramebuffer("depth").framebuffer), C.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), C.clear({ color: u.bp.transparent, depth: 1 });
              for (const te of V) {
                const he = S.getTerrainMesh(te.tileID), pe = S.getTerrainData(te.tileID), fe = F.getProjectionData({ overscaledTileID: te.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), we = { u_ele_delta: S.getMeshFrameDelta(F.zoom) };
                W.draw(C, A.TRIANGLES, q, pr.disabled, O, sr.backCCW, we, pe, fe, "terrain", he.vertexBuffer, he.indexBuffer, he.segments);
              }
              C.bindFramebuffer.set(null), C.viewport.set([0, 0, w.width, w.height]);
            })(this, this.style.map.terrain), (function(w, S) {
              const C = w.context, A = C.gl, F = w.transform, O = Dr.unblended, q = new nr(A.LEQUAL, nr.ReadWrite, [0, 1]), V = S.getCoordsTexture(), W = S.tileManager.getRenderableTiles(), te = w.useProgram("terrainCoords");
              C.bindFramebuffer.set(S.getFramebuffer("coords").framebuffer), C.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), C.clear({ color: u.bp.transparent, depth: 1 }), S.coordsIndex = [];
              for (const he of W) {
                const pe = S.getTerrainMesh(he.tileID), fe = S.getTerrainData(he.tileID);
                C.activeTexture.set(A.TEXTURE0), A.bindTexture(A.TEXTURE_2D, V.texture);
                const we = { u_terrain_coords_id: (255 - S.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: S.getMeshFrameDelta(F.zoom) }, Le = F.getProjectionData({ overscaledTileID: he.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                te.draw(C, A.TRIANGLES, q, pr.disabled, O, sr.backCCW, we, fe, Le, "terrain", pe.vertexBuffer, pe.indexBuffer, pe.segments), S.coordsIndex.push(he.tileID.key);
              }
              C.bindFramebuffer.set(null), C.viewport.set([0, 0, w.width, w.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(t, s, d, g, w) {
            d.isHidden(this.transform.zoom) || (d.type === "background" || d.type === "custom" || (g || []).length) && (this.id = d.id, u.cm(d) ? (function(S, C, A, F, O, q) {
              if (S.renderPass !== "translucent") return;
              const { isRenderingToTexture: V } = q, W = pr.disabled, te = S.colorModeForRenderPass();
              (A._unevaluatedLayout.hasValue("text-variable-anchor") || A._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(he, pe, fe, we, Le, ve, Ce, Ne, ke) {
                const Ge = pe.transform, at = pe.style.map.terrain, tt = Le === "map", nt = ve === "map";
                for (const it of he) {
                  const Et = we.getTile(it), kt = Et.getBucket(fe);
                  if (!kt || !kt.text || !kt.text.segments.get().length) continue;
                  const gt = u.ay(kt.textSizeData, Ge.zoom), At = u.aN(Et, 1, pe.transform.zoom), ar = pn(tt, pe.transform, At), zr = fe.layout.get("icon-text-fit") !== "none" && kt.hasIconData();
                  if (gt) {
                    const sn = Math.pow(2, Ge.zoom - Et.tileID.overscaledZ), qr = at ? (ln, $r) => at.getElevation(it, ln, $r) : null;
                    lm(kt, tt, nt, ke, Ge, ar, sn, gt, zr, u.aO(Ge, Et, Ce, Ne), it.toUnwrapped(), qr);
                  }
                }
              })(F, S, A, C, A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), O), A.paint.get("icon-opacity").constantOr(1) !== 0 && Mu(S, C, A, F, !1, A.paint.get("icon-translate"), A.paint.get("icon-translate-anchor"), A.layout.get("icon-rotation-alignment"), A.layout.get("icon-pitch-alignment"), A.layout.get("icon-keep-upright"), W, te, V), A.paint.get("text-opacity").constantOr(1) !== 0 && Mu(S, C, A, F, !0, A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.layout.get("text-keep-upright"), W, te, V), C.map.showCollisionBoxes && (Uo(S, C, A, F, !0), Uo(S, C, A, F, !1));
            })(t, s, d, g, this.style.placement.variableOffsets, w) : u.cn(d) ? (function(S, C, A, F, O) {
              if (S.renderPass !== "translucent") return;
              const { isRenderingToTexture: q } = O, V = A.paint.get("circle-opacity"), W = A.paint.get("circle-stroke-width"), te = A.paint.get("circle-stroke-opacity"), he = !A.layout.get("circle-sort-key").isConstant();
              if (V.constantOr(1) === 0 && (W.constantOr(1) === 0 || te.constantOr(1) === 0)) return;
              const pe = S.context, fe = pe.gl, we = S.transform, Le = S.getDepthModeForSublayer(0, nr.ReadOnly), ve = pr.disabled, Ce = S.colorModeForRenderPass(), Ne = [], ke = we.getCircleRadiusCorrection();
              for (let Ge = 0; Ge < F.length; Ge++) {
                const at = F[Ge], tt = C.getTile(at), nt = tt.getBucket(A);
                if (!nt) continue;
                const it = A.paint.get("circle-translate"), Et = A.paint.get("circle-translate-anchor"), kt = u.aO(we, tt, it, Et), gt = nt.programConfigurations.get(A.id), At = S.useProgram("circle", gt), ar = nt.layoutVertexBuffer, zr = nt.indexBuffer, sn = S.style.map.terrain && S.style.map.terrain.getTerrainData(at), qr = { programConfiguration: gt, program: At, layoutVertexBuffer: ar, indexBuffer: zr, uniformValues: Pc(S, tt, A, kt, ke), terrainData: sn, projectionData: we.getProjectionData({ overscaledTileID: at, applyGlobeMatrix: !q, applyTerrainMatrix: !0 }) };
                if (he) {
                  const ln = nt.segments.get();
                  for (const $r of ln) Ne.push({ segments: new u.aX([$r]), sortKey: $r.sortKey, state: qr });
                } else Ne.push({ segments: nt.segments, sortKey: 0, state: qr });
              }
              he && Ne.sort(((Ge, at) => Ge.sortKey - at.sortKey));
              for (const Ge of Ne) {
                const { programConfiguration: at, program: tt, layoutVertexBuffer: nt, indexBuffer: it, uniformValues: Et, terrainData: kt, projectionData: gt } = Ge.state;
                tt.draw(pe, fe.TRIANGLES, Le, ve, Ce, sr.backCCW, Et, kt, gt, A.id, nt, it, Ge.segments, A.paint, S.transform.zoom, at);
              }
            })(t, s, d, g, w) : u.co(d) ? (function(S, C, A, F, O) {
              if (A.paint.get("heatmap-opacity") === 0) return;
              const q = S.context, { isRenderingToTexture: V, isRenderingGlobe: W } = O;
              if (S.style.map.terrain) {
                for (const te of F) {
                  const he = C.getTile(te);
                  C.hasRenderableParent(te) || (S.renderPass === "offscreen" ? Wf(S, he, A, te, W) : S.renderPass === "translucent" && Xf(S, A, te, V, W));
                }
                q.viewport.set([0, 0, S.width, S.height]);
              } else S.renderPass === "offscreen" ? (function(te, he, pe, fe) {
                const we = te.context, Le = we.gl, ve = te.transform, Ce = pr.disabled, Ne = new Dr([Le.ONE, Le.ONE], u.bp.transparent, [!0, !0, !0, !0]);
                (function(ke, Ge, at) {
                  const tt = ke.gl;
                  ke.activeTexture.set(tt.TEXTURE1), ke.viewport.set([0, 0, Ge.width / 4, Ge.height / 4]);
                  let nt = at.heatmapFbos.get(u.cd);
                  nt ? (tt.bindTexture(tt.TEXTURE_2D, nt.colorAttachment.get()), ke.bindFramebuffer.set(nt.framebuffer)) : (nt = Cu(ke, Ge.width / 4, Ge.height / 4), at.heatmapFbos.set(u.cd, nt));
                })(we, te, pe), we.clear({ color: u.bp.transparent });
                for (let ke = 0; ke < fe.length; ke++) {
                  const Ge = fe[ke];
                  if (he.hasRenderableParent(Ge)) continue;
                  const at = he.getTile(Ge), tt = at.getBucket(pe);
                  if (!tt) continue;
                  const nt = tt.programConfigurations.get(pe.id), it = te.useProgram("heatmap", nt), Et = ve.getProjectionData({ overscaledTileID: Ge, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), kt = ve.getCircleRadiusCorrection();
                  it.draw(we, Le.TRIANGLES, nr.disabled, Ce, Ne, sr.backCCW, Ca(at, ve.zoom, pe.paint.get("heatmap-intensity"), kt), null, Et, pe.id, tt.layoutVertexBuffer, tt.indexBuffer, tt.segments, pe.paint, ve.zoom, nt);
                }
                we.viewport.set([0, 0, te.width, te.height]);
              })(S, C, A, F) : S.renderPass === "translucent" && (function(te, he) {
                const pe = te.context, fe = pe.gl;
                pe.setColorMode(te.colorModeForRenderPass());
                const we = he.heatmapFbos.get(u.cd);
                we && (pe.activeTexture.set(fe.TEXTURE0), fe.bindTexture(fe.TEXTURE_2D, we.colorAttachment.get()), pe.activeTexture.set(fe.TEXTURE1), Bc(pe, he).bind(fe.LINEAR, fe.CLAMP_TO_EDGE), te.useProgram("heatmapTexture").draw(pe, fe.TRIANGLES, nr.disabled, pr.disabled, te.colorModeForRenderPass(), sr.disabled, wu(te, he, 0, 1), null, null, he.id, te.viewportBuffer, te.quadTriangleIndexBuffer, te.viewportSegments, he.paint, te.transform.zoom));
              })(S, A);
            })(t, s, d, g, w) : u.cp(d) ? (function(S, C, A, F, O) {
              if (S.renderPass !== "translucent") return;
              const { isRenderingToTexture: q } = O, V = A.paint.get("line-opacity"), W = A.paint.get("line-width");
              if (V.constantOr(1) === 0 || W.constantOr(1) === 0) return;
              const te = S.getDepthModeForSublayer(0, nr.ReadOnly), he = S.colorModeForRenderPass(), pe = A.paint.get("line-dasharray"), fe = pe.constantOr(1), we = A.paint.get("line-pattern"), Le = we.constantOr(1), ve = A.paint.get("line-gradient"), Ce = A.getCrossfadeParameters();
              let Ne;
              Ne = Le ? "linePattern" : fe && ve ? "lineGradientSDF" : fe ? "lineSDF" : ve ? "lineGradient" : "line";
              const ke = S.context, Ge = ke.gl, at = S.transform;
              let tt = !0;
              for (const nt of F) {
                const it = C.getTile(nt);
                if (Le && !it.patternsLoaded()) continue;
                const Et = it.getBucket(A);
                if (!Et) continue;
                const kt = Et.programConfigurations.get(A.id), gt = S.context.program.get(), At = S.useProgram(Ne, kt), ar = tt || At.program !== gt, zr = S.style.map.terrain && S.style.map.terrain.getTerrainData(nt), sn = we.constantOr(null), qr = pe && pe.constantOr(null);
                if (sn && it.imageAtlas) {
                  const ui = it.imageAtlas, On = ui.patternPositions[sn.to.toString()], Ln = ui.patternPositions[sn.from.toString()];
                  On && Ln && kt.setConstantPatternPositions(On, Ln);
                } else if (qr) {
                  const ui = A.layout.get("line-cap") === "round", On = S.lineAtlas.getDash(qr.to, ui), Ln = S.lineAtlas.getDash(qr.from, ui);
                  kt.setConstantDashPositions(On, Ln);
                }
                const ln = at.getProjectionData({ overscaledTileID: nt, applyGlobeMatrix: !q, applyTerrainMatrix: !0 }), $r = at.getPixelScale();
                let En;
                Le ? (En = Sl(S, it, A, $r, Ce), Kf(ke, Ge, it, kt, Ce)) : fe && ve ? (En = kl(S, it, A, $r, Ce, Et.lineClipsArray.length), as(S, C, ke, Ge, A, Et, nt, kt, Ce)) : fe ? (En = Dc(S, it, A, $r, Ce), Pn(S, ke, Ge, kt, ar, Ce)) : ve ? (En = Eu(S, it, A, $r, Et.lineClipsArray.length), qo(S, C, ke, Ge, A, Et, nt)) : En = Bo(S, it, A, $r);
                const un = S.stencilModeForClipping(nt);
                At.draw(ke, Ge.TRIANGLES, te, un, he, sr.disabled, En, zr, ln, A.id, Et.layoutVertexBuffer, Et.indexBuffer, Et.segments, A.paint, S.transform.zoom, kt, Et.layoutVertexBuffer2), tt = !1;
              }
            })(t, s, d, g, w) : u.cq(d) ? (function(S, C, A, F, O) {
              const q = A.paint.get("fill-color"), V = A.paint.get("fill-opacity");
              if (V.constantOr(1) === 0) return;
              const { isRenderingToTexture: W } = O, te = S.colorModeForRenderPass(), he = A.paint.get("fill-pattern"), pe = S.opaquePassEnabledForLayer() && !he.constantOr(1) && q.constantOr(u.bp.transparent).a === 1 && V.constantOr(0) === 1 ? "opaque" : "translucent";
              if (S.renderPass === pe) {
                const fe = S.getDepthModeForSublayer(1, S.renderPass === "opaque" ? nr.ReadWrite : nr.ReadOnly);
                Pu(S, C, A, F, fe, te, !1, W);
              }
              if (S.renderPass === "translucent" && A.paint.get("fill-antialias")) {
                const fe = S.getDepthModeForSublayer(A.getPaintProperty("fill-outline-color") ? 2 : 0, nr.ReadOnly);
                Pu(S, C, A, F, fe, te, !0, W);
              }
            })(t, s, d, g, w) : u.cr(d) ? (function(S, C, A, F, O) {
              const q = A.paint.get("fill-extrusion-opacity");
              if (q === 0) return;
              const { isRenderingToTexture: V } = O;
              if (S.renderPass === "translucent") {
                const W = new nr(S.context.gl.LEQUAL, nr.ReadWrite, S.depthRangeFor3D);
                if (q !== 1 || A.paint.get("fill-extrusion-pattern").constantOr(1)) jc(S, C, A, F, W, pr.disabled, Dr.disabled, V), jc(S, C, A, F, W, S.stencilModeFor3D(), S.colorModeForRenderPass(), V);
                else {
                  const te = S.colorModeForRenderPass();
                  jc(S, C, A, F, W, pr.disabled, te, V);
                }
              }
            })(t, s, d, g, w) : u.cs(d) ? (function(S, C, A, F, O) {
              if (S.renderPass !== "offscreen" && S.renderPass !== "translucent") return;
              const { isRenderingToTexture: q } = O, V = S.context, W = S.style.projection.useSubdivision, te = S.getDepthModeForSublayer(0, nr.ReadOnly), he = S.colorModeForRenderPass();
              if (S.renderPass === "offscreen") (function(pe, fe, we, Le, ve, Ce, Ne) {
                const ke = pe.context, Ge = ke.gl;
                for (const at of we) {
                  const tt = fe.getTile(at), nt = tt.dem;
                  if (!nt || !nt.data || !tt.needsHillshadePrepare) continue;
                  const it = nt.dim, Et = nt.stride, kt = nt.getPixels();
                  if (ke.activeTexture.set(Ge.TEXTURE1), ke.pixelStoreUnpackPremultiplyAlpha.set(!1), tt.demTexture = tt.demTexture || pe.getTileTexture(Et), tt.demTexture) {
                    const At = tt.demTexture;
                    At.update(kt, { premultiply: !1 }), At.bind(Ge.NEAREST, Ge.CLAMP_TO_EDGE);
                  } else tt.demTexture = new u.T(ke, kt, Ge.RGBA, { premultiply: !1 }), tt.demTexture.bind(Ge.NEAREST, Ge.CLAMP_TO_EDGE);
                  ke.activeTexture.set(Ge.TEXTURE0);
                  let gt = tt.fbo;
                  if (!gt) {
                    const At = new u.T(ke, { width: it, height: it, data: null }, Ge.RGBA);
                    At.bind(Ge.LINEAR, Ge.CLAMP_TO_EDGE), gt = tt.fbo = ke.createFramebuffer(it, it, !0, !1), gt.colorAttachment.set(At.texture);
                  }
                  ke.bindFramebuffer.set(gt.framebuffer), ke.viewport.set([0, 0, it, it]), pe.useProgram("hillshadePrepare").draw(ke, Ge.TRIANGLES, ve, Ce, Ne, sr.disabled, td(tt.tileID, nt), null, null, Le.id, pe.rasterBoundsBuffer, pe.quadTriangleIndexBuffer, pe.rasterBoundsSegments), tt.needsHillshadePrepare = !1;
                }
              })(S, C, F, A, te, pr.disabled, he), V.viewport.set([0, 0, S.width, S.height]);
              else if (S.renderPass === "translucent") if (W) {
                const [pe, fe, we] = S.stencilConfigForOverlapTwoPass(F);
                oo(S, C, A, we, pe, te, he, !1, q), oo(S, C, A, we, fe, te, he, !0, q);
              } else {
                const [pe, fe] = S.getStencilConfigForOverlapAndUpdateStencilID(F);
                oo(S, C, A, fe, pe, te, he, !1, q);
              }
            })(t, s, d, g, w) : u.ct(d) ? (function(S, C, A, F, O) {
              if (S.renderPass !== "translucent" || !F.length) return;
              const { isRenderingToTexture: q } = O, V = S.style.projection.useSubdivision, W = S.getDepthModeForSublayer(0, nr.ReadOnly), te = S.colorModeForRenderPass();
              if (V) {
                const [he, pe, fe] = S.stencilConfigForOverlapTwoPass(F);
                Au(S, C, A, fe, he, W, te, !1, q), Au(S, C, A, fe, pe, W, te, !0, q);
              } else {
                const [he, pe] = S.getStencilConfigForOverlapAndUpdateStencilID(F);
                Au(S, C, A, pe, he, W, te, !1, q);
              }
            })(t, s, d, g, w) : u.bU(d) ? (function(S, C, A, F, O) {
              if (S.renderPass !== "translucent" || A.paint.get("raster-opacity") === 0 || !F.length) return;
              const { isRenderingToTexture: q } = O, V = C.getSource(), W = S.style.projection.useSubdivision;
              if (V instanceof Kr) Al(S, C, A, F, null, !1, !1, V.tileCoords, V.flippedWindingOrder, q);
              else if (W) {
                const [te, he, pe] = S.stencilConfigForOverlapTwoPass(F);
                Al(S, C, A, pe, te, !1, !0, $o, !1, q), Al(S, C, A, pe, he, !0, !0, $o, !1, q);
              } else {
                const [te, he] = S.getStencilConfigForOverlapAndUpdateStencilID(F);
                Al(S, C, A, he, te, !1, !0, $o, !1, q);
              }
            })(t, s, d, g, w) : u.cu(d) ? (function(S, C, A, F, O) {
              const q = A.paint.get("background-color"), V = A.paint.get("background-opacity");
              if (V === 0) return;
              const { isRenderingToTexture: W } = O, te = S.context, he = te.gl, pe = S.style.projection, fe = S.transform, we = fe.tileSize, Le = A.paint.get("background-pattern");
              if (S.isPatternMissing(Le)) return;
              const ve = !Le && q.a === 1 && V === 1 && S.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (S.renderPass !== ve) return;
              const Ce = pr.disabled, Ne = S.getDepthModeForSublayer(0, ve === "opaque" ? nr.ReadWrite : nr.ReadOnly), ke = S.colorModeForRenderPass(), Ge = S.useProgram(Le ? "backgroundPattern" : "background"), at = F || Pr(fe, { tileSize: we, terrain: S.style.map.terrain });
              Le && (te.activeTexture.set(he.TEXTURE0), S.imageManager.bind(S.context));
              const tt = A.getCrossfadeParameters();
              for (const nt of at) {
                const it = fe.getProjectionData({ overscaledTileID: nt, applyGlobeMatrix: !W, applyTerrainMatrix: !0 }), Et = Le ? _(V, S, Le, { tileID: nt, tileSize: we }, tt) : h(V, q), kt = S.style.map.terrain && S.style.map.terrain.getTerrainData(nt), gt = pe.getMeshFromTileID(te, nt.canonical, !1, !0, "raster");
                Ge.draw(te, he.TRIANGLES, Ne, Ce, ke, sr.backCCW, Et, kt, it, A.id, gt.vertexBuffer, gt.indexBuffer, gt.segments);
              }
            })(t, 0, d, g, w) : u.cv(d) && (function(S, C, A, F) {
              const { isRenderingGlobe: O } = F, q = S.context, V = A.implementation, W = S.style.projection, te = S.transform, he = te.getProjectionDataForCustomLayer(O), pe = { farZ: te.farZ, nearZ: te.nearZ, fov: te.fov * Math.PI / 180, modelViewProjectionMatrix: te.modelViewProjectionMatrix, projectionMatrix: te.projectionMatrix, shaderData: { variantName: W.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${W.shaderPreludeCode.vertexSource}`, define: W.shaderDefine }, defaultProjectionData: he }, fe = V.renderingMode ? V.renderingMode : "2d";
              if (S.renderPass === "offscreen") {
                const we = V.prerender;
                we && (S.setCustomLayerDefaults(), q.setColorMode(S.colorModeForRenderPass()), we.call(V, q.gl, pe), q.setDirty(), S.setBaseState());
              } else if (S.renderPass === "translucent") {
                S.setCustomLayerDefaults(), q.setColorMode(S.colorModeForRenderPass()), q.setStencilMode(pr.disabled);
                const we = fe === "3d" ? S.getDepthModeFor3D() : S.getDepthModeForSublayer(0, nr.ReadOnly);
                q.setDepthMode(we), V.render(q.gl, pe), q.setDirty(), S.setBaseState(), q.bindFramebuffer.set(null);
              }
            })(t, 0, d, w));
          }
          saveTileTexture(t) {
            const s = this._tileTextures[t.size[0]];
            s ? s.push(t) : this._tileTextures[t.size[0]] = [t];
          }
          getTileTexture(t) {
            const s = this._tileTextures[t];
            return s && s.length > 0 ? s.pop() : null;
          }
          isPatternMissing(t) {
            if (!t) return !1;
            if (!t.from || !t.to) return !0;
            const s = this.imageManager.getPattern(t.from.toString()), d = this.imageManager.getPattern(t.to.toString());
            return !s || !d;
          }
          useProgram(t, s, d = !1, g = []) {
            this.cache = this.cache || {};
            const w = !!this.style.map.terrain, S = this.style.projection, C = d ? en.projectionMercator : S.shaderPreludeCode, A = d ? si : S.shaderDefine, F = t + (s ? s.cacheKey : "") + `/${d ? dr : S.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (w ? "/terrain" : "") + (g ? `/${g.join("/")}` : "");
            return this.cache[F] || (this.cache[F] = new Ic(this.context, en[t], s, D[t], this._showOverdrawInspector, w, C, A, g)), this.cache[F];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new u.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            var t, s;
            if (this._tileTextures) {
              for (const d in this._tileTextures) {
                const g = this._tileTextures[d];
                if (g) for (const w of g) w.destroy();
              }
              this._tileTextures = {};
            }
            if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && ((t = this.tileExtentMesh.vertexBuffer) === null || t === void 0 || t.destroy()), this.tileExtentMesh && ((s = this.tileExtentMesh.indexBuffer) === null || s === void 0 || s.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) {
              for (const d in this.cache) {
                const g = this.cache[d];
                g && g.program && this.context.gl.deleteProgram(g.program);
              }
              this.cache = {};
            }
            this.context && this.context.setDefault();
          }
          overLimit() {
            const { drawingBufferWidth: t, drawingBufferHeight: s } = this.context.gl;
            return this.width !== t || this.height !== s;
          }
        }
        function cd(b, t) {
          let s, d = !1, g = null, w = null;
          const S = () => {
            g = null, d && (b.apply(w, s), g = setTimeout(S, t), d = !1);
          };
          return (...C) => (d = !0, w = this, s = C, g || S(), g);
        }
        class hd {
          constructor(t) {
            this._getCurrentHash = () => {
              const s = window.location.hash.replace("#", "");
              if (this._hashName) {
                let d;
                return s.split("&").map(((g) => g.split("="))).forEach(((g) => {
                  g[0] === this._hashName && (d = g);
                })), (d && d[1] || "").split("/");
              }
              return s.split("/");
            }, this._onHashChange = () => {
              const s = this._getCurrentHash();
              if (!this._isValidHash(s)) return !1;
              const d = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(s[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+s[2], +s[1]], zoom: +s[0], bearing: d, pitch: +(s[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const s = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, s);
            }, this._removeHash = () => {
              const s = this._getCurrentHash();
              if (s.length === 0) return;
              const d = s.join("/");
              let g = d;
              g.split("&").length > 0 && (g = g.split("&")[0]), this._hashName && (g = `${this._hashName}=${d}`);
              let w = window.location.hash.replace(g, "");
              w.startsWith("#&") ? w = w.slice(0, 1) + w.slice(2) : w === "#" && (w = "");
              let S = window.location.href.replace(/(#.+)?$/, w);
              S = S.replace("&&", "&"), window.history.replaceState(window.history.state, null, S);
            }, this._updateHash = cd(this._updateHashUnthrottled, 300), this._hashName = t && encodeURIComponent(t);
          }
          addTo(t) {
            return this._map = t, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(t) {
            const s = this._map.getCenter(), d = Math.round(100 * this._map.getZoom()) / 100, g = Math.ceil((d * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), w = Math.pow(10, g), S = Math.round(s.lng * w) / w, C = Math.round(s.lat * w) / w, A = this._map.getBearing(), F = this._map.getPitch();
            let O = "";
            if (O += t ? `/${S}/${C}/${d}` : `${d}/${C}/${S}`, (A || F) && (O += "/" + Math.round(10 * A) / 10), F && (O += `/${Math.round(F)}`), this._hashName) {
              const q = this._hashName;
              let V = !1;
              const W = window.location.hash.slice(1).split("&").map(((te) => {
                const he = te.split("=")[0];
                return he === q ? (V = !0, `${he}=${O}`) : te;
              })).filter(((te) => te));
              return V || W.push(`${q}=${O}`), `#${W.join("&")}`;
            }
            return `#${O}`;
          }
          _isValidHash(t) {
            if (t.length < 3 || t.some(isNaN)) return !1;
            try {
              new u.V(+t[2], +t[1]);
            } catch {
              return !1;
            }
            const s = +t[0], d = +(t[3] || 0), g = +(t[4] || 0);
            return s >= this._map.getMinZoom() && s <= this._map.getMaxZoom() && d >= -180 && d <= 180 && g >= this._map.getMinPitch() && g <= this._map.getMaxPitch();
          }
        }
        const uo = { linearity: 0.3, easing: u.cw(0, 0, 0.3, 1) }, ap = u.e({ deceleration: 2500, maxSpeed: 1400 }, uo), ws = u.e({ deceleration: 20, maxSpeed: 1400 }, uo), Os = u.e({ deceleration: 1e3, maxSpeed: 360 }, uo), op = u.e({ deceleration: 1e3, maxSpeed: 90 }, uo), zs = u.e({ deceleration: 1e3, maxSpeed: 360 }, uo);
        class um {
          constructor(t) {
            this._map = t, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: me(), settings: t });
          }
          _drainInertiaBuffer() {
            const t = this._inertiaBuffer, s = me();
            for (; t.length > 0 && s - t[0].time > 160; ) t.shift();
          }
          _onMoveEnd(t) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const s = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new u.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: w } of this._inertiaBuffer) s.zoom += w.zoomDelta || 0, s.bearing += w.bearingDelta || 0, s.pitch += w.pitchDelta || 0, s.roll += w.rollDelta || 0, w.panDelta && s.pan._add(w.panDelta), w.around && (s.around = w.around), w.pinchAround && (s.pinchAround = w.pinchAround);
            const d = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, g = {};
            if (s.pan.mag()) {
              const w = Ru(s.pan.mag(), d, u.e({}, ap, t || {})), S = s.pan.mult(w.amount / s.pan.mag()), C = this._map.cameraHelper.handlePanInertia(S, this._map.transform);
              g.center = C.easingCenter, g.offset = C.easingOffset, Du(g, w);
            }
            if (s.zoom) {
              const w = Ru(s.zoom, d, ws);
              g.zoom = this._map.transform.zoom + w.amount, Du(g, w);
            }
            if (s.bearing) {
              const w = Ru(s.bearing, d, Os);
              g.bearing = this._map.transform.bearing + u.an(w.amount, -179, 179), Du(g, w);
            }
            if (s.pitch) {
              const w = Ru(s.pitch, d, op);
              g.pitch = this._map.transform.pitch + w.amount, Du(g, w);
            }
            if (s.roll) {
              const w = Ru(s.roll, d, zs);
              g.roll = this._map.transform.roll + u.an(w.amount, -179, 179), Du(g, w);
            }
            if (g.zoom || g.bearing) {
              const w = s.pinchAround === void 0 ? s.around : s.pinchAround;
              g.around = w ? this._map.unproject(w) : this._map.getCenter();
            }
            return this.clear(), u.e(g, { noMoveStart: !0 });
          }
        }
        function Du(b, t) {
          (!b.duration || b.duration < t.duration) && (b.duration = t.duration, b.easing = t.easing);
        }
        function Ru(b, t, s) {
          const { maxSpeed: d, linearity: g, deceleration: w } = s, S = u.an(b * g / (t / 1e3), -d, d), C = Math.abs(S) / (w * g);
          return { easing: s.easing, duration: 1e3 * C, amount: S * (C / 2) };
        }
        class li extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, s, d, g = {}) {
            d = d instanceof MouseEvent ? d : new MouseEvent(t, d);
            const w = re.mousePos(s.getCanvas(), d), S = s.unproject(w);
            super(t, u.e({ point: w, lngLat: S, originalEvent: d }, g)), this._defaultPrevented = !1, this.target = s;
          }
        }
        class Fu extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, s, d) {
            const g = t === "touchend" ? d.changedTouches : d.touches, w = re.touchPos(s.getCanvasContainer(), g), S = w.map(((A) => s.unproject(A))), C = w.reduce(((A, F, O, q) => A.add(F.div(q.length))), new u.P(0, 0));
            super(t, { points: w, point: C, lngLats: S, lngLat: s.unproject(C), originalEvent: d }), this._defaultPrevented = !1;
          }
        }
        class lp extends u.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, s, d) {
            super(t, { originalEvent: d }), this._defaultPrevented = !1;
          }
        }
        class cm {
          constructor(t, s) {
            this._map = t, this._clickTolerance = s.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t) {
            return this._firePreventable(new lp(t.type, this._map, t));
          }
          mousedown(t, s) {
            return this._mousedownPos = s, this._firePreventable(new li(t.type, this._map, t));
          }
          mouseup(t) {
            this._map.fire(new li(t.type, this._map, t));
          }
          click(t, s) {
            this._mousedownPos && this._mousedownPos.dist(s) >= this._clickTolerance || this._map.fire(new li(t.type, this._map, t));
          }
          dblclick(t) {
            return this._firePreventable(new li(t.type, this._map, t));
          }
          mouseover(t) {
            this._map.fire(new li(t.type, this._map, t));
          }
          mouseout(t) {
            this._map.fire(new li(t.type, this._map, t));
          }
          touchstart(t) {
            return this._firePreventable(new Fu(t.type, this._map, t));
          }
          touchmove(t) {
            this._map.fire(new Fu(t.type, this._map, t));
          }
          touchend(t) {
            this._map.fire(new Fu(t.type, this._map, t));
          }
          touchcancel(t) {
            this._map.fire(new Fu(t.type, this._map, t));
          }
          _firePreventable(t) {
            if (this._map.fire(t), t.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class hm {
          constructor(t) {
            this._map = t;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(t) {
            this._map.fire(new li(t.type, this._map, t));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new li("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t) {
            this._delayContextMenu ? this._contextMenuEvent = t : this._ignoreContextMenu || this._map.fire(new li(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ll {
          constructor(t) {
            this._map = t;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(t) {
            return this.transform.screenPointToLocation(u.P.convert(t), this._map.terrain);
          }
        }
        class Dl {
          constructor(t, s) {
            this._map = t, this._tr = new Ll(t), this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = s.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(t, s) {
            this.isEnabled() && t.shiftKey && t.button === 0 && (re.disableDrag(), this._startPos = this._lastPos = s, this._active = !0);
          }
          mousemoveWindow(t, s) {
            if (!this._active) return;
            const d = s;
            if (this._lastPos.equals(d) || !this._box && d.dist(this._startPos) < this._clickTolerance) return;
            const g = this._startPos;
            this._lastPos = d, this._box || (this._box = re.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t));
            const w = Math.min(g.x, d.x), S = Math.max(g.x, d.x), C = Math.min(g.y, d.y), A = Math.max(g.y, d.y);
            re.setTransform(this._box, `translate(${w}px,${C}px)`), this._box.style.width = S - w + "px", this._box.style.height = A - C + "px";
          }
          mouseupWindow(t, s) {
            if (!this._active || t.button !== 0) return;
            const d = this._startPos, g = s;
            if (this.reset(), re.suppressClick(), d.x !== g.x || d.y !== g.y) return this._map.fire(new u.l("boxzoomend", { originalEvent: t })), { cameraAnimation: (w) => w.fitScreenCoordinates(d, g, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", t);
          }
          keydown(t) {
            this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (re.remove(this._box), this._box = null), re.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t, s) {
            return this._map.fire(new u.l(t, { originalEvent: s }));
          }
        }
        function Bs(b, t) {
          if (b.length !== t.length) throw new Error(`The number of touches and points are not equal - touches ${b.length}, points ${t.length}`);
          const s = {};
          for (let d = 0; d < b.length; d++) s[b[d].identifier] = t[d];
          return s;
        }
        class jt {
          constructor(t) {
            this.reset(), this.numTouches = t.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(t, s, d) {
            (this.centroid || d.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = t.timeStamp), d.length === this.numTouches && (this.centroid = (function(g) {
              const w = new u.P(0, 0);
              for (const S of g) w._add(S);
              return w.div(g.length);
            })(s), this.touches = Bs(d, s)));
          }
          touchmove(t, s, d) {
            if (this.aborted || !this.centroid) return;
            const g = Bs(d, s);
            for (const w in this.touches) {
              const S = g[w];
              (!S || S.dist(this.touches[w]) > 30) && (this.aborted = !0);
            }
          }
          touchend(t, s, d) {
            if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), d.length === 0) {
              const g = !this.aborted && this.centroid;
              if (this.reset(), g) return g;
            }
          }
        }
        class Vc {
          constructor(t) {
            this.singleTap = new jt(t), this.numTaps = t.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t, s, d) {
            this.singleTap.touchstart(t, s, d);
          }
          touchmove(t, s, d) {
            this.singleTap.touchmove(t, s, d);
          }
          touchend(t, s, d) {
            const g = this.singleTap.touchend(t, s, d);
            if (g) {
              const w = t.timeStamp - this.lastTime < 500, S = !this.lastTap || this.lastTap.dist(g) < 30;
              if (w && S || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = g, this.count === this.numTaps) return this.reset(), g;
            }
          }
        }
        class dd {
          constructor(t) {
            this._tr = new Ll(t), this._zoomIn = new Vc({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Vc({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t, s, d) {
            this._zoomIn.touchstart(t, s, d), this._zoomOut.touchstart(t, s, d);
          }
          touchmove(t, s, d) {
            this._zoomIn.touchmove(t, s, d), this._zoomOut.touchmove(t, s, d);
          }
          touchend(t, s, d) {
            const g = this._zoomIn.touchend(t, s, d), w = this._zoomOut.touchend(t, s, d), S = this._tr;
            return g ? (this._active = !0, t.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: S.zoom + 1, around: S.unproject(g) }, { originalEvent: t }) }) : w ? (this._active = !0, t.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: S.zoom - 1, around: S.unproject(w) }, { originalEvent: t }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Rl {
          constructor(t) {
            this._enabled = !!t.enable, this._moveStateManager = t.moveStateManager, this._clickTolerance = t.clickTolerance || 1, this._moveFunction = t.move, this._activateOnStart = !!t.activateOnStart, t.assignEvents(this), this.reset();
          }
          reset(t) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(t);
          }
          _move(...t) {
            const s = this._moveFunction(...t);
            if (s.bearingDelta || s.pitchDelta || s.rollDelta || s.around || s.panDelta) return this._active = !0, s;
          }
          dragStart(t, s) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t) && (this._moveStateManager.startMove(t), this._lastPoint = Array.isArray(s) ? s[0] : s, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(t, s) {
            if (!this.isEnabled()) return;
            const d = this._lastPoint;
            if (!d) return;
            if (t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t)) return void this.reset(t);
            const g = Array.isArray(s) ? s[0] : s;
            return !this._moved && g.dist(d) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = g, this._move(d, g));
          }
          dragEnd(t) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t) && (this._moved && re.suppressClick(), this.reset(t));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Nu = 0, Ou = 2, fd = { [Nu]: 1, [Ou]: 2 };
        class zu {
          constructor(t) {
            this._correctEvent = t.checkCorrectEvent;
          }
          startMove(t) {
            const s = re.mouseButton(t);
            this._eventButton = s;
          }
          endMove(t) {
            delete this._eventButton;
          }
          isValidStartEvent(t) {
            return this._correctEvent(t);
          }
          isValidMoveEvent(t) {
            return !(function(s, d) {
              const g = fd[d];
              return s.buttons === void 0 || (s.buttons & g) !== g;
            })(t, this._eventButton);
          }
          isValidEndEvent(t) {
            return re.mouseButton(t) === this._eventButton;
          }
        }
        class pd {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t) {
            return t.targetTouches.length === 1;
          }
          _isSameTouchEvent(t) {
            return t.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t) {
            this._firstTouch = t.targetTouches[0].identifier;
          }
          endMove(t) {
            delete this._firstTouch;
          }
          isValidStartEvent(t) {
            return this._isOneFingerTouch(t);
          }
          isValidMoveEvent(t) {
            return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
          }
          isValidEndEvent(t) {
            return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
          }
        }
        class up {
          constructor(t = new zu({ checkCorrectEvent: () => !0 }), s = new pd()) {
            this.mouseMoveStateManager = t, this.oneFingerTouchMoveStateManager = s;
          }
          _executeRelevantHandler(t, s, d) {
            return t instanceof MouseEvent ? s(t) : typeof TouchEvent < "u" && t instanceof TouchEvent ? d(t) : void 0;
          }
          startMove(t) {
            this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.startMove(s)), ((s) => this.oneFingerTouchMoveStateManager.startMove(s)));
          }
          endMove(t) {
            this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.endMove(s)), ((s) => this.oneFingerTouchMoveStateManager.endMove(s)));
          }
          isValidStartEvent(t) {
            return this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.isValidStartEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidStartEvent(s)));
          }
          isValidMoveEvent(t) {
            return this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.isValidMoveEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(s)));
          }
          isValidEndEvent(t) {
            return this._executeRelevantHandler(t, ((s) => this.mouseMoveStateManager.isValidEndEvent(s)), ((s) => this.oneFingerTouchMoveStateManager.isValidEndEvent(s)));
          }
        }
        const Fl = (b) => {
          b.mousedown = b.dragStart, b.mousemoveWindow = b.dragMove, b.mouseup = b.dragEnd, b.contextmenu = (t) => {
            t.preventDefault();
          };
        };
        class dm {
          constructor(t, s) {
            this._clickTolerance = t.clickTolerance || 1, this._map = s, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new u.P(0, 0);
          }
          _shouldBePrevented(t) {
            return t < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(t, s, d) {
            return this._calculateTransform(t, s, d);
          }
          touchmove(t, s, d) {
            if (this._active) {
              if (!this._shouldBePrevented(d.length)) return t.preventDefault(), this._calculateTransform(t, s, d);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t);
            }
          }
          touchend(t, s, d) {
            this._calculateTransform(t, s, d), this._active && this._shouldBePrevented(d.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t, s, d) {
            d.length > 0 && (this._active = !0);
            const g = Bs(d, s), w = new u.P(0, 0), S = new u.P(0, 0);
            let C = 0;
            for (const F in g) {
              const O = g[F], q = this._touches[F];
              q && (w._add(O), S._add(O.sub(q)), C++, g[F] = O);
            }
            if (this._touches = g, this._shouldBePrevented(C) || !S.mag()) return;
            const A = S.div(C);
            return this._sum._add(A), this._sum.mag() < this._clickTolerance ? void 0 : { around: w.div(C), panDelta: A };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Uc {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(t, s, d) {
            this._firstTwoTouches || d.length < 2 || (this._firstTwoTouches = [d[0].identifier, d[1].identifier], this._start([s[0], s[1]]));
          }
          touchmove(t, s, d) {
            if (!this._firstTwoTouches) return;
            t.preventDefault();
            const [g, w] = this._firstTwoTouches, S = qc(d, s, g), C = qc(d, s, w);
            if (!S || !C) return;
            const A = this._aroundCenter ? null : S.add(C).div(2);
            return this._move([S, C], A, t);
          }
          touchend(t, s, d) {
            if (!this._firstTwoTouches) return;
            const [g, w] = this._firstTwoTouches, S = qc(d, s, g), C = qc(d, s, w);
            S && C || (this._active && re.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t) {
            this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function qc(b, t, s) {
          for (let d = 0; d < b.length; d++) if (b[d].identifier === s) return t[d];
        }
        function cp(b, t) {
          return Math.log(b / t) / Math.LN2;
        }
        class gd extends Uc {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t) {
            this._startDistance = this._distance = t[0].dist(t[1]);
          }
          _move(t, s) {
            const d = this._distance;
            if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(cp(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: cp(this._distance, d), pinchAround: s };
          }
        }
        function hp(b, t) {
          return 180 * b.angleWith(t) / Math.PI;
        }
        class md extends Uc {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t) {
            this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
          }
          _move(t, s, d) {
            const g = this._vector;
            if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: hp(this._vector, g), pinchAround: s };
          }
          _isBelowThreshold(t) {
            this._minDiameter = Math.min(this._minDiameter, t.mag());
            const s = 25 / (Math.PI * this._minDiameter) * 360, d = hp(t, this._startVector);
            return Math.abs(d) < s;
          }
        }
        function _d(b) {
          return Math.abs(b.y) > Math.abs(b.x);
        }
        class dp extends Uc {
          constructor(t) {
            super(), this._currentTouchCount = 0, this._map = t;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t, s, d) {
            super.touchstart(t, s, d), this._currentTouchCount = d.length;
          }
          _start(t) {
            this._lastPoints = t, _d(t[0].sub(t[1])) && (this._valid = !1);
          }
          _move(t, s, d) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const g = t[0].sub(this._lastPoints[0]), w = t[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(g, w, d.timeStamp), this._valid ? (this._lastPoints = t, this._active = !0, { pitchDelta: (g.y + w.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t, s, d) {
            if (this._valid !== void 0) return this._valid;
            const g = t.mag() >= 2, w = s.mag() >= 2;
            if (!g && !w) return;
            if (!g || !w) return this._firstMove === void 0 && (this._firstMove = d), d - this._firstMove < 100 && void 0;
            const S = t.y > 0 == s.y > 0;
            return _d(t) && _d(s) && S;
          }
        }
        const co = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Vr {
          constructor(t) {
            this._tr = new Ll(t);
            const s = co;
            this._panStep = s.panStep, this._bearingStep = s.bearingStep, this._pitchStep = s.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(t) {
            if (t.altKey || t.ctrlKey || t.metaKey) return;
            let s = 0, d = 0, g = 0, w = 0, S = 0;
            switch (t.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                s = 1;
                break;
              case 189:
              case 109:
              case 173:
                s = -1;
                break;
              case 37:
                t.shiftKey ? d = -1 : (t.preventDefault(), w = -1);
                break;
              case 39:
                t.shiftKey ? d = 1 : (t.preventDefault(), w = 1);
                break;
              case 38:
                t.shiftKey ? g = 1 : (t.preventDefault(), S = -1);
                break;
              case 40:
                t.shiftKey ? g = -1 : (t.preventDefault(), S = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (d = 0, g = 0), { cameraAnimation: (C) => {
              const A = this._tr;
              C.easeTo({ duration: 300, easeId: "keyboardHandler", easing: fm, zoom: s ? Math.round(A.zoom) + s * (t.shiftKey ? 2 : 1) : A.zoom, bearing: A.bearing + d * this._bearingStep, pitch: A.pitch + g * this._pitchStep, offset: [-w * this._panStep, -S * this._panStep], center: A.center }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function fm(b) {
          return b * (2 - b);
        }
        const Bu = 4.000244140625, $c = 1 / 450;
        class Zc {
          constructor(t, s) {
            this._onTimeout = (d) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(d);
            }, this._map = t, this._tr = new Ll(t), this._triggerRenderFrame = s, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = $c;
          }
          setZoomRate(t) {
            this._defaultZoomRate = t;
          }
          setWheelZoomRate(t) {
            this._wheelZoomRate = t;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(t) {
            return !!this._map.cooperativeGestures.isEnabled() && !(t.ctrlKey || this._map.cooperativeGestures.isBypassed(t));
          }
          wheel(t) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(t)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t);
            let s = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
            const d = me(), g = d - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = d, s !== 0 && s % Bu == 0 ? this._type = "wheel" : s !== 0 && Math.abs(s) < 4 ? this._type = "trackpad" : g > 400 ? (this._type = null, this._lastValue = s, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(g * s) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, s += this._lastValue)), t.shiftKey && s && (s /= 4), this._type && (this._lastWheelEvent = t, this._delta -= s, this._active || this._start(t)), t.preventDefault();
          }
          _start(t) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const s = re.mousePos(this._map.getCanvas(), t), d = this._tr;
            this._aroundPoint = this._aroundCenter ? d.transform.locationToScreenPoint(u.V.convert(d.center)) : s, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const t = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const C = t.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += C), typeof this._targetZoom == "number" && (this._targetZoom += C);
            }
            if (this._delta !== 0) {
              const C = this._type === "wheel" && Math.abs(this._delta) > Bu ? this._wheelZoomRate : this._defaultZoomRate;
              let A = 2 / (1 + Math.exp(-Math.abs(this._delta * C)));
              this._delta < 0 && A !== 0 && (A = 1 / A);
              const F = typeof this._targetZoom != "number" ? t.scale : u.aq(this._targetZoom);
              this._targetZoom = t.applyConstrain(t.getCameraLngLat(), u.at(F * A)).zoom, this._type === "wheel" && (this._startZoom = t.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const s = typeof this._targetZoom != "number" ? t.zoom : this._targetZoom, d = this._startZoom, g = this._easing;
            let w, S = !1;
            if (this._type === "wheel" && d && g) {
              const C = me() - this._lastWheelEventTime, A = Math.min((C + 5) / 200, 1), F = g(A);
              w = u.G.number(d, s, F), A < 1 ? this._frameId || (this._frameId = !0) : S = !0;
            } else w = s, S = !0;
            return this._active = !0, S && (this._active = !1, this._finishTimeout = setTimeout((() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = w, { noInertia: !0, needsRenderFrame: !S, zoomDelta: w - t.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t) {
            let s = u.cy;
            if (this._prevEase) {
              const d = this._prevEase, g = (me() - d.start) / d.duration, w = d.easing(g + 0.01) - d.easing(g), S = 0.27 / Math.sqrt(w * w + 1e-4) * 0.01, C = Math.sqrt(0.0729 - S * S);
              s = u.cw(S, C, 0.25, 1);
            }
            return this._prevEase = { start: me(), duration: t, easing: s }, s;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class yd {
          constructor(t, s) {
            this._clickZoom = t, this._tapZoom = s;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class fp {
          constructor(t) {
            this._tr = new Ll(t), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(t, s) {
            return t.preventDefault(), { cameraAnimation: (d) => {
              d.easeTo({ duration: 300, zoom: this._tr.zoom + (t.shiftKey ? -1 : 1), around: this._tr.unproject(s) }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class pp {
          constructor() {
            this._tap = new Vc({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(t, s, d) {
            if (!this._swipePoint) if (this._tapTime) {
              const g = s[0], w = t.timeStamp - this._tapTime < 500, S = this._tapPoint.dist(g) < 30;
              w && S ? d.length > 0 && (this._swipePoint = g, this._swipeTouch = d[0].identifier) : this.reset();
            } else this._tap.touchstart(t, s, d);
          }
          touchmove(t, s, d) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (d[0].identifier !== this._swipeTouch) return;
                const g = s[0], w = g.y - this._swipePoint.y;
                return this._swipePoint = g, t.preventDefault(), this._active = !0, { zoomDelta: w / 128 };
              }
            } else this._tap.touchmove(t, s, d);
          }
          touchend(t, s, d) {
            if (this._tapTime) this._swipePoint && d.length === 0 && this.reset();
            else {
              const g = this._tap.touchend(t, s, d);
              g && (this._tapTime = t.timeStamp, this._tapPoint = g);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class gp {
          constructor(t, s, d) {
            this._el = t, this._mousePan = s, this._touchPan = d;
          }
          enable(t) {
            this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Gs {
          constructor(t, s, d, g) {
            this._pitchWithRotate = t.pitchWithRotate, this._rollEnabled = t.rollEnabled, this._mouseRotate = s, this._mousePitch = d, this._mouseRoll = g;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Gu {
          constructor(t, s, d, g) {
            this._el = t, this._touchZoom = s, this._touchRotate = d, this._tapDragZoom = g, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(t) {
            this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Zt {
          constructor(t, s) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t, this._options = s, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const t = this._map.getCanvasContainer();
            t.classList.add("maplibregl-cooperative-gestures"), this._container = re.create("div", "maplibregl-cooperative-gesture-screen", t);
            let s = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (s = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const d = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), g = document.createElement("div");
            g.className = "maplibregl-desktop-message", g.textContent = s, this._container.appendChild(g);
            const w = document.createElement("div");
            w.className = "maplibregl-mobile-message", w.textContent = d, this._container.appendChild(w), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (re.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(t) {
            return t[this._bypassKey];
          }
          notifyGestureBlocked(t, s) {
            this._enabled && (this._map.fire(new u.l("cooperativegestureprevented", { gestureType: t, originalEvent: s })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const Jt = (b) => b.zoom || b.drag || b.roll || b.pitch || b.rotate;
        class ju extends u.l {
        }
        function Hc(b) {
          return b.panDelta && b.panDelta.mag() || b.zoomDelta || b.bearingDelta || b.pitchDelta || b.rollDelta;
        }
        class Yc {
          constructor(t, s) {
            this.handleWindowEvent = (g) => {
              this.handleEvent(g, `${g.type}Window`);
            }, this.handleEvent = (g, w) => {
              if (g.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const S = g.type === "renderFrame" ? void 0 : g, C = { needsRenderFrame: !1 }, A = {}, F = {};
              for (const { handlerName: V, handler: W, allowed: te } of this._handlers) {
                if (!W.isEnabled()) continue;
                let he;
                if (this._blockedByActive(F, te, V)) W.reset();
                else if (W[w || g.type]) {
                  if (u.cz(g, w || g.type)) {
                    const pe = re.mousePos(this._map.getCanvas(), g);
                    he = W[w || g.type](g, pe);
                  } else if (u.cA(g, w || g.type)) {
                    const pe = this._getMapTouches(g.touches), fe = re.touchPos(this._map.getCanvas(), pe);
                    he = W[w || g.type](g, fe, pe);
                  } else u.cB(w || g.type) || (he = W[w || g.type](g));
                  this.mergeHandlerResult(C, A, he, V, S), he && he.needsRenderFrame && this._triggerRenderFrame();
                }
                (he || W.isActive()) && (F[V] = W);
              }
              const O = {};
              for (const V in this._previousActiveHandlers) F[V] || (O[V] = S);
              this._previousActiveHandlers = F, (Object.keys(O).length || Hc(C)) && (this._changes.push([C, A, O]), this._triggerRenderFrame()), (Object.keys(F).length || Hc(C)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: q } = C;
              q && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], q(this._map));
            }, this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new um(t), this._bearingSnap = s.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(s);
            const d = this._el;
            this._listeners = [[d, "touchstart", { passive: !0 }], [d, "touchmove", { passive: !1 }], [d, "touchend", void 0], [d, "touchcancel", void 0], [d, "mousedown", void 0], [d, "mousemove", void 0], [d, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [d, "mouseover", void 0], [d, "mouseout", void 0], [d, "dblclick", void 0], [d, "click", void 0], [d, "keydown", { capture: !1 }], [d, "keyup", void 0], [d, "wheel", { passive: !1 }], [d, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [g, w, S] of this._listeners) re.addEventListener(g, w, g === document ? this.handleWindowEvent : this.handleEvent, S);
          }
          destroy() {
            for (const [t, s, d] of this._listeners) re.removeEventListener(t, s, t === document ? this.handleWindowEvent : this.handleEvent, d);
          }
          _addDefaultHandlers(t) {
            const s = this._map, d = s.getCanvasContainer();
            this._add("mapEvent", new cm(s, t));
            const g = s.boxZoom = new Dl(s, t);
            this._add("boxZoom", g), t.interactive && t.boxZoom && g.enable();
            const w = s.cooperativeGestures = new Zt(s, t.cooperativeGestures);
            this._add("cooperativeGestures", w), t.cooperativeGestures && w.enable();
            const S = new dd(s), C = new fp(s);
            s.doubleClickZoom = new yd(C, S), this._add("tapZoom", S), this._add("clickZoom", C), t.interactive && t.doubleClickZoom && s.doubleClickZoom.enable();
            const A = new pp();
            this._add("tapDragZoom", A);
            const F = s.touchPitch = new dp(s);
            this._add("touchPitch", F), t.interactive && t.touchPitch && s.touchPitch.enable(t.touchPitch);
            const O = () => s.project(s.getCenter()), q = (function({ enable: ve, clickTolerance: Ce, aroundCenter: Ne = !0, minPixelCenterThreshold: ke = 100, rotateDegreesPerPixelMoved: Ge = 0.8 }, at) {
              const tt = new zu({ checkCorrectEvent: (nt) => re.mouseButton(nt) === 0 && nt.ctrlKey || re.mouseButton(nt) === 2 && !nt.ctrlKey });
              return new Rl({ clickTolerance: Ce, move: (nt, it) => {
                const Et = at();
                if (Ne && Math.abs(Et.y - nt.y) > ke) return { bearingDelta: u.cx(new u.P(nt.x, it.y), it, Et) };
                let kt = (it.x - nt.x) * Ge;
                return Ne && it.y < Et.y && (kt = -kt), { bearingDelta: kt };
              }, moveStateManager: tt, enable: ve, assignEvents: Fl });
            })(t, O), V = (function({ enable: ve, clickTolerance: Ce, pitchDegreesPerPixelMoved: Ne = -0.5 }) {
              const ke = new zu({ checkCorrectEvent: (Ge) => re.mouseButton(Ge) === 0 && Ge.ctrlKey || re.mouseButton(Ge) === 2 });
              return new Rl({ clickTolerance: Ce, move: (Ge, at) => ({ pitchDelta: (at.y - Ge.y) * Ne }), moveStateManager: ke, enable: ve, assignEvents: Fl });
            })(t), W = (function({ enable: ve, clickTolerance: Ce, rollDegreesPerPixelMoved: Ne = 0.3 }, ke) {
              const Ge = new zu({ checkCorrectEvent: (at) => re.mouseButton(at) === 2 && at.ctrlKey });
              return new Rl({ clickTolerance: Ce, move: (at, tt) => {
                const nt = ke();
                let it = (tt.x - at.x) * Ne;
                return tt.y < nt.y && (it = -it), { rollDelta: it };
              }, moveStateManager: Ge, enable: ve, assignEvents: Fl });
            })(t, O);
            s.dragRotate = new Gs(t, q, V, W), this._add("mouseRotate", q, ["mousePitch"]), this._add("mousePitch", V, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", W, ["mousePitch"]), t.interactive && t.dragRotate && s.dragRotate.enable();
            const te = (function({ enable: ve, clickTolerance: Ce }) {
              const Ne = new zu({ checkCorrectEvent: (ke) => re.mouseButton(ke) === 0 && !ke.ctrlKey });
              return new Rl({ clickTolerance: Ce, move: (ke, Ge) => ({ around: Ge, panDelta: Ge.sub(ke) }), activateOnStart: !0, moveStateManager: Ne, enable: ve, assignEvents: Fl });
            })(t), he = new dm(t, s);
            s.dragPan = new gp(d, te, he), this._add("mousePan", te), this._add("touchPan", he, ["touchZoom", "touchRotate"]), t.interactive && t.dragPan && s.dragPan.enable(t.dragPan);
            const pe = new md(), fe = new gd();
            s.touchZoomRotate = new Gu(d, fe, pe, A), this._add("touchRotate", pe, ["touchPan", "touchZoom"]), this._add("touchZoom", fe, ["touchPan", "touchRotate"]), t.interactive && t.touchZoomRotate && s.touchZoomRotate.enable(t.touchZoomRotate), this._add("blockableMapEvent", new hm(s));
            const we = s.scrollZoom = new Zc(s, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", we, ["mousePan"]), t.interactive && t.scrollZoom && s.scrollZoom.enable(t.scrollZoom);
            const Le = s.keyboard = new Vr(s);
            this._add("keyboard", Le), t.interactive && t.keyboard && s.keyboard.enable();
          }
          _add(t, s, d) {
            this._handlers.push({ handlerName: t, handler: s, allowed: d }), this._handlersById[t] = s;
          }
          stop(t) {
            if (!this._updatingCamera) {
              for (const { handler: s } of this._handlers) s.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t } of this._handlers) if (t.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Jt(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(t, s, d) {
            for (const g in t) if (g !== d && (!s || s.indexOf(g) < 0)) return !0;
            return !1;
          }
          _getMapTouches(t) {
            const s = [];
            for (const d of t) this._el.contains(d.target) && s.push(d);
            return s;
          }
          mergeHandlerResult(t, s, d, g, w) {
            if (!d) return;
            u.e(t, d);
            const S = { handlerName: g, originalEvent: d.originalEvent || w };
            d.zoomDelta !== void 0 && (s.zoom = S), d.panDelta !== void 0 && (s.drag = S), d.rollDelta !== void 0 && (s.roll = S), d.pitchDelta !== void 0 && (s.pitch = S), d.bearingDelta !== void 0 && (s.rotate = S);
          }
          _applyChanges() {
            const t = {}, s = {}, d = {};
            for (const [g, w, S] of this._changes) g.panDelta && (t.panDelta = (t.panDelta || new u.P(0, 0))._add(g.panDelta)), g.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + g.zoomDelta), g.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + g.bearingDelta), g.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + g.pitchDelta), g.rollDelta && (t.rollDelta = (t.rollDelta || 0) + g.rollDelta), g.around !== void 0 && (t.around = g.around), g.pinchAround !== void 0 && (t.pinchAround = g.pinchAround), g.noInertia && (t.noInertia = g.noInertia), u.e(s, w), u.e(d, S);
            this._updateMapTransform(t, s, d), this._changes = [];
          }
          _updateMapTransform(t, s, d) {
            const g = this._map, w = g._getTransformForUpdate(), S = g.terrain;
            if (!(Hc(t) || S && this._terrainMovement)) return this._fireEvents(s, d, !0);
            g._stop(!0);
            let { panDelta: C, zoomDelta: A, bearingDelta: F, pitchDelta: O, rollDelta: q, around: V, pinchAround: W } = t;
            W !== void 0 && (V = W), V = V || g.transform.centerPoint, S && !w.isPointOnMapSurface(V) && (V = w.centerPoint);
            const te = { panDelta: C, zoomDelta: A, rollDelta: q, pitchDelta: O, bearingDelta: F, around: V };
            this._map.cameraHelper.useGlobeControls && !w.isPointOnMapSurface(V) && (V = w.centerPoint);
            const he = V.distSqr(w.centerPoint) < 0.01 ? w.center : w.screenPointToLocation(C ? V.sub(C) : V);
            this._handleMapControls({ terrain: S, tr: w, deltasForHelper: te, preZoomAroundLoc: he, combinedEventsInProgress: s, panDelta: C }), g._applyUpdatedTransform(w), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(s, d, !0);
          }
          _handleMapControls({ terrain: t, tr: s, deltasForHelper: d, preZoomAroundLoc: g, combinedEventsInProgress: w, panDelta: S }) {
            const C = this._map.cameraHelper;
            if (C.handleMapControlsRollPitchBearingZoom(d, s), t) return C.useGlobeControls ? (this._terrainMovement || !w.drag && !w.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void C.handleMapControlsPan(d, s, g)) : this._terrainMovement || !w.drag && !w.zoom ? void (w.drag && this._terrainMovement && S ? s.setCenter(s.screenPointToLocation(s.centerPoint.sub(S))) : C.handleMapControlsPan(d, s, g)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void C.handleMapControlsPan(d, s, g));
            C.handleMapControlsPan(d, s, g);
          }
          _fireEvents(t, s, d) {
            const g = Jt(this._eventsInProgress), w = Jt(t), S = {};
            for (const q in t) {
              const { originalEvent: V } = t[q];
              this._eventsInProgress[q] || (S[`${q}start`] = V), this._eventsInProgress[q] = t[q];
            }
            !g && w && this._fireEvent("movestart", w.originalEvent);
            for (const q in S) this._fireEvent(q, S[q]);
            w && this._fireEvent("move", w.originalEvent);
            for (const q in t) {
              const { originalEvent: V } = t[q];
              this._fireEvent(q, V);
            }
            const C = {};
            let A;
            for (const q in this._eventsInProgress) {
              const { handlerName: V, originalEvent: W } = this._eventsInProgress[q];
              this._handlersById[V].isActive() || (delete this._eventsInProgress[q], A = s[V] || W, C[`${q}end`] = A);
            }
            for (const q in C) this._fireEvent(q, C[q]);
            const F = Jt(this._eventsInProgress), O = (g || w) && !F;
            if (O && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const q = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && q.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(q);
            }
            if (d && O) {
              this._updatingCamera = !0;
              const q = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), V = (W) => W !== 0 && -this._bearingSnap < W && W < this._bearingSnap;
              !q || !q.essential && oe.prefersReducedMotion ? (this._map.fire(new u.l("moveend", { originalEvent: A })), V(this._map.getBearing()) && this._map.resetNorth()) : (V(q.bearing || this._map.getBearing()) && (q.bearing = 0), q.freezeElevation = !0, this._map.easeTo(q, { originalEvent: A })), this._updatingCamera = !1;
            }
          }
          _fireEvent(t, s) {
            this._map.fire(new u.l(t, s ? { originalEvent: s } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((t) => {
              delete this._frameId, this.handleEvent(new ju("renderFrame", { timeStamp: t })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Vi extends u.E {
          constructor(t, s, d) {
            super(), this._renderFrameCallback = () => {
              const g = Math.min((me() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(g)), g < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = d.bearingSnap, this.cameraHelper = s, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(t, s) {
            t.apply(this.transform, !0), this.transform = t, this.cameraHelper = s;
          }
          getCenter() {
            return new u.V(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t, s) {
            return this.jumpTo({ center: t }, s);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(t, s) {
            return this.jumpTo({ elevation: t }, s), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(t) {
            this._centerClampedToGround = t;
          }
          panBy(t, s, d) {
            return t = u.P.convert(t).mult(-1), this.panTo(this.transform.center, u.e({ offset: t }, s), d);
          }
          panTo(t, s, d) {
            return this.easeTo(u.e({ center: t }, s), d);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t, s) {
            return this.jumpTo({ zoom: t }, s), this;
          }
          zoomTo(t, s, d) {
            return this.easeTo(u.e({ zoom: t }, s), d);
          }
          zoomIn(t, s) {
            return this.zoomTo(this.getZoom() + 1, t, s), this;
          }
          zoomOut(t, s) {
            return this.zoomTo(this.getZoom() - 1, t, s), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(t, s) {
            return t != this.transform.fov && (this.transform.setFov(t), this.fire(new u.l("movestart", s)).fire(new u.l("move", s)).fire(new u.l("moveend", s))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t, s) {
            return this.jumpTo({ bearing: t }, s), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t, s) {
            return this.jumpTo({ padding: t }, s), this;
          }
          rotateTo(t, s, d) {
            return this.easeTo(u.e({ bearing: t }, s), d);
          }
          resetNorth(t, s) {
            return this.rotateTo(0, u.e({ duration: 1e3 }, t), s), this;
          }
          resetNorthPitch(t, s) {
            return this.easeTo(u.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, t), s), this;
          }
          snapToNorth(t, s) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, s) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t, s) {
            return this.jumpTo({ pitch: t }, s), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(t, s) {
            return this.jumpTo({ roll: t }, s), this;
          }
          cameraForBounds(t, s) {
            t = Nr.convert(t).adjustAntiMeridian();
            const d = s && s.bearing || 0;
            return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), d, s);
          }
          _cameraForBoxAndBearing(t, s, d, g) {
            const w = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (g = u.e({ padding: w, offset: [0, 0], maxZoom: this.transform.maxZoom }, g)).padding == "number") {
              const F = g.padding;
              g.padding = { top: F, bottom: F, right: F, left: F };
            }
            const S = u.e(w, g.padding);
            g.padding = S;
            const C = this.transform, A = new Nr(t, s);
            return this.cameraHelper.cameraForBoxAndBearing(g, S, A, d, C);
          }
          fitBounds(t, s, d) {
            return this._fitInternal(this.cameraForBounds(t, s), s, d);
          }
          fitScreenCoordinates(t, s, d, g, w) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(u.P.convert(t)), this.transform.screenPointToLocation(u.P.convert(s)), d, g), g, w);
          }
          _fitInternal(t, s, d) {
            return t ? (delete (s = u.e(t, s)).padding, s.linear ? this.easeTo(s, d) : this.flyTo(s, d)) : this;
          }
          jumpTo(t, s) {
            this.stop();
            const d = this._getTransformForUpdate();
            let g = !1, w = !1, S = !1;
            const C = d.zoom;
            this.cameraHelper.handleJumpToCenterZoom(d, t);
            const A = d.zoom !== C;
            return "elevation" in t && d.elevation !== +t.elevation && d.setElevation(+t.elevation), "bearing" in t && d.bearing !== +t.bearing && (g = !0, d.setBearing(+t.bearing)), "pitch" in t && d.pitch !== +t.pitch && (w = !0, d.setPitch(+t.pitch)), "roll" in t && d.roll !== +t.roll && (S = !0, d.setRoll(+t.roll)), t.padding == null || d.isPaddingEqual(t.padding) || d.setPadding(t.padding), this._applyUpdatedTransform(d), this.fire(new u.l("movestart", s)).fire(new u.l("move", s)), A && this.fire(new u.l("zoomstart", s)).fire(new u.l("zoom", s)).fire(new u.l("zoomend", s)), g && this.fire(new u.l("rotatestart", s)).fire(new u.l("rotate", s)).fire(new u.l("rotateend", s)), w && this.fire(new u.l("pitchstart", s)).fire(new u.l("pitch", s)).fire(new u.l("pitchend", s)), S && this.fire(new u.l("rollstart", s)).fire(new u.l("roll", s)).fire(new u.l("rollend", s)), this.fire(new u.l("moveend", s));
          }
          calculateCameraOptionsFromTo(t, s, d, g = 0) {
            const w = u.a9.fromLngLat(t, s), S = u.a9.fromLngLat(d, g), C = S.x - w.x, A = S.y - w.y, F = S.z - w.z, O = Math.hypot(C, A, F);
            if (O === 0) throw new Error("Can't calculate camera options with same From and To");
            const q = Math.hypot(C, A), V = u.at(this.transform.cameraToCenterDistance / O / this.transform.tileSize), W = 180 * Math.atan2(C, -A) / Math.PI;
            let te = 180 * Math.acos(q / O) / Math.PI;
            return te = F < 0 ? 90 - te : 90 + te, { center: S.toLngLat(), elevation: g, zoom: V, pitch: te, bearing: W };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(t, s, d, g, w) {
            const S = this.transform.calculateCenterFromCameraLngLatAlt(t, s, d, g);
            return { center: S.center, elevation: S.elevation, zoom: S.zoom, bearing: d, pitch: g, roll: w };
          }
          easeTo(t, s) {
            this._stop(!1, t.easeId), ((t = u.e({ offset: [0, 0], duration: 500, easing: u.cy }, t)).animate === !1 || !t.essential && oe.prefersReducedMotion) && (t.duration = 0);
            const d = this._getTransformForUpdate(), g = this.getBearing(), w = d.pitch, S = d.roll, C = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, A = "pitch" in t ? +t.pitch : w, F = "roll" in t ? this._normalizeBearing(t.roll, S) : S, O = "padding" in t ? t.padding : d.padding, q = u.P.convert(t.offset);
            let V, W;
            t.around && (V = u.V.convert(t.around), W = d.locationToScreenPoint(V));
            const te = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, he = this.cameraHelper.handleEaseTo(d, { bearing: C, pitch: A, roll: F, padding: O, around: V, aroundPoint: W, offsetAsPoint: q, offset: t.offset, zoom: t.zoom, center: t.center });
            return this._rotating = this._rotating || g !== C, this._pitching = this._pitching || A !== w, this._rolling = this._rolling || F !== S, this._padding = !d.isPaddingEqual(O), this._zooming = this._zooming || he.isZooming, this._easeId = t.easeId, this._prepareEase(s, t.noMoveStart, te), this.terrain && this._prepareElevation(he.elevationCenter), this._ease(((pe) => {
              he.easeFunc(pe), this.terrain && !t.freezeElevation && this._updateElevation(pe), this._applyUpdatedTransform(d), this._fireMoveEvents(s);
            }), ((pe) => {
              this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(s, pe);
            }), t), this;
          }
          _prepareEase(t, s, d = {}) {
            this._moving = !0, s || d.moving || this.fire(new u.l("movestart", t)), this._zooming && !d.zooming && this.fire(new u.l("zoomstart", t)), this._rotating && !d.rotating && this.fire(new u.l("rotatestart", t)), this._pitching && !d.pitching && this.fire(new u.l("pitchstart", t)), this._rolling && !d.rolling && this.fire(new u.l("rollstart", t));
          }
          _prepareElevation(t) {
            this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(t) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const s = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (t < 1 && s !== this._elevationTarget) {
              const d = this._elevationTarget - this._elevationStart;
              this._elevationStart += t * (d - (s - (d * t + this._elevationStart)) / (1 - t)), this._elevationTarget = s;
            }
            this.transform.setElevation(u.G.number(this._elevationStart, this._elevationTarget, t));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(t) {
            if (!this.terrain && t.elevation >= 0 && t.pitch <= 90) return {};
            const s = t.getCameraLngLat(), d = t.getCameraAltitude(), g = this.terrain ? this.terrain.getElevationForLngLatZoom(s, t.zoom) : 0;
            if (d < g) {
              const w = this.calculateCameraOptionsFromTo(s, g, t.center, t.elevation);
              return { pitch: w.pitch, zoom: w.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(t) {
            const s = [];
            if (s.push(((g) => this._elevateCameraIfInsideTerrain(g))), this.transformCameraUpdate && s.push(((g) => this.transformCameraUpdate(g))), !s.length) return;
            const d = t.clone();
            for (const g of s) {
              const w = d.clone(), { center: S, zoom: C, roll: A, pitch: F, bearing: O, elevation: q } = g(w);
              S && w.setCenter(S), q !== void 0 && w.setElevation(q), C !== void 0 && w.setZoom(C), A !== void 0 && w.setRoll(A), F !== void 0 && w.setPitch(F), O !== void 0 && w.setBearing(O), d.apply(w, !1);
            }
            this.transform.apply(d, !1);
          }
          _fireMoveEvents(t) {
            this.fire(new u.l("move", t)), this._zooming && this.fire(new u.l("zoom", t)), this._rotating && this.fire(new u.l("rotate", t)), this._pitching && this.fire(new u.l("pitch", t)), this._rolling && this.fire(new u.l("roll", t));
          }
          _afterEase(t, s) {
            if (this._easeId && s && this._easeId === s) return;
            delete this._easeId;
            const d = this._zooming, g = this._rotating, w = this._pitching, S = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, d && this.fire(new u.l("zoomend", t)), g && this.fire(new u.l("rotateend", t)), w && this.fire(new u.l("pitchend", t)), S && this.fire(new u.l("rollend", t)), this.fire(new u.l("moveend", t));
          }
          flyTo(t, s) {
            if (!t.essential && oe.prefersReducedMotion) {
              const it = u.U(t, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(it, s);
            }
            this.stop(), t = u.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: u.cy }, t);
            const d = this._getTransformForUpdate(), g = d.bearing, w = d.pitch, S = d.roll, C = d.padding, A = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, F = "pitch" in t ? +t.pitch : w, O = "roll" in t ? this._normalizeBearing(t.roll, S) : S, q = "padding" in t ? t.padding : d.padding, V = u.P.convert(t.offset);
            let W = d.centerPoint.add(V);
            const te = d.screenPointToLocation(W), he = this.cameraHelper.handleFlyTo(d, { bearing: A, pitch: F, roll: O, padding: q, locationAtOffset: te, offsetAsPoint: V, center: t.center, minZoom: t.minZoom, zoom: t.zoom });
            let pe = t.curve;
            const fe = Math.max(d.width, d.height), we = fe / he.scaleOfZoom, Le = he.pixelPathLength;
            typeof he.scaleOfMinZoom == "number" && (pe = Math.sqrt(fe / he.scaleOfMinZoom / Le * 2));
            const ve = pe * pe;
            function Ce(it) {
              const Et = (we * we - fe * fe + (it ? -1 : 1) * ve * ve * Le * Le) / (2 * (it ? we : fe) * ve * Le);
              return Math.log(Math.sqrt(Et * Et + 1) - Et);
            }
            function Ne(it) {
              return (Math.exp(it) - Math.exp(-it)) / 2;
            }
            function ke(it) {
              return (Math.exp(it) + Math.exp(-it)) / 2;
            }
            const Ge = Ce(!1);
            let at = function(it) {
              return ke(Ge) / ke(Ge + pe * it);
            }, tt = function(it) {
              return fe * ((ke(Ge) * (Ne(Et = Ge + pe * it) / ke(Et)) - Ne(Ge)) / ve) / Le;
              var Et;
            }, nt = (Ce(!0) - Ge) / pe;
            if (Math.abs(Le) < 2e-6 || !isFinite(nt)) {
              if (Math.abs(fe - we) < 1e-6) return this.easeTo(t, s);
              const it = we < fe ? -1 : 1;
              nt = Math.abs(Math.log(we / fe)) / pe, tt = () => 0, at = (Et) => Math.exp(it * pe * Et);
            }
            return t.duration = "duration" in t ? +t.duration : 1e3 * nt / ("screenSpeed" in t ? +t.screenSpeed / pe : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = !0, this._rotating = g !== A, this._pitching = F !== w, this._rolling = O !== S, this._padding = !d.isPaddingEqual(q), this._prepareEase(s, !1), this.terrain && this._prepareElevation(he.targetCenter), this._ease(((it) => {
              const Et = it * nt, kt = 1 / at(Et), gt = tt(Et);
              this._rotating && d.setBearing(u.G.number(g, A, it)), this._pitching && d.setPitch(u.G.number(w, F, it)), this._rolling && d.setRoll(u.G.number(S, O, it)), this._padding && (d.interpolatePadding(C, q, it), W = d.centerPoint.add(V)), he.easeFunc(it, kt, gt, W), this.terrain && !t.freezeElevation && this._updateElevation(it), this._applyUpdatedTransform(d), this._fireMoveEvents(s);
            }), (() => {
              this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(s);
            }), t), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t, s) {
            var d;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const g = this._onEaseEnd;
              delete this._onEaseEnd, g.call(this, s);
            }
            return t || (d = this.handlers) === null || d === void 0 || d.stop(!1), this;
          }
          _ease(t, s, d) {
            d.animate === !1 || d.duration === 0 ? (t(1), s()) : (this._easeStart = me(), this._easeOptions = d, this._onEaseFrame = t, this._onEaseEnd = s, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(t, s) {
            t = u.W(t, -180, 180);
            const d = Math.abs(t - s);
            return Math.abs(t - 360 - s) < d && (t -= 360), Math.abs(t + 360 - s) < d && (t += 360), t;
          }
          queryTerrainElevation(t) {
            return this.terrain ? this.terrain.getElevationForLngLat(u.V.convert(t), this.transform) : null;
          }
        }
        const Es = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class vd {
          constructor(t = Es) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (s) => {
              !s || s.sourceDataType !== "metadata" && s.sourceDataType !== "visibility" && s.dataType !== "style" && s.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = t;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t) {
            return this._map = t, this._compact = this.options.compact, this._container = re.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = re.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = re.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            re.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t, s) {
            const d = this._map._getUIString(`AttributionControl.${s}`);
            t.title = d, t.setAttribute("aria-label", d);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let t = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map(((g) => typeof g != "string" ? "" : g))) : typeof this.options.customAttribution == "string" && t.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const g = this._map.style.stylesheet;
              this.styleOwner = g.owner, this.styleId = g.id;
            }
            const s = this._map.style.tileManagers;
            for (const g in s) {
              const w = s[g];
              if (w.used || w.usedForTerrain) {
                const S = w.getSource();
                S.attribution && t.indexOf(S.attribution) < 0 && t.push(S.attribution);
              }
            }
            t = t.filter(((g) => String(g).trim())), t.sort(((g, w) => g.length - w.length)), t = t.filter(((g, w) => {
              for (let S = w + 1; S < t.length; S++) if (t[S].indexOf(g) >= 0) return !1;
              return !0;
            }));
            const d = t.join(" | ");
            d !== this._attribHTML && (this._attribHTML = d, t.length ? (this._innerContainer.innerHTML = re.sanitize(d), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class mp {
          constructor(t = {}) {
            this._updateCompact = () => {
              const s = this._container.children;
              if (s.length) {
                const d = s[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && d.classList.add("maplibregl-compact") : d.classList.remove("maplibregl-compact");
              }
            }, this.options = t;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t) {
            this._map = t, this._compact = this.options && this.options.compact, this._container = re.create("div", "maplibregl-ctrl");
            const s = re.create("a", "maplibregl-ctrl-logo");
            return s.target = "_blank", s.rel = "noopener nofollow", s.href = "https://maplibre.org/", s.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), s.setAttribute("rel", "noopener nofollow"), this._container.appendChild(s), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            re.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class pm {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(t) {
            const s = ++this._id;
            return this._queue.push({ callback: t, id: s, cancelled: !1 }), s;
          }
          remove(t) {
            const s = this._currentlyRunning, d = s ? this._queue.concat(s) : this._queue;
            for (const g of d) if (g.id === t) return void (g.cancelled = !0);
          }
          run(t = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const s = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const d of s) if (!d.cancelled && (d.callback(t), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var gm = u.aU([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Vu extends u.E {
          constructor(t) {
            super(), this._lastTilesetChange = me(), this.tileManager = t, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = t._source.tileSize * 2 ** this.deltaZoom, t.usedForTerrain = !0, t.tileSize = this.tileSize;
          }
          destruct() {
            this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null;
          }
          getSource() {
            return this.tileManager._source;
          }
          update(t, s) {
            this.tileManager.update(t, s), this._renderableTilesKeys = [];
            const d = {};
            for (const g of Pr(t, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: s, calculateTileZoom: this.tileManager._source.calculateTileZoom })) d[g.key] = !0, this._renderableTilesKeys.push(g.key), this._tiles[g.key] || (g.terrainRttPosMatrix32f = new Float64Array(16), u.c7(g.terrainRttPosMatrix32f, 0, u.a5, u.a5, 0, 0, 1), this._tiles[g.key] = new ft(g, this.tileSize), this._lastTilesetChange = me());
            for (const g in this._tiles) d[g] || delete this._tiles[g];
          }
          freeRtt(t) {
            for (const s in this._tiles) {
              const d = this._tiles[s];
              (!t || d.tileID.equals(t) || d.tileID.isChildOf(t) || t.isChildOf(d.tileID)) && (d.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((t) => this.getTileByID(t)));
          }
          getTileByID(t) {
            return this._tiles[t];
          }
          getTerrainCoords(t, s) {
            return s ? this._getTerrainCoordsForTileRanges(t, s) : this._getTerrainCoordsForRegularTile(t);
          }
          _getTerrainCoordsForRegularTile(t) {
            const s = {};
            for (const d of this._renderableTilesKeys) {
              const g = this._tiles[d].tileID, w = t.clone(), S = u.bk();
              if (g.canonical.equals(t.canonical)) u.c7(S, 0, u.a5, u.a5, 0, 0, 1);
              else if (g.canonical.isChildOf(t.canonical)) {
                const C = g.canonical.z - t.canonical.z, A = g.canonical.x - (g.canonical.x >> C << C), F = g.canonical.y - (g.canonical.y >> C << C), O = u.a5 >> C;
                u.c7(S, 0, O, O, 0, 0, 1), u.O(S, S, [-A * O, -F * O, 0]);
              } else {
                if (!t.canonical.isChildOf(g.canonical)) continue;
                {
                  const C = t.canonical.z - g.canonical.z, A = t.canonical.x - (t.canonical.x >> C << C), F = t.canonical.y - (t.canonical.y >> C << C), O = u.a5 >> C;
                  u.c7(S, 0, u.a5, u.a5, 0, 0, 1), u.O(S, S, [A * O, F * O, 0]), u.Q(S, S, [1 / 2 ** C, 1 / 2 ** C, 0]);
                }
              }
              w.terrainRttPosMatrix32f = new Float32Array(S), s[d] = w;
            }
            return s;
          }
          _getTerrainCoordsForTileRanges(t, s) {
            const d = {};
            for (const g of this._renderableTilesKeys) {
              const w = this._tiles[g].tileID;
              if (!this._isWithinTileRanges(w, s)) continue;
              const S = t.clone(), C = u.bk();
              if (w.canonical.z === t.canonical.z) {
                const A = t.canonical.x - w.canonical.x + t.wrap * (1 << t.canonical.z), F = t.canonical.y - w.canonical.y;
                u.c7(C, 0, u.a5, u.a5, 0, 0, 1), u.O(C, C, [A * u.a5, F * u.a5, 0]);
              } else if (w.canonical.z > t.canonical.z) {
                const A = w.canonical.z - t.canonical.z, F = w.canonical.x - (w.canonical.x >> A << A) + t.wrap * (1 << w.canonical.z), O = w.canonical.y - (w.canonical.y >> A << A), q = t.canonical.x - (w.canonical.x >> A), V = t.canonical.y - (w.canonical.y >> A), W = u.a5 >> A;
                u.c7(C, 0, W, W, 0, 0, 1), u.O(C, C, [-F * W + q * u.a5, -O * W + V * u.a5, 0]);
              } else {
                const A = t.canonical.z - w.canonical.z, F = t.canonical.x - (t.canonical.x >> A << A) + t.wrap * (1 << t.canonical.z), O = t.canonical.y - (t.canonical.y >> A << A), q = (t.canonical.x >> A) - w.canonical.x, V = (t.canonical.y >> A) - w.canonical.y, W = u.a5 << A;
                u.c7(C, 0, W, W, 0, 0, 1), u.O(C, C, [F * u.a5 + q * W, O * u.a5 + V * W, 0]);
              }
              S.terrainRttPosMatrix32f = new Float32Array(C), d[g] = S;
            }
            return d;
          }
          getSourceTile(t, s) {
            const d = this.tileManager._source;
            let g = t.overscaledZ - this.deltaZoom;
            if (g > d.maxzoom && (g = d.maxzoom), g < d.minzoom) return;
            this._sourceTileCache[t.key] || (this._sourceTileCache[t.key] = t.scaledTo(g).key);
            let w = this.findTileInCaches(this._sourceTileCache[t.key]);
            if (!w?.dem && s) for (; g >= d.minzoom && !w?.dem; ) w = this.findTileInCaches(t.scaledTo(g--).key);
            return w;
          }
          findTileInCaches(t) {
            let s = this.tileManager.getTileByID(t);
            return s || (s = this.tileManager._outOfViewCache.getByKey(t), s);
          }
          anyTilesAfterTime(t = Date.now()) {
            return this._lastTilesetChange >= t;
          }
          _isWithinTileRanges(t, s) {
            const d = s[t.canonical.z];
            return !!d && (t.wrap > d.minWrap || t.wrap < d.maxWrap || t.canonical.x >= d.minTileXWrapped && t.canonical.x <= d.maxTileXWrapped && t.canonical.y >= d.minTileY && t.canonical.y <= d.maxTileY);
          }
        }
        class mn {
          constructor(t, s, d) {
            this._meshCache = {}, this.painter = t, this.tileManager = new Vu(s), this.options = d, this.exaggeration = typeof d.exaggeration == "number" ? d.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(t, s, d, g = u.a5) {
            var w;
            if (!(s >= 0 && s < g && d >= 0 && d < g)) return 0;
            const S = this.getTerrainData(t), C = (w = S.tile) === null || w === void 0 ? void 0 : w.dem;
            if (!C) return 0;
            const A = u.cC([], [s / g * u.a5, d / g * u.a5], S.u_terrain_matrix), F = [A[0] * C.dim, A[1] * C.dim], O = Math.floor(F[0]), q = Math.floor(F[1]), V = F[0] - O, W = F[1] - q;
            return C.get(O, q) * (1 - V) * (1 - W) + C.get(O + 1, q) * V * (1 - W) + C.get(O, q + 1) * (1 - V) * W + C.get(O + 1, q + 1) * V * W;
          }
          getElevationForLngLatZoom(t, s) {
            if (!u.cD(s, t.wrap())) return 0;
            const { tileID: d, mercatorX: g, mercatorY: w } = this._getOverscaledTileIDFromLngLatZoom(t, s);
            return this.getElevation(d, g % u.a5, w % u.a5, u.a5);
          }
          getElevationForLngLat(t, s) {
            const d = Pr(s, { maxzoom: this.tileManager.maxzoom, minzoom: this.tileManager.minzoom, tileSize: 512, terrain: this });
            let g = 0;
            for (const w of d) w.canonical.z > g && (g = Math.min(w.canonical.z, this.tileManager.maxzoom));
            return this.getElevationForLngLatZoom(t, g);
          }
          getElevation(t, s, d, g = u.a5) {
            return this.getDEMElevation(t, s, d, g) * this.exaggeration;
          }
          getTerrainData(t) {
            if (!this._emptyDemTexture) {
              const g = this.painter.context, w = new u.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new u.T(g, w, g.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new u.T(g, new u.R({ width: 1, height: 1 }), g.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(g.gl.NEAREST, g.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = u.ar([]);
            }
            const s = this.tileManager.getSourceTile(t, !0);
            if (s && s.dem && (!s.demTexture || s.needsTerrainPrepare)) {
              const g = this.painter.context;
              s.demTexture = this.painter.getTileTexture(s.dem.stride), s.demTexture ? s.demTexture.update(s.dem.getPixels(), { premultiply: !1 }) : s.demTexture = new u.T(g, s.dem.getPixels(), g.gl.RGBA, { premultiply: !1 }), s.demTexture.bind(g.gl.NEAREST, g.gl.CLAMP_TO_EDGE), s.needsTerrainPrepare = !1;
            }
            const d = s && s.toString() + s.tileID.key + t.key;
            if (d && !this._demMatrixCache[d]) {
              const g = this.tileManager.getSource().maxzoom;
              let w = t.canonical.z - s.tileID.canonical.z;
              t.overscaledZ > t.canonical.z && (t.canonical.z >= g ? w = t.canonical.z - g : u.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const S = t.canonical.x - (t.canonical.x >> w << w), C = t.canonical.y - (t.canonical.y >> w << w), A = u.cE(new Float64Array(16), [1 / (u.a5 << w), 1 / (u.a5 << w), 0]);
              u.O(A, A, [S * u.a5, C * u.a5, 0]), this._demMatrixCache[t.key] = { matrix: A, coord: t };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: s && s.dem && s.dem.dim || 1, u_terrain_matrix: d ? this._demMatrixCache[t.key].matrix : this._emptyDemMatrix, u_terrain_unpack: s && s.dem && s.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (s && s.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: s };
          }
          getFramebuffer(t) {
            const s = this.painter, d = s.width / devicePixelRatio, g = s.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === d && this._fbo.height === g || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new u.T(s.context, { width: d, height: g, data: null }, s.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new u.T(s.context, { width: d, height: g, data: null }, s.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = s.context.createFramebuffer(d, g, !0, !1), this._fbo.depthAttachment.set(s.context.createRenderbuffer(s.context.gl.DEPTH_COMPONENT16, d, g))), this._fbo.colorAttachment.set(t === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const t = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const s = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let w = 0, S = 0; w < this._coordsTextureSize; w++) for (let C = 0; C < this._coordsTextureSize; C++, S += 4) s[S + 0] = 255 & C, s[S + 1] = 255 & w, s[S + 2] = C >> 8 << 4 | w >> 8, s[S + 3] = 0;
            const d = new u.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(s.buffer)), g = new u.T(t, d, t.gl.RGBA, { premultiply: !1 });
            return g.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE), this._coordsTexture = g, g;
          }
          pointCoordinate(t) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const s = new Uint8Array(4), d = this.painter.context, g = d.gl, w = Math.round(t.x * this.painter.pixelRatio / devicePixelRatio), S = Math.round(t.y * this.painter.pixelRatio / devicePixelRatio), C = Math.round(this.painter.height / devicePixelRatio);
            d.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), g.readPixels(w, C - S - 1, 1, 1, g.RGBA, g.UNSIGNED_BYTE, s), d.bindFramebuffer.set(null);
            const A = s[0] + (s[2] >> 4 << 8), F = s[1] + ((15 & s[2]) << 8), O = this.coordsIndex[255 - s[3]], q = O && this.tileManager.getTileByID(O);
            if (!q) return null;
            const V = this._coordsTextureSize, W = (1 << q.tileID.canonical.z) * V;
            return new u.a9((q.tileID.canonical.x * V + A) / W + q.tileID.wrap, (q.tileID.canonical.y * V + F) / W, this.getElevation(q.tileID, A, F, V));
          }
          depthAtPoint(t) {
            const s = new Uint8Array(4), d = this.painter.context, g = d.gl;
            return d.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), g.readPixels(t.x, this.painter.height / devicePixelRatio - t.y - 1, 1, 1, g.RGBA, g.UNSIGNED_BYTE, s), d.bindFramebuffer.set(null), (s[0] / 16777216 + s[1] / 65536 + s[2] / 256 + s[3]) / 256;
          }
          getTerrainMesh(t) {
            var s;
            const d = ((s = this.painter.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0, g = d && t.canonical.y === 0, w = d && t.canonical.y === (1 << t.canonical.z) - 1, S = `m_${g ? "n" : ""}_${w ? "s" : ""}`;
            if (this._meshCache[S]) return this._meshCache[S];
            const C = this.painter.context, A = new u.cF(), F = new u.aY(), O = this.meshSize, q = u.a5 / O, V = O * O;
            for (let ke = 0; ke <= O; ke++) for (let Ge = 0; Ge <= O; Ge++) A.emplaceBack(Ge * q, ke * q, 0);
            for (let ke = 0; ke < V; ke += O + 1) for (let Ge = 0; Ge < O; Ge++) F.emplaceBack(Ge + ke, O + Ge + ke + 1, O + Ge + ke + 2), F.emplaceBack(Ge + ke, O + Ge + ke + 2, Ge + ke + 1);
            const W = A.length, te = W + (O + 1), he = (O + 1) * O, pe = g ? u.br : 0, fe = g ? 0 : 1, we = w ? u.bs : u.a5, Le = w ? 0 : 1;
            for (let ke = 0; ke <= O; ke++) A.emplaceBack(ke * q, pe, fe);
            for (let ke = 0; ke <= O; ke++) A.emplaceBack(ke * q, we, Le);
            for (let ke = 0; ke < O; ke++) F.emplaceBack(he + ke, te + ke, te + ke + 1), F.emplaceBack(he + ke, te + ke + 1, he + ke + 1), F.emplaceBack(0 + ke, W + ke + 1, W + ke), F.emplaceBack(0 + ke, 0 + ke + 1, W + ke + 1);
            const ve = A.length, Ce = ve + 2 * (O + 1);
            for (const ke of [0, 1]) for (let Ge = 0; Ge <= O; Ge++) for (const at of [0, 1]) A.emplaceBack(ke * u.a5, Ge * q, at);
            for (let ke = 0; ke < 2 * O; ke += 2) F.emplaceBack(ve + ke, ve + ke + 1, ve + ke + 3), F.emplaceBack(ve + ke, ve + ke + 3, ve + ke + 2), F.emplaceBack(Ce + ke, Ce + ke + 3, Ce + ke + 1), F.emplaceBack(Ce + ke, Ce + ke + 2, Ce + ke + 3);
            const Ne = new Lr(C.createVertexBuffer(A, gm.members), C.createIndexBuffer(F), u.aX.simpleSegment(0, 0, A.length, F.length));
            return this._meshCache[S] = Ne, Ne;
          }
          getMeshFrameDelta(t) {
            return 2 * Math.PI * u.bE / Math.pow(2, Math.max(t, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(t, s) {
            var d;
            if (!u.cD(s, t.wrap())) return 0;
            const { tileID: g } = this._getOverscaledTileIDFromLngLatZoom(t, s);
            return (d = this.getMinMaxElevation(g).minElevation) !== null && d !== void 0 ? d : 0;
          }
          getMinMaxElevation(t) {
            const s = this.getTerrainData(t).tile, d = { minElevation: null, maxElevation: null };
            return s && s.dem && (d.minElevation = s.dem.min * this.exaggeration, d.maxElevation = s.dem.max * this.exaggeration), d;
          }
          _getOverscaledTileIDFromLngLatZoom(t, s) {
            const d = u.a9.fromLngLat(t.wrap()), g = (1 << s) * u.a5, w = d.x * g, S = d.y * g, C = Math.floor(w / u.a5), A = Math.floor(S / u.a5);
            return { tileID: new u.a2(s, 0, s, C, A), mercatorX: w, mercatorY: S };
          }
        }
        class An {
          constructor(t, s, d) {
            this._context = t, this._size = s, this._tileSize = d, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const t of this._objects) t.texture.destroy(), t.fbo.destroy();
          }
          _createObject(t) {
            const s = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), d = new u.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return d.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), s.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), s.colorAttachment.set(d.texture), { id: t, fbo: s, texture: d, stamp: -1, inUse: !1 };
          }
          getObjectForId(t) {
            return this._objects[t];
          }
          useObject(t) {
            t.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((s) => t.id !== s)), this._recentlyUsed.push(t.id);
          }
          stampObject(t) {
            t.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const s of this._recentlyUsed) if (!this._objects[s].inUse) return this._objects[s];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const t = this._createObject(this._objects.length);
            return this._objects.push(t), t;
          }
          freeObject(t) {
            t.inUse = !1;
          }
          freeAllObjects() {
            for (const t of this._objects) this.freeObject(t);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((t) => !t.inUse)) === !1;
          }
        }
        const Zo = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 };
        class Uu {
          constructor(t, s) {
            this.painter = t, this.terrain = s, this.pool = new An(t.context, 30, s.tileManager.tileSize * s.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t) {
            return this.pool.getObjectForId(t.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t, s) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = t._order.filter(((d) => !t._layers[d].isHidden(s))), this._coordsAscending = {};
            for (const d in t.tileManagers) {
              this._coordsAscending[d] = {};
              const g = t.tileManagers[d].getVisibleCoordinates(), w = t.tileManagers[d].getSource(), S = w instanceof Kr ? w.terrainTileRanges : null;
              for (const C of g) {
                const A = this.terrain.tileManager.getTerrainCoords(C, S);
                for (const F in A) this._coordsAscending[d][F] || (this._coordsAscending[d][F] = []), this._coordsAscending[d][F].push(A[F]);
              }
            }
            this._coordsAscendingStr = {};
            for (const d of t._order) {
              const g = t._layers[d], w = g.source;
              if (Zo[g.type] && !this._coordsAscendingStr[w]) {
                this._coordsAscendingStr[w] = {};
                for (const S in this._coordsAscending[w]) this._coordsAscendingStr[w][S] = this._coordsAscending[w][S].map(((C) => C.key)).sort().join();
              }
            }
            for (const d of this._renderableTiles) for (const g in this._coordsAscendingStr) {
              const w = this._coordsAscendingStr[g][d.tileID.key];
              w && w !== d.rttCoords[g] && (d.rtt = []);
            }
          }
          renderLayer(t, s) {
            if (t.isHidden(this.painter.transform.zoom)) return !1;
            const d = Object.assign(Object.assign({}, s), { isRenderingToTexture: !0 }), g = t.type, w = this.painter, S = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t.id;
            if (Zo[g] && (this._prevType && Zo[this._prevType] || this._stacks.push([]), this._prevType = g, this._stacks[this._stacks.length - 1].push(t.id), !S)) return !0;
            if (Zo[this._prevType] || Zo[g] && S) {
              this._prevType = g;
              const C = this._stacks.length - 1, A = this._stacks[C] || [];
              for (const F of this._renderableTiles) {
                if (this.pool.isFull() && (ld(this.painter, this.terrain, this._rttTiles, d), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(F), F.rtt[C]) {
                  const q = this.pool.getObjectForId(F.rtt[C].id);
                  if (q.stamp === F.rtt[C].stamp) {
                    this.pool.useObject(q);
                    continue;
                  }
                }
                const O = this.pool.getOrCreateFreeObject();
                this.pool.useObject(O), this.pool.stampObject(O), F.rtt[C] = { id: O.id, stamp: O.stamp }, w.context.bindFramebuffer.set(O.fbo.framebuffer), w.context.clear({ color: u.bp.transparent, stencil: 0 }), w.currentStencilSource = void 0;
                for (let q = 0; q < A.length; q++) {
                  const V = w.style._layers[A[q]], W = V.source ? this._coordsAscending[V.source][F.tileID.key] : [F.tileID];
                  w.context.viewport.set([0, 0, O.fbo.width, O.fbo.height]), w._renderTileClippingMasks(V, W, !0), w.renderLayer(w, w.style.tileManagers[V.source], V, W, d), V.source && (F.rttCoords[V.source] = this._coordsAscendingStr[V.source][F.tileID.key]);
                }
              }
              return ld(this.painter, this.terrain, this._rttTiles, d), this._rttTiles = [], this.pool.freeAllObjects(), Zo[g];
            }
            return !1;
          }
        }
        const Wc = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, xd = R, Xc = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: Es, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: u.c.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, reduceMotion: void 0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0, experimentalZoomLevelsToOverscale: void 0 }, bd = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class qu {
          constructor(t, s, d = !1) {
            this.mousedown = (w) => {
              this.startMove(w, re.mousePos(this.element, w)), re.addEventListener(window, "mousemove", this.mousemove), re.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (w) => {
              this.move(w, re.mousePos(this.element, w));
            }, this.mouseup = (w) => {
              this._rotatePitchHandler.dragEnd(w), this.offTemp();
            }, this.touchstart = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = re.touchPos(this.element, w.targetTouches)[0], this.startMove(w, this._startPos), re.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), re.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._lastPos = re.touchPos(this.element, w.targetTouches)[0], this.move(w, this._lastPos));
            }, this.touchend = (w) => {
              w.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = s;
            const g = new up();
            this._rotatePitchHandler = new Rl({ clickTolerance: 3, move: (w, S) => {
              const C = s.getBoundingClientRect(), A = new u.P((C.bottom - C.top) / 2, (C.right - C.left) / 2);
              return { bearingDelta: u.cx(new u.P(w.x, S.y), S, A), pitchDelta: d ? -0.5 * (S.y - w.y) : void 0 };
            }, moveStateManager: g, enable: !0, assignEvents: () => {
            } }), this.map = t, re.addEventListener(s, "mousedown", this.mousedown), re.addEventListener(s, "touchstart", this.touchstart, { passive: !1 }), re.addEventListener(s, "touchcancel", this.reset);
          }
          startMove(t, s) {
            this._rotatePitchHandler.dragStart(t, s), re.disableDrag();
          }
          move(t, s) {
            const d = this.map, { bearingDelta: g, pitchDelta: w } = this._rotatePitchHandler.dragMove(t, s) || {};
            g && d.setBearing(d.getBearing() + g), w && d.setPitch(d.getPitch() + w);
          }
          off() {
            const t = this.element;
            re.removeEventListener(t, "mousedown", this.mousedown), re.removeEventListener(t, "touchstart", this.touchstart, { passive: !1 }), re.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), re.removeEventListener(window, "touchend", this.touchend), re.removeEventListener(t, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            re.enableDrag(), re.removeEventListener(window, "mousemove", this.mousemove), re.removeEventListener(window, "mouseup", this.mouseup), re.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), re.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let La;
        function Jc(b, t, s, d = !1) {
          if (d || !s.getCoveringTilesDetailsProvider().allowWorldCopies()) return b?.wrap();
          const g = new u.V(b.lng, b.lat);
          if (b = new u.V(b.lng, b.lat), t) {
            const w = new u.V(b.lng - 360, b.lat), S = new u.V(b.lng + 360, b.lat), C = s.locationToScreenPoint(b).distSqr(t);
            s.locationToScreenPoint(w).distSqr(t) < C ? b = w : s.locationToScreenPoint(S).distSqr(t) < C && (b = S);
          }
          for (; Math.abs(b.lng - s.center.lng) > 180; ) {
            const w = s.locationToScreenPoint(b);
            if (w.x >= 0 && w.y >= 0 && w.x <= s.width && w.y <= s.height) break;
            b.lng > s.center.lng ? b.lng -= 360 : b.lng += 360;
          }
          return b.lng !== g.lng && s.isPointOnMapSurface(s.locationToScreenPoint(b)) ? b : g;
        }
        const $u = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Kc(b, t, s) {
          const d = b.classList;
          for (const g in $u) d.remove(`maplibregl-${s}-anchor-${g}`);
          d.add(`maplibregl-${s}-anchor-${t}`);
        }
        class Zu extends u.E {
          constructor(t) {
            if (super(), this._onKeyPress = (s) => {
              const d = s.code, g = s.charCode || s.keyCode;
              d !== "Space" && d !== "Enter" && g !== 32 && g !== 13 || this.togglePopup();
            }, this._onMapClick = (s) => {
              const d = s.originalEvent.target, g = this._element;
              this._popup && (d === g || g.contains(d)) && this.togglePopup();
            }, this._update = (s) => {
              if (!this._map) return;
              const d = this._map.loaded() && !this._map.isMoving();
              (s?.type === "terrain" || s?.type === "render" && !d) && this._map.once("render", this._update), this._lngLat = Jc(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let g = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? g = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (g = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let w = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? w = "rotateX(0deg)" : this._pitchAlignment === "map" && (w = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || s && s.type !== "moveend" || (this._pos = this._pos.round()), re.setTransform(this._element, `${$u[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${w} ${g}`), oe.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(s && s.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (s) => {
              if (!this._isDragging) {
                const d = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = s.point.dist(this._pointerdownPos) >= d;
              }
              this._isDragging && (this._pos = s.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new u.l("dragstart"))), this.fire(new u.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new u.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (s) => {
              this._element.contains(s.originalEvent.target) && (s.preventDefault(), this._positionDelta = s.point.sub(this._pos).add(this._offset), this._pointerdownPos = s.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._subpixelPositioning = t && t.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(t?.opacity, t?.opacityWhenCovered), t && t.element) this._element = t.element, this._offset = u.P.convert(t && t.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = re.create("div");
              const s = re.createNS("http://www.w3.org/2000/svg", "svg"), d = 41, g = 27;
              s.setAttributeNS(null, "display", "block"), s.setAttributeNS(null, "height", `${d}px`), s.setAttributeNS(null, "width", `${g}px`), s.setAttributeNS(null, "viewBox", `0 0 ${g} ${d}`);
              const w = re.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
              const S = re.createNS("http://www.w3.org/2000/svg", "g");
              S.setAttributeNS(null, "fill-rule", "nonzero");
              const C = re.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), C.setAttributeNS(null, "fill", "#000000");
              const A = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const fe of A) {
                const we = re.createNS("http://www.w3.org/2000/svg", "ellipse");
                we.setAttributeNS(null, "opacity", "0.04"), we.setAttributeNS(null, "cx", "10.5"), we.setAttributeNS(null, "cy", "5.80029008"), we.setAttributeNS(null, "rx", fe.rx), we.setAttributeNS(null, "ry", fe.ry), C.appendChild(we);
              }
              const F = re.createNS("http://www.w3.org/2000/svg", "g");
              F.setAttributeNS(null, "fill", this._color);
              const O = re.createNS("http://www.w3.org/2000/svg", "path");
              O.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), F.appendChild(O);
              const q = re.createNS("http://www.w3.org/2000/svg", "g");
              q.setAttributeNS(null, "opacity", "0.25"), q.setAttributeNS(null, "fill", "#000000");
              const V = re.createNS("http://www.w3.org/2000/svg", "path");
              V.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), q.appendChild(V);
              const W = re.createNS("http://www.w3.org/2000/svg", "g");
              W.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), W.setAttributeNS(null, "fill", "#FFFFFF");
              const te = re.createNS("http://www.w3.org/2000/svg", "g");
              te.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const he = re.createNS("http://www.w3.org/2000/svg", "circle");
              he.setAttributeNS(null, "fill", "#000000"), he.setAttributeNS(null, "opacity", "0.25"), he.setAttributeNS(null, "cx", "5.5"), he.setAttributeNS(null, "cy", "5.5"), he.setAttributeNS(null, "r", "5.4999962");
              const pe = re.createNS("http://www.w3.org/2000/svg", "circle");
              pe.setAttributeNS(null, "fill", "#FFFFFF"), pe.setAttributeNS(null, "cx", "5.5"), pe.setAttributeNS(null, "cy", "5.5"), pe.setAttributeNS(null, "r", "5.4999962"), te.appendChild(he), te.appendChild(pe), S.appendChild(C), S.appendChild(F), S.appendChild(q), S.appendChild(W), S.appendChild(te), s.appendChild(S), s.setAttributeNS(null, "height", d * this._scale + "px"), s.setAttributeNS(null, "width", g * this._scale + "px"), this._element.appendChild(s), this._offset = u.P.convert(t && t.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((s) => {
              s.preventDefault();
            })), this._element.addEventListener("mousedown", ((s) => {
              s.preventDefault();
            })), Kc(this._element, this._anchor, "marker"), t && t.className) for (const s of t.className.split(" ")) this._element.classList.add(s);
            this._popup = null;
          }
          addTo(t) {
            return this.remove(), this._map = t, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", t._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), t.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), re.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t) {
            return this._lngLat = u.V.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
              if (!("offset" in t.options)) {
                const g = Math.abs(13.5) / Math.SQRT2;
                t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [g, -1 * (38.1 - 13.5 + g)], "bottom-right": [-g, -1 * (38.1 - 13.5 + g)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(t) {
            return this._subpixelPositioning = t, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : t ? (t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map)), this) : this;
          }
          _updateOpacity(t = !1) {
            var s, d;
            const g = (s = this._map) === null || s === void 0 ? void 0 : s.terrain, w = this._map.transform.isLocationOccluded(this._lngLat);
            if (!g || w) {
              const W = w ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== W && (this._element.style.opacity = W));
            }
            if (t) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const S = this._map, C = S.terrain.depthAtPoint(this._pos), A = S.terrain.getElevationForLngLat(this._lngLat, S.transform);
            if (S.transform.lngLatToCameraDepth(this._lngLat, A) - C < 6e-3) return void (this._element.style.opacity = this._opacity);
            const F = -this._offset.y / S.transform.pixelsPerMeter, O = Math.sin(S.getPitch() * Math.PI / 180) * F, q = S.terrain.depthAtPoint(new u.P(this._pos.x, this._pos.y - this._offset.y)), V = S.transform.lngLatToCameraDepth(this._lngLat, A + O) - q > 6e-3;
            !((d = this._popup) === null || d === void 0) && d.isOpen() && V && this._popup.remove(), this._element.style.opacity = V ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t) {
            return this._offset = u.P.convert(t), this._update(), this;
          }
          addClassName(t) {
            this._element.classList.add(t);
          }
          removeClassName(t) {
            this._element.classList.remove(t);
          }
          toggleClassName(t) {
            return this._element.classList.toggle(t);
          }
          setDraggable(t) {
            return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t) {
            return this._rotation = t || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t) {
            return this._rotationAlignment = t || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t) {
            return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(t, s) {
            return (this._opacity === void 0 || t === void 0 && s === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), s !== void 0 && (this._opacityWhenCovered = s), this._map && this._updateOpacity(!0), this;
          }
        }
        const wd = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let Nl = 0, Ho = !1;
        const Ed = { maxWidth: 100, unit: "metric" };
        function Hu(b, t, s) {
          const d = s && s.maxWidth || 100, g = b._container.clientHeight / 2, w = b._container.clientWidth / 2, S = b.unproject([w - d / 2, g]), C = b.unproject([w + d / 2, g]), A = Math.round(b.project(C).x - b.project(S).x), F = Math.min(d, A, b._container.clientWidth), O = S.distanceTo(C);
          if (s && s.unit === "imperial") {
            const q = 3.2808 * O;
            q > 5280 ? Yo(t, F, q / 5280, b._getUIString("ScaleControl.Miles")) : Yo(t, F, q, b._getUIString("ScaleControl.Feet"));
          } else s && s.unit === "nautical" ? Yo(t, F, O / 1852, b._getUIString("ScaleControl.NauticalMiles")) : O >= 1e3 ? Yo(t, F, O / 1e3, b._getUIString("ScaleControl.Kilometers")) : Yo(t, F, O, b._getUIString("ScaleControl.Meters"));
        }
        function Yo(b, t, s, d) {
          const g = (function(w) {
            const S = Math.pow(10, `${Math.floor(w)}`.length - 1);
            let C = w / S;
            return C = C >= 10 ? 10 : C >= 5 ? 5 : C >= 3 ? 3 : C >= 2 ? 2 : C >= 1 ? 1 : (function(A) {
              const F = Math.pow(10, Math.ceil(-Math.log(A) / Math.LN10));
              return Math.round(A * F) / F;
            })(C), S * C;
          })(s);
          b.style.width = t * (g / s) + "px", b.innerHTML = `${g}&nbsp;${d}`;
        }
        const Td = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0, padding: void 0 }, Qc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function eh(b) {
          if (b) {
            if (typeof b == "number") {
              const t = Math.round(Math.abs(b) / Math.SQRT2);
              return { center: new u.P(0, 0), top: new u.P(0, b), "top-left": new u.P(t, t), "top-right": new u.P(-t, t), bottom: new u.P(0, -b), "bottom-left": new u.P(t, -t), "bottom-right": new u.P(-t, -t), left: new u.P(b, 0), right: new u.P(-b, 0) };
            }
            if (b instanceof u.P || Array.isArray(b)) {
              const t = u.P.convert(b);
              return { center: t, top: t, "top-left": t, "top-right": t, bottom: t, "bottom-left": t, "bottom-right": t, left: t, right: t };
            }
            return { center: u.P.convert(b.center || [0, 0]), top: u.P.convert(b.top || [0, 0]), "top-left": u.P.convert(b["top-left"] || [0, 0]), "top-right": u.P.convert(b["top-right"] || [0, 0]), bottom: u.P.convert(b.bottom || [0, 0]), "bottom-left": u.P.convert(b["bottom-left"] || [0, 0]), "bottom-right": u.P.convert(b["bottom-right"] || [0, 0]), left: u.P.convert(b.left || [0, 0]), right: u.P.convert(b.right || [0, 0]) };
          }
          return eh(new u.P(0, 0));
        }
        const Sd = R;
        T.AJAXError = u.cI, T.Event = u.l, T.Evented = u.E, T.LngLat = u.V, T.MercatorCoordinate = u.a9, T.Point = u.P, T.addProtocol = u.cJ, T.config = u.c, T.removeProtocol = u.cK, T.AttributionControl = vd, T.BoxZoomHandler = Dl, T.CanvasSource = K, T.CooperativeGesturesHandler = Zt, T.DoubleClickZoomHandler = yd, T.DragPanHandler = gp, T.DragRotateHandler = Gs, T.EdgeInsets = ra, T.FullscreenControl = class extends u.E {
          constructor(b = {}) {
            super(), this._onFullscreenChange = () => {
              var t;
              let s = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((t = s?.shadowRoot) === null || t === void 0) && t.fullscreenElement; ) s = s.shadowRoot.fullscreenElement;
              s === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, b && b.container && (b.container instanceof HTMLElement ? this._container = b.container : u.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(b) {
            return this._map = b, this._container || (this._container = this._map.getContainer()), this._controlContainer = re.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            re.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const b = this._fullscreenButton = re.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            re.create("span", "maplibregl-ctrl-icon", b).setAttribute("aria-hidden", "true"), b.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const b = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", b), this._fullscreenButton.title = b;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new u.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new u.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, T.GeoJSONSource = er, T.GeolocateControl = class extends u.E {
          constructor(b) {
            super(), this._onSuccess = (t) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new u.l("outofmaxbounds", t)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new u.l("geolocate", t)), this._finish();
              }
            }, this._updateCamera = (t) => {
              const s = new u.V(t.coords.longitude, t.coords.latitude), d = t.coords.accuracy, g = this._map.getBearing(), w = u.e({ bearing: g }, this.options.fitBoundsOptions), S = Nr.fromLngLat(s, d);
              this._map.fitBounds(S, w, { geolocateSource: !0 });
            }, this._updateMarker = (t) => {
              if (t) {
                const s = new u.V(t.coords.longitude, t.coords.latitude);
                this._accuracyCircleMarker.setLngLat(s).addTo(this._map), this._userLocationDotMarker.setLngLat(s).addTo(this._map), this._accuracy = t.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (t) => {
              if (this._map) {
                if (t.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const s = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (t.code === 3 && Ho) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new u.l("error", t)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((t) => t.preventDefault())), this._geolocateButton = re.create("button", "maplibregl-ctrl-geolocate", this._container), re.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (t) => {
              if (this._map) {
                if (t === !1) {
                  u.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const s = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s);
                } else {
                  const s = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = re.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Zu({ element: this._dotElement }), this._circleElement = re.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Zu({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((s) => {
                  const d = s?.[0] instanceof ResizeObserverEntry;
                  s.geolocateSource || this._watchState !== "ACTIVE_LOCK" || d || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new u.l("trackuserlocationend")), this.fire(new u.l("userlocationlostfocus")));
                }));
              }
            }, this.options = u.e({}, wd, b);
          }
          onAdd(b) {
            return this._map = b, this._container = re.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return u._(this, arguments, void 0, (function* (t = !1) {
                if (La !== void 0 && !t) return La;
                if (window.navigator.permissions === void 0) return La = !!window.navigator.geolocation, La;
                try {
                  La = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  La = !!window.navigator.geolocation;
                }
                return La;
              }));
            })().then(((t) => this._finishSetupUI(t))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), re.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Nl = 0, Ho = !1;
          }
          _isOutOfMapMaxBounds(b) {
            const t = this._map.getMaxBounds(), s = b.coords;
            return t && (s.longitude < t.getWest() || s.longitude > t.getEast() || s.latitude < t.getSouth() || s.latitude > t.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const b = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && b)) return;
            const t = this._map.project(b), s = this._map.unproject([t.x + 100, t.y]), d = b.distanceTo(s) / 100, g = 2 * this._accuracy / d;
            this._circleElement.style.width = `${g.toFixed(2)}px`, this._circleElement.style.height = `${g.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return u.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new u.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Nl--, Ho = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new u.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new u.l("trackuserlocationstart")), this.fire(new u.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let b;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Nl++, Nl > 1 ? (b = { maximumAge: 6e5, timeout: 0 }, Ho = !0) : (b = this.options.positionOptions, Ho = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, b);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, T.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var b;
              const t = (b = this._map.getProjection()) === null || b === void 0 ? void 0 : b.type;
              this._map.setProjection(t !== "mercator" && t ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var b;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((b = this._map.getProjection()) === null || b === void 0 ? void 0 : b.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(b) {
            return this._map = b, this._container = re.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = re.create("button", "maplibregl-ctrl-globe", this._container), re.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            re.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, T.Hash = hd, T.ImageSource = Kr, T.KeyboardHandler = Vr, T.LngLatBounds = Nr, T.LogoControl = mp, T.Map = class extends Vi {
          constructor(b) {
            var t, s;
            u.cG.mark(u.cH.create);
            const d = Object.assign(Object.assign(Object.assign({}, Xc), b), { canvasContextAttributes: Object.assign(Object.assign({}, Xc.canvasContextAttributes), b.canvasContextAttributes) });
            if (d.minZoom != null && d.maxZoom != null && d.minZoom > d.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (d.minPitch != null && d.maxPitch != null && d.minPitch > d.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (d.minPitch != null && d.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (d.maxPitch != null && d.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const g = new ia(), w = new vi();
            if (d.minZoom !== void 0 && g.setMinZoom(d.minZoom), d.maxZoom !== void 0 && g.setMaxZoom(d.maxZoom), d.minPitch !== void 0 && g.setMinPitch(d.minPitch), d.maxPitch !== void 0 && g.setMaxPitch(d.maxPitch), d.renderWorldCopies !== void 0 && g.setRenderWorldCopies(d.renderWorldCopies), d.transformConstrain !== null && g.setConstrainOverride(d.transformConstrain), super(g, w, { bearingSnap: d.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new pm(), this._controls = [], this._mapId = u.af(), this._lostContextStyle = { style: null, images: null }, this._contextLost = (C) => {
              C.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy();
              for (const A of Object.values(this.style._layers)) if (A.type === "custom" && console.warn(`Custom layer with id '${A.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), A._listeners) for (const [F] of Object.entries(A._listeners)) console.warn(`Custom layer with id '${A.id}' had event listeners for event '${F}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`);
              this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new u.l("webglcontextlost", { originalEvent: C }));
            }, this._contextRestored = (C) => {
              this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: !1 }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._lostContextStyle = { style: null, images: null }, this._setupPainter(), this.resize(), this._update(), this._resizeInternal(), this.fire(new u.l("webglcontextrestored", { originalEvent: C }));
            }, this._onMapScroll = (C) => {
              if (C.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = d.interactive, this._maxTileCacheSize = d.maxTileCacheSize, this._maxTileCacheZoomLevels = d.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, d.canvasContextAttributes), this._trackResize = d.trackResize === !0, this._bearingSnap = d.bearingSnap, this._centerClampedToGround = d.centerClampedToGround, this._refreshExpiredTiles = d.refreshExpiredTiles === !0, this._fadeDuration = d.fadeDuration, this._crossSourceCollisions = d.crossSourceCollisions === !0, this._collectResourceTiming = d.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Wc), d.locale), this._clickTolerance = d.clickTolerance, this._overridePixelRatio = d.pixelRatio, this._maxCanvasSize = d.maxCanvasSize, this._zoomLevelsToOverscale = d.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = d.transformCameraUpdate, this.transformConstrain = d.transformConstrain, this.cancelPendingTileRequestsWhileZooming = d.cancelPendingTileRequestsWhileZooming === !0, d.reduceMotion !== void 0 && (oe.prefersReducedMotion = d.reduceMotion), this._imageQueueHandle = ot.addThrottleControl((() => this.isMoving())), this._requestManager = new Q(d.transformRequest), typeof d.container == "string") {
              if (this._container = document.getElementById(d.container), !this._container) throw new Error(`Container '${d.container}' not found.`);
            } else {
              if (!(d.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = d.container;
            }
            if (d.maxBounds && this.setMaxBounds(d.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            })), this.once("idle", (() => {
              this._idleTriggered = !0;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let C = !1;
              const A = cd(((F) => {
                this._trackResize && !this._removed && (this.resize(F), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((F) => {
                C ? A(F) : C = !0;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new Yc(this, d), this._hash = d.hash && new hd(typeof d.hash == "string" && d.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: d.center, elevation: d.elevation, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch, roll: d.roll }), d.bounds && (this.resize(), this.fitBounds(d.bounds, u.e({}, d.fitBoundsOptions, { duration: 0 }))));
            const S = typeof d.style == "string" || ((s = (t = d.style) === null || t === void 0 ? void 0 : t.projection) === null || s === void 0 ? void 0 : s.type) !== "globe";
            this.resize(null, S), this._localIdeographFontFamily = d.localIdeographFontFamily, this._validateStyle = d.validateStyle, d.style && this.setStyle(d.style, { localIdeographFontFamily: d.localIdeographFontFamily }), d.attributionControl && this.addControl(new vd(typeof d.attributionControl == "boolean" ? void 0 : d.attributionControl)), d.maplibreLogo && this.addControl(new mp(), d.logoPosition), this.on("style.load", (() => {
              if (S || this._resizeTransform(), this.transform.unmodified) {
                const C = u.U(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(C);
              }
            })), this.on("data", ((C) => {
              this._update(C.dataType === "style"), this.fire(new u.l(`${C.dataType}data`, C));
            })), this.on("dataloading", ((C) => {
              this.fire(new u.l(`${C.dataType}dataloading`, C));
            })), this.on("dataabort", ((C) => {
              this.fire(new u.l("sourcedataabort", C));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(b, t) {
            return this.style.setGlobalStateProperty(b, t), this._update(!0);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(b, t) {
            if (t === void 0 && (t = b.getDefaultPosition ? b.getDefaultPosition() : "top-right"), !b || !b.onAdd) return this.fire(new u.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const s = b.onAdd(this);
            this._controls.push(b);
            const d = this._controlPositions[t];
            return t.indexOf("bottom") !== -1 ? d.insertBefore(s, d.firstChild) : d.appendChild(s), this;
          }
          removeControl(b) {
            if (!b || !b.onRemove) return this.fire(new u.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const t = this._controls.indexOf(b);
            return t > -1 && this._controls.splice(t, 1), b.onRemove(this), this;
          }
          hasControl(b) {
            return this._controls.indexOf(b) > -1;
          }
          coveringTiles(b) {
            return Pr(this.transform, b);
          }
          calculateCameraOptionsFromTo(b, t, s, d) {
            return d == null && this.terrain && (d = this.terrain.getElevationForLngLat(s, this.transform)), super.calculateCameraOptionsFromTo(b, t, s, d);
          }
          resize(b, t = !0) {
            if (this._lostContextStyle.style !== null) return this;
            this._resizeInternal(t);
            const s = !this._moving;
            return s && (this.stop(), this.fire(new u.l("movestart", b)).fire(new u.l("move", b))), this.fire(new u.l("resize", b)), s && this.fire(new u.l("moveend", b)), this;
          }
          _resizeInternal(b = !0) {
            const [t, s] = this._containerDimensions(), d = this._getClampedPixelRatio(t, s);
            if (this._resizeCanvas(t, s, d), this.painter.resize(t, s, d), this.painter.overLimit()) {
              const g = this.painter.context.gl;
              this._maxCanvasSize = [g.drawingBufferWidth, g.drawingBufferHeight];
              const w = this._getClampedPixelRatio(t, s);
              this._resizeCanvas(t, s, w), this.painter.resize(t, s, w);
            }
            this._resizeTransform(b);
          }
          _resizeTransform(b = !0) {
            var t;
            const [s, d] = this._containerDimensions();
            this.transform.resize(s, d, b), (t = this._requestedCameraState) === null || t === void 0 || t.resize(s, d, b);
          }
          _getClampedPixelRatio(b, t) {
            const { 0: s, 1: d } = this._maxCanvasSize, g = this.getPixelRatio(), w = b * g, S = t * g;
            return Math.min(w > s ? s / w : 1, S > d ? d / S : 1) * g;
          }
          getPixelRatio() {
            var b;
            return (b = this._overridePixelRatio) !== null && b !== void 0 ? b : devicePixelRatio;
          }
          setPixelRatio(b) {
            this._overridePixelRatio = b, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(b) {
            return this.transform.setMaxBounds(Nr.convert(b)), this._update();
          }
          setMinZoom(b) {
            if ((b = b ?? -2) >= -2 && b <= this.transform.maxZoom) {
              const t = this._getTransformForUpdate();
              return t.setMinZoom(b), this._applyUpdatedTransform(t), this._update(), this;
            }
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(b) {
            if ((b = b ?? 22) >= this.transform.minZoom) {
              const t = this._getTransformForUpdate();
              return t.setMaxZoom(b), this._applyUpdatedTransform(t), this._update(), this;
            }
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(b) {
            if ((b = b ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (b >= 0 && b <= this.transform.maxPitch) return this.transform.setMinPitch(b), this._update(), this.getPitch() < b && this.setPitch(b), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(b) {
            if ((b = b ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (b >= this.transform.minPitch) return this.transform.setMaxPitch(b), this._update(), this.getPitch() > b && this.setPitch(b), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(b) {
            return this.transform.setRenderWorldCopies(b), this._update();
          }
          setTransformConstrain(b) {
            return this.transform.setConstrainOverride(b), this._update();
          }
          project(b) {
            return this.transform.locationToScreenPoint(u.V.convert(b), this.style && this.terrain);
          }
          unproject(b) {
            return this.transform.screenPointToLocation(u.P.convert(b), this.terrain);
          }
          isMoving() {
            var b;
            return this._moving || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isMoving());
          }
          isZooming() {
            var b;
            return this._zooming || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isZooming());
          }
          isRotating() {
            var b;
            return this._rotating || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isRotating());
          }
          _createDelegatedListener(b, t, s) {
            if (b === "mouseenter" || b === "mouseover") {
              let d = !1;
              return { layers: t, listener: s, delegates: { mousemove: (w) => {
                const S = t.filter(((A) => this.getLayer(A))), C = S.length !== 0 ? this.queryRenderedFeatures(w.point, { layers: S }) : [];
                C.length ? d || (d = !0, s.call(this, new li(b, this, w.originalEvent, { features: C }))) : d = !1;
              }, mouseout: () => {
                d = !1;
              } } };
            }
            if (b === "mouseleave" || b === "mouseout") {
              let d = !1;
              return { layers: t, listener: s, delegates: { mousemove: (S) => {
                const C = t.filter(((A) => this.getLayer(A)));
                (C.length !== 0 ? this.queryRenderedFeatures(S.point, { layers: C }) : []).length ? d = !0 : d && (d = !1, s.call(this, new li(b, this, S.originalEvent)));
              }, mouseout: (S) => {
                d && (d = !1, s.call(this, new li(b, this, S.originalEvent)));
              } } };
            }
            {
              const d = (g) => {
                const w = t.filter(((C) => this.getLayer(C))), S = w.length !== 0 ? this.queryRenderedFeatures(g.point, { layers: w }) : [];
                S.length && (g.features = S, s.call(this, g), delete g.features);
              };
              return { layers: t, listener: s, delegates: { [b]: d } };
            }
          }
          _saveDelegatedListener(b, t) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[b] = this._delegatedListeners[b] || [], this._delegatedListeners[b].push(t);
          }
          _removeDelegatedListener(b, t, s) {
            if (!this._delegatedListeners || !this._delegatedListeners[b]) return;
            const d = this._delegatedListeners[b];
            for (let g = 0; g < d.length; g++) {
              const w = d[g];
              if (w.listener === s && w.layers.length === t.length && w.layers.every(((S) => t.includes(S)))) {
                for (const S in w.delegates) this.off(S, w.delegates[S]);
                return void d.splice(g, 1);
              }
            }
          }
          on(b, t, s) {
            if (s === void 0) return super.on(b, t);
            const d = typeof t == "string" ? [t] : t, g = this._createDelegatedListener(b, d, s);
            this._saveDelegatedListener(b, g);
            for (const w in g.delegates) this.on(w, g.delegates[w]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(b, d, s);
            } };
          }
          once(b, t, s) {
            if (s === void 0) return super.once(b, t);
            const d = typeof t == "string" ? [t] : t, g = this._createDelegatedListener(b, d, s);
            for (const w in g.delegates) {
              const S = g.delegates[w];
              g.delegates[w] = (...C) => {
                this._removeDelegatedListener(b, d, s), S(...C);
              };
            }
            this._saveDelegatedListener(b, g);
            for (const w in g.delegates) this.once(w, g.delegates[w]);
            return this;
          }
          off(b, t, s) {
            return s === void 0 ? super.off(b, t) : (this._removeDelegatedListener(b, typeof t == "string" ? [t] : t, s), this);
          }
          queryRenderedFeatures(b, t) {
            if (!this.style) return [];
            let s;
            const d = b instanceof u.P || Array.isArray(b), g = d ? b : [[0, 0], [this.transform.width, this.transform.height]];
            if (t = t || (d ? {} : b) || {}, g instanceof u.P || typeof g[0] == "number") s = [u.P.convert(g)];
            else {
              const w = u.P.convert(g[0]), S = u.P.convert(g[1]);
              s = [w, new u.P(S.x, w.y), S, new u.P(w.x, S.y), w];
            }
            return this.style.queryRenderedFeatures(s, t, this.transform);
          }
          querySourceFeatures(b, t) {
            return this.style.querySourceFeatures(b, t);
          }
          setStyle(b, t) {
            return (t = u.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, t)).diff !== !1 && t.localIdeographFontFamily === this._localIdeographFontFamily && this.style && b ? (this._diffStyle(b, t), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._updateStyle(b, t));
          }
          setTransformRequest(b) {
            return this._requestManager.setTransformRequest(b), this;
          }
          _getUIString(b) {
            const t = this._locale[b];
            if (t == null) throw new Error(`Missing UI string '${b}'`);
            return t;
          }
          _updateStyle(b, t) {
            var s, d;
            if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(b, t)));
            const g = this.style && t.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!b)), b ? (this.style = new Ia(this, t || {}), this.style.setEventedParent(this, { style: this.style }), typeof b == "string" ? this.style.loadURL(b, t, g) : this.style.loadJSON(b, t, g), this) : ((d = (s = this.style) === null || s === void 0 ? void 0 : s.projection) === null || d === void 0 || d.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Ia(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(b, t) {
            if (typeof b == "string") {
              const s = this._requestManager.transformRequest(b, "Style");
              u.j(s, new AbortController()).then(((d) => {
                this._updateDiff(d.data, t);
              })).catch(((d) => {
                d && this.fire(new u.k(d));
              }));
            } else typeof b == "object" && this._updateDiff(b, t);
          }
          _updateDiff(b, t) {
            try {
              this.style.setState(b, t) && this._update(!0);
            } catch (s) {
              u.w(`Unable to perform style diff: ${s.message || s.error || s}.  Rebuilding the style from scratch.`), this._updateStyle(b, t);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          _getStyleAndImages() {
            return this.style ? { style: this.style.serialize(), images: this.style.imageManager.cloneImages() } : { style: null, images: {} };
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : u.w("There is no style added to the map.");
          }
          addSource(b, t) {
            return this._lazyInitEmptyStyle(), this.style.addSource(b, t), this._update(!0);
          }
          isSourceLoaded(b) {
            const t = this.style && this.style.tileManagers[b];
            if (t !== void 0) return t.loaded();
            this.fire(new u.k(new Error(`There is no tile manager with ID '${b}'`)));
          }
          setTerrain(b) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), b) {
              const t = this.style.tileManagers[b.source];
              if (!t) throw new Error(`cannot load terrain, because there exists no source with ID: ${b.source}`);
              this.terrain === null && t.reload();
              for (const s in this.style._layers) {
                const d = this.style._layers[s];
                d.type === "hillshade" && d.source === b.source && u.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), d.type === "color-relief" && d.source === b.source && u.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new mn(this.painter, t, b), this.painter.renderToTexture = new Uu(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (s) => {
                var d;
                s.dataType === "style" ? this.terrain.tileManager.freeRtt() : s.dataType === "source" && s.tile && (s.sourceId !== b.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((d = s.source) === null || d === void 0 ? void 0 : d.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(s.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new u.l("terrain", { terrain: b })), this;
          }
          getTerrain() {
            var b, t;
            return (t = (b = this.terrain) === null || b === void 0 ? void 0 : b.options) !== null && t !== void 0 ? t : null;
          }
          areTilesLoaded() {
            const b = this.style && this.style.tileManagers;
            for (const t of Object.values(b)) if (!t.areTilesLoaded()) return !1;
            return !0;
          }
          removeSource(b) {
            return this.style.removeSource(b), this._update(!0);
          }
          getSource(b) {
            return this.style.getSource(b);
          }
          setSourceTileLodParams(b, t, s) {
            if (s) {
              const d = this.getSource(s);
              if (!d) throw new Error(`There is no source with ID "${s}", cannot set LOD parameters`);
              d.calculateTileZoom = mt(Math.max(1, b), Math.max(1, t));
            } else for (const d in this.style.tileManagers) this.style.tileManagers[d].getSource().calculateTileZoom = mt(Math.max(1, b), Math.max(1, t));
            return this._update(!0), this;
          }
          refreshTiles(b, t) {
            const s = this.style.tileManagers[b];
            if (!s) throw new Error(`There is no tile manager with ID "${b}", cannot refresh tile`);
            t === void 0 ? s.reload(!0) : s.refreshTiles(t.map(((d) => new u.ac(d.z, d.x, d.y))));
          }
          addImage(b, t, s = {}) {
            const { pixelRatio: d = 1, sdf: g = !1, stretchX: w, stretchY: S, content: C, textFitWidth: A, textFitHeight: F } = s;
            if (this._lazyInitEmptyStyle(), !(t instanceof HTMLImageElement || u.b(t))) {
              if (t.width === void 0 || t.height === void 0) return this.fire(new u.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: O, height: q, data: V } = t, W = t;
                return this.style.addImage(b, { data: new u.R({ width: O, height: q }, new Uint8Array(V)), pixelRatio: d, stretchX: w, stretchY: S, content: C, textFitWidth: A, textFitHeight: F, sdf: g, version: 0, userImage: W }), W.onAdd && W.onAdd(this, b), this;
              }
            }
            {
              const { width: O, height: q, data: V } = oe.getImageData(t);
              this.style.addImage(b, { data: new u.R({ width: O, height: q }, V), pixelRatio: d, stretchX: w, stretchY: S, content: C, textFitWidth: A, textFitHeight: F, sdf: g, version: 0 });
            }
          }
          updateImage(b, t) {
            const s = this.style.getImage(b);
            if (!s) return this.fire(new u.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const d = t instanceof HTMLImageElement || u.b(t) ? oe.getImageData(t) : t, { width: g, height: w, data: S } = d;
            if (g === void 0 || w === void 0) return this.fire(new u.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (g !== s.data.width || w !== s.data.height) return this.fire(new u.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const C = !(t instanceof HTMLImageElement || u.b(t));
            return s.data.replace(S, C), this.style.updateImage(b, s), this;
          }
          getImage(b) {
            return this.style.getImage(b);
          }
          hasImage(b) {
            return b ? !!this.style.getImage(b) : (this.fire(new u.k(new Error("Missing required image id"))), !1);
          }
          removeImage(b) {
            this.style.removeImage(b);
          }
          loadImage(b) {
            return ot.getImage(this._requestManager.transformRequest(b, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(b, t) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(b, t), this._update(!0);
          }
          moveLayer(b, t) {
            return this.style.moveLayer(b, t), this._update(!0);
          }
          removeLayer(b) {
            return this.style.removeLayer(b), this._update(!0);
          }
          getLayer(b) {
            return this.style.getLayer(b);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(b, t, s) {
            return this.style.setLayerZoomRange(b, t, s), this._update(!0);
          }
          setFilter(b, t, s = {}) {
            return this.style.setFilter(b, t, s), this._update(!0);
          }
          getFilter(b) {
            return this.style.getFilter(b);
          }
          setPaintProperty(b, t, s, d = {}) {
            return this.style.setPaintProperty(b, t, s, d), this._update(!0);
          }
          getPaintProperty(b, t) {
            return this.style.getPaintProperty(b, t);
          }
          setLayoutProperty(b, t, s, d = {}) {
            return this.style.setLayoutProperty(b, t, s, d), this._update(!0);
          }
          getLayoutProperty(b, t) {
            return this.style.getLayoutProperty(b, t);
          }
          setGlyphs(b, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(b, t), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(b, t, s = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(b, t, s, ((d) => {
              d || this._update(!0);
            })), this;
          }
          removeSprite(b) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(b), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(b, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(b, t, ((s) => {
              s || this._update(!0);
            })), this;
          }
          setLight(b, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(b, t), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(b, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(b, t), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(b, t) {
            return this.style.setFeatureState(b, t), this._update();
          }
          removeFeatureState(b, t) {
            return this.style.removeFeatureState(b, t), this._update();
          }
          getFeatureState(b) {
            return this.style.getFeatureState(b);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let b = 0, t = 0;
            return this._container && (b = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [b, t];
          }
          _setupContainer() {
            const b = this._container;
            b.classList.add("maplibregl-map");
            const t = this._canvasContainer = re.create("div", "maplibregl-canvas-container", b);
            this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = re.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const s = this._containerDimensions(), d = this._getClampedPixelRatio(s[0], s[1]);
            this._resizeCanvas(s[0], s[1], d);
            const g = this._controlContainer = re.create("div", "maplibregl-control-container", b), w = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((S) => {
              w[S] = re.create("div", `maplibregl-ctrl-${S} `, g);
            })), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(b, t, s) {
            this._canvas.width = Math.floor(s * b), this._canvas.height = Math.floor(s * t), this._canvas.style.width = `${b}px`, this._canvas.style.height = `${t}px`;
          }
          _setupPainter() {
            const b = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let t = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((d) => {
              t = { requestedAttributes: b }, d && (t.statusMessage = d.statusMessage, t.type = d.type);
            }), { once: !0 });
            let s = null;
            if (s = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, b) : this._canvas.getContext("webgl2", b) || this._canvas.getContext("webgl", b), !s) {
              const d = "Failed to initialize WebGL";
              throw t ? (t.message = d, new Error(JSON.stringify(t))) : new Error(d);
            }
            this.painter = new sp(s, this.transform), Pe.testSupport(s);
          }
          migrateProjection(b, t) {
            super.migrateProjection(b, t), this.painter.transform = b, this.fire(new u.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(b) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || b, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(b) {
            return this._update(), this._renderTaskQueue.add(b);
          }
          _cancelRenderFrame(b) {
            this._renderTaskQueue.remove(b);
          }
          _render(b) {
            var t, s, d, g, w;
            const S = this._idleTriggered ? this._fadeDuration : 0, C = ((t = this.style.projection) === null || t === void 0 ? void 0 : t.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(b), this._removed) return;
            let A = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const q = this.transform.zoom, V = me();
              this.style.zoomHistory.update(q, V);
              const W = new u.H(q, { now: V, fadeDuration: S, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), te = W.crossFadingFactor();
              te === 1 && te === this._crossFadingFactor || (A = !0, this._crossFadingFactor = te), this.style.update(W);
            }
            const F = ((s = this.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0 !== C;
            (d = this.style.projection) === null || d === void 0 || d.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((g = this.style.projection) === null || g === void 0 ? void 0 : g.transitionState, (w = this.style.projection) === null || w === void 0 ? void 0 : w.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || F) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, S, this._crossSourceCollisions, F), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: S, showPadding: this.showPadding }), this.fire(new u.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, u.cG.mark(u.cH.load), this.fire(new u.l("load"))), this.style && (this.style.hasTransitions() || A) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const O = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return O || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new u.l("idle")), !this._loaded || this._fullyLoaded || O || (this._fullyLoaded = !0, u.cG.mark(u.cH.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var b;
            this._hash && this._hash.remove();
            for (const s of this._controls) s.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), ot.removeThrottleControl(this._imageQueueHandle), (b = this._resizeObserver) === null || b === void 0 || b.disconnect();
            const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t?.loseContext && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), re.remove(this._canvasContainer), re.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), u.cG.clearMetrics(), this._removed = !0, this.fire(new u.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), oe.frame(this._frameRequest, ((b) => {
              u.cG.frame(b), this._frameRequest = null;
              try {
                this._render(b);
              } catch (t) {
                if (!u.Z(t) && !(function(s) {
                  return s.message === id;
                })(t)) throw t;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(b) {
            this._showTileBoundaries !== b && (this._showTileBoundaries = b, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(b) {
            this._showPadding !== b && (this._showPadding = b, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(b) {
            this._showCollisionBoxes !== b && (this._showCollisionBoxes = b, b ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(b) {
            this._showOverdrawInspector !== b && (this._showOverdrawInspector = b, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(b) {
            this._repaint !== b && (this._repaint = b, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(b) {
            this._vertices = b, this._update();
          }
          get version() {
            return xd;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(b) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(b), this._update(!0);
          }
        }, T.MapMouseEvent = li, T.MapTouchEvent = Fu, T.MapWheelEvent = lp, T.Marker = Zu, T.NavigationControl = class {
          constructor(b) {
            this._updateZoomButtons = () => {
              const t = this._map.getZoom(), s = t === this._map.getMaxZoom(), d = t === this._map.getMinZoom();
              this._zoomInButton.disabled = s, this._zoomOutButton.disabled = d, this._zoomInButton.setAttribute("aria-disabled", s.toString()), this._zoomOutButton.setAttribute("aria-disabled", d.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (t, s) => {
              const d = this._map._getUIString(`NavigationControl.${s}`);
              t.title = d, t.setAttribute("aria-label", d);
            }, this.options = u.e({}, bd, b), this._container = re.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((t) => t.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((t) => this._map.zoomIn({}, { originalEvent: t }))), re.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((t) => this._map.zoomOut({}, { originalEvent: t }))), re.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((t) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
            })), this._compassIcon = re.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(b) {
            return this._map = b, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new qu(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            re.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(b, t) {
            const s = re.create("button", b, this._container);
            return s.type = "button", s.addEventListener("click", t), s;
          }
        }, T.Popup = class extends u.E {
          constructor(b) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && re.remove(this._content), this._container && (re.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new u.l("close"))), this), this._onMouseUp = (t) => {
              this._update(t.point);
            }, this._onMouseMove = (t) => {
              this._update(t.point);
            }, this._onDrag = (t) => {
              this._update(t.point);
            }, this._update = (t) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = re.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = re.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const S of this.options.className.split(" ")) this._container.classList.add(S);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Jc(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !t) return;
              const s = this._flatPos = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && t ? t : this._map.transform.locationToScreenPoint(this._lngLat));
              let d = this.options.anchor;
              const g = eh(this.options.offset);
              if (!d) {
                const S = this._container.offsetWidth, C = this._container.offsetHeight, A = (function(O) {
                  var q, V, W, te;
                  return O ? { top: (q = O.top) !== null && q !== void 0 ? q : 0, right: (V = O.right) !== null && V !== void 0 ? V : 0, bottom: (W = O.bottom) !== null && W !== void 0 ? W : 0, left: (te = O.left) !== null && te !== void 0 ? te : 0 } : { top: 0, right: 0, bottom: 0, left: 0 };
                })(this.options.padding);
                let F;
                F = s.y + g.bottom.y < C + A.top ? ["top"] : s.y > this._map.transform.height - C - A.bottom ? ["bottom"] : [], s.x < S / 2 + A.left ? F.push("left") : s.x > this._map.transform.width - S / 2 - A.right && F.push("right"), d = F.length === 0 ? "bottom" : F.join("-");
              }
              let w = s.add(g[d]);
              this.options.subpixelPositioning || (w = w.round()), re.setTransform(this._container, `${$u[d]} translate(${w.x}px,${w.y}px)`), Kc(this._container, d, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = u.e(Object.create(Td), b);
          }
          addTo(b) {
            return this._map && this.remove(), this._map = b, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new u.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(b) {
            return this._lngLat = u.V.convert(b), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(b) {
            return this.setDOMContent(document.createTextNode(b));
          }
          setHTML(b) {
            const t = document.createDocumentFragment(), s = document.createElement("body");
            let d;
            for (s.innerHTML = b; d = s.firstChild, d; ) t.appendChild(d);
            return this.setDOMContent(t);
          }
          getMaxWidth() {
            var b;
            return (b = this._container) === null || b === void 0 ? void 0 : b.style.maxWidth;
          }
          setMaxWidth(b) {
            return this.options.maxWidth = b, this._update(), this;
          }
          setDOMContent(b) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = re.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(b), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(b) {
            return this._container && this._container.classList.add(b), this;
          }
          removeClassName(b) {
            return this._container && this._container.classList.remove(b), this;
          }
          setOffset(b) {
            return this.options.offset = b, this._update(), this;
          }
          toggleClassName(b) {
            if (this._container) return this._container.classList.toggle(b);
          }
          setSubpixelPositioning(b) {
            this.options.subpixelPositioning = b;
          }
          setPadding(b) {
            this.options.padding = b, this._update();
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = re.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const b = this._container.querySelector(Qc);
            b && b.focus();
          }
        }, T.RasterDEMTileSource = Zi, T.RasterTileSource = $i, T.ScaleControl = class {
          constructor(b) {
            this._onMove = () => {
              Hu(this._map, this._container, this.options);
            }, this.setUnit = (t) => {
              this.options.unit = t, Hu(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, Ed), b);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(b) {
            return this._map = b, this._container = re.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", b.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            re.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, T.ScrollZoomHandler = Zc, T.Style = Ia, T.TerrainControl = class {
          constructor(b) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = b;
          }
          onAdd(b) {
            return this._map = b, this._container = re.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = re.create("button", "maplibregl-ctrl-terrain", this._container), re.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            re.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, T.TwoFingersTouchPitchHandler = dp, T.TwoFingersTouchRotateHandler = md, T.TwoFingersTouchZoomHandler = gd, T.TwoFingersTouchZoomRotateHandler = Gu, T.VectorTileSource = St, T.VideoSource = He, T.addSourceType = (b, t) => u._(void 0, void 0, void 0, (function* () {
          if (le(b)) throw new Error(`A source type called "${b}" already exists.`);
          ((s, d) => {
            J[s] = d;
          })(b, t);
        })), T.clearPrewarmedResources = function() {
          const b = gr;
          b && (b.isPreloaded() && b.numActive() === 1 ? (b.release(Pt), gr = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, T.createTileMesh = fu, T.getMaxParallelImageRequests = function() {
          return u.c.MAX_PARALLEL_IMAGE_REQUESTS;
        }, T.getRTLTextPluginStatus = function() {
          return qe().getRTLTextPluginStatus();
        }, T.getVersion = function() {
          return Sd;
        }, T.getWorkerCount = function() {
          return Mt.workerCount;
        }, T.getWorkerUrl = function() {
          return u.c.WORKER_URL;
        }, T.importScriptInWorkers = function(b) {
          return Ut().broadcast("IS", b);
        }, T.isTimeFrozen = function() {
          return ce.isFrozen();
        }, T.now = me, T.prewarm = function() {
          ri().acquire(Pt);
        }, T.restoreNow = function() {
          ce.restoreNow();
        }, T.setMaxParallelImageRequests = function(b) {
          u.c.MAX_PARALLEL_IMAGE_REQUESTS = b;
        }, T.setNow = function(b) {
          ce.setNow(b);
        }, T.setRTLTextPlugin = function(b, t) {
          return qe().setRTLTextPlugin(b, t);
        }, T.setWorkerCount = function(b) {
          Mt.workerCount = b;
        }, T.setWorkerUrl = function(b) {
          u.c.WORKER_URL = b;
        };
      }));
      var M = l;
      return M;
    }));
  })(hg)), hg.exports;
}
var XS = WS();
const Gg = /* @__PURE__ */ HS(XS), JS = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mLYpUHOwgopChOtlFRRxrFYpQIdQKrTqYXPoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJESv0sKLWK847iH97735e47QGhWmWaFEoCm22YmlRRz+VWx5xUhmmGMIi4zy5iTpDR8x9c9Any/i/Ms/7o/R79asBgQEIkTzDBt4g3imU3b4LxPHGVlWSU+J54w6YLEj1xXPH7jXHJZ4JlRM5uZJ44Si6UuVrqYlU2NeJo4pmo65Qs5j1XOW5y1ap2178lfGCnoK8tcpzWCFBaxBAkiFNRRQRU24rTrpFjI0HnSxz/s+iVyKeSqgJFjATVokF0/+B/87q1VnJr0kiJJIPziOB9jQM8u0Go4zvex47ROgOAzcKV3/LUmMPtJeqOjxY6AgW3g4rqjKXvA5Q4w9GTIpuxKQVpCsQi8n9E35YHBW6Bvzetb+xynD0CWepW+AQ4OgfESZa/7vLu3u2//1rT79wN2rHKoBaSKHQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+gEBAUlKJesuC4AABWbSURBVHja7Z3fcxTHEce/t1ohYekA2QaBDBgocGLHNmW7Kg4pV9l5SeUleci/4b9H/0aeU3mJXXEF5yEmEOw4hgKFH7JBtpEQwhLS3eVhunV9w+7tHWh3e2Z7q64OyZJ18+Mz3+7pme4W7Bn6tBdXWwD4lYj3FMA0gCkAswCOAJihrw8AOAfgdwDOAmgDmKDf3YunB6ADYB3AdQB/BnANwEMAWwA2ANwH8Ii+3gSwA6BLv8vvvfWPD/VslPOflnVBLhQQYKQCiEl6zQCYB/AigGMA3gBwGMB+guQQgFfpfZKg2sunC2AbwCqA/9H7FoCfAKwA+ArAtwB+BHCPoNmmFwOzw6AAgMFigIyrFhMChgMERJu+PkJQHCNI5un7qfi9F+i9VUJf88TeBvCY3js06TcIih8Jkq9IUTZIde6R2myI3zNVMUBGAiOlST1NrwMAjgM4BeAtAUKbIJklxZim35WAJSXB4UPSlROcINkkRXlEcKwLcP4NYAnAHQJlk17bUlUMlIYDkgHGPpr8BwEcJWVYAPA2AXKcwGAza0ooRiL6s1Vx//Yy3rtCUbaEebVOYCwBuAJgmZTmOwBrBNETA6XBgAwBYw7ACYLhbYLjRYLlIP3MpOest2oAYhxgep5zvk0QrBEUPxIkVwia2wAeGCgNBGQEME4DeIcAOUHm1bRwztMaVWIv1WVHOOubZGbdJkAuAbhpoDQIELErlRSAcZq+nhNqMeEpReh91vOUpSNU5QGBcbMAlG5Tdr1aDYGjRROdYxZFYOzzHO4Y+8o3w3YIgCJQOLbSaYKatBoAR0JKsB/Ay2Q+nRkRjKaYoL0RQblBZtj3cPGWbQDdmCFpRQyGVI0DcFuybwL4FVx0+6SBMRYot+Ci9p8DuAq3dfwwdjVpRQxHCheoO0xKcY7geJNgaRsYY4GyTlBcJUiukbKswAUqd2KEpBUhHBM06WfgotznAVwgQE6TmbWffiYxMEYCpUsA/ETm1U0C5CKAy3DR+g36mU5MkLQiAsM3qeYJjg/pfZ6+P4X+wUEDYzxQOmRSPYSLyF8G8Cm934vR5GpFBEeWSXWB4DiGwXNSMDieCRJg8LzXtwTHxVhNrlZEcMzCRb59k+owgZOaauypmuwQCCsZJtcy3HZw8JCkEcHxCoB3AXxkJlUli2oqVHmGFqIZsRDdZUjai6vBBhXTwOHgo+gMx2/ofcEzqQyMvYfEP7YzhcGjOCBINgBshwpJGigciYBjwYPjFQFHYnCUDgovQKzi/rMsIAkuqJgGCscU+kfSz5NZxXDMmr9ROSS8YPmQsLrwUfqt0CBpBQrHS+SE/xzArwmSBYNDjfP+iJTjMoC/A/ianPgf4LaBg4GkFRAcLbjI9xyA1wH8Fu6G31m4yLjtVOmC5DFc5P063A3GvwD4D9yxlScIZHcrCQgO9jmOknK8Re9Hvd0Tg6N+5z0tGKtJAC1xDcEAeU44UuGQnyez6iz6x0ZsG1cfJBPon6A+65nCuwuadkiSQODIinMcMTiCgeTIsM0UzZCkyjvZh0PGOV4wOILwbydorBbQP67Cz24wMeO/GSAF6iE71o9z2G5VWJDIhc536u8A2Ggvrqp02lPFcEzBHV+wOEeckPBu1xYrSHtxVd1R+UQhHGxaHYA7bHghy7kzOIL0SfzNlgs0xge0+iOpwo7kTpyHCwaew2BaT4MjfCXxx3eFlKSrzR9RoyCe33EsZ4Wxs1XhQ5LkWAjHeONFk4okiuBIPL+DbwIexuCRdXvCh2SiYKwTLZAkSuDgSHnuqmJwRAlJnrWgJtKuxcSSAaU8v8Oe+CDJ8kdkALjZCuKZVi+jn7dqYGcDcWY19EsX5L3kz8YGiL9jyWmZXtZiaqVKVpFZuIyHfgfFYlrllSfojdFPdZZXqMIf4QVyDS5Dyjr6JRt6jQMk4wj7GfSPrquR2D2Cwi9BwAEyruxUpPI8ieROntbSC89rYp+luXAHlGurvbjaqiuAmNa8erANegIuV+5JuIyHIZtWWdnT/SI2G/DS4xT0Eacz4qPiecV7QuwzGR9p0xx4By5TCt8dqU1FagEkQz1O02uOvhdivMNP18n1N7LKoN2HuzwkA2S9HLOKt0NfR7+Sblb5t0mEm0aV2+rPh9t1q0haY4f46nEi0F2rvITPsoJTViHNFfTTdfZG6KcryC8gKitghZpvOGtO1K4ilQMygnqEMqhFJQOWMFgD0C/FvAWvDPOQnZ4HBJQsQX0VT9dQDLmUQ968qFVFUiUrRWjqIZ3tvFoaS/S1rCK74znrow42A8WmyAO4JNJchfc6ATKs5kkSCCSqVKRSQCJQDz+J8yMUly3z65Dv7nCNuhpSv3VF32yLv79GCnWL/nZW1Sz2VbRfMFOnIqmCFSIU9cjKSbsEV3WpsPDlOED4j/i9ngcM1xfMUjEG5Qypi8xRDOWQqFGRyjpJRM33w12a+RDAH+HO4cyhX15Zs0nVwWDOp4tk3txCTRVhCyr3noSLK8g7NbN4uq67tofLVT+gfv4TXJmFu3A1SirLq1W1giRkNx8lxzIE9fDriy8D+ALAJzR4XIqsllLJ9Hd6BMq25xc9FDtn/Nn44tmkYkh8FXkbwH8hEs/FaGLxsYJpsfuye3JT6UCxv8G1xLlozCcEyTKZW9vsY9QV8c0AhQOUm56pt4N+5vtp6DzO45/wXqA5M00K3qnKzKoEkIwj7bLBE8rh4AyBN5BdA6MDRak0BShyQ+GugGMD7tTsGfQzUmqFJGtBXYNLhF2Js55W2FiWzOMkmUep8YlSOLq0+t4H8E8AnwH4BoFUUVr/+FCvvbjKO2eP4M42bdFnfw3ABwDeo3HYr9Tc8k3ya7RjV5mzXvrkzEjEcIpeB5WaV9LneEjK8RmAfwD4EoMFK1Xnl2U1wWDJtC+pLZ9R2x5KE1GpmXVQzJtKEzykFa8E83B5Wo8rdc6lWbJBPsc1Uo5lAKu0CgdTyTXD5OLP/Q21ja+5tqHvZLBvebwFd4btB1KRbhUTt8qVoE2QtBWrh5++/yKZVWuhwZEBCgc416hNmTUFlapILXOnKvtfVoSSW4xanXJ/K3clZDhyIFlB9o5cB/puL9Y2f0r9IxnZ2Y8oVQ/2O4ZOnBjqfgtIhi0EmvwRX0WOoMLs8GlFELL/8QY1cEqZgkjTaikA02OvTcmsBWxS0QLG92L4mP9VuMOapQcNkwro5+uiL8LdX9CWW5cd1ydwRxtuwB0fuS9NjhjUI2N3S8Z5rlPbdytAKVkU/DIYfAemkpwFpQGSUd+j0oY9w2q6AXfQ7xLc2ard7c+Y4PAgkdvZt6jtuydnlZlZuQttmWZW2QriS+M8dAUHffW4icGTo1HCkQFJXvs1pRuqxVSvwsRi+/Yw9CWgzlIPjSto0/ugVTCXggSEG8WX8aehKzBYpB69mNUjwx8JQUUYkmkMJvcI1sSqvEGmHtGrSKULbimAZMQ/KpPEMdVjGy6qvESvRqnHEBXh/lhD/1CgFkgy51RZjnpSMnwyp9Nh6Ip/8Gnd7+CyjzRVPfJU5Ar1zSYqvKCkbU6V7YNwinttDro8cvEjXLCMt3UbpR4ZKsLbvpyuiFOk1t0nWVZJ6XdZkhIbw///FP00mZrMK44kf0sTYRM6zyHVsXBsop/wTp4k0GRmyVzFKGtuVXWaV5NzzubVFlwE+Su4Y+2aTAkNpuc99LNBbinqmxaeznYflpM+RFG0rJJsSqzDS2rQRPMqw8xiX4TzCWty1CudU0lD54LMUsLJ3Uw9rH8aD0hIK6RKhW1aHzVRQeS9D78EgT3WR40HRB7zXjH/o9AP4Qwujdzha6KJxSskV31qamBwlL6SfdT1+tAAacAE6JrvUeiLdJvcP4lNAnusjwwQe+wxQOyxxwCxp+qnZYDY4NuT3TeVnXkyQHROAG2HKLX1T2WnZg0QXYqh8Ri+iifnNqjWGiIGSEmQZF7kqiKdfkDzQvNtUAPEBl+FeaU1XVN0gGhLhKw9mbYW51xjuqZK51RSUUO0HekIoRyDBgXRmq6psiMwScl0azwUWGs6/QAddG2VwCo9RJmU3JDMY+UKQNGeM7juvtFYrqKWY/hlNlrrpZu8rPOaS1JX2Tey9LK2chWVz6lSAMm5dKMtjaVMp881uCebamYNqWWvqVxF7pwq67JbUlGDNtGvSqrFWfdrcJ+Azsq7VTvmM9QX2mrZS+f8Cc2p0hfcJLYGPYOjLmtwz9GuTaNURKjHPuoD7g9ttewrX3CrUpANhY66v2K+02AV0d4XtZnsZQOiOTuGv2qeplejVCRDPZ7qByWLRS1zqTRAAsnSZyoSRh/Ulg0zqYh8rVn6ilbPJGYVobYlAahHbfMoqZN8xSpyEv1t3yghEXDwtu5J5epRiyVSlYJoztLnq8gZAGfhIsi79yBigkT4HXzs/wi1+Yxi9ahlDpUKSEDZwmVk/RSACwDOwwXLZiP0R2R7F6itF6jt2tpbazb+pMIVQHO2cDY3+J7IeQAfAXiXJtALACZiUBFqAyvHArXxI2qzvBujqa21zZ+0xhVgjuzfnpLB8CeOVL/d08jtxdVOqDl8BRxDFwKF6lGbBVKlgoRQ0SnP9DgNF1WeClVJPDgOUptCMCVrrXhVuoKsf3yo115czasJOKtsxeLPMUE7OfMAzgF4Da48MuBKI2+1F1c7CCAjvOeQMxwL1KZz1MYZMQ7aqoHl1kysou+TihuaWVUW+kp7ye3PMwA+APA+gF/AHQEP4oJVxgWoY9SG96lNZyC2s6G3VF5tVXerPKXp1yW/A711yRmSabgt0PcA/B7AHwD8EsBxYZKojJOIOAebjMfps/+B2vIetW0aOpPDSd/jDmqq216Fky7NrG0yUZbo9aqYaD1lgySd9qPIrve+DHerbbu9uNrVYHIJ1WAVzNqtmifl0HpJTKqHnC9rqLiWfVrzivAzAC9Bb9odhmQ/nk40x6bLfTIBngDYoYWgclAEGPy59hEERzJ2q2aUmlXqLI7KAPFURNqUGp31PJ+kDeAVz66/DuAWOfEbVYOSA8YM3Db6SbgIub9bNaEcDt85H/BZq1x80pobzrsSh6ArJpIHSUvY85z04QaASwBuAridBwovEnsIBYaAcQJuG/cdcsRPoZ9CVHsCuDznfBM11ElMa+gAua/9Je2qvAz92Q1bos/YD2kTLKcJkCxQtmlguwQLxgXGA0ICO4F+fi8fjNP09RxBLe+Wa47jqHDOawEksJhIHiS+E+xPTgZliUB5SO3jK8d8TVQCM46C8c7UNL0O0N8+lQHGDClLijDKGKhxzutUkDz78qByMyvPL8kzb5Zo9WMT4Z5QlG0MJtPrFQDJGwSTAsp59DOyvE2AZIHRQlhpVVWFA1IlnXCWBnsf+kkCEAAkLRq0LFBepV069rX4mMQG3HmiUe5V+1kO2+jnFH4D/ZxeR2mBCRkMVc55bYAMiYmcFLZ9L6CBzQNlFm4Le4vMybcIDD50599r6OWolMxEz2lSOWUq+xbT4m+HCIY657xuBZGO2G2y2eVVz8kABzgLlCka3IO0EcHm1QaZRY9HVBAZpGQzi2Mycss25Az1/pyo1TmvFRChIk9ot+cmvU4EqiJ5oMidpin084TN0YTvjDD4/P+Y8pxtP+N6yHdVWD14PtTunNetILGqiA8KPFh4kCUw4+5iIRIoiubCbSg4q1db3EFcx/VV5AF9T9sp371QlUS8UmGKDXtNCuVIEF/h0cJ5UOf5tlThyhGTihSpC2BVrdSqR60K0kAVsScw9agdkBBWEHuaPfa1A2IqYuqhVT20KIipiKmH2jFXAYipiKmHRvXQpCCmIqYeKsdaDSCmIqYe2tRDm4KYiph6qBtjVYCMoCJdgyR4OLqhqIdGBclbYW7BHRXXVFfEnmczrXZoLG+FYCGoAyRDRW7AZQ65D+AnuBOw9oT5dGgM79OY3tCsHkD9Z7GKVOQR3LHnz9G/Mcf5nEK4Y23PoGm1BeB7AFdpTJcgcu1q/OAqs4jQShJkh9oz8oJ3lcZ2C0BXaxLwRHnHDpNkc9jDdMyDMpnVAuKVb5NOnTns4TvmA2OouYSEagURppY57HE65l3t9VXSADrYHHZzzE1BnsFhvwm9RXjsCdgxDwqQHKm+Ri8ztcwxN0CEw85JxW5mrUimIuaYN1ZBLDZijrkBsgedb5DUrh6dmBaxoAApiI2Yw67HtMo1g0NSjyAVpCA2UpTr1p5yAeFT2Pdi2UhJAx8M3kK8iH5cZIL+HVP2wVBMq8dwpR4u05gMbMWHph6h+iC+w75CA/IpvQ8rKWBPOXAUjkWIcAQLiICkcNUySCrxO+T2+0Uai29pbDqhwhE0IDHbvYE9WQFcLjcXvD8YNCDerpYFEOszrbKOAAUVEIxVQaSpZWe16jWt/IWpEzocUQBSIPVmall/GyAjntWqrRBkhOpRqNgxqEdUCjLCsXi7gbh3plVU0fJhTxrhIGZJ/2G4moBc+swCiM8OSKN2DWPyQfJMraf25U1Fnsu0ii5a3hhAMkytvMiuQfLsfkd00fJGASIgGbbamT/yfH5HVNHypvkgRfay+SN704/RRMsbpyCeP7Jj/khpfkcU0fJGAuKZWuaPlON3dGKGI3pAzB8xv8N8EPNHzO8wBTF/xPwOA8T8EfM7DJAA/JGm3h/hAGvj/Y7GAjKifd1poNPeE+rReL+j0YAU+CPLaGaWRpklZrnpfkfTFSTPH/kEwBc0QZrktEuzc5n64JMm+x3ySdHQZ/3jQ7324qqcGJxHK4Xb+uVt3wnEu/070kLRVDgaDUiOaZHCJZ07TO8MSYwFeoY55U01Nc3EyvFHRnFOe5HBMdJmRZPVo/GACEiGraSxQeLDkeeUd5sOhwEymtN+NzJzQ5qVd80pNx/keZx2floAjiP8pNhZO1Z/NafcAHnW1ZXhiGFnq0kqaSZWyU57oX0e2EQa2c8y9TBAxoUk9J2tkdtjcBgg40ASw86W7VgZIKVCMqrN3lMOh+1YmZNeDiRDdrYA4BUAs6IfW8rhsB0rA6SUyebvbOVB0lL6mSUctmNlgOy5imAIJNpiJMNiHQNwmHoYIGVDoi1GMrLfZHCYk16G0645RmKxDgNEHSRaYiQW6zBAVEGiKUZisQ4DRCUkGmIkFuswJ121415njMRiHQaI+mecGMleQlIEh8U6DBA1KoKKIRkLDlMPA6RJkBgcBohBYnAYIAbJeJAYHAaIQWJwGCAGyXiQGBwGiEGSA4nBYYAYJDmQGBwGiEGSAwkMDgPEIBkOicFhgBgkGZDM0L83DA4DxCDpP1xi4Sh9/R2ASwaHAdJkSPjuRgJgEv167QBwFcDfAPwLdhuw1sfug9QAiXDCH8Pd+Psa7v7GHXpdpu/do58xOGp6/g9eQPkxBqxc0wAAAABJRU5ErkJggg==";
let H_;
try {
  H_ = "free";
} catch {
  H_ = process.env.VITE_GEOMAN_VERSION || null;
}
const Fi = "gm", Ft = `_${Fi}`, Di = H_ === "pro", jb = {
  draw: {
    marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "marker",
      settings: {
        exclusive: !0
      }
    },
    circle_marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "circle_marker",
      settings: {
        exclusive: !0
      }
    },
    text_marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "text_marker",
      settings: {
        exclusive: !0
      }
    },
    circle: {
      type: "draw",
      eventType: "toggle",
      targetMode: "circle",
      settings: {
        exclusive: !0
      }
    },
    ellipse: {
      type: "draw",
      eventType: "toggle",
      targetMode: "ellipse",
      settings: {
        exclusive: !0
      }
    },
    line: {
      type: "draw",
      eventType: "toggle",
      targetMode: "line",
      settings: {
        exclusive: !0
      }
    },
    rectangle: {
      type: "draw",
      eventType: "toggle",
      targetMode: "rectangle",
      settings: {
        exclusive: !0
      }
    },
    polygon: {
      type: "draw",
      eventType: "toggle",
      targetMode: "polygon",
      settings: {
        exclusive: !0
      }
    },
    freehand: {
      type: "draw",
      eventType: "toggle",
      targetMode: "freehand",
      settings: {
        exclusive: !0
      }
    },
    custom_shape: {
      type: "draw",
      eventType: "toggle",
      targetMode: "custom_shape",
      settings: {
        exclusive: !0
      }
    }
  },
  edit: {
    drag: {
      type: "edit",
      eventType: "toggle",
      targetMode: "drag",
      settings: {
        exclusive: !0
      }
    },
    change: {
      type: "edit",
      eventType: "toggle",
      targetMode: "change",
      settings: {
        exclusive: !0
      }
    },
    rotate: {
      type: "edit",
      eventType: "toggle",
      targetMode: "rotate",
      settings: {
        exclusive: !0
      }
    },
    scale: {
      type: "edit",
      eventType: "toggle",
      targetMode: "scale",
      settings: {
        exclusive: !0
      }
    },
    copy: {
      type: "edit",
      eventType: "toggle",
      targetMode: "copy",
      settings: {
        exclusive: !0
      }
    },
    cut: {
      type: "edit",
      eventType: "toggle",
      targetMode: "cut",
      settings: {
        exclusive: !0
      }
    },
    split: {
      type: "edit",
      eventType: "toggle",
      targetMode: "split",
      settings: {
        exclusive: !0
      }
    },
    union: {
      type: "edit",
      eventType: "toggle",
      targetMode: "union",
      settings: {
        exclusive: !0
      }
    },
    difference: {
      type: "edit",
      eventType: "toggle",
      targetMode: "difference",
      settings: {
        exclusive: !0
      }
    },
    line_simplification: {
      type: "edit",
      eventType: "toggle",
      targetMode: "line_simplification",
      settings: {
        exclusive: !0
      }
    },
    lasso: {
      type: "edit",
      eventType: "toggle",
      targetMode: "lasso",
      settings: {
        exclusive: !0
      }
    },
    delete: {
      type: "edit",
      eventType: "toggle",
      targetMode: "delete",
      settings: {
        exclusive: !0
      }
    }
  },
  helper: {
    shape_markers: {
      type: "helper",
      eventType: "toggle",
      targetMode: "shape_markers",
      settings: {
        exclusive: !1,
        enabledBy: ["drag", "change", "rotate", "scale", "line_simplification"]
      }
    },
    snapping: {
      type: "helper",
      eventType: "toggle",
      targetMode: "snapping",
      settings: {
        exclusive: !1
      }
    },
    pin: {
      type: "helper",
      eventType: "toggle",
      targetMode: "pin",
      settings: {
        exclusive: !1
      }
    },
    snap_guides: {
      type: "helper",
      eventType: "toggle",
      targetMode: "snap_guides",
      settings: {
        exclusive: !1
      }
    },
    measurements: {
      type: "helper",
      eventType: "toggle",
      targetMode: "measurements",
      settings: {
        exclusive: !1
      }
    },
    auto_trace: {
      type: "helper",
      eventType: "toggle",
      targetMode: "auto_trace",
      settings: {
        exclusive: !1
      }
    },
    geofencing: {
      type: "helper",
      eventType: "toggle",
      targetMode: "geofencing",
      settings: {
        exclusive: !1
      }
    },
    zoom_to_features: {
      type: "helper",
      eventType: "click",
      targetMode: "zoom_to_features",
      settings: {
        exclusive: !1
      }
    },
    click_to_edit: {
      type: "helper",
      eventType: "toggle",
      targetMode: "click_to_edit",
      settings: {
        exclusive: !1
      }
    }
  }
}, KS = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="m22.775 29.562 6.75-6.75-5.625-5.625-3.6 3.6-3.15-3.15 3.6-3.6-5.626-5.55-6.75 6.75zm25.95 26.101 6.75-6.825-5.624-5.625-3.6 3.6-3.15-3.15 3.6-3.6-5.55-5.55-6.75 6.75zm.6-46.126 5.25 5.25ZM16.7 59.039H5v-11.7l14.55-14.551L2 15.237l13.05-13.2 17.7 17.624L46.1 6.312q.676-.676 1.5-.976.826-.3 1.65-.3.826 0 1.65.3.826.3 1.5.976l5.326 5.325q.675.675.975 1.5.3.825.3 1.65t-.3 1.65q-.3.825-.975 1.5l-13.35 13.35L62 48.913l-13.125 13.05-17.551-17.55Zm-7.2-4.5h5.25l29.476-29.552-5.25-5.25L9.5 49.288Zm32.1-32.178-2.625-2.625 5.25 5.25Z"/>
</svg>`, Vb = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <circle cx="32" cy="32" r="26" fill="currentColor" fill-opacity=".15" stroke="currentColor" stroke-width="7"/>
    <circle cx="32" cy="32" r="5" fill="currentColor"/>
</svg>`, QS = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <circle cx="32" cy="32" r="26" fill="currentColor" fill-opacity=".15" stroke="currentColor" stroke-width="7"/>
    <path stroke="currentColor" stroke-dasharray="3" stroke-width="4" d="M6 32h52M32 6v52"/>
</svg>`, ek = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   viewBox="0 0 64 64"
   version="1.1"
   id="svg2"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs2" />
  <path
     fill="none"
     d="M 0,0 H 24 V 24 H 0 Z"
     id="path1"
     style="display:inline" />
  <ellipse
     cx="32"
     cy="32"
     fill="currentColor"
     fill-opacity="0.15"
     stroke="currentColor"
     stroke-width="7"
     id="circle1"
     rx="26.787416"
     ry="15.158148" />
  <path
     stroke="currentColor"
     stroke-dasharray="3"
     stroke-width="4"
     d="M 6.4966994,32 H 58 M 32,18.552705 v 30.15073"
     id="path2"
     style="stroke-width:3;stroke-dasharray:3;stroke-dashoffset:0" />
</svg>
`, tk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path
            fill="currentColor"
            d="M32 61.4 19.85 49.42l3.28-3.235 6.634 6.542V34.205H10.98l6.26 6.174-3.279 3.234L2.185 32l11.852-11.686 3.28 3.234-6.336 6.247h18.783V11.273l-6.261 6.174-3.28-3.234L32 2.6l11.777 11.613-3.28 3.234-6.26-6.174v18.522h18.782l-6.26-6.174 3.279-3.234L61.815 32 50.038 43.613l-3.28-3.234 6.261-6.174H34.236v18.522l6.634-6.542 3.28 3.234z"
    />
</svg>
`, rk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <line x1="8" y1="50" x2="24" y2="20" stroke="currentColor" stroke-width="8"/>
    <line x1="24" y1="20" x2="40" y2="54" stroke="currentColor" stroke-width="8"/>
    <line x1="40" y1="54" x2="54" y2="10" stroke="currentColor" stroke-width="8"/>
    <circle cx="8" cy="50" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="24" cy="20" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="40" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, nk = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M32 62.81s23.107-21.898 23.107-38.512a23.107 23.107 0 0 0-46.214 0C8.893 40.912 32 62.809 32 62.809m0-26.958a11.554 11.554 0 1 1 0-23.107 11.554 11.554 0 0 1 0 23.107"/>
</svg>
`, ik = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <!-- Polygon -->
    <polygon points="8,28 40,6 55,35 51,55 18,54" fill="none" stroke="currentColor" stroke-width="8"/>

    <!-- Vertex Circles -->
    <circle cx="9" cy="28" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="40" cy="8" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="55" cy="35" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="50" cy="55" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="18" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, sk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <!-- Rectangle -->
    <polygon points="10,10 54,10 54,54 10,54" fill="none" stroke="currentColor" stroke-width="8"/>

    <!-- Vertex Circles -->
    <circle cx="10" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="10" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, ak = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M39.063 42.14 22.288 28.12 7.96 44.603l11.338 9.854h9.059zm-3.498 12.317h25.941v5.465h-44.25L4.377 48.726a5.465 5.465 0 0 1-.542-7.711L34.311 5.958a5.465 5.465 0 0 1 7.712-.538l16.496 14.343a5.465 5.465 0 0 1 .541 7.709z"/>
</svg>`, ok = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M58.709 17.724c-.3-.6-.601-.901-.902-1.502l-.3-.601c-.301-.601-.602-.902-.902-1.503l-.3-.601c-.301-.601-.602-.902-1.203-1.503l-.6-.901 8.414-9.317-13.825.3-13.824.301 1.502 13.524 1.503 13.524 9.617-10.819v.3l.3.602c.301.3.301.6.602.6l.3.602c0 .6 0 .901.3 1.202.903 2.104 1.804 4.208 2.105 6.311.6 4.208 0 8.716-1.804 12.623l-.6 1.202-.301.3-.902 1.503-.3.601c-.601.601-1.202 1.503-1.804 2.104-1.502 1.503-3.305 3.005-5.109 3.907-1.803 1.202-3.907 1.803-6.311 2.404-2.104.301-4.508.601-6.612.301-2.404-.3-4.508-.902-6.612-1.503-2.103-.901-3.907-2.104-5.71-3.606l-1.202-1.202-.601-.902-.601-.601c-.3-.3-.601-.601-.601-.902l-.902-1.202-.3-.3-.602-1.203c0-.3-.3-.3-.3-.6l-.902-1.503-.3-.601-.902-2.705q-.901-3.607-.901-7.213V27.04c0-.601 0-.901.3-1.202l.3-1.803.602-1.803c.901-2.405 2.103-4.509 3.606-6.612q2.254-3.156 5.41-5.41c.6-.3.901-1.202.3-1.803-.3-.3-.6-.601-.901-.601h-.601l-.3.3c-2.706 1.202-4.81 3.006-6.913 4.809-2.104 2.104-3.607 4.508-5.11 7.213-2.704 5.41-3.606 11.42-2.404 17.431.3 1.503.601 2.705.902 4.207l.902 2.405c.3.3.6.6.6 1.202l.602 1.202c0 .3.3.601.3.601l.902 1.503c.3.601.6.901.901 1.503l.301.6c.3.301.601.902.902 1.203l2.103 1.803c2.104 2.104 4.809 3.907 7.514 5.41q4.057 2.254 9.016 2.705c1.503.3 3.005.3 4.508.3 1.803 0 3.306 0 4.809-.3 3.005-.602 6.311-1.503 9.016-3.006l.6-.3c.602-.3.903-.601 1.504-.902l2.103-1.202c.601-.3.902-.601 1.203-.902l.6-.6a3.622 3.622 0 0 0 1.503-1.504l.3-.3c.902-.902 2.105-2.104 2.706-3.005l1.803-2.705 1.202-1.804c3.005-5.71 4.208-12.322 3.306-18.633-.601-3.306-1.503-6.612-3.005-9.317z"/>
</svg>
`, lk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <path fill="currentColor"
          d="M6.962 3.385h50.076a3.577 3.577 0 0 1 3.577 3.577v50.076a3.577 3.577 0 0 1-3.577 3.577H6.962a3.577 3.577 0 0 1-3.577-3.577V6.962a3.577 3.577 0 0 1 3.577-3.577Zm3.577 7.154v42.922h42.922V10.539Zm7.154 7.154h28.614v7.153H17.693Zm0 14.307h28.614v7.154H17.693Z"/>
</svg>
`, uk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path stroke="currentColor" fill="currentColor" stroke-width="2"
          d="M44.095 2.247a2.285 2.285 0 0 0-.135.04L12.025 12.762a2.285 2.285 0 0 0-1.497 1.588l-7.772 29.4a2.285 2.285 0 0 0 1.213 2.641L35.397 61.6a2.285 2.285 0 0 0 2.873-.754l22.64-32.582a2.285 2.285 0 0 0 .05-2.534L46.6 3.23a2.285 2.285 0 0 0-2.504-.982ZM43.7 7.182l12.203 19.12-5.167 1.76 1.052 3.09 2.031-.693L38.07 53.122l.01-1.375-3.262-.023-.034 4.5-27.13-13.127 6.975-26.38Zm3.946 21.932-6.18 2.105 1.052 3.09 6.18-2.105zm-9.27 3.157-2.329.793a1.632 1.632 0 0 0-1.105 1.534l-.03 4.068 3.265.024.02-2.91 1.232-.419zm-3.488 9.66-.047 6.529 3.264.023.048-6.528z"/>
</svg>
`, ck = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor" fill-rule="evenodd"
          d="M19.435 3.417c-4.478 0-8.96 1.693-12.343 5.076-6.766 6.766-6.766 17.913 0 24.679h.006c2.754 2.749 5.563 5.561 8.357 8.357 1.857 1.859 3.696 3.696 5.553 5.553l.949.949 1.892 1.898 9.496-9.49-1.898-1.898-6.502-6.502c-2.796-2.797-5.6-5.606-8.363-8.362-1.65-1.653-1.652-4.042 0-5.694 1.653-1.653 4.047-1.653 5.7 0l8.357 8.362 6.502 6.502 1.898 1.893 9.49-9.49-1.893-1.893-6.507-6.502-8.357-8.362c-3.384-3.383-7.86-5.076-12.337-5.076Zm0 2.68c3.789 0 7.577 1.432 10.439 4.294l8.357 8.362-5.694 5.694-8.357-8.362a6.7 6.7 0 0 0-9.496 0 6.697 6.697 0 0 0 0 9.49c2.76 2.755 5.566 5.564 8.363 8.362l-5.694 5.694c-2.795-2.796-5.601-5.607-8.357-8.357H8.99c-5.724-5.724-5.724-15.16 0-20.883 2.861-2.862 6.655-4.294 10.444-4.294ZM57.709 29.03a4.266 4.266 0 0 0-4.268 4.268c0 1.594.881 2.973 2.176 3.707-.714 4.997-1.424 10.107-2.176 15.037-.934 0-1.792.309-2.495.818l-7.115-5.07a4.25 4.25 0 0 0 .115-.965 4.27 4.27 0 1 0-4.268 4.268 4.23 4.23 0 0 0 2.732-1.012l6.973 4.965a4.22 4.22 0 0 0-.215 1.269 4.27 4.27 0 0 0 4.273 4.268 4.266 4.266 0 0 0 4.268-4.268 4.247 4.247 0 0 0-1.657-3.356l2.208-15.446c2.095-.273 3.722-2.045 3.722-4.215a4.27 4.27 0 0 0-4.273-4.268z"
    />
</svg>
`, hk = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M1.585 1.585V13.75h5.17v1.52H8.58v-1.52h5.17V1.585Zm3.041 3.041h6.083v6.083H4.626Zm9.429 2.13V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.474 0V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.475 0v1.597a1.521 1.521 0 0 0-.325.152l-15.686 9.758a1.52 1.52 0 0 0-.199 2.437l23.512 20.553a1.52 1.52 0 0 0 2.477-.78l4.212-17.037v.352h1.825v-3.65H55.42v1.524a1.52 1.52 0 0 0-.222-.296L43.002 8.741a1.521 1.521 0 0 0-.182-.16h2.259V6.754Zm5.475 0V8.58h3.65V6.755Zm5.474 0V8.58h3.65V6.755Zm3.042 2.432v3.65h1.825v-3.65Zm-13.752 2.549 10.757 11.137-3.57 14.446-20.087-17.559Zm13.752 2.926v3.65h1.825v-3.65ZM6.755 17.096v3.65H8.58v-3.65zm0 5.475v3.65h1.628a1.52 1.52 0 0 0 1.02.909l12.683 3.406 7.905 12.694c.168.27.417.481.712.602l13.39 4.576a1.52 1.52 0 0 0 1.157-2.814l-12.936-4.389L24.35 28.42a1.52 1.52 0 0 0-.896-.664L10.19 24.193a1.52 1.52 0 0 0-1.61.557v-2.178zm48.665 3.042v3.65h1.825v-3.65ZM6.755 28.046v3.65H8.58v-3.65zm48.665 3.042v3.65h1.825v-3.65ZM6.755 33.52v3.65H8.58v-3.65zm48.665 3.041v3.65h1.825v-3.65ZM6.755 38.996v3.65H8.58v-3.65zm48.665 3.041v3.65h1.825v-3.65zm-35.382.913c-3.454 0-6.287 2.833-6.287 6.287 0 3.076 2.248 5.654 5.179 6.183h-1.225v1.825h3.65V55.42h-.206c2.712-.5 4.777-2.796 5.055-5.59l.002-.002a1.52 1.52 0 0 0 0-1.18c-.314-3.168-2.922-5.698-6.168-5.698zM6.755 44.47v3.65H8.58v-3.65zm13.283 1.521a3.223 3.223 0 0 1 3.246 3.246 3.223 3.223 0 0 1-3.246 3.246 3.223 3.223 0 0 1-3.246-3.246 3.223 3.223 0 0 1 3.246-3.246zm35.382 1.52v2.738h-5.17v12.166h12.165V50.25h-5.17v-2.737ZM6.755 49.946v3.65H8.58v-3.65zm46.536 3.346h6.083v6.083H53.29ZM6.755 55.42v1.825h3.65V55.42H7.668Zm5.475 0v1.825h3.65V55.42zm10.95 0v1.825h3.65V55.42zm5.474 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42z"/>
</svg>
`, cs = {
  marker: nk,
  circle: QS,
  ellipse: ek,
  circle_marker: Vb,
  text_marker: lk,
  line: rk,
  rectangle: sk,
  polygon: ik,
  drag: tk,
  change: KS,
  rotate: ok,
  cut: uk,
  delete: ak,
  snapping: ck,
  zoom_to_features: hk
}, g_ = (a) => [
  {
    type: "circle",
    paint: {
      "circle-radius": a.circleMarkerRadius,
      "circle-color": a.fillColor,
      "circle-opacity": a.fillOpacity,
      "circle-stroke-color": a.lineColor,
      "circle-stroke-width": a.lineWidth,
      "circle-stroke-opacity": a.lineOpacity
    }
  }
], xh = (a) => [
  {
    type: "circle",
    paint: {
      "circle-radius": 7,
      "circle-color": "#ffffff",
      "circle-opacity": 1,
      "circle-stroke-color": a.lineColor,
      "circle-stroke-width": 2,
      "circle-stroke-opacity": 1
    }
  }
], m_ = (a) => [
  {
    type: "line",
    paint: {
      "line-color": a.lineColor,
      "line-opacity": a.lineOpacity,
      "line-width": a.lineWidth
    }
  }
], __ = () => [
  {
    type: "symbol",
    layout: {
      "icon-image": "default-marker",
      "icon-size": 0.18,
      "icon-allow-overlap": !0,
      "icon-anchor": "bottom"
    }
  }
], ca = (a) => [
  {
    type: "fill",
    paint: {
      "fill-color": a.fillColor,
      "fill-opacity": a.fillOpacity
    }
  },
  {
    type: "line",
    paint: {
      "line-color": a.lineColor,
      "line-opacity": a.lineOpacity,
      "line-width": a.lineWidth
    }
  }
], y_ = (a) => [
  {
    type: "circle",
    paint: {
      "circle-radius": 6,
      "circle-color": "#ffffff",
      "circle-opacity": 0.6,
      "circle-stroke-color": a.lineColor,
      "circle-stroke-width": 2,
      "circle-stroke-opacity": 1
    }
  }
], v_ = () => [
  {
    type: "line",
    paint: {
      "line-color": "#00979f",
      "line-width": 1.8,
      "line-dasharray": [2, 1]
    }
  }
], rs = `__${Fi}_`, Hs = `${rs}id`, Nx = 6e4, wt = {
  // order matters here, layers order will be aligned according to these items
  ...Di && { standby: `${Fi}_standby` },
  // available only in the pro version
  main: `${Fi}_main`,
  temporary: `${Fi}_temporary`
}, x_ = () => [
  {
    type: "symbol",
    layout: {
      "text-field": ["get", `${rs}text`],
      "text-justify": "center"
    },
    paint: {
      "text-color": "black",
      "text-halo-color": "#fff",
      "text-halo-width": 2
    }
  }
], dn = {
  [wt.main]: {
    lineColor: "#278cda",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#4fb3ff",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  },
  [wt.temporary]: {
    lineColor: "#ff5600",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#4fb3ff",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  },
  ...Di && {
    [wt.standby]: {
      lineColor: "#787878",
      lineOpacity: 0.8,
      lineWidth: 3,
      fillColor: "#a5a5a5",
      fillOpacity: 0.4,
      circleMarkerRadius: 10
    }
  }
}, dk = {
  // order matters here, layers order will be aligned according to these items
  polygon: {
    [wt.main]: ca(dn[wt.main]),
    [wt.temporary]: ca(dn[wt.temporary]),
    ...Di && { [wt.standby]: ca(dn[wt.standby]) }
  },
  ellipse: {
    [wt.main]: ca(dn[wt.main]),
    [wt.temporary]: ca(dn[wt.temporary]),
    ...Di && { [wt.standby]: ca(dn[wt.standby]) }
  },
  rectangle: {
    [wt.main]: ca(dn[wt.main]),
    [wt.temporary]: ca(dn[wt.temporary]),
    ...Di && { [wt.standby]: ca(dn[wt.standby]) }
  },
  circle: {
    [wt.main]: ca(dn[wt.main]),
    [wt.temporary]: ca(dn[wt.temporary]),
    ...Di && { [wt.standby]: ca(dn[wt.standby]) }
  },
  circle_marker: {
    [wt.main]: g_(dn[wt.main]),
    [wt.temporary]: g_(dn[wt.temporary]),
    ...Di && { [wt.standby]: g_(dn[wt.standby]) }
  },
  line: {
    [wt.main]: m_(dn[wt.main]),
    [wt.temporary]: m_(dn[wt.temporary]),
    ...Di && { [wt.standby]: m_(dn[wt.standby]) }
  },
  marker: {
    [wt.temporary]: __(),
    [wt.main]: __(),
    ...Di && { [wt.standby]: __() }
  },
  text_marker: {
    [wt.main]: x_(),
    [wt.temporary]: x_(),
    ...Di && { [wt.standby]: x_() }
  },
  dom_marker: {
    // not a geojson source, layers aren't required
    [wt.main]: [],
    [wt.temporary]: [],
    ...Di && { [wt.standby]: [] }
  },
  center_marker: {
    [wt.main]: xh(dn[wt.main]),
    [wt.temporary]: xh(dn[wt.temporary]),
    ...Di && { [wt.standby]: xh(dn[wt.standby]) }
  },
  vertex_marker: {
    [wt.main]: xh(dn[wt.main]),
    [wt.temporary]: xh(dn[wt.temporary]),
    ...Di && { [wt.standby]: xh(dn[wt.standby]) }
  },
  edge_marker: {
    [wt.main]: y_(dn[wt.main]),
    [wt.temporary]: y_(dn[wt.temporary]),
    ...Di && {
      [wt.standby]: y_(dn[wt.standby])
    }
  },
  snap_guide: {
    // todo: check which sources can't display snap guides (and other shapes) and remove layers
    [wt.main]: v_(),
    [wt.temporary]: v_(),
    ...Di && { [wt.standby]: v_() }
  }
}, fk = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="#0A95F0" class="bi bi-geo-alt-fill"
     viewBox="0 0 16 16">
    <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10m0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6"/>
</svg>
`, pk = `<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21">
    <circle cx="10.5" cy="10.5" r="9.213" fill="#fff" stroke="#278cda" stroke-width="2.303"/>
</svg>
`, gk = {
  settings: {
    throttlingDelay: 10,
    awaitDataUpdatesOnEvents: !0,
    useDefaultLayers: !0,
    controlsPosition: "top-left",
    controlsUiEnabledByDefault: !0,
    controlsCollapsible: !1,
    controlsStyles: {
      controlGroupClass: "maplibregl-ctrl maplibregl-ctrl-group",
      controlContainerClass: "gm-control-container",
      controlButtonClass: "gm-control-button"
    },
    idGenerator: null,
    markerIcons: {
      default: fk,
      control: pk
    }
  },
  layerStyles: dk,
  controls: {
    draw: {
      marker: {
        title: "Marker",
        icon: cs.marker,
        uiEnabled: !0,
        active: !1
      },
      circle_marker: {
        title: "Circle Marker",
        icon: cs.circle_marker,
        uiEnabled: !0,
        active: !1
      },
      text_marker: {
        title: "Text Marker",
        icon: cs.text_marker,
        uiEnabled: !0,
        active: !1
      },
      circle: {
        title: "Circle",
        icon: cs.circle,
        uiEnabled: !0,
        active: !1
      },
      ellipse: {
        title: "Ellipse",
        icon: cs.ellipse,
        uiEnabled: !0,
        active: !1
      },
      line: {
        title: "Line",
        icon: cs.line,
        uiEnabled: !0,
        active: !1
      },
      rectangle: {
        title: "Rectangle",
        icon: cs.rectangle,
        uiEnabled: !0,
        active: !1
      },
      polygon: {
        title: "Polygon",
        icon: cs.polygon,
        uiEnabled: !0,
        active: !1
      }
    },
    edit: {
      drag: {
        title: "Drag",
        icon: cs.drag,
        uiEnabled: !0,
        active: !1
      },
      change: {
        title: "Change",
        icon: cs.change,
        uiEnabled: !0,
        active: !1
      },
      rotate: {
        title: "Rotate",
        icon: cs.rotate,
        uiEnabled: !0,
        active: !1
      },
      cut: {
        title: "Cut",
        icon: cs.cut,
        uiEnabled: !0,
        active: !1
      },
      delete: {
        title: "Delete",
        icon: cs.delete,
        uiEnabled: !0,
        active: !1
      }
    },
    helper: {
      shape_markers: {
        title: "Shape markers",
        icon: null,
        uiEnabled: !1,
        active: !1
      },
      snapping: {
        title: "Snapping",
        icon: cs.snapping,
        uiEnabled: !0,
        active: !1
      },
      zoom_to_features: {
        title: "Zoom to features",
        icon: cs.zoom_to_features,
        uiEnabled: !0,
        active: !1
      }
    }
  }
};
var Ub = typeof global == "object" && global && global.Object === Object && global, mk = typeof self == "object" && self && self.Object === Object && self, Ka = Ub || mk || Function("return this")(), ya = Ka.Symbol, qb = Object.prototype, _k = qb.hasOwnProperty, yk = qb.toString, Hd = ya ? ya.toStringTag : void 0;
function vk(a) {
  var n = _k.call(a, Hd), l = a[Hd];
  try {
    a[Hd] = void 0;
    var p = !0;
  } catch {
  }
  var x = yk.call(a);
  return p && (n ? a[Hd] = l : delete a[Hd]), x;
}
var xk = Object.prototype, bk = xk.toString;
function wk(a) {
  return bk.call(a);
}
var Ek = "[object Null]", Tk = "[object Undefined]", Ox = ya ? ya.toStringTag : void 0;
function mc(a) {
  return a == null ? a === void 0 ? Tk : Ek : Ox && Ox in Object(a) ? vk(a) : wk(a);
}
function So(a) {
  return a != null && typeof a == "object";
}
var Sk = "[object Symbol]";
function Rh(a) {
  return typeof a == "symbol" || So(a) && mc(a) == Sk;
}
function Ph(a, n) {
  for (var l = -1, p = a == null ? 0 : a.length, x = Array(p); ++l < p; )
    x[l] = n(a[l], l, a);
  return x;
}
var gs = Array.isArray, zx = ya ? ya.prototype : void 0, Bx = zx ? zx.toString : void 0;
function $b(a) {
  if (typeof a == "string")
    return a;
  if (gs(a))
    return Ph(a, $b) + "";
  if (Rh(a))
    return Bx ? Bx.call(a) : "";
  var n = a + "";
  return n == "0" && 1 / a == -1 / 0 ? "-0" : n;
}
var kk = /\s/;
function Ik(a) {
  for (var n = a.length; n-- && kk.test(a.charAt(n)); )
    ;
  return n;
}
var Mk = /^\s+/;
function Ck(a) {
  return a && a.slice(0, Ik(a) + 1).replace(Mk, "");
}
function ms(a) {
  var n = typeof a;
  return a != null && (n == "object" || n == "function");
}
var Gx = NaN, Pk = /^[-+]0x[0-9a-f]+$/i, Ak = /^0b[01]+$/i, Lk = /^0o[0-7]+$/i, Dk = parseInt;
function jx(a) {
  if (typeof a == "number")
    return a;
  if (Rh(a))
    return Gx;
  if (ms(a)) {
    var n = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = ms(n) ? n + "" : n;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = Ck(a);
  var l = Ak.test(a);
  return l || Lk.test(a) ? Dk(a.slice(2), l ? 2 : 8) : Pk.test(a) ? Gx : +a;
}
function jg(a) {
  return a;
}
var Rk = "[object AsyncFunction]", Fk = "[object Function]", Nk = "[object GeneratorFunction]", Ok = "[object Proxy]";
function zy(a) {
  if (!ms(a))
    return !1;
  var n = mc(a);
  return n == Fk || n == Nk || n == Rk || n == Ok;
}
var b_ = Ka["__core-js_shared__"], Vx = (function() {
  var a = /[^.]+$/.exec(b_ && b_.keys && b_.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
})();
function zk(a) {
  return !!Vx && Vx in a;
}
var Bk = Function.prototype, Gk = Bk.toString;
function _c(a) {
  if (a != null) {
    try {
      return Gk.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var jk = /[\\^$.*+?()[\]{}|]/g, Vk = /^\[object .+?Constructor\]$/, Uk = Function.prototype, qk = Object.prototype, $k = Uk.toString, Zk = qk.hasOwnProperty, Hk = RegExp(
  "^" + $k.call(Zk).replace(jk, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Yk(a) {
  if (!ms(a) || zk(a))
    return !1;
  var n = zy(a) ? Hk : Vk;
  return n.test(_c(a));
}
function Wk(a, n) {
  return a?.[n];
}
function yc(a, n) {
  var l = Wk(a, n);
  return Yk(l) ? l : void 0;
}
var Y_ = yc(Ka, "WeakMap"), Ux = Object.create, Xk = /* @__PURE__ */ (function() {
  function a() {
  }
  return function(n) {
    if (!ms(n))
      return {};
    if (Ux)
      return Ux(n);
    a.prototype = n;
    var l = new a();
    return a.prototype = void 0, l;
  };
})();
function Jk(a, n, l) {
  switch (l.length) {
    case 0:
      return a.call(n);
    case 1:
      return a.call(n, l[0]);
    case 2:
      return a.call(n, l[0], l[1]);
    case 3:
      return a.call(n, l[0], l[1], l[2]);
  }
  return a.apply(n, l);
}
function Kk() {
}
function Qk(a, n) {
  var l = -1, p = a.length;
  for (n || (n = Array(p)); ++l < p; )
    n[l] = a[l];
  return n;
}
var eI = 800, tI = 16, rI = Date.now;
function nI(a) {
  var n = 0, l = 0;
  return function() {
    var p = rI(), x = tI - (p - l);
    if (l = p, x > 0) {
      if (++n >= eI)
        return arguments[0];
    } else
      n = 0;
    return a.apply(void 0, arguments);
  };
}
function iI(a) {
  return function() {
    return a;
  };
}
var wg = (function() {
  try {
    var a = yc(Object, "defineProperty");
    return a({}, "", {}), a;
  } catch {
  }
})(), sI = wg ? function(a, n) {
  return wg(a, "toString", {
    configurable: !0,
    enumerable: !1,
    value: iI(n),
    writable: !0
  });
} : jg, aI = nI(sI);
function oI(a, n) {
  for (var l = -1, p = a == null ? 0 : a.length; ++l < p && n(a[l], l, a) !== !1; )
    ;
  return a;
}
function lI(a, n, l, p) {
  for (var x = a.length, M = l + -1; ++M < x; )
    if (n(a[M], M, a))
      return M;
  return -1;
}
function uI(a) {
  return a !== a;
}
function cI(a, n, l) {
  for (var p = l - 1, x = a.length; ++p < x; )
    if (a[p] === n)
      return p;
  return -1;
}
function hI(a, n, l) {
  return n === n ? cI(a, n, l) : lI(a, uI, l);
}
function Zb(a, n) {
  var l = a == null ? 0 : a.length;
  return !!l && hI(a, n, 0) > -1;
}
var dI = 9007199254740991, fI = /^(?:0|[1-9]\d*)$/;
function Vg(a, n) {
  var l = typeof a;
  return n = n ?? dI, !!n && (l == "number" || l != "symbol" && fI.test(a)) && a > -1 && a % 1 == 0 && a < n;
}
function Df(a, n, l) {
  n == "__proto__" && wg ? wg(a, n, {
    configurable: !0,
    enumerable: !0,
    value: l,
    writable: !0
  }) : a[n] = l;
}
function Rf(a, n) {
  return a === n || a !== a && n !== n;
}
var pI = Object.prototype, gI = pI.hasOwnProperty;
function By(a, n, l) {
  var p = a[n];
  (!(gI.call(a, n) && Rf(p, l)) || l === void 0 && !(n in a)) && Df(a, n, l);
}
function mI(a, n, l, p) {
  var x = !l;
  l || (l = {});
  for (var M = -1, T = n.length; ++M < T; ) {
    var u = n[M], R = void 0;
    R === void 0 && (R = a[u]), x ? Df(l, u, R) : By(l, u, R);
  }
  return l;
}
var qx = Math.max;
function _I(a, n, l) {
  return n = qx(n === void 0 ? a.length - 1 : n, 0), function() {
    for (var p = arguments, x = -1, M = qx(p.length - n, 0), T = Array(M); ++x < M; )
      T[x] = p[n + x];
    x = -1;
    for (var u = Array(n + 1); ++x < n; )
      u[x] = p[x];
    return u[n] = l(T), Jk(a, this, u);
  };
}
function Gy(a, n) {
  return aI(_I(a, n, jg), a + "");
}
var yI = 9007199254740991;
function jy(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= yI;
}
function qh(a) {
  return a != null && jy(a.length) && !zy(a);
}
function W_(a, n, l) {
  if (!ms(l))
    return !1;
  var p = typeof n;
  return (p == "number" ? qh(l) && Vg(n, l.length) : p == "string" && n in l) ? Rf(l[n], a) : !1;
}
function Hb(a) {
  return Gy(function(n, l) {
    var p = -1, x = l.length, M = x > 1 ? l[x - 1] : void 0, T = x > 2 ? l[2] : void 0;
    for (M = a.length > 3 && typeof M == "function" ? (x--, M) : void 0, T && W_(l[0], l[1], T) && (M = x < 3 ? void 0 : M, x = 1), n = Object(n); ++p < x; ) {
      var u = l[p];
      u && a(n, u, p, M);
    }
    return n;
  });
}
var vI = Object.prototype;
function Vy(a) {
  var n = a && a.constructor, l = typeof n == "function" && n.prototype || vI;
  return a === l;
}
function xI(a, n) {
  for (var l = -1, p = Array(a); ++l < a; )
    p[l] = n(l);
  return p;
}
var bI = "[object Arguments]";
function $x(a) {
  return So(a) && mc(a) == bI;
}
var Yb = Object.prototype, wI = Yb.hasOwnProperty, EI = Yb.propertyIsEnumerable, wf = $x(/* @__PURE__ */ (function() {
  return arguments;
})()) ? $x : function(a) {
  return So(a) && wI.call(a, "callee") && !EI.call(a, "callee");
};
function TI() {
  return !1;
}
var Wb = typeof exports == "object" && exports && !exports.nodeType && exports, Zx = Wb && typeof module == "object" && module && !module.nodeType && module, SI = Zx && Zx.exports === Wb, Hx = SI ? Ka.Buffer : void 0, kI = Hx ? Hx.isBuffer : void 0, Ef = kI || TI, II = "[object Arguments]", MI = "[object Array]", CI = "[object Boolean]", PI = "[object Date]", AI = "[object Error]", LI = "[object Function]", DI = "[object Map]", RI = "[object Number]", FI = "[object Object]", NI = "[object RegExp]", OI = "[object Set]", zI = "[object String]", BI = "[object WeakMap]", GI = "[object ArrayBuffer]", jI = "[object DataView]", VI = "[object Float32Array]", UI = "[object Float64Array]", qI = "[object Int8Array]", $I = "[object Int16Array]", ZI = "[object Int32Array]", HI = "[object Uint8Array]", YI = "[object Uint8ClampedArray]", WI = "[object Uint16Array]", XI = "[object Uint32Array]", kn = {};
kn[VI] = kn[UI] = kn[qI] = kn[$I] = kn[ZI] = kn[HI] = kn[YI] = kn[WI] = kn[XI] = !0;
kn[II] = kn[MI] = kn[GI] = kn[CI] = kn[jI] = kn[PI] = kn[AI] = kn[LI] = kn[DI] = kn[RI] = kn[FI] = kn[NI] = kn[OI] = kn[zI] = kn[BI] = !1;
function JI(a) {
  return So(a) && jy(a.length) && !!kn[mc(a)];
}
function Ug(a) {
  return function(n) {
    return a(n);
  };
}
var Xb = typeof exports == "object" && exports && !exports.nodeType && exports, pf = Xb && typeof module == "object" && module && !module.nodeType && module, KI = pf && pf.exports === Xb, w_ = KI && Ub.process, Fh = (function() {
  try {
    var a = pf && pf.require && pf.require("util").types;
    return a || w_ && w_.binding && w_.binding("util");
  } catch {
  }
})(), Yx = Fh && Fh.isTypedArray, Uy = Yx ? Ug(Yx) : JI, QI = Object.prototype, eM = QI.hasOwnProperty;
function Jb(a, n) {
  var l = gs(a), p = !l && wf(a), x = !l && !p && Ef(a), M = !l && !p && !x && Uy(a), T = l || p || x || M, u = T ? xI(a.length, String) : [], R = u.length;
  for (var z in a)
    (n || eM.call(a, z)) && !(T && // Safari 9 has enumerable `arguments.length` in strict mode.
    (z == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    x && (z == "offset" || z == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    M && (z == "buffer" || z == "byteLength" || z == "byteOffset") || // Skip index properties.
    Vg(z, R))) && u.push(z);
  return u;
}
function Kb(a, n) {
  return function(l) {
    return a(n(l));
  };
}
var tM = Kb(Object.keys, Object), rM = Object.prototype, nM = rM.hasOwnProperty;
function iM(a) {
  if (!Vy(a))
    return tM(a);
  var n = [];
  for (var l in Object(a))
    nM.call(a, l) && l != "constructor" && n.push(l);
  return n;
}
function qg(a) {
  return qh(a) ? Jb(a) : iM(a);
}
function sM(a) {
  var n = [];
  if (a != null)
    for (var l in Object(a))
      n.push(l);
  return n;
}
var aM = Object.prototype, oM = aM.hasOwnProperty;
function lM(a) {
  if (!ms(a))
    return sM(a);
  var n = Vy(a), l = [];
  for (var p in a)
    p == "constructor" && (n || !oM.call(a, p)) || l.push(p);
  return l;
}
function Qb(a) {
  return qh(a) ? Jb(a, !0) : lM(a);
}
var uM = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, cM = /^\w*$/;
function qy(a, n) {
  if (gs(a))
    return !1;
  var l = typeof a;
  return l == "number" || l == "symbol" || l == "boolean" || a == null || Rh(a) ? !0 : cM.test(a) || !uM.test(a) || n != null && a in Object(n);
}
var Tf = yc(Object, "create");
function hM() {
  this.__data__ = Tf ? Tf(null) : {}, this.size = 0;
}
function dM(a) {
  var n = this.has(a) && delete this.__data__[a];
  return this.size -= n ? 1 : 0, n;
}
var fM = "__lodash_hash_undefined__", pM = Object.prototype, gM = pM.hasOwnProperty;
function mM(a) {
  var n = this.__data__;
  if (Tf) {
    var l = n[a];
    return l === fM ? void 0 : l;
  }
  return gM.call(n, a) ? n[a] : void 0;
}
var _M = Object.prototype, yM = _M.hasOwnProperty;
function vM(a) {
  var n = this.__data__;
  return Tf ? n[a] !== void 0 : yM.call(n, a);
}
var xM = "__lodash_hash_undefined__";
function bM(a, n) {
  var l = this.__data__;
  return this.size += this.has(a) ? 0 : 1, l[a] = Tf && n === void 0 ? xM : n, this;
}
function lc(a) {
  var n = -1, l = a == null ? 0 : a.length;
  for (this.clear(); ++n < l; ) {
    var p = a[n];
    this.set(p[0], p[1]);
  }
}
lc.prototype.clear = hM;
lc.prototype.delete = dM;
lc.prototype.get = mM;
lc.prototype.has = vM;
lc.prototype.set = bM;
function wM() {
  this.__data__ = [], this.size = 0;
}
function $g(a, n) {
  for (var l = a.length; l--; )
    if (Rf(a[l][0], n))
      return l;
  return -1;
}
var EM = Array.prototype, TM = EM.splice;
function SM(a) {
  var n = this.__data__, l = $g(n, a);
  if (l < 0)
    return !1;
  var p = n.length - 1;
  return l == p ? n.pop() : TM.call(n, l, 1), --this.size, !0;
}
function kM(a) {
  var n = this.__data__, l = $g(n, a);
  return l < 0 ? void 0 : n[l][1];
}
function IM(a) {
  return $g(this.__data__, a) > -1;
}
function MM(a, n) {
  var l = this.__data__, p = $g(l, a);
  return p < 0 ? (++this.size, l.push([a, n])) : l[p][1] = n, this;
}
function fl(a) {
  var n = -1, l = a == null ? 0 : a.length;
  for (this.clear(); ++n < l; ) {
    var p = a[n];
    this.set(p[0], p[1]);
  }
}
fl.prototype.clear = wM;
fl.prototype.delete = SM;
fl.prototype.get = kM;
fl.prototype.has = IM;
fl.prototype.set = MM;
var Sf = yc(Ka, "Map");
function CM() {
  this.size = 0, this.__data__ = {
    hash: new lc(),
    map: new (Sf || fl)(),
    string: new lc()
  };
}
function PM(a) {
  var n = typeof a;
  return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? a !== "__proto__" : a === null;
}
function Zg(a, n) {
  var l = a.__data__;
  return PM(n) ? l[typeof n == "string" ? "string" : "hash"] : l.map;
}
function AM(a) {
  var n = Zg(this, a).delete(a);
  return this.size -= n ? 1 : 0, n;
}
function LM(a) {
  return Zg(this, a).get(a);
}
function DM(a) {
  return Zg(this, a).has(a);
}
function RM(a, n) {
  var l = Zg(this, a), p = l.size;
  return l.set(a, n), this.size += l.size == p ? 0 : 1, this;
}
function pl(a) {
  var n = -1, l = a == null ? 0 : a.length;
  for (this.clear(); ++n < l; ) {
    var p = a[n];
    this.set(p[0], p[1]);
  }
}
pl.prototype.clear = CM;
pl.prototype.delete = AM;
pl.prototype.get = LM;
pl.prototype.has = DM;
pl.prototype.set = RM;
var FM = "Expected a function";
function $y(a, n) {
  if (typeof a != "function" || n != null && typeof n != "function")
    throw new TypeError(FM);
  var l = function() {
    var p = arguments, x = n ? n.apply(this, p) : p[0], M = l.cache;
    if (M.has(x))
      return M.get(x);
    var T = a.apply(this, p);
    return l.cache = M.set(x, T) || M, T;
  };
  return l.cache = new ($y.Cache || pl)(), l;
}
$y.Cache = pl;
var NM = 500;
function OM(a) {
  var n = $y(a, function(p) {
    return l.size === NM && l.clear(), p;
  }), l = n.cache;
  return n;
}
var zM = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, BM = /\\(\\)?/g, GM = OM(function(a) {
  var n = [];
  return a.charCodeAt(0) === 46 && n.push(""), a.replace(zM, function(l, p, x, M) {
    n.push(x ? M.replace(BM, "$1") : p || l);
  }), n;
});
function jM(a) {
  return a == null ? "" : $b(a);
}
function Zy(a, n) {
  return gs(a) ? a : qy(a, n) ? [a] : GM(jM(a));
}
function Ff(a) {
  if (typeof a == "string" || Rh(a))
    return a;
  var n = a + "";
  return n == "0" && 1 / a == -1 / 0 ? "-0" : n;
}
function Hy(a, n) {
  n = Zy(n, a);
  for (var l = 0, p = n.length; a != null && l < p; )
    a = a[Ff(n[l++])];
  return l && l == p ? a : void 0;
}
function Nh(a, n, l) {
  var p = a == null ? void 0 : Hy(a, n);
  return p === void 0 ? l : p;
}
function ew(a, n) {
  for (var l = -1, p = n.length, x = a.length; ++l < p; )
    a[x + l] = n[l];
  return a;
}
var Wx = ya ? ya.isConcatSpreadable : void 0;
function VM(a) {
  return gs(a) || wf(a) || !!(Wx && a && a[Wx]);
}
function UM(a, n, l, p, x) {
  var M = -1, T = a.length;
  for (l || (l = VM), x || (x = []); ++M < T; ) {
    var u = a[M];
    l(u) ? ew(x, u) : x[x.length] = u;
  }
  return x;
}
var tw = Kb(Object.getPrototypeOf, Object), qM = "[object Object]", $M = Function.prototype, ZM = Object.prototype, rw = $M.toString, HM = ZM.hasOwnProperty, YM = rw.call(Object);
function nw(a) {
  if (!So(a) || mc(a) != qM)
    return !1;
  var n = tw(a);
  if (n === null)
    return !0;
  var l = HM.call(n, "constructor") && n.constructor;
  return typeof l == "function" && l instanceof l && rw.call(l) == YM;
}
function WM() {
  this.__data__ = new fl(), this.size = 0;
}
function XM(a) {
  var n = this.__data__, l = n.delete(a);
  return this.size = n.size, l;
}
function JM(a) {
  return this.__data__.get(a);
}
function KM(a) {
  return this.__data__.has(a);
}
var QM = 200;
function eC(a, n) {
  var l = this.__data__;
  if (l instanceof fl) {
    var p = l.__data__;
    if (!Sf || p.length < QM - 1)
      return p.push([a, n]), this.size = ++l.size, this;
    l = this.__data__ = new pl(p);
  }
  return l.set(a, n), this.size = l.size, this;
}
function Ya(a) {
  var n = this.__data__ = new fl(a);
  this.size = n.size;
}
Ya.prototype.clear = WM;
Ya.prototype.delete = XM;
Ya.prototype.get = JM;
Ya.prototype.has = KM;
Ya.prototype.set = eC;
var iw = typeof exports == "object" && exports && !exports.nodeType && exports, Xx = iw && typeof module == "object" && module && !module.nodeType && module, tC = Xx && Xx.exports === iw, Jx = tC ? Ka.Buffer : void 0, Kx = Jx ? Jx.allocUnsafe : void 0;
function sw(a, n) {
  if (n)
    return a.slice();
  var l = a.length, p = Kx ? Kx(l) : new a.constructor(l);
  return a.copy(p), p;
}
function rC(a, n) {
  for (var l = -1, p = a == null ? 0 : a.length, x = 0, M = []; ++l < p; ) {
    var T = a[l];
    n(T, l, a) && (M[x++] = T);
  }
  return M;
}
function nC() {
  return [];
}
var iC = Object.prototype, sC = iC.propertyIsEnumerable, Qx = Object.getOwnPropertySymbols, aC = Qx ? function(a) {
  return a == null ? [] : (a = Object(a), rC(Qx(a), function(n) {
    return sC.call(a, n);
  }));
} : nC;
function oC(a, n, l) {
  var p = n(a);
  return gs(a) ? p : ew(p, l(a));
}
function X_(a) {
  return oC(a, qg, aC);
}
var J_ = yc(Ka, "DataView"), K_ = yc(Ka, "Promise"), Ah = yc(Ka, "Set"), e1 = "[object Map]", lC = "[object Object]", t1 = "[object Promise]", r1 = "[object Set]", n1 = "[object WeakMap]", i1 = "[object DataView]", uC = _c(J_), cC = _c(Sf), hC = _c(K_), dC = _c(Ah), fC = _c(Y_), Va = mc;
(J_ && Va(new J_(new ArrayBuffer(1))) != i1 || Sf && Va(new Sf()) != e1 || K_ && Va(K_.resolve()) != t1 || Ah && Va(new Ah()) != r1 || Y_ && Va(new Y_()) != n1) && (Va = function(a) {
  var n = mc(a), l = n == lC ? a.constructor : void 0, p = l ? _c(l) : "";
  if (p)
    switch (p) {
      case uC:
        return i1;
      case cC:
        return e1;
      case hC:
        return t1;
      case dC:
        return r1;
      case fC:
        return n1;
    }
  return n;
});
var pC = Object.prototype, gC = pC.hasOwnProperty;
function mC(a) {
  var n = a.length, l = new a.constructor(n);
  return n && typeof a[0] == "string" && gC.call(a, "index") && (l.index = a.index, l.input = a.input), l;
}
var Eg = Ka.Uint8Array;
function Yy(a) {
  var n = new a.constructor(a.byteLength);
  return new Eg(n).set(new Eg(a)), n;
}
function _C(a, n) {
  var l = Yy(a.buffer);
  return new a.constructor(l, a.byteOffset, a.byteLength);
}
var yC = /\w*$/;
function vC(a) {
  var n = new a.constructor(a.source, yC.exec(a));
  return n.lastIndex = a.lastIndex, n;
}
var s1 = ya ? ya.prototype : void 0, a1 = s1 ? s1.valueOf : void 0;
function xC(a) {
  return a1 ? Object(a1.call(a)) : {};
}
function aw(a, n) {
  var l = n ? Yy(a.buffer) : a.buffer;
  return new a.constructor(l, a.byteOffset, a.length);
}
var bC = "[object Boolean]", wC = "[object Date]", EC = "[object Map]", TC = "[object Number]", SC = "[object RegExp]", kC = "[object Set]", IC = "[object String]", MC = "[object Symbol]", CC = "[object ArrayBuffer]", PC = "[object DataView]", AC = "[object Float32Array]", LC = "[object Float64Array]", DC = "[object Int8Array]", RC = "[object Int16Array]", FC = "[object Int32Array]", NC = "[object Uint8Array]", OC = "[object Uint8ClampedArray]", zC = "[object Uint16Array]", BC = "[object Uint32Array]";
function GC(a, n, l) {
  var p = a.constructor;
  switch (n) {
    case CC:
      return Yy(a);
    case bC:
    case wC:
      return new p(+a);
    case PC:
      return _C(a);
    case AC:
    case LC:
    case DC:
    case RC:
    case FC:
    case NC:
    case OC:
    case zC:
    case BC:
      return aw(a, l);
    case EC:
      return new p();
    case TC:
    case IC:
      return new p(a);
    case SC:
      return vC(a);
    case kC:
      return new p();
    case MC:
      return xC(a);
  }
}
function ow(a) {
  return typeof a.constructor == "function" && !Vy(a) ? Xk(tw(a)) : {};
}
var jC = "[object Map]";
function VC(a) {
  return So(a) && Va(a) == jC;
}
var o1 = Fh && Fh.isMap, UC = o1 ? Ug(o1) : VC, qC = "[object Set]";
function $C(a) {
  return So(a) && Va(a) == qC;
}
var l1 = Fh && Fh.isSet, ZC = l1 ? Ug(l1) : $C, HC = 1, lw = "[object Arguments]", YC = "[object Array]", WC = "[object Boolean]", XC = "[object Date]", JC = "[object Error]", uw = "[object Function]", KC = "[object GeneratorFunction]", QC = "[object Map]", eP = "[object Number]", cw = "[object Object]", tP = "[object RegExp]", rP = "[object Set]", nP = "[object String]", iP = "[object Symbol]", sP = "[object WeakMap]", aP = "[object ArrayBuffer]", oP = "[object DataView]", lP = "[object Float32Array]", uP = "[object Float64Array]", cP = "[object Int8Array]", hP = "[object Int16Array]", dP = "[object Int32Array]", fP = "[object Uint8Array]", pP = "[object Uint8ClampedArray]", gP = "[object Uint16Array]", mP = "[object Uint32Array]", yn = {};
yn[lw] = yn[YC] = yn[aP] = yn[oP] = yn[WC] = yn[XC] = yn[lP] = yn[uP] = yn[cP] = yn[hP] = yn[dP] = yn[QC] = yn[eP] = yn[cw] = yn[tP] = yn[rP] = yn[nP] = yn[iP] = yn[fP] = yn[pP] = yn[gP] = yn[mP] = !0;
yn[JC] = yn[uw] = yn[sP] = !1;
function dg(a, n, l, p, x, M) {
  var T, u = n & HC;
  if (T !== void 0)
    return T;
  if (!ms(a))
    return a;
  var R = gs(a);
  if (R)
    T = mC(a);
  else {
    var z = Va(a), U = z == uw || z == KC;
    if (Ef(a))
      return sw(a, u);
    if (z == cw || z == lw || U && !x)
      T = U ? {} : ow(a);
    else {
      if (!yn[z])
        return x ? a : {};
      T = GC(a, z, u);
    }
  }
  M || (M = new Ya());
  var $ = M.get(a);
  if ($)
    return $;
  M.set(a, T), ZC(a) ? a.forEach(function(ce) {
    T.add(dg(ce, n, l, ce, a, M));
  }) : UC(a) && a.forEach(function(ce, me) {
    T.set(me, dg(ce, n, l, me, a, M));
  });
  var ee = X_, oe = R ? void 0 : ee(a);
  return oI(oe || a, function(ce, me) {
    oe && (me = ce, ce = a[me]), By(T, me, dg(ce, n, l, me, a, M));
  }), T;
}
var _P = 1, yP = 4;
function Js(a) {
  return dg(a, _P | yP);
}
var vP = "__lodash_hash_undefined__";
function xP(a) {
  return this.__data__.set(a, vP), this;
}
function bP(a) {
  return this.__data__.has(a);
}
function Oh(a) {
  var n = -1, l = a == null ? 0 : a.length;
  for (this.__data__ = new pl(); ++n < l; )
    this.add(a[n]);
}
Oh.prototype.add = Oh.prototype.push = xP;
Oh.prototype.has = bP;
function wP(a, n) {
  for (var l = -1, p = a == null ? 0 : a.length; ++l < p; )
    if (n(a[l], l, a))
      return !0;
  return !1;
}
function Tg(a, n) {
  return a.has(n);
}
var EP = 1, TP = 2;
function hw(a, n, l, p, x, M) {
  var T = l & EP, u = a.length, R = n.length;
  if (u != R && !(T && R > u))
    return !1;
  var z = M.get(a), U = M.get(n);
  if (z && U)
    return z == n && U == a;
  var $ = -1, ee = !0, oe = l & TP ? new Oh() : void 0;
  for (M.set(a, n), M.set(n, a); ++$ < u; ) {
    var ce = a[$], me = n[$];
    if (p)
      var re = T ? p(me, ce, $, n, a, M) : p(ce, me, $, a, n, M);
    if (re !== void 0) {
      if (re)
        continue;
      ee = !1;
      break;
    }
    if (oe) {
      if (!wP(n, function(Pe, _e) {
        if (!Tg(oe, _e) && (ce === Pe || x(ce, Pe, l, p, M)))
          return oe.push(_e);
      })) {
        ee = !1;
        break;
      }
    } else if (!(ce === me || x(ce, me, l, p, M))) {
      ee = !1;
      break;
    }
  }
  return M.delete(a), M.delete(n), ee;
}
function SP(a) {
  var n = -1, l = Array(a.size);
  return a.forEach(function(p, x) {
    l[++n] = [x, p];
  }), l;
}
function Wy(a) {
  var n = -1, l = Array(a.size);
  return a.forEach(function(p) {
    l[++n] = p;
  }), l;
}
var kP = 1, IP = 2, MP = "[object Boolean]", CP = "[object Date]", PP = "[object Error]", AP = "[object Map]", LP = "[object Number]", DP = "[object RegExp]", RP = "[object Set]", FP = "[object String]", NP = "[object Symbol]", OP = "[object ArrayBuffer]", zP = "[object DataView]", u1 = ya ? ya.prototype : void 0, E_ = u1 ? u1.valueOf : void 0;
function BP(a, n, l, p, x, M, T) {
  switch (l) {
    case zP:
      if (a.byteLength != n.byteLength || a.byteOffset != n.byteOffset)
        return !1;
      a = a.buffer, n = n.buffer;
    case OP:
      return !(a.byteLength != n.byteLength || !M(new Eg(a), new Eg(n)));
    case MP:
    case CP:
    case LP:
      return Rf(+a, +n);
    case PP:
      return a.name == n.name && a.message == n.message;
    case DP:
    case FP:
      return a == n + "";
    case AP:
      var u = SP;
    case RP:
      var R = p & kP;
      if (u || (u = Wy), a.size != n.size && !R)
        return !1;
      var z = T.get(a);
      if (z)
        return z == n;
      p |= IP, T.set(a, n);
      var U = hw(u(a), u(n), p, x, M, T);
      return T.delete(a), U;
    case NP:
      if (E_)
        return E_.call(a) == E_.call(n);
  }
  return !1;
}
var GP = 1, jP = Object.prototype, VP = jP.hasOwnProperty;
function UP(a, n, l, p, x, M) {
  var T = l & GP, u = X_(a), R = u.length, z = X_(n), U = z.length;
  if (R != U && !T)
    return !1;
  for (var $ = R; $--; ) {
    var ee = u[$];
    if (!(T ? ee in n : VP.call(n, ee)))
      return !1;
  }
  var oe = M.get(a), ce = M.get(n);
  if (oe && ce)
    return oe == n && ce == a;
  var me = !0;
  M.set(a, n), M.set(n, a);
  for (var re = T; ++$ < R; ) {
    ee = u[$];
    var Pe = a[ee], _e = n[ee];
    if (p)
      var je = T ? p(_e, Pe, ee, n, a, M) : p(Pe, _e, ee, a, n, M);
    if (!(je === void 0 ? Pe === _e || x(Pe, _e, l, p, M) : je)) {
      me = !1;
      break;
    }
    re || (re = ee == "constructor");
  }
  if (me && !re) {
    var Qe = a.constructor, et = n.constructor;
    Qe != et && "constructor" in a && "constructor" in n && !(typeof Qe == "function" && Qe instanceof Qe && typeof et == "function" && et instanceof et) && (me = !1);
  }
  return M.delete(a), M.delete(n), me;
}
var qP = 1, c1 = "[object Arguments]", h1 = "[object Array]", Zp = "[object Object]", $P = Object.prototype, d1 = $P.hasOwnProperty;
function ZP(a, n, l, p, x, M) {
  var T = gs(a), u = gs(n), R = T ? h1 : Va(a), z = u ? h1 : Va(n);
  R = R == c1 ? Zp : R, z = z == c1 ? Zp : z;
  var U = R == Zp, $ = z == Zp, ee = R == z;
  if (ee && Ef(a)) {
    if (!Ef(n))
      return !1;
    T = !0, U = !1;
  }
  if (ee && !U)
    return M || (M = new Ya()), T || Uy(a) ? hw(a, n, l, p, x, M) : BP(a, n, R, l, p, x, M);
  if (!(l & qP)) {
    var oe = U && d1.call(a, "__wrapped__"), ce = $ && d1.call(n, "__wrapped__");
    if (oe || ce) {
      var me = oe ? a.value() : a, re = ce ? n.value() : n;
      return M || (M = new Ya()), x(me, re, l, p, M);
    }
  }
  return ee ? (M || (M = new Ya()), UP(a, n, l, p, x, M)) : !1;
}
function Hg(a, n, l, p, x) {
  return a === n ? !0 : a == null || n == null || !So(a) && !So(n) ? a !== a && n !== n : ZP(a, n, l, p, Hg, x);
}
var HP = 1, YP = 2;
function WP(a, n, l, p) {
  var x = l.length, M = x;
  if (a == null)
    return !M;
  for (a = Object(a); x--; ) {
    var T = l[x];
    if (T[2] ? T[1] !== a[T[0]] : !(T[0] in a))
      return !1;
  }
  for (; ++x < M; ) {
    T = l[x];
    var u = T[0], R = a[u], z = T[1];
    if (T[2]) {
      if (R === void 0 && !(u in a))
        return !1;
    } else {
      var U = new Ya(), $;
      if (!($ === void 0 ? Hg(z, R, HP | YP, p, U) : $))
        return !1;
    }
  }
  return !0;
}
function dw(a) {
  return a === a && !ms(a);
}
function XP(a) {
  for (var n = qg(a), l = n.length; l--; ) {
    var p = n[l], x = a[p];
    n[l] = [p, x, dw(x)];
  }
  return n;
}
function fw(a, n) {
  return function(l) {
    return l == null ? !1 : l[a] === n && (n !== void 0 || a in Object(l));
  };
}
function JP(a) {
  var n = XP(a);
  return n.length == 1 && n[0][2] ? fw(n[0][0], n[0][1]) : function(l) {
    return l === a || WP(l, a, n);
  };
}
function KP(a, n) {
  return a != null && n in Object(a);
}
function QP(a, n, l) {
  n = Zy(n, a);
  for (var p = -1, x = n.length, M = !1; ++p < x; ) {
    var T = Ff(n[p]);
    if (!(M = a != null && l(a, T)))
      break;
    a = a[T];
  }
  return M || ++p != x ? M : (x = a == null ? 0 : a.length, !!x && jy(x) && Vg(T, x) && (gs(a) || wf(a)));
}
function eA(a, n) {
  return a != null && QP(a, n, KP);
}
var tA = 1, rA = 2;
function nA(a, n) {
  return qy(a) && dw(n) ? fw(Ff(a), n) : function(l) {
    var p = Nh(l, a);
    return p === void 0 && p === n ? eA(l, a) : Hg(n, p, tA | rA);
  };
}
function iA(a) {
  return function(n) {
    return n?.[a];
  };
}
function sA(a) {
  return function(n) {
    return Hy(n, a);
  };
}
function aA(a) {
  return qy(a) ? iA(Ff(a)) : sA(a);
}
function pw(a) {
  return typeof a == "function" ? a : a == null ? jg : typeof a == "object" ? gs(a) ? nA(a[0], a[1]) : JP(a) : aA(a);
}
function oA(a, n, l, p) {
  for (var x = -1, M = a == null ? 0 : a.length; ++x < M; ) {
    var T = a[x];
    n(p, T, l(T), a);
  }
  return p;
}
function lA(a) {
  return function(n, l, p) {
    for (var x = -1, M = Object(n), T = p(n), u = T.length; u--; ) {
      var R = T[++x];
      if (l(M[R], R, M) === !1)
        break;
    }
    return n;
  };
}
var gw = lA();
function uA(a, n) {
  return a && gw(a, n, qg);
}
function cA(a, n) {
  return function(l, p) {
    if (l == null)
      return l;
    if (!qh(l))
      return a(l, p);
    for (var x = l.length, M = -1, T = Object(l); ++M < x && p(T[M], M, T) !== !1; )
      ;
    return l;
  };
}
var mw = cA(uA);
function hA(a, n, l, p) {
  return mw(a, function(x, M, T) {
    n(p, x, l(x), T);
  }), p;
}
function _w(a, n) {
  return function(l, p) {
    var x = gs(l) ? oA : hA, M = {};
    return x(l, a, pw(p), M);
  };
}
var dA = Object.prototype, fA = dA.hasOwnProperty, pA = _w(function(a, n, l) {
  fA.call(a, l) ? ++a[l] : Df(a, l, 1);
}), T_ = function() {
  return Ka.Date.now();
}, gA = "Expected a function", mA = Math.max, _A = Math.min;
function yw(a, n, l) {
  var p, x, M, T, u, R, z = 0, U = !1, $ = !1, ee = !0;
  if (typeof a != "function")
    throw new TypeError(gA);
  n = jx(n) || 0, ms(l) && (U = !!l.leading, $ = "maxWait" in l, M = $ ? mA(jx(l.maxWait) || 0, n) : M, ee = "trailing" in l ? !!l.trailing : ee);
  function oe(Ye) {
    var ot = p, Q = x;
    return p = x = void 0, z = Ye, T = a.apply(Q, ot), T;
  }
  function ce(Ye) {
    return z = Ye, u = setTimeout(Pe, n), U ? oe(Ye) : T;
  }
  function me(Ye) {
    var ot = Ye - R, Q = Ye - z, ie = n - ot;
    return $ ? _A(ie, M - Q) : ie;
  }
  function re(Ye) {
    var ot = Ye - R, Q = Ye - z;
    return R === void 0 || ot >= n || ot < 0 || $ && Q >= M;
  }
  function Pe() {
    var Ye = T_();
    if (re(Ye))
      return _e(Ye);
    u = setTimeout(Pe, me(Ye));
  }
  function _e(Ye) {
    return u = void 0, ee && p ? oe(Ye) : (p = x = void 0, T);
  }
  function je() {
    u !== void 0 && clearTimeout(u), z = 0, p = R = x = u = void 0;
  }
  function Qe() {
    return u === void 0 ? T : _e(T_());
  }
  function et() {
    var Ye = T_(), ot = re(Ye);
    if (p = arguments, x = this, R = Ye, ot) {
      if (u === void 0)
        return ce(R);
      if ($)
        return clearTimeout(u), u = setTimeout(Pe, n), oe(R);
    }
    return u === void 0 && (u = setTimeout(Pe, n)), T;
  }
  return et.cancel = je, et.flush = Qe, et;
}
function Q_(a, n, l) {
  (l !== void 0 && !Rf(a[n], l) || l === void 0 && !(n in a)) && Df(a, n, l);
}
function vw(a) {
  return So(a) && qh(a);
}
function ey(a, n) {
  if (!(n === "constructor" && typeof a[n] == "function") && n != "__proto__")
    return a[n];
}
function yA(a) {
  return mI(a, Qb(a));
}
function vA(a, n, l, p, x, M, T) {
  var u = ey(a, l), R = ey(n, l), z = T.get(R);
  if (z) {
    Q_(a, l, z);
    return;
  }
  var U = M ? M(u, R, l + "", a, n, T) : void 0, $ = U === void 0;
  if ($) {
    var ee = gs(R), oe = !ee && Ef(R), ce = !ee && !oe && Uy(R);
    U = R, ee || oe || ce ? gs(u) ? U = u : vw(u) ? U = Qk(u) : oe ? ($ = !1, U = sw(R, !0)) : ce ? ($ = !1, U = aw(R, !0)) : U = [] : nw(R) || wf(R) ? (U = u, wf(u) ? U = yA(u) : (!ms(u) || zy(u)) && (U = ow(R))) : $ = !1;
  }
  $ && (T.set(R, U), x(U, R, p, M, T), T.delete(R)), Q_(a, l, U);
}
function Xy(a, n, l, p, x) {
  a !== n && gw(n, function(M, T) {
    if (x || (x = new Ya()), ms(M))
      vA(a, n, T, l, Xy, p, x);
    else {
      var u = p ? p(ey(a, T), M, T + "", a, n, x) : void 0;
      u === void 0 && (u = M), Q_(a, T, u);
    }
  }, Qb);
}
var xA = Hb(function(a, n, l, p) {
  Xy(a, n, l, p);
});
function bA(a, n, l) {
  for (var p = -1, x = a == null ? 0 : a.length; ++p < x; )
    if (l(n, a[p]))
      return !0;
  return !1;
}
function wA(a, n) {
  var l = -1, p = qh(a) ? Array(a.length) : [];
  return mw(a, function(x, M, T) {
    p[++l] = n(x, M, T);
  }), p;
}
function EA(a, n) {
  return Ph(n, function(l) {
    return a[l];
  });
}
function TA(a) {
  return a == null ? [] : EA(a, qg(a));
}
var SA = Math.min;
function kA(a, n, l) {
  for (var p = Zb, x = a[0].length, M = a.length, T = M, u = Array(M), R = 1 / 0, z = []; T--; ) {
    var U = a[T];
    R = SA(U.length, R), u[T] = x >= 120 && U.length >= 120 ? new Oh(T && U) : void 0;
  }
  U = a[0];
  var $ = -1, ee = u[0];
  e:
    for (; ++$ < x && z.length < R; ) {
      var oe = U[$], ce = oe;
      if (oe = oe !== 0 ? oe : 0, !(ee ? Tg(ee, ce) : p(z, ce))) {
        for (T = M; --T; ) {
          var me = u[T];
          if (!(me ? Tg(me, ce) : p(a[T], ce)))
            continue e;
        }
        ee && ee.push(ce), z.push(oe);
      }
    }
  return z;
}
function IA(a) {
  return vw(a) ? a : [];
}
var MA = Gy(function(a) {
  var n = Ph(a, IA);
  return n.length && n[0] === a[0] ? kA(n) : [];
});
function $h(a, n) {
  return Hg(a, n);
}
var CA = _w(function(a, n, l) {
  Df(a, l, n);
}), PA = Hb(function(a, n, l) {
  Xy(a, n, l);
});
function AA(a, n, l, p) {
  if (!ms(a))
    return a;
  n = Zy(n, a);
  for (var x = -1, M = n.length, T = M - 1, u = a; u != null && ++x < M; ) {
    var R = Ff(n[x]), z = l;
    if (R === "__proto__" || R === "constructor" || R === "prototype")
      return a;
    if (x != T) {
      var U = u[R];
      z = void 0, z === void 0 && (z = ms(U) ? U : Vg(n[x + 1]) ? [] : {});
    }
    By(u, R, z), u = u[R];
  }
  return a;
}
function LA(a, n) {
  var l = a.length;
  for (a.sort(n); l--; )
    a[l] = a[l].value;
  return a;
}
function DA(a, n) {
  if (a !== n) {
    var l = a !== void 0, p = a === null, x = a === a, M = Rh(a), T = n !== void 0, u = n === null, R = n === n, z = Rh(n);
    if (!u && !z && !M && a > n || M && T && R && !u && !z || p && T && R || !l && R || !x)
      return 1;
    if (!p && !M && !z && a < n || z && l && x && !p && !M || u && l && x || !T && x || !R)
      return -1;
  }
  return 0;
}
function RA(a, n, l) {
  for (var p = -1, x = a.criteria, M = n.criteria, T = x.length, u = l.length; ++p < T; ) {
    var R = DA(x[p], M[p]);
    if (R) {
      if (p >= u)
        return R;
      var z = l[p];
      return R * (z == "desc" ? -1 : 1);
    }
  }
  return a.index - n.index;
}
function FA(a, n, l) {
  n.length ? n = Ph(n, function(M) {
    return gs(M) ? function(T) {
      return Hy(T, M.length === 1 ? M[0] : M);
    } : M;
  }) : n = [jg];
  var p = -1;
  n = Ph(n, Ug(pw));
  var x = wA(a, function(M, T, u) {
    var R = Ph(n, function(z) {
      return z(M);
    });
    return { criteria: R, index: ++p, value: M };
  });
  return LA(x, function(M, T) {
    return RA(M, T, l);
  });
}
function NA(a, n, l) {
  return a == null ? a : AA(a, n, l);
}
var f1 = Gy(function(a, n) {
  if (a == null)
    return [];
  var l = n.length;
  return l > 1 && W_(a, n[0], n[1]) ? n = [] : l > 2 && W_(n[0], n[1], n[2]) && (n = [n[0]]), FA(a, UM(n), []);
}), OA = "Expected a function";
function xw(a, n, l) {
  var p = !0, x = !0;
  if (typeof a != "function")
    throw new TypeError(OA);
  return ms(l) && (p = "leading" in l ? !!l.leading : p, x = "trailing" in l ? !!l.trailing : x), yw(a, n, {
    leading: p,
    maxWait: n,
    trailing: x
  });
}
var zA = 1 / 0, BA = Ah && 1 / Wy(new Ah([, -0]))[1] == zA ? function(a) {
  return new Ah(a);
} : Kk, GA = 200;
function jA(a, n, l) {
  var p = -1, x = Zb, M = a.length, T = !0, u = [], R = u;
  if (l)
    T = !1, x = bA;
  else if (M >= GA) {
    var z = BA(a);
    if (z)
      return Wy(z);
    T = !1, x = Tg, R = new Oh();
  } else
    R = u;
  e:
    for (; ++p < M; ) {
      var U = a[p], $ = U;
      if (U = l || U !== 0 ? U : 0, T && $ === $) {
        for (var ee = R.length; ee--; )
          if (R[ee] === $)
            continue e;
        u.push(U);
      } else x(R, $, l) || (R !== u && R.push($), u.push(U));
    }
  return u;
}
function p1(a, n) {
  return n = typeof n == "function" ? n : void 0, a && a.length ? jA(a, void 0, n) : [];
}
function bw(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var ty = { exports: {} }, VA = ty.exports, g1;
function UA() {
  return g1 || (g1 = 1, (function(a) {
    (function(n, l) {
      a.exports ? a.exports = l() : n.log = l();
    })(VA, function() {
      var n = function() {
      }, l = "undefined", p = typeof window !== l && typeof window.navigator !== l && /Trident\/|MSIE /.test(window.navigator.userAgent), x = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], M = {}, T = null;
      function u(me, re) {
        var Pe = me[re];
        if (typeof Pe.bind == "function")
          return Pe.bind(me);
        try {
          return Function.prototype.bind.call(Pe, me);
        } catch {
          return function() {
            return Function.prototype.apply.apply(Pe, [me, arguments]);
          };
        }
      }
      function R() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function z(me) {
        return me === "debug" && (me = "log"), typeof console === l ? !1 : me === "trace" && p ? R : console[me] !== void 0 ? u(console, me) : console.log !== void 0 ? u(console, "log") : n;
      }
      function U() {
        for (var me = this.getLevel(), re = 0; re < x.length; re++) {
          var Pe = x[re];
          this[Pe] = re < me ? n : this.methodFactory(Pe, me, this.name);
        }
        if (this.log = this.debug, typeof console === l && me < this.levels.SILENT)
          return "No console available for logging";
      }
      function $(me) {
        return function() {
          typeof console !== l && (U.call(this), this[me].apply(this, arguments));
        };
      }
      function ee(me, re, Pe) {
        return z(me) || $.apply(this, arguments);
      }
      function oe(me, re) {
        var Pe = this, _e, je, Qe, et = "loglevel";
        typeof me == "string" ? et += ":" + me : typeof me == "symbol" && (et = void 0);
        function Ye(Se) {
          var Ie = (x[Se] || "silent").toUpperCase();
          if (!(typeof window === l || !et)) {
            try {
              window.localStorage[et] = Ie;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(et) + "=" + Ie + ";";
            } catch {
            }
          }
        }
        function ot() {
          var Se;
          if (!(typeof window === l || !et)) {
            try {
              Se = window.localStorage[et];
            } catch {
            }
            if (typeof Se === l)
              try {
                var Ie = window.document.cookie, Oe = encodeURIComponent(et), Re = Ie.indexOf(Oe + "=");
                Re !== -1 && (Se = /^([^;]+)/.exec(
                  Ie.slice(Re + Oe.length + 1)
                )[1]);
              } catch {
              }
            return Pe.levels[Se] === void 0 && (Se = void 0), Se;
          }
        }
        function Q() {
          if (!(typeof window === l || !et)) {
            try {
              window.localStorage.removeItem(et);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(et) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function ie(Se) {
          var Ie = Se;
          if (typeof Ie == "string" && Pe.levels[Ie.toUpperCase()] !== void 0 && (Ie = Pe.levels[Ie.toUpperCase()]), typeof Ie == "number" && Ie >= 0 && Ie <= Pe.levels.SILENT)
            return Ie;
          throw new TypeError("log.setLevel() called with invalid level: " + Se);
        }
        Pe.name = me, Pe.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, Pe.methodFactory = re || ee, Pe.getLevel = function() {
          return Qe ?? je ?? _e;
        }, Pe.setLevel = function(Se, Ie) {
          return Qe = ie(Se), Ie !== !1 && Ye(Qe), U.call(Pe);
        }, Pe.setDefaultLevel = function(Se) {
          je = ie(Se), ot() || Pe.setLevel(Se, !1);
        }, Pe.resetLevel = function() {
          Qe = null, Q(), U.call(Pe);
        }, Pe.enableAll = function(Se) {
          Pe.setLevel(Pe.levels.TRACE, Se);
        }, Pe.disableAll = function(Se) {
          Pe.setLevel(Pe.levels.SILENT, Se);
        }, Pe.rebuild = function() {
          if (T !== Pe && (_e = ie(T.getLevel())), U.call(Pe), T === Pe)
            for (var Se in M)
              M[Se].rebuild();
        }, _e = ie(
          T ? T.getLevel() : "WARN"
        );
        var ge = ot();
        ge != null && (Qe = ie(ge)), U.call(Pe);
      }
      T = new oe(), T.getLogger = function(me) {
        if (typeof me != "symbol" && typeof me != "string" || me === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var re = M[me];
        return re || (re = M[me] = new oe(
          me,
          T.methodFactory
        )), re;
      };
      var ce = typeof window !== l ? window.log : void 0;
      return T.noConflict = function() {
        return typeof window !== l && window.log === T && (window.log = ce), T;
      }, T.getLoggers = function() {
        return M;
      }, T.default = T, T;
    });
  })(ty)), ty.exports;
}
var qA = UA();
const It = /* @__PURE__ */ bw(qA), $A = (a, n) => {
  let l = null;
  try {
    a.forEach((p) => {
      if (n(p))
        throw l = p, new Error("found");
    });
  } catch {
  }
  return l;
};
function ry(a, n, l = []) {
  n(a, l), Array.isArray(a) ? a.forEach((p, x) => ry(p, n, [...l, x])) : nw(a) ? Object.entries(a).forEach(
    ([p, x]) => ry(x, n, [...l, p])
  ) : a !== null && typeof a == "object" && It.warn(`forEachDeep: unknown collection type (${a}), path "${l.join(".")}"`);
}
const ZA = (a) => {
  const n = ["shape_markers"], l = a.settings.controlsUiEnabledByDefault;
  ry(a, (p, x) => {
    const M = x.at(2);
    if (x.length === 4 && x.at(-1) === "uiEnabled") {
      if (n.includes(M))
        return;
      NA(a, x, l);
    }
  });
}, ny = () => Js(gk), HA = !1;
var Jy = Array.isArray, YA = Array.prototype.indexOf, Yg = Array.from, ww = Object.defineProperty, gf = Object.getOwnPropertyDescriptor, WA = Object.getOwnPropertyDescriptors, XA = Object.prototype, JA = Array.prototype, Ew = Object.getPrototypeOf, m1 = Object.isExtensible;
function KA(a) {
  return typeof a == "function";
}
const Ua = () => {
};
function QA(a) {
  for (var n = 0; n < a.length; n++)
    a[n]();
}
function Tw() {
  var a, n, l = new Promise((p, x) => {
    a = p, n = x;
  });
  return { promise: l, resolve: a, reject: n };
}
function Sg(a, n) {
  if (Array.isArray(a))
    return a;
  if (!(Symbol.iterator in a))
    return Array.from(a);
  const l = [];
  for (const p of a)
    if (l.push(p), l.length === n) break;
  return l;
}
const qi = 2, Ky = 4, Qy = 8, eL = 1 << 24, Po = 16, gl = 32, vc = 64, Wg = 128, Xa = 512, ns = 1024, Cs = 2048, ko = 4096, Xs = 8192, Yl = 16384, Xg = 32768, uc = 65536, _1 = 1 << 17, Sw = 1 << 18, Zh = 1 << 19, tL = 1 << 20, al = 1 << 25, cc = 32768, iy = 1 << 21, ev = 1 << 22, Wl = 1 << 23, mf = Symbol("$state"), rL = Symbol(""), Ih = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function kw(a) {
  return a === this.v;
}
function Iw(a, n) {
  return a != a ? n == n : a !== n || a !== null && typeof a == "object" || typeof a == "function";
}
function Mw(a) {
  return !Iw(a, this.v);
}
function Cw(a) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function nL() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function iL(a) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function sL() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function aL(a) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function oL() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function lL() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function uL() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function cL() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function hL() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
let dL = !1;
const fL = 1, pL = 2, Pw = 4, gL = 8, mL = 16, _L = 1, yL = 2, vL = 4, xL = 1, bL = 2, ts = Symbol(), wL = "http://www.w3.org/1999/xhtml";
let is = null;
function zh(a) {
  is = a;
}
function Aw(a) {
  return (
    /** @type {T} */
    EL().get(a)
  );
}
function Hh(a, n = !1, l) {
  is = {
    p: is,
    i: !1,
    c: null,
    e: null,
    s: a,
    x: null,
    l: null
  };
}
function Yh(a) {
  var n = (
    /** @type {ComponentContext} */
    is
  ), l = n.e;
  if (l !== null) {
    n.e = null;
    for (var p of l)
      Qw(p);
  }
  return n.i = !0, is = n.p, /** @type {T} */
  {};
}
function Lw() {
  return !0;
}
function EL(a) {
  return is === null && Cw(), is.c ??= new Map(TL(is) || void 0);
}
function TL(a) {
  let n = a.p;
  for (; n !== null; ) {
    const l = n.c;
    if (l !== null)
      return l;
    n = n.p;
  }
  return null;
}
let Mh = [];
function SL() {
  var a = Mh;
  Mh = [], QA(a);
}
function Nf(a) {
  if (Mh.length === 0) {
    var n = Mh;
    queueMicrotask(() => {
      n === Mh && SL();
    });
  }
  Mh.push(a);
}
function kL() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
function IL() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
function nf(a) {
  if (typeof a != "object" || a === null || mf in a)
    return a;
  const n = Ew(a);
  if (n !== XA && n !== JA)
    return a;
  var l = /* @__PURE__ */ new Map(), p = Jy(a), x = /* @__PURE__ */ yo(0), M = ac, T = (u) => {
    if (ac === M)
      return u();
    var R = Br, z = ac;
    Is(null), E1(M);
    var U = u();
    return Is(R), E1(z), U;
  };
  return p && l.set("length", /* @__PURE__ */ yo(
    /** @type {any[]} */
    a.length
  )), new Proxy(
    /** @type {any} */
    a,
    {
      defineProperty(u, R, z) {
        (!("value" in z) || z.configurable === !1 || z.enumerable === !1 || z.writable === !1) && lL();
        var U = l.get(R);
        return U === void 0 ? U = T(() => {
          var $ = /* @__PURE__ */ yo(z.value);
          return l.set(R, $), $;
        }) : ps(U, z.value, !0), !0;
      },
      deleteProperty(u, R) {
        var z = l.get(R);
        if (z === void 0) {
          if (R in u) {
            const U = T(() => /* @__PURE__ */ yo(ts));
            l.set(R, U), _f(x);
          }
        } else
          ps(z, ts), _f(x);
        return !0;
      },
      get(u, R, z) {
        if (R === mf)
          return a;
        var U = l.get(R), $ = R in u;
        if (U === void 0 && (!$ || gf(u, R)?.writable) && (U = T(() => {
          var oe = nf($ ? u[R] : ts), ce = /* @__PURE__ */ yo(oe);
          return ce;
        }), l.set(R, U)), U !== void 0) {
          var ee = fr(U);
          return ee === ts ? void 0 : ee;
        }
        return Reflect.get(u, R, z);
      },
      getOwnPropertyDescriptor(u, R) {
        var z = Reflect.getOwnPropertyDescriptor(u, R);
        if (z && "value" in z) {
          var U = l.get(R);
          U && (z.value = fr(U));
        } else if (z === void 0) {
          var $ = l.get(R), ee = $?.v;
          if ($ !== void 0 && ee !== ts)
            return {
              enumerable: !0,
              configurable: !0,
              value: ee,
              writable: !0
            };
        }
        return z;
      },
      has(u, R) {
        if (R === mf)
          return !0;
        var z = l.get(R), U = z !== void 0 && z.v !== ts || Reflect.has(u, R);
        if (z !== void 0 || Hr !== null && (!U || gf(u, R)?.writable)) {
          z === void 0 && (z = T(() => {
            var ee = U ? nf(u[R]) : ts, oe = /* @__PURE__ */ yo(ee);
            return oe;
          }), l.set(R, z));
          var $ = fr(z);
          if ($ === ts)
            return !1;
        }
        return U;
      },
      set(u, R, z, U) {
        var $ = l.get(R), ee = R in u;
        if (p && R === "length")
          for (var oe = z; oe < /** @type {Source<number>} */
          $.v; oe += 1) {
            var ce = l.get(oe + "");
            ce !== void 0 ? ps(ce, ts) : oe in u && (ce = T(() => /* @__PURE__ */ yo(ts)), l.set(oe + "", ce));
          }
        if ($ === void 0)
          (!ee || gf(u, R)?.writable) && ($ = T(() => /* @__PURE__ */ yo(void 0)), ps($, nf(z)), l.set(R, $));
        else {
          ee = $.v !== ts;
          var me = T(() => nf(z));
          ps($, me);
        }
        var re = Reflect.getOwnPropertyDescriptor(u, R);
        if (re?.set && re.set.call(U, z), !ee) {
          if (p && typeof R == "string") {
            var Pe = (
              /** @type {Source<number>} */
              l.get("length")
            ), _e = Number(R);
            Number.isInteger(_e) && _e >= Pe.v && ps(Pe, _e + 1);
          }
          _f(x);
        }
        return !0;
      },
      ownKeys(u) {
        fr(x);
        var R = Reflect.ownKeys(u).filter(($) => {
          var ee = l.get($);
          return ee === void 0 || ee.v !== ts;
        });
        for (var [z, U] of l)
          U.v !== ts && !(z in u) && R.push(z);
        return R;
      },
      setPrototypeOf() {
        uL();
      }
    }
  );
}
function y1(a) {
  try {
    if (a !== null && typeof a == "object" && mf in a)
      return a[mf];
  } catch {
  }
  return a;
}
function ML(a, n) {
  return Object.is(y1(a), y1(n));
}
var v1, Dw, Rw, Fw;
function CL() {
  if (v1 === void 0) {
    v1 = window, Dw = /Firefox/.test(navigator.userAgent);
    var a = Element.prototype, n = Node.prototype, l = Text.prototype;
    Rw = gf(n, "firstChild").get, Fw = gf(n, "nextSibling").get, m1(a) && (a.__click = void 0, a.__className = void 0, a.__attributes = null, a.__style = void 0, a.__e = void 0), m1(l) && (l.__t = void 0);
  }
}
function Xl(a = "") {
  return document.createTextNode(a);
}
// @__NO_SIDE_EFFECTS__
function Zl(a) {
  return (
    /** @type {TemplateNode | null} */
    Rw.call(a)
  );
}
// @__NO_SIDE_EFFECTS__
function Of(a) {
  return (
    /** @type {TemplateNode | null} */
    Fw.call(a)
  );
}
function $a(a, n) {
  return /* @__PURE__ */ Zl(a);
}
function Wa(a, n = !1) {
  {
    var l = /* @__PURE__ */ Zl(a);
    return l instanceof Comment && l.data === "" ? /* @__PURE__ */ Of(l) : l;
  }
}
function kf(a, n = 1, l = !1) {
  let p = a;
  for (; n--; )
    p = /** @type {TemplateNode} */
    /* @__PURE__ */ Of(p);
  return p;
}
function PL(a) {
  a.textContent = "";
}
function Nw() {
  return !1;
}
function Ow(a) {
  var n = Hr;
  if (n === null)
    return Br.f |= Wl, a;
  if ((n.f & Xg) === 0) {
    if ((n.f & Wg) === 0)
      throw a;
    n.b.error(a);
  } else
    Bh(a, n);
}
function Bh(a, n) {
  for (; n !== null; ) {
    if ((n.f & Wg) !== 0)
      try {
        n.b.error(a);
        return;
      } catch (l) {
        a = l;
      }
    n = n.parent;
  }
  throw a;
}
const Hp = /* @__PURE__ */ new Set();
let vn = null, fg = null, _a = null, vo = [], tv = null, sy = !1;
class bo {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #i = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #n = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(n) {
    vo = [], fg = null, this.apply();
    var l = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const p of n)
      this.#o(p, l);
    this.is_fork || this.#h(), this.is_deferred() ? (this.#l(l.effects), this.#l(l.render_effects)) : (fg = this, vn = null, x1(l.render_effects), x1(l.effects), fg = null, this.#n?.resolve()), _a = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #o(n, l) {
    n.f ^= ns;
    for (var p = n.first; p !== null; ) {
      var x = p.f, M = (x & (gl | vc)) !== 0, T = M && (x & ns) !== 0, u = T || (x & Xs) !== 0 || this.skipped_effects.has(p);
      if ((p.f & Wg) !== 0 && p.b?.is_pending() && (l = {
        parent: l,
        effect: p,
        effects: [],
        render_effects: []
      }), !u && p.fn !== null) {
        M ? p.f ^= ns : (x & Ky) !== 0 ? l.effects.push(p) : Bf(p) && ((p.f & Po) !== 0 && this.#a.add(p), Mf(p));
        var R = p.first;
        if (R !== null) {
          p = R;
          continue;
        }
      }
      var z = p.parent;
      for (p = p.next; p === null && z !== null; )
        z === l.effect && (this.#l(l.effects), this.#l(l.render_effects), l = /** @type {EffectTarget} */
        l.parent), p = z.next, z = z.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #l(n) {
    for (const l of n)
      (l.f & Cs) !== 0 ? this.#a.add(l) : (l.f & ko) !== 0 && this.#s.add(l), this.#u(l.deps), ss(l, ns);
  }
  /**
   * @param {Value[] | null} deps
   */
  #u(n) {
    if (n !== null)
      for (const l of n)
        (l.f & qi) === 0 || (l.f & cc) === 0 || (l.f ^= cc, this.#u(
          /** @type {Derived} */
          l.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(n, l) {
    this.previous.has(n) || this.previous.set(n, l), (n.f & Wl) === 0 && (this.current.set(n, n.v), _a?.set(n, n.v));
  }
  activate() {
    vn = this, this.apply();
  }
  deactivate() {
    vn === this && (vn = null, _a = null);
  }
  flush() {
    if (this.activate(), vo.length > 0) {
      if (AL(), vn !== null && vn !== this)
        return;
    } else this.#i === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const n of this.#r) n(this);
    this.#r.clear();
  }
  #h() {
    if (this.#t === 0) {
      for (const n of this.#e) n();
      this.#e.clear();
    }
    this.#i === 0 && this.#c();
  }
  #c() {
    if (Hp.size > 1) {
      this.previous.clear();
      var n = _a, l = !0, p = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const M of Hp) {
        if (M === this) {
          l = !1;
          continue;
        }
        const T = [];
        for (const [R, z] of this.current) {
          if (M.current.has(R))
            if (l && z !== M.current.get(R))
              M.current.set(R, z);
            else
              continue;
          T.push(R);
        }
        if (T.length === 0)
          continue;
        const u = [...M.current.keys()].filter((R) => !this.current.has(R));
        if (u.length > 0) {
          var x = vo;
          vo = [];
          const R = /* @__PURE__ */ new Set(), z = /* @__PURE__ */ new Map();
          for (const U of T)
            zw(U, u, R, z);
          if (vo.length > 0) {
            vn = M, M.apply();
            for (const U of vo)
              M.#o(U, p);
            M.deactivate();
          }
          vo = x;
        }
      }
      vn = null, _a = n;
    }
    this.committed = !0, Hp.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(n) {
    this.#i += 1, n && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(n) {
    this.#i -= 1, n && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const n of this.#a)
      this.#s.delete(n), ss(n, Cs), hc(n);
    for (const n of this.#s)
      ss(n, ko), hc(n);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(n) {
    this.#e.add(n);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(n) {
    this.#r.add(n);
  }
  settled() {
    return (this.#n ??= Tw()).promise;
  }
  static ensure() {
    if (vn === null) {
      const n = vn = new bo();
      Hp.add(vn), bo.enqueue(() => {
        vn === n && n.flush();
      });
    }
    return vn;
  }
  /** @param {() => void} task */
  static enqueue(n) {
    Nf(n);
  }
  apply() {
  }
}
function AL() {
  var a = sc;
  sy = !0;
  try {
    var n = 0;
    for (Ig(!0); vo.length > 0; ) {
      var l = bo.ensure();
      if (n++ > 1e3) {
        var p, x;
        LL();
      }
      l.process(vo), Jl.clear();
    }
  } finally {
    sy = !1, Ig(a), tv = null;
  }
}
function LL() {
  try {
    oL();
  } catch (a) {
    Bh(a, tv);
  }
}
let nl = null;
function x1(a) {
  var n = a.length;
  if (n !== 0) {
    for (var l = 0; l < n; ) {
      var p = a[l++];
      if ((p.f & (Yl | Xs)) === 0 && Bf(p) && (nl = /* @__PURE__ */ new Set(), Mf(p), p.deps === null && p.first === null && p.nodes === null && (p.teardown === null && p.ac === null ? s2(p) : p.fn = null), nl?.size > 0)) {
        Jl.clear();
        for (const x of nl) {
          if ((x.f & (Yl | Xs)) !== 0) continue;
          const M = [x];
          let T = x.parent;
          for (; T !== null; )
            nl.has(T) && (nl.delete(T), M.push(T)), T = T.parent;
          for (let u = M.length - 1; u >= 0; u--) {
            const R = M[u];
            (R.f & (Yl | Xs)) === 0 && Mf(R);
          }
        }
        nl.clear();
      }
    }
    nl = null;
  }
}
function zw(a, n, l, p) {
  if (!l.has(a) && (l.add(a), a.reactions !== null))
    for (const x of a.reactions) {
      const M = x.f;
      (M & qi) !== 0 ? zw(
        /** @type {Derived} */
        x,
        n,
        l,
        p
      ) : (M & (ev | Po)) !== 0 && (M & Cs) === 0 && Bw(x, n, p) && (ss(x, Cs), hc(
        /** @type {Effect} */
        x
      ));
    }
}
function Bw(a, n, l) {
  const p = l.get(a);
  if (p !== void 0) return p;
  if (a.deps !== null)
    for (const x of a.deps) {
      if (n.includes(x))
        return !0;
      if ((x.f & qi) !== 0 && Bw(
        /** @type {Derived} */
        x,
        n,
        l
      ))
        return l.set(
          /** @type {Derived} */
          x,
          !0
        ), !0;
    }
  return l.set(a, !1), !1;
}
function hc(a) {
  for (var n = tv = a; n.parent !== null; ) {
    n = n.parent;
    var l = n.f;
    if (sy && n === Hr && (l & Po) !== 0 && (l & Sw) === 0)
      return;
    if ((l & (vc | gl)) !== 0) {
      if ((l & ns) === 0) return;
      n.f ^= ns;
    }
  }
  vo.push(n);
}
function DL(a) {
  let n = 0, l = dc(0), p;
  return () => {
    Cf() && (fr(l), t2(() => (n === 0 && (p = Gf(() => a(() => _f(l)))), n += 1, () => {
      Nf(() => {
        n -= 1, n === 0 && (p?.(), p = void 0, _f(l));
      });
    })));
  };
}
var RL = uc | Zh | Wg;
function FL(a, n, l) {
  new NL(a, n, l);
}
class NL {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #r;
  /** @type {TemplateNode | null} */
  #i = null;
  /** @type {BoundaryProps} */
  #t;
  /** @type {((anchor: Node) => void)} */
  #n;
  /** @type {Effect} */
  #a;
  /** @type {Effect | null} */
  #s = null;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #l = null;
  /** @type {DocumentFragment | null} */
  #u = null;
  /** @type {TemplateNode | null} */
  #h = null;
  #c = 0;
  #d = 0;
  #f = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #p = null;
  #g = DL(() => (this.#p = dc(this.#c), () => {
    this.#p = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(n, l, p) {
    this.#r = n, this.#t = l, this.#n = p, this.parent = /** @type {Effect} */
    Hr.b, this.#e = !!this.#t.pending, this.#a = sv(() => {
      Hr.b = this;
      {
        var x = this.#v();
        try {
          this.#s = ja(() => p(x));
        } catch (M) {
          this.error(M);
        }
        this.#d > 0 ? this.#_() : this.#e = !1;
      }
      return () => {
        this.#h?.remove();
      };
    }, RL);
  }
  #y() {
    try {
      this.#s = ja(() => this.#n(this.#r));
    } catch (n) {
      this.error(n);
    }
    this.#e = !1;
  }
  #b() {
    const n = this.#t.pending;
    n && (this.#o = ja(() => n(this.#r)), bo.enqueue(() => {
      var l = this.#v();
      this.#s = this.#m(() => (bo.ensure(), ja(() => this.#n(l)))), this.#d > 0 ? this.#_() : (oc(
        /** @type {Effect} */
        this.#o,
        () => {
          this.#o = null;
        }
      ), this.#e = !1);
    }));
  }
  #v() {
    var n = this.#r;
    return this.#e && (this.#h = Xl(), this.#r.before(this.#h), n = this.#h), n;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#t.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #m(n) {
    var l = Hr, p = Br, x = is;
    Io(this.#a), Is(this.#a), zh(this.#a.ctx);
    try {
      return n();
    } catch (M) {
      return Ow(M), null;
    } finally {
      Io(l), Is(p), zh(x);
    }
  }
  #_() {
    const n = (
      /** @type {(anchor: Node) => void} */
      this.#t.pending
    );
    this.#s !== null && (this.#u = document.createDocumentFragment(), this.#u.append(
      /** @type {TemplateNode} */
      this.#h
    ), l2(this.#s, this.#u)), this.#o === null && (this.#o = ja(() => n(this.#r)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #x(n) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#x(n);
      return;
    }
    this.#d += n, this.#d === 0 && (this.#e = !1, this.#o && oc(this.#o, () => {
      this.#o = null;
    }), this.#u && (this.#r.before(this.#u), this.#u = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(n) {
    this.#x(n), this.#c += n, this.#p && Gh(this.#p, this.#c);
  }
  get_effect_pending() {
    return this.#g(), fr(
      /** @type {Source<number>} */
      this.#p
    );
  }
  /** @param {unknown} error */
  error(n) {
    var l = this.#t.onerror;
    let p = this.#t.failed;
    if (this.#f || !l && !p)
      throw n;
    this.#s && (Ms(this.#s), this.#s = null), this.#o && (Ms(this.#o), this.#o = null), this.#l && (Ms(this.#l), this.#l = null);
    var x = !1, M = !1;
    const T = () => {
      if (x) {
        IL();
        return;
      }
      x = !0, M && hL(), bo.ensure(), this.#c = 0, this.#l !== null && oc(this.#l, () => {
        this.#l = null;
      }), this.#e = this.has_pending_snippet(), this.#s = this.#m(() => (this.#f = !1, ja(() => this.#n(this.#r)))), this.#d > 0 ? this.#_() : this.#e = !1;
    };
    var u = Br;
    try {
      Is(null), M = !0, l?.(n, T), M = !1;
    } catch (R) {
      Bh(R, this.#a && this.#a.parent);
    } finally {
      Is(u);
    }
    p && Nf(() => {
      this.#l = this.#m(() => {
        bo.ensure(), this.#f = !0;
        try {
          return ja(() => {
            p(
              this.#r,
              () => n,
              () => T
            );
          });
        } catch (R) {
          return Bh(
            R,
            /** @type {Effect} */
            this.#a.parent
          ), null;
        } finally {
          this.#f = !1;
        }
      });
    });
  }
}
function OL(a, n, l, p) {
  const x = rv;
  if (l.length === 0 && a.length === 0) {
    p(n.map(x));
    return;
  }
  var M = vn, T = (
    /** @type {Effect} */
    Hr
  ), u = zL();
  function R() {
    Promise.all(l.map((z) => /* @__PURE__ */ BL(z))).then((z) => {
      u();
      try {
        p([...n.map(x), ...z]);
      } catch (U) {
        (T.f & Yl) === 0 && Bh(U, T);
      }
      M?.deactivate(), kg();
    }).catch((z) => {
      Bh(z, T);
    });
  }
  a.length > 0 ? Promise.all(a).then(() => {
    u();
    try {
      return R();
    } finally {
      M?.deactivate(), kg();
    }
  }) : R();
}
function zL() {
  var a = Hr, n = Br, l = is, p = vn;
  return function(x = !0) {
    Io(a), Is(n), zh(l), x && p?.activate();
  };
}
function kg() {
  Io(null), Is(null), zh(null);
}
// @__NO_SIDE_EFFECTS__
function rv(a) {
  var n = qi | Cs, l = Br !== null && (Br.f & qi) !== 0 ? (
    /** @type {Derived} */
    Br
  ) : null;
  return Hr !== null && (Hr.f |= Zh), {
    ctx: is,
    deps: null,
    effects: null,
    equals: kw,
    f: n,
    fn: a,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      ts
    ),
    wv: 0,
    parent: l ?? Hr,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function BL(a, n) {
  let l = (
    /** @type {Effect | null} */
    Hr
  );
  l === null && nL();
  var p = (
    /** @type {Boundary} */
    l.b
  ), x = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), M = dc(
    /** @type {V} */
    ts
  ), T = !Br, u = /* @__PURE__ */ new Map();
  return JL(() => {
    var R = Tw();
    x = R.promise;
    try {
      Promise.resolve(a()).then(R.resolve, R.reject).then(() => {
        z === vn && z.committed && z.deactivate(), kg();
      });
    } catch (ee) {
      R.reject(ee), kg();
    }
    var z = (
      /** @type {Batch} */
      vn
    );
    if (T) {
      var U = !p.is_pending();
      p.update_pending_count(1), z.increment(U), u.get(z)?.reject(Ih), u.delete(z), u.set(z, R);
    }
    const $ = (ee, oe = void 0) => {
      if (z.activate(), oe)
        oe !== Ih && (M.f |= Wl, Gh(M, oe));
      else {
        (M.f & Wl) !== 0 && (M.f ^= Wl), Gh(M, ee);
        for (const [ce, me] of u) {
          if (u.delete(ce), ce === z) break;
          me.reject(Ih);
        }
      }
      T && (p.update_pending_count(-1), z.decrement(U));
    };
    R.promise.then($, (ee) => $(null, ee || "unknown"));
  }), iv(() => {
    for (const R of u.values())
      R.reject(Ih);
  }), new Promise((R) => {
    function z(U) {
      function $() {
        U === x ? R(M) : z(x);
      }
      U.then($, $);
    }
    z(x);
  });
}
// @__NO_SIDE_EFFECTS__
function qa(a) {
  const n = /* @__PURE__ */ rv(a);
  return Zw(n), n;
}
// @__NO_SIDE_EFFECTS__
function GL(a) {
  const n = /* @__PURE__ */ rv(a);
  return n.equals = Mw, n;
}
function Gw(a) {
  var n = a.effects;
  if (n !== null) {
    a.effects = null;
    for (var l = 0; l < n.length; l += 1)
      Ms(
        /** @type {Effect} */
        n[l]
      );
  }
}
function jL(a) {
  for (var n = a.parent; n !== null; ) {
    if ((n.f & qi) === 0)
      return (n.f & Yl) === 0 ? (
        /** @type {Effect} */
        n
      ) : null;
    n = n.parent;
  }
  return null;
}
function nv(a) {
  var n, l = Hr;
  Io(jL(a));
  try {
    a.f &= ~cc, Gw(a), n = Xw(a);
  } finally {
    Io(l);
  }
  return n;
}
function jw(a) {
  var n = nv(a);
  if (a.equals(n) || (vn?.is_fork || (a.v = n), a.wv = Yw()), !Wh)
    if (_a !== null)
      (Cf() || vn?.is_fork) && _a.set(a, n);
    else {
      var l = (a.f & Xa) === 0 ? ko : ns;
      ss(a, l);
    }
}
let ay = /* @__PURE__ */ new Set();
const Jl = /* @__PURE__ */ new Map();
let Vw = !1;
function dc(a, n) {
  var l = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: a,
    reactions: null,
    equals: kw,
    rv: 0,
    wv: 0
  };
  return l;
}
// @__NO_SIDE_EFFECTS__
function yo(a, n) {
  const l = dc(a);
  return Zw(l), l;
}
// @__NO_SIDE_EFFECTS__
function Uw(a, n = !1, l = !0) {
  const p = dc(a);
  return n || (p.equals = Mw), p;
}
function ps(a, n, l = !1) {
  Br !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!wo || (Br.f & _1) !== 0) && Lw() && (Br.f & (qi | Po | ev | _1)) !== 0 && !ll?.includes(a) && cL();
  let p = l ? nf(n) : n;
  return Gh(a, p);
}
function Gh(a, n) {
  if (!a.equals(n)) {
    var l = a.v;
    Wh ? Jl.set(a, n) : Jl.set(a, l), a.v = n;
    var p = bo.ensure();
    p.capture(a, l), (a.f & qi) !== 0 && ((a.f & Cs) !== 0 && nv(
      /** @type {Derived} */
      a
    ), ss(a, (a.f & Xa) !== 0 ? ns : ko)), a.wv = Yw(), qw(a, Cs), Hr !== null && (Hr.f & ns) !== 0 && (Hr.f & (gl | vc)) === 0 && (ga === null ? qL([a]) : ga.push(a)), !p.is_fork && ay.size > 0 && !Vw && VL();
  }
  return n;
}
function VL() {
  Vw = !1;
  var a = sc;
  Ig(!0);
  const n = Array.from(ay);
  try {
    for (const l of n)
      (l.f & ns) !== 0 && ss(l, ko), Bf(l) && Mf(l);
  } finally {
    Ig(a);
  }
  ay.clear();
}
function _f(a) {
  ps(a, a.v + 1);
}
function qw(a, n) {
  var l = a.reactions;
  if (l !== null)
    for (var p = l.length, x = 0; x < p; x++) {
      var M = l[x], T = M.f, u = (T & Cs) === 0;
      if (u && ss(M, n), (T & qi) !== 0) {
        var R = (
          /** @type {Derived} */
          M
        );
        _a?.delete(R), (T & cc) === 0 && (T & Xa && (M.f |= cc), qw(R, ko));
      } else u && ((T & Po) !== 0 && nl !== null && nl.add(
        /** @type {Effect} */
        M
      ), hc(
        /** @type {Effect} */
        M
      ));
    }
}
let b1 = !1;
function UL() {
  b1 || (b1 = !0, document.addEventListener(
    "reset",
    (a) => {
      Promise.resolve().then(() => {
        if (!a.defaultPrevented)
          for (
            const n of
            /**@type {HTMLFormElement} */
            a.target.elements
          )
            n.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
    { capture: !0 }
  ));
}
function zf(a) {
  var n = Br, l = Hr;
  Is(null), Io(null);
  try {
    return a();
  } finally {
    Is(n), Io(l);
  }
}
function $w(a, n, l, p = l) {
  a.addEventListener(n, () => zf(l));
  const x = a.__on_r;
  x ? a.__on_r = () => {
    x(), p(!0);
  } : a.__on_r = () => p(!0), UL();
}
let sc = !1;
function Ig(a) {
  sc = a;
}
let Wh = !1;
function w1(a) {
  Wh = a;
}
let Br = null, wo = !1;
function Is(a) {
  Br = a;
}
let Hr = null;
function Io(a) {
  Hr = a;
}
let ll = null;
function Zw(a) {
  Br !== null && (ll === null ? ll = [a] : ll.push(a));
}
let fs = null, Zs = 0, ga = null;
function qL(a) {
  ga = a;
}
let Hw = 1, If = 0, ac = If;
function E1(a) {
  ac = a;
}
function Yw() {
  return ++Hw;
}
function Bf(a) {
  var n = a.f;
  if ((n & Cs) !== 0)
    return !0;
  if (n & qi && (a.f &= ~cc), (n & ko) !== 0) {
    var l = a.deps;
    if (l !== null)
      for (var p = l.length, x = 0; x < p; x++) {
        var M = l[x];
        if (Bf(
          /** @type {Derived} */
          M
        ) && jw(
          /** @type {Derived} */
          M
        ), M.wv > a.wv)
          return !0;
      }
    (n & Xa) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    _a === null && ss(a, ns);
  }
  return !1;
}
function Ww(a, n, l = !0) {
  var p = a.reactions;
  if (p !== null && !ll?.includes(a))
    for (var x = 0; x < p.length; x++) {
      var M = p[x];
      (M.f & qi) !== 0 ? Ww(
        /** @type {Derived} */
        M,
        n,
        !1
      ) : n === M && (l ? ss(M, Cs) : (M.f & ns) !== 0 && ss(M, ko), hc(
        /** @type {Effect} */
        M
      ));
    }
}
function Xw(a) {
  var n = fs, l = Zs, p = ga, x = Br, M = ll, T = is, u = wo, R = ac, z = a.f;
  fs = /** @type {null | Value[]} */
  null, Zs = 0, ga = null, Br = (z & (gl | vc)) === 0 ? a : null, ll = null, zh(a.ctx), wo = !1, ac = ++If, a.ac !== null && (zf(() => {
    a.ac.abort(Ih);
  }), a.ac = null);
  try {
    a.f |= iy;
    var U = (
      /** @type {Function} */
      a.fn
    ), $ = U(), ee = a.deps;
    if (fs !== null) {
      var oe;
      if (Mg(a, Zs), ee !== null && Zs > 0)
        for (ee.length = Zs + fs.length, oe = 0; oe < fs.length; oe++)
          ee[Zs + oe] = fs[oe];
      else
        a.deps = ee = fs;
      if (Cf() && (a.f & Xa) !== 0)
        for (oe = Zs; oe < ee.length; oe++)
          (ee[oe].reactions ??= []).push(a);
    } else ee !== null && Zs < ee.length && (Mg(a, Zs), ee.length = Zs);
    if (Lw() && ga !== null && !wo && ee !== null && (a.f & (qi | ko | Cs)) === 0)
      for (oe = 0; oe < /** @type {Source[]} */
      ga.length; oe++)
        Ww(
          ga[oe],
          /** @type {Effect} */
          a
        );
    return x !== null && x !== a && (If++, ga !== null && (p === null ? p = ga : p.push(.../** @type {Source[]} */
    ga))), (a.f & Wl) !== 0 && (a.f ^= Wl), $;
  } catch (ce) {
    return Ow(ce);
  } finally {
    a.f ^= iy, fs = n, Zs = l, ga = p, Br = x, ll = M, zh(T), wo = u, ac = R;
  }
}
function $L(a, n) {
  let l = n.reactions;
  if (l !== null) {
    var p = YA.call(l, a);
    if (p !== -1) {
      var x = l.length - 1;
      x === 0 ? l = n.reactions = null : (l[p] = l[x], l.pop());
    }
  }
  l === null && (n.f & qi) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (fs === null || !fs.includes(n)) && (ss(n, ko), (n.f & Xa) !== 0 && (n.f ^= Xa, n.f &= ~cc), Gw(
    /** @type {Derived} **/
    n
  ), Mg(
    /** @type {Derived} **/
    n,
    0
  ));
}
function Mg(a, n) {
  var l = a.deps;
  if (l !== null)
    for (var p = n; p < l.length; p++)
      $L(a, l[p]);
}
function Mf(a) {
  var n = a.f;
  if ((n & Yl) === 0) {
    ss(a, ns);
    var l = Hr, p = sc;
    Hr = a, sc = !0;
    try {
      (n & (Po | eL)) !== 0 ? KL(a) : n2(a), r2(a);
      var x = Xw(a);
      a.teardown = typeof x == "function" ? x : null, a.wv = Hw;
      var M;
      HA && dL && (a.f & Cs) !== 0 && a.deps;
    } finally {
      sc = p, Hr = l;
    }
  }
}
function fr(a) {
  var n = a.f, l = (n & qi) !== 0;
  if (Br !== null && !wo) {
    var p = Hr !== null && (Hr.f & Yl) !== 0;
    if (!p && !ll?.includes(a)) {
      var x = Br.deps;
      if ((Br.f & iy) !== 0)
        a.rv < If && (a.rv = If, fs === null && x !== null && x[Zs] === a ? Zs++ : fs === null ? fs = [a] : fs.includes(a) || fs.push(a));
      else {
        (Br.deps ??= []).push(a);
        var M = a.reactions;
        M === null ? a.reactions = [Br] : M.includes(Br) || M.push(Br);
      }
    }
  }
  if (Wh) {
    if (Jl.has(a))
      return Jl.get(a);
    if (l) {
      var T = (
        /** @type {Derived} */
        a
      ), u = T.v;
      return ((T.f & ns) === 0 && T.reactions !== null || Kw(T)) && (u = nv(T)), Jl.set(T, u), u;
    }
  } else l && (!_a?.has(a) || vn?.is_fork && !Cf()) && (T = /** @type {Derived} */
  a, Bf(T) && jw(T), sc && Cf() && (T.f & Xa) === 0 && Jw(T));
  if (_a?.has(a))
    return _a.get(a);
  if ((a.f & Wl) !== 0)
    throw a.v;
  return a.v;
}
function Jw(a) {
  if (a.deps !== null) {
    a.f ^= Xa;
    for (const n of a.deps)
      (n.reactions ??= []).push(a), (n.f & qi) !== 0 && (n.f & Xa) === 0 && Jw(
        /** @type {Derived} */
        n
      );
  }
}
function Kw(a) {
  if (a.v === ts) return !0;
  if (a.deps === null) return !1;
  for (const n of a.deps)
    if (Jl.has(n) || (n.f & qi) !== 0 && Kw(
      /** @type {Derived} */
      n
    ))
      return !0;
  return !1;
}
function Gf(a) {
  var n = wo;
  try {
    return wo = !0, a();
  } finally {
    wo = n;
  }
}
const ZL = -7169;
function ss(a, n) {
  a.f = a.f & ZL | n;
}
function HL(a) {
  Hr === null && (Br === null && aL(), sL()), Wh && iL();
}
function YL(a, n) {
  var l = n.last;
  l === null ? n.last = n.first = a : (l.next = a, a.prev = l, n.last = a);
}
function ml(a, n, l) {
  var p = Hr;
  p !== null && (p.f & Xs) !== 0 && (a |= Xs);
  var x = {
    ctx: is,
    deps: null,
    nodes: null,
    f: a | Cs | Xa,
    first: null,
    fn: n,
    last: null,
    next: null,
    parent: p,
    b: p && p.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (l)
    try {
      Mf(x), x.f |= Xg;
    } catch (u) {
      throw Ms(x), u;
    }
  else n !== null && hc(x);
  var M = x;
  if (l && M.deps === null && M.teardown === null && M.nodes === null && M.first === M.last && // either `null`, or a singular child
  (M.f & Zh) === 0 && (M = M.first, (a & Po) !== 0 && (a & uc) !== 0 && M !== null && (M.f |= uc)), M !== null && (M.parent = p, p !== null && YL(M, p), Br !== null && (Br.f & qi) !== 0 && (a & vc) === 0)) {
    var T = (
      /** @type {Derived} */
      Br
    );
    (T.effects ??= []).push(M);
  }
  return x;
}
function Cf() {
  return Br !== null && !wo;
}
function iv(a) {
  const n = ml(Qy, null, !1);
  return ss(n, ns), n.teardown = a, n;
}
function WL(a) {
  HL();
  var n = (
    /** @type {Effect} */
    Hr.f
  ), l = !Br && (n & gl) !== 0 && (n & Xg) === 0;
  if (l) {
    var p = (
      /** @type {ComponentContext} */
      is
    );
    (p.e ??= []).push(a);
  } else
    return Qw(a);
}
function Qw(a) {
  return ml(Ky | tL, a, !1);
}
function XL(a) {
  bo.ensure();
  const n = ml(vc | Zh, a, !0);
  return (l = {}) => new Promise((p) => {
    l.outro ? oc(n, () => {
      Ms(n), p(void 0);
    }) : (Ms(n), p(void 0));
  });
}
function e2(a) {
  return ml(Ky, a, !1);
}
function JL(a) {
  return ml(ev | Zh, a, !0);
}
function t2(a, n = 0) {
  return ml(Qy | n, a, !0);
}
function Za(a, n = [], l = [], p = []) {
  OL(p, n, l, (x) => {
    ml(Qy, () => a(...x.map(fr)), !0);
  });
}
function sv(a, n = 0) {
  var l = ml(Po | n, a, !0);
  return l;
}
function ja(a) {
  return ml(gl | Zh, a, !0);
}
function r2(a) {
  var n = a.teardown;
  if (n !== null) {
    const l = Wh, p = Br;
    w1(!0), Is(null);
    try {
      n.call(null);
    } finally {
      w1(l), Is(p);
    }
  }
}
function n2(a, n = !1) {
  var l = a.first;
  for (a.first = a.last = null; l !== null; ) {
    const x = l.ac;
    x !== null && zf(() => {
      x.abort(Ih);
    });
    var p = l.next;
    (l.f & vc) !== 0 ? l.parent = null : Ms(l, n), l = p;
  }
}
function KL(a) {
  for (var n = a.first; n !== null; ) {
    var l = n.next;
    (n.f & gl) === 0 && Ms(n), n = l;
  }
}
function Ms(a, n = !0) {
  var l = !1;
  (n || (a.f & Sw) !== 0) && a.nodes !== null && a.nodes.end !== null && (i2(
    a.nodes.start,
    /** @type {TemplateNode} */
    a.nodes.end
  ), l = !0), n2(a, n && !l), Mg(a, 0), ss(a, Yl);
  var p = a.nodes && a.nodes.t;
  if (p !== null)
    for (const M of p)
      M.stop();
  r2(a);
  var x = a.parent;
  x !== null && x.first !== null && s2(a), a.next = a.prev = a.teardown = a.ctx = a.deps = a.fn = a.nodes = a.ac = null;
}
function i2(a, n) {
  for (; a !== null; ) {
    var l = a === n ? null : /* @__PURE__ */ Of(a);
    a.remove(), a = l;
  }
}
function s2(a) {
  var n = a.parent, l = a.prev, p = a.next;
  l !== null && (l.next = p), p !== null && (p.prev = l), n !== null && (n.first === a && (n.first = p), n.last === a && (n.last = l));
}
function oc(a, n, l = !0) {
  var p = [];
  a2(a, p, !0);
  var x = () => {
    l && Ms(a), n && n();
  }, M = p.length;
  if (M > 0) {
    var T = () => --M || x();
    for (var u of p)
      u.out(T);
  } else
    x();
}
function a2(a, n, l) {
  if ((a.f & Xs) === 0) {
    a.f ^= Xs;
    var p = a.nodes && a.nodes.t;
    if (p !== null)
      for (const u of p)
        (u.is_global || l) && n.push(u);
    for (var x = a.first; x !== null; ) {
      var M = x.next, T = (x.f & uc) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (x.f & gl) !== 0 && (a.f & Po) !== 0;
      a2(x, n, T ? l : !1), x = M;
    }
  }
}
function av(a) {
  o2(a, !0);
}
function o2(a, n) {
  if ((a.f & Xs) !== 0) {
    a.f ^= Xs, (a.f & ns) === 0 && (ss(a, Cs), hc(a));
    for (var l = a.first; l !== null; ) {
      var p = l.next, x = (l.f & uc) !== 0 || (l.f & gl) !== 0;
      o2(l, x ? n : !1), l = p;
    }
    var M = a.nodes && a.nodes.t;
    if (M !== null)
      for (const T of M)
        (T.is_global || n) && T.in();
  }
}
function l2(a, n) {
  if (a.nodes)
    for (var l = a.nodes.start, p = a.nodes.end; l !== null; ) {
      var x = l === p ? null : /* @__PURE__ */ Of(l);
      n.append(l), l = x;
    }
}
const QL = ["touchstart", "touchmove"];
function eD(a) {
  return QL.includes(a);
}
const u2 = /* @__PURE__ */ new Set(), oy = /* @__PURE__ */ new Set();
function Jg(a) {
  for (var n = 0; n < a.length; n++)
    u2.add(a[n]);
  for (var l of oy)
    l(a);
}
let T1 = null;
function Yp(a) {
  var n = this, l = (
    /** @type {Node} */
    n.ownerDocument
  ), p = a.type, x = a.composedPath?.() || [], M = (
    /** @type {null | Element} */
    x[0] || a.target
  );
  T1 = a;
  var T = 0, u = T1 === a && a.__root;
  if (u) {
    var R = x.indexOf(u);
    if (R !== -1 && (n === document || n === /** @type {any} */
    window)) {
      a.__root = n;
      return;
    }
    var z = x.indexOf(n);
    if (z === -1)
      return;
    R <= z && (T = R);
  }
  if (M = /** @type {Element} */
  x[T] || a.target, M !== n) {
    ww(a, "currentTarget", {
      configurable: !0,
      get() {
        return M || l;
      }
    });
    var U = Br, $ = Hr;
    Is(null), Io(null);
    try {
      for (var ee, oe = []; M !== null; ) {
        var ce = M.assignedSlot || M.parentNode || /** @type {any} */
        M.host || null;
        try {
          var me = M["__" + p];
          me != null && (!/** @type {any} */
          M.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          a.target === M) && me.call(M, a);
        } catch (re) {
          ee ? oe.push(re) : ee = re;
        }
        if (a.cancelBubble || ce === n || ce === null)
          break;
        M = ce;
      }
      if (ee) {
        for (let re of oe)
          queueMicrotask(() => {
            throw re;
          });
        throw ee;
      }
    } finally {
      a.__root = n, delete a.currentTarget, Is(U), Io($);
    }
  }
}
function c2(a) {
  var n = document.createElement("template");
  return n.innerHTML = a.replaceAll("<!>", "<!---->"), n.content;
}
function Pf(a, n) {
  var l = (
    /** @type {Effect} */
    Hr
  );
  l.nodes === null && (l.nodes = { start: a, end: n, a: null, t: null });
}
// @__NO_SIDE_EFFECTS__
function xa(a, n) {
  var l = (n & xL) !== 0, p = (n & bL) !== 0, x, M = !a.startsWith("<!>");
  return () => {
    x === void 0 && (x = c2(M ? a : "<!>" + a), l || (x = /** @type {TemplateNode} */
    /* @__PURE__ */ Zl(x)));
    var T = (
      /** @type {TemplateNode} */
      p || Dw ? document.importNode(x, !0) : x.cloneNode(!0)
    );
    if (l) {
      var u = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Zl(T)
      ), R = (
        /** @type {TemplateNode} */
        T.lastChild
      );
      Pf(u, R);
    } else
      Pf(T, T);
    return T;
  };
}
function S1(a = "") {
  {
    var n = Xl(a + "");
    return Pf(n, n), n;
  }
}
function ul() {
  var a = document.createDocumentFragment(), n = document.createComment(""), l = Xl();
  return a.append(n, l), Pf(n, l), a;
}
function Gn(a, n) {
  a !== null && a.before(
    /** @type {Node} */
    n
  );
}
let ly = !0;
function Lh(a, n) {
  var l = n == null ? "" : typeof n == "object" ? n + "" : n;
  l !== (a.__t ??= a.nodeValue) && (a.__t = l, a.nodeValue = l + "");
}
function tD(a, n) {
  return rD(a, n);
}
const bh = /* @__PURE__ */ new Map();
function rD(a, { target: n, anchor: l, props: p = {}, events: x, context: M, intro: T = !0 }) {
  CL();
  var u = /* @__PURE__ */ new Set(), R = ($) => {
    for (var ee = 0; ee < $.length; ee++) {
      var oe = $[ee];
      if (!u.has(oe)) {
        u.add(oe);
        var ce = eD(oe);
        n.addEventListener(oe, Yp, { passive: ce });
        var me = bh.get(oe);
        me === void 0 ? (document.addEventListener(oe, Yp, { passive: ce }), bh.set(oe, 1)) : bh.set(oe, me + 1);
      }
    }
  };
  R(Yg(u2)), oy.add(R);
  var z = void 0, U = XL(() => {
    var $ = l ?? n.appendChild(Xl());
    return FL(
      /** @type {TemplateNode} */
      $,
      {
        pending: () => {
        }
      },
      (ee) => {
        if (M) {
          Hh({});
          var oe = (
            /** @type {ComponentContext} */
            is
          );
          oe.c = M;
        }
        x && (p.$$events = x), ly = T, z = a(ee, p) || {}, ly = !0, M && Yh();
      }
    ), () => {
      for (var ee of u) {
        n.removeEventListener(ee, Yp);
        var oe = (
          /** @type {number} */
          bh.get(ee)
        );
        --oe === 0 ? (document.removeEventListener(ee, Yp), bh.delete(ee)) : bh.set(ee, oe);
      }
      oy.delete(R), $ !== l && $.parentNode?.removeChild($);
    };
  });
  return uy.set(z, U), z;
}
let uy = /* @__PURE__ */ new WeakMap();
function nD(a, n) {
  const l = uy.get(a);
  return l ? (uy.delete(a), l(n)) : Promise.resolve();
}
class iD {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /**
   * Map of keys to effects that are currently rendered in the DOM.
   * These effects are visible and actively part of the document tree.
   * Example:
   * ```
   * {#if condition}
   * 	foo
   * {:else}
   * 	bar
   * {/if}
   * ```
   * Can result in the entries `true->Effect` and `false->Effect`
   * @type {Map<Key, Effect>}
   */
  #r = /* @__PURE__ */ new Map();
  /**
   * Similar to #onscreen with respect to the keys, but contains branches that are not yet
   * in the DOM, because their insertion is deferred.
   * @type {Map<Key, Branch>}
   */
  #i = /* @__PURE__ */ new Map();
  /**
   * Keys of effects that are currently outroing
   * @type {Set<Key>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #n = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(n, l = !0) {
    this.anchor = n, this.#n = l;
  }
  #a = () => {
    var n = (
      /** @type {Batch} */
      vn
    );
    if (this.#e.has(n)) {
      var l = (
        /** @type {Key} */
        this.#e.get(n)
      ), p = this.#r.get(l);
      if (p)
        av(p), this.#t.delete(l);
      else {
        var x = this.#i.get(l);
        x && (this.#r.set(l, x.effect), this.#i.delete(l), x.fragment.lastChild.remove(), this.anchor.before(x.fragment), p = x.effect);
      }
      for (const [M, T] of this.#e) {
        if (this.#e.delete(M), M === n)
          break;
        const u = this.#i.get(T);
        u && (Ms(u.effect), this.#i.delete(T));
      }
      for (const [M, T] of this.#r) {
        if (M === l || this.#t.has(M)) continue;
        const u = () => {
          if (Array.from(this.#e.values()).includes(M)) {
            var R = document.createDocumentFragment();
            l2(T, R), R.append(Xl()), this.#i.set(M, { effect: T, fragment: R });
          } else
            Ms(T);
          this.#t.delete(M), this.#r.delete(M);
        };
        this.#n || !p ? (this.#t.add(M), oc(T, u, !1)) : u();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #s = (n) => {
    this.#e.delete(n);
    const l = Array.from(this.#e.values());
    for (const [p, x] of this.#i)
      l.includes(p) || (Ms(x.effect), this.#i.delete(p));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(n, l) {
    var p = (
      /** @type {Batch} */
      vn
    ), x = Nw();
    l && !this.#r.has(n) && !this.#i.has(n) && this.#r.set(
      n,
      ja(() => l(this.anchor))
    ), this.#e.set(p, n), x || this.#a();
  }
}
function Ys(a, n, l = !1) {
  var p = new iD(a), x = l ? uc : 0;
  function M(T, u) {
    p.ensure(T, u);
  }
  sv(() => {
    var T = !1;
    n((u, R = !0) => {
      T = !0, M(R, u);
    }), T || M(!1, null);
  }, x);
}
function sD(a, n) {
  return n;
}
function aD(a, n, l) {
  for (var p = [], x = n.length, M, T = n.length, u = 0; u < x; u++) {
    let $ = n[u];
    oc(
      $,
      () => {
        if (M) {
          if (M.pending.delete($), M.done.add($), M.pending.size === 0) {
            var ee = (
              /** @type {Set<EachOutroGroup>} */
              a.outrogroups
            );
            cy(Yg(M.done)), ee.delete(M), ee.size === 0 && (a.outrogroups = null);
          }
        } else
          T -= 1;
      },
      !1
    );
  }
  if (T === 0) {
    var R = p.length === 0 && l !== null;
    if (R) {
      var z = (
        /** @type {Element} */
        l
      ), U = (
        /** @type {Element} */
        z.parentNode
      );
      PL(U), U.append(z), a.items.clear();
    }
    cy(n, !R);
  } else
    M = {
      pending: new Set(n),
      done: /* @__PURE__ */ new Set()
    }, (a.outrogroups ??= /* @__PURE__ */ new Set()).add(M);
}
function cy(a, n = !0) {
  for (var l = 0; l < a.length; l++)
    Ms(a[l], n);
}
var k1;
function Af(a, n, l, p, x, M = null) {
  var T = a, u = /* @__PURE__ */ new Map(), R = (n & Pw) !== 0;
  if (R) {
    var z = (
      /** @type {Element} */
      a
    );
    T = z.appendChild(Xl());
  }
  var U = null, $ = /* @__PURE__ */ GL(() => {
    var Pe = l();
    return Jy(Pe) ? Pe : Pe == null ? [] : Yg(Pe);
  }), ee, oe = !0;
  function ce() {
    re.fallback = U, oD(re, ee, T, n, p), U !== null && (ee.length === 0 ? (U.f & al) === 0 ? av(U) : (U.f ^= al, sf(U, null, T)) : oc(U, () => {
      U = null;
    }));
  }
  var me = sv(() => {
    ee = /** @type {V[]} */
    fr($);
    for (var Pe = ee.length, _e = /* @__PURE__ */ new Set(), je = (
      /** @type {Batch} */
      vn
    ), Qe = Nw(), et = 0; et < Pe; et += 1) {
      var Ye = ee[et], ot = p(Ye, et), Q = oe ? null : u.get(ot);
      Q ? (Q.v && Gh(Q.v, Ye), Q.i && Gh(Q.i, et), Qe && je.skipped_effects.delete(Q.e)) : (Q = lD(
        u,
        oe ? T : k1 ??= Xl(),
        Ye,
        ot,
        et,
        x,
        n,
        l
      ), oe || (Q.e.f |= al), u.set(ot, Q)), _e.add(ot);
    }
    if (Pe === 0 && M && !U && (oe ? U = ja(() => M(T)) : (U = ja(() => M(k1 ??= Xl())), U.f |= al)), !oe)
      if (Qe) {
        for (const [ie, ge] of u)
          _e.has(ie) || je.skipped_effects.add(ge.e);
        je.oncommit(ce), je.ondiscard(() => {
        });
      } else
        ce();
    fr($);
  }), re = { effect: me, items: u, outrogroups: null, fallback: U };
  oe = !1;
}
function oD(a, n, l, p, x) {
  var M = (p & gL) !== 0, T = n.length, u = a.items, R = a.effect.first, z, U = null, $, ee = [], oe = [], ce, me, re, Pe;
  if (M)
    for (Pe = 0; Pe < T; Pe += 1)
      ce = n[Pe], me = x(ce, Pe), re = /** @type {EachItem} */
      u.get(me).e, (re.f & al) === 0 && (re.nodes?.a?.measure(), ($ ??= /* @__PURE__ */ new Set()).add(re));
  for (Pe = 0; Pe < T; Pe += 1) {
    if (ce = n[Pe], me = x(ce, Pe), re = /** @type {EachItem} */
    u.get(me).e, a.outrogroups !== null)
      for (const ge of a.outrogroups)
        ge.pending.delete(re), ge.done.delete(re);
    if ((re.f & al) !== 0)
      if (re.f ^= al, re === R)
        sf(re, null, l);
      else {
        var _e = U ? U.next : R;
        re === a.effect.last && (a.effect.last = re.prev), re.prev && (re.prev.next = re.next), re.next && (re.next.prev = re.prev), Ul(a, U, re), Ul(a, re, _e), sf(re, _e, l), U = re, ee = [], oe = [], R = U.next;
        continue;
      }
    if ((re.f & Xs) !== 0 && (av(re), M && (re.nodes?.a?.unfix(), ($ ??= /* @__PURE__ */ new Set()).delete(re))), re !== R) {
      if (z !== void 0 && z.has(re)) {
        if (ee.length < oe.length) {
          var je = oe[0], Qe;
          U = je.prev;
          var et = ee[0], Ye = ee[ee.length - 1];
          for (Qe = 0; Qe < ee.length; Qe += 1)
            sf(ee[Qe], je, l);
          for (Qe = 0; Qe < oe.length; Qe += 1)
            z.delete(oe[Qe]);
          Ul(a, et.prev, Ye.next), Ul(a, U, et), Ul(a, Ye, je), R = je, U = Ye, Pe -= 1, ee = [], oe = [];
        } else
          z.delete(re), sf(re, R, l), Ul(a, re.prev, re.next), Ul(a, re, U === null ? a.effect.first : U.next), Ul(a, U, re), U = re;
        continue;
      }
      for (ee = [], oe = []; R !== null && R !== re; )
        (z ??= /* @__PURE__ */ new Set()).add(R), oe.push(R), R = R.next;
      if (R === null)
        continue;
    }
    (re.f & al) === 0 && ee.push(re), U = re, R = re.next;
  }
  if (a.outrogroups !== null) {
    for (const ge of a.outrogroups)
      ge.pending.size === 0 && (cy(Yg(ge.done)), a.outrogroups?.delete(ge));
    a.outrogroups.size === 0 && (a.outrogroups = null);
  }
  if (R !== null || z !== void 0) {
    var ot = [];
    if (z !== void 0)
      for (re of z)
        (re.f & Xs) === 0 && ot.push(re);
    for (; R !== null; )
      (R.f & Xs) === 0 && R !== a.fallback && ot.push(R), R = R.next;
    var Q = ot.length;
    if (Q > 0) {
      var ie = (p & Pw) !== 0 && T === 0 ? l : null;
      if (M) {
        for (Pe = 0; Pe < Q; Pe += 1)
          ot[Pe].nodes?.a?.measure();
        for (Pe = 0; Pe < Q; Pe += 1)
          ot[Pe].nodes?.a?.fix();
      }
      aD(a, ot, ie);
    }
  }
  M && Nf(() => {
    if ($ !== void 0)
      for (re of $)
        re.nodes?.a?.apply();
  });
}
function lD(a, n, l, p, x, M, T, u) {
  var R = (T & fL) !== 0 ? (T & mL) === 0 ? /* @__PURE__ */ Uw(l, !1, !1) : dc(l) : null, z = (T & pL) !== 0 ? dc(x) : null;
  return {
    v: R,
    i: z,
    e: ja(() => (M(n, R ?? l, z ?? x, u), () => {
      a.delete(p);
    }))
  };
}
function sf(a, n, l) {
  if (a.nodes)
    for (var p = a.nodes.start, x = a.nodes.end, M = n && (n.f & al) === 0 ? (
      /** @type {EffectNodes} */
      n.nodes.start
    ) : l; p !== null; ) {
      var T = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Of(p)
      );
      if (M.before(p), p === x)
        return;
      p = T;
    }
}
function Ul(a, n, l) {
  n === null ? a.effect.first = l : n.next = l, l === null ? a.effect.last = n : l.prev = n;
}
function h2(a, n, l = !1, p = !1, x = !1) {
  var M = a, T = "";
  Za(() => {
    var u = (
      /** @type {Effect} */
      Hr
    );
    if (T !== (T = n() ?? "") && (u.nodes !== null && (i2(
      u.nodes.start,
      /** @type {TemplateNode} */
      u.nodes.end
    ), u.nodes = null), T !== "")) {
      var R = T + "";
      l ? R = `<svg>${R}</svg>` : p && (R = `<math>${R}</math>`);
      var z = c2(R);
      if ((l || p) && (z = /** @type {Element} */
      /* @__PURE__ */ Zl(z)), Pf(
        /** @type {TemplateNode} */
        /* @__PURE__ */ Zl(z),
        /** @type {TemplateNode} */
        z.lastChild
      ), l || p)
        for (; /* @__PURE__ */ Zl(z); )
          M.before(
            /** @type {TemplateNode} */
            /* @__PURE__ */ Zl(z)
          );
      else
        M.before(z);
    }
  });
}
const uD = () => performance.now(), sl = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    ((a) => requestAnimationFrame(a))
  ),
  now: () => uD(),
  tasks: /* @__PURE__ */ new Set()
};
function d2() {
  const a = sl.now();
  sl.tasks.forEach((n) => {
    n.c(a) || (sl.tasks.delete(n), n.f());
  }), sl.tasks.size !== 0 && sl.tick(d2);
}
function cD(a) {
  let n;
  return sl.tasks.size === 0 && sl.tick(d2), {
    promise: new Promise((l) => {
      sl.tasks.add(n = { c: a, f: l });
    }),
    abort() {
      sl.tasks.delete(n);
    }
  };
}
function Wp(a, n) {
  zf(() => {
    a.dispatchEvent(new CustomEvent(n));
  });
}
function hD(a) {
  if (a === "float") return "cssFloat";
  if (a === "offset") return "cssOffset";
  if (a.startsWith("--")) return a;
  const n = a.split("-");
  return n.length === 1 ? n[0] : n[0] + n.slice(1).map(
    /** @param {any} word */
    (l) => l[0].toUpperCase() + l.slice(1)
  ).join("");
}
function I1(a) {
  const n = {}, l = a.split(";");
  for (const p of l) {
    const [x, M] = p.split(":");
    if (!x || M === void 0) break;
    const T = hD(x.trim());
    n[T] = M.trim();
  }
  return n;
}
const dD = (a) => a;
function M1(a, n, l, p) {
  var x = (a & _L) !== 0, M = (a & yL) !== 0, T = x && M, u = (a & vL) !== 0, R = T ? "both" : x ? "in" : "out", z, U = n.inert, $ = n.style.overflow, ee, oe;
  function ce() {
    return zf(() => z ??= l()(n, p?.() ?? /** @type {P} */
    {}, {
      direction: R
    }));
  }
  var me = {
    is_global: u,
    in() {
      if (n.inert = U, !x) {
        oe?.abort(), oe?.reset?.();
        return;
      }
      M || ee?.abort(), Wp(n, "introstart"), ee = hy(n, ce(), oe, 1, () => {
        Wp(n, "introend"), ee?.abort(), ee = z = void 0, n.style.overflow = $;
      });
    },
    out(je) {
      if (!M) {
        je?.(), z = void 0;
        return;
      }
      n.inert = !0, Wp(n, "outrostart"), oe = hy(n, ce(), ee, 0, () => {
        Wp(n, "outroend"), je?.();
      });
    },
    stop: () => {
      ee?.abort(), oe?.abort();
    }
  }, re = (
    /** @type {Effect & { nodes: EffectNodes }} */
    Hr
  );
  if ((re.nodes.t ??= []).push(me), x && ly) {
    var Pe = u;
    if (!Pe) {
      for (var _e = (
        /** @type {Effect | null} */
        re.parent
      ); _e && (_e.f & uc) !== 0; )
        for (; (_e = _e.parent) && (_e.f & Po) === 0; )
          ;
      Pe = !_e || (_e.f & Xg) !== 0;
    }
    Pe && e2(() => {
      Gf(() => me.in());
    });
  }
}
function hy(a, n, l, p, x) {
  var M = p === 1;
  if (KA(n)) {
    var T, u = !1;
    return Nf(() => {
      if (!u) {
        var re = n({ direction: M ? "in" : "out" });
        T = hy(a, re, l, p, x);
      }
    }), {
      abort: () => {
        u = !0, T?.abort();
      },
      deactivate: () => T.deactivate(),
      reset: () => T.reset(),
      t: () => T.t()
    };
  }
  if (l?.deactivate(), !n?.duration)
    return x(), {
      abort: Ua,
      deactivate: Ua,
      reset: Ua,
      t: () => p
    };
  const { delay: R = 0, css: z, tick: U, easing: $ = dD } = n;
  var ee = [];
  if (M && l === void 0 && (U && U(0, 1), z)) {
    var oe = I1(z(0, 1));
    ee.push(oe, oe);
  }
  var ce = () => 1 - p, me = a.animate(ee, { duration: R, fill: "forwards" });
  return me.onfinish = () => {
    me.cancel();
    var re = l?.t() ?? 1 - p;
    l?.abort();
    var Pe = p - re, _e = (
      /** @type {number} */
      n.duration * Math.abs(Pe)
    ), je = [];
    if (_e > 0) {
      var Qe = !1;
      if (z)
        for (var et = Math.ceil(_e / 16.666666666666668), Ye = 0; Ye <= et; Ye += 1) {
          var ot = re + Pe * $(Ye / et), Q = I1(z(ot, 1 - ot));
          je.push(Q), Qe ||= Q.overflow === "hidden";
        }
      Qe && (a.style.overflow = "hidden"), ce = () => {
        var ie = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          me.currentTime
        );
        return re + Pe * $(ie / _e);
      }, U && cD(() => {
        if (me.playState !== "running") return !1;
        var ie = ce();
        return U(ie, 1 - ie), !0;
      });
    }
    me = a.animate(je, { duration: _e, fill: "forwards" }), me.onfinish = () => {
      ce = () => p, U?.(p, 1 - p), x();
    };
  }, {
    abort: () => {
      me && (me.cancel(), me.effect = null, me.onfinish = Ua);
    },
    deactivate: () => {
      x = Ua;
    },
    reset: () => {
      p === 0 && U?.(1, 0);
    },
    t: () => ce()
  };
}
function f2(a) {
  var n, l, p = "";
  if (typeof a == "string" || typeof a == "number") p += a;
  else if (typeof a == "object") if (Array.isArray(a)) {
    var x = a.length;
    for (n = 0; n < x; n++) a[n] && (l = f2(a[n])) && (p && (p += " "), p += l);
  } else for (l in a) a[l] && (p && (p += " "), p += l);
  return p;
}
function fD() {
  for (var a, n, l = 0, p = "", x = arguments.length; l < x; l++) (a = arguments[l]) && (n = f2(a)) && (p && (p += " "), p += n);
  return p;
}
function pD(a) {
  return typeof a == "object" ? fD(a) : a ?? "";
}
const C1 = [...` 	
\r\f\v\uFEFF`];
function gD(a, n, l) {
  var p = a == null ? "" : "" + a;
  if (n && (p = p ? p + " " + n : n), l) {
    for (var x in l)
      if (l[x])
        p = p ? p + " " + x : x;
      else if (p.length)
        for (var M = x.length, T = 0; (T = p.indexOf(x, T)) >= 0; ) {
          var u = T + M;
          (T === 0 || C1.includes(p[T - 1])) && (u === p.length || C1.includes(p[u])) ? p = (T === 0 ? "" : p.substring(0, T)) + p.substring(u + 1) : T = u;
        }
  }
  return p === "" ? null : p;
}
function yf(a, n, l, p, x, M) {
  var T = a.__className;
  if (T !== l || T === void 0) {
    var u = gD(l, p, M);
    u == null ? a.removeAttribute("class") : a.className = u, a.__className = l;
  } else if (M && x !== M)
    for (var R in M) {
      var z = !!M[R];
      (x == null || z !== !!x[R]) && a.classList.toggle(R, z);
    }
  return M;
}
function p2(a, n, l = !1) {
  if (a.multiple) {
    if (n == null)
      return;
    if (!Jy(n))
      return kL();
    for (var p of a.options)
      p.selected = n.includes(vf(p));
    return;
  }
  for (p of a.options) {
    var x = vf(p);
    if (ML(x, n)) {
      p.selected = !0;
      return;
    }
  }
  (!l || n !== void 0) && (a.selectedIndex = -1);
}
function mD(a) {
  var n = new MutationObserver(() => {
    p2(a, a.__value);
  });
  n.observe(a, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), iv(() => {
    n.disconnect();
  });
}
function _D(a, n, l = n) {
  var p = /* @__PURE__ */ new WeakSet(), x = !0;
  $w(a, "change", (M) => {
    var T = M ? "[selected]" : ":checked", u;
    if (a.multiple)
      u = [].map.call(a.querySelectorAll(T), vf);
    else {
      var R = a.querySelector(T) ?? // will fall back to first non-disabled option if no option is selected
      a.querySelector("option:not([disabled])");
      u = R && vf(R);
    }
    l(u), vn !== null && p.add(vn);
  }), e2(() => {
    var M = n();
    if (a === document.activeElement) {
      var T = (
        /** @type {Batch} */
        fg ?? vn
      );
      if (p.has(T))
        return;
    }
    if (p2(a, M, x), x && M === void 0) {
      var u = a.querySelector(":checked");
      u !== null && (M = vf(u), l(M));
    }
    a.__value = M, x = !1;
  }), mD(a);
}
function vf(a) {
  return "__value" in a ? a.__value : a.value;
}
const yD = Symbol("is custom element"), vD = Symbol("is html");
function Hl(a, n, l, p) {
  var x = xD(a);
  x[n] !== (x[n] = l) && (n === "loading" && (a[rL] = l), l == null ? a.removeAttribute(n) : typeof l != "string" && bD(a).includes(n) ? a[n] = l : a.setAttribute(n, l));
}
function xD(a) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    a.__attributes ??= {
      [yD]: a.nodeName.includes("-"),
      [vD]: a.namespaceURI === wL
    }
  );
}
var P1 = /* @__PURE__ */ new Map();
function bD(a) {
  var n = a.getAttribute("is") || a.nodeName, l = P1.get(n);
  if (l) return l;
  P1.set(n, l = []);
  for (var p, x = a, M = Element.prototype; M !== x; ) {
    p = WA(x);
    for (var T in p)
      p[T].set && l.push(T);
    x = Ew(x);
  }
  return l;
}
function wD(a, n, l = n) {
  $w(a, "change", (p) => {
    var x = p ? a.defaultChecked : a.checked;
    l(x);
  }), // If we are hydrating and the value has since changed,
  // then use the update value from the input instead.
  // If defaultChecked is set, then checked == defaultChecked
  Gf(n) == null && l(a.checked), t2(() => {
    var p = n();
    a.checked = !!p;
  });
}
let dy = Symbol();
function g2(a, n, l) {
  const p = l[n] ??= {
    store: null,
    source: /* @__PURE__ */ Uw(void 0),
    unsubscribe: Ua
  };
  if (p.store !== a && !(dy in l))
    if (p.unsubscribe(), p.store = a ?? null, a == null)
      p.source.v = void 0, p.unsubscribe = Ua;
    else {
      var x = !0;
      p.unsubscribe = _2(a, (M) => {
        x ? p.source.v = M : ps(p.source, M);
      }), x = !1;
    }
  return a && dy in l ? SD(a) : fr(p.source);
}
function m2() {
  const a = {};
  function n() {
    iv(() => {
      for (var l in a)
        a[l].unsubscribe();
      ww(a, dy, {
        enumerable: !1,
        value: !0
      });
    });
  }
  return [a, n];
}
function ED(a) {
  is === null && Cw(), WL(() => {
    const n = Gf(a);
    if (typeof n == "function") return (
      /** @type {() => void} */
      n
    );
  });
}
function _2(a, n, l) {
  if (a == null)
    return n(void 0), Ua;
  const p = Gf(
    () => a.subscribe(
      n,
      // @ts-expect-error
      l
    )
  );
  return p.unsubscribe ? () => p.unsubscribe() : p;
}
const wh = [];
function TD(a, n = Ua) {
  let l = null;
  const p = /* @__PURE__ */ new Set();
  function x(u) {
    if (Iw(a, u) && (a = u, l)) {
      const R = !wh.length;
      for (const z of p)
        z[1](), wh.push(z, a);
      if (R) {
        for (let z = 0; z < wh.length; z += 2)
          wh[z][0](wh[z + 1]);
        wh.length = 0;
      }
    }
  }
  function M(u) {
    x(u(
      /** @type {T} */
      a
    ));
  }
  function T(u, R = Ua) {
    const z = [u, R];
    return p.add(z), p.size === 1 && (l = n(x, M) || Ua), u(
      /** @type {T} */
      a
    ), () => {
      p.delete(z), p.size === 0 && l && (l(), l = null);
    };
  }
  return { set: x, update: M, subscribe: T };
}
function SD(a) {
  let n;
  return _2(a, (l) => n = l)(), n;
}
const kD = {
  controls: Js(jb),
  options: ny().controls,
  settings: ny().settings
}, ov = TD(kD), ID = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(ID);
const MD = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M7.474 17.988h49.045L31.996 46.012zm-3.85 3.37 24.522 28.019a5.113 5.113 0 0 0 7.7 0l24.523-28.02c2.894-3.308.542-8.482-3.85-8.482H7.474a5.113 5.113 0 0 0-3.85 8.482"/>
</svg>
`, CD = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M7.474 46.012h49.045L31.996 17.988Zm-3.85-3.37 24.522-28.019a5.113 5.113 0 0 1 7.7 0l24.523 28.02c2.894 3.308.542 8.482-3.85 8.482H7.474a5.113 5.113 0 0 1-3.85-8.482"/>
</svg>
`;
var PD = /* @__PURE__ */ xa("<option> </option>"), AD = /* @__PURE__ */ xa('<label class="svelte-18zciyf"> </label> <select class="svelte-18zciyf"></select>', 1), LD = /* @__PURE__ */ xa('<label class="svelte-18zciyf"><input type="checkbox" class="svelte-18zciyf"/> </label>'), DD = /* @__PURE__ */ xa('<div class="action-option svelte-18zciyf"><!></div>');
function RD(a, n) {
  Hh(n, !0);
  let l = /* @__PURE__ */ yo("");
  ED(() => {
    n.actionOption && (n.actionOption.type === "select" ? ps(l, n.actionOption.value.value, !0) : n.actionOption.type === "toggle" && ps(l, n.actionOption.value, !0));
  });
  const p = (u) => {
    if (!n.actionInstance || !n.actionOption) {
      It.error("Can't apply option value", n.actionInstance, n.actionOption);
      return;
    }
    if (n.actionOption?.type === "toggle") {
      const R = u.target;
      ps(l, R.checked, !0);
    } else if (n.actionOption?.type === "select") {
      const R = u.target;
      ps(l, R.value, !0);
    }
    n.actionInstance.applyOptionValue(n.name, fr(l));
  };
  var x = ul(), M = Wa(x);
  {
    var T = (u) => {
      var R = DD(), z = $a(R);
      {
        var U = (ee) => {
          var oe = AD(), ce = Wa(oe), me = $a(ce), re = kf(ce, 2);
          re.__change = p, Af(re, 21, () => n.actionOption.choices, sD, (Pe, _e) => {
            var je = PD(), Qe = $a(je), et = {};
            Za(() => {
              Lh(Qe, fr(_e).title), et !== (et = fr(_e).value) && (je.value = (je.__value = fr(_e).value) ?? "");
            }), Gn(Pe, je);
          }), Za(() => {
            Hl(ce, "for", n.name), Lh(me, n.actionOption.label), Hl(re, "id", n.name);
          }), _D(re, () => fr(l), (Pe) => ps(l, Pe)), Gn(ee, oe);
        }, $ = (ee) => {
          var oe = ul(), ce = Wa(oe);
          {
            var me = (re) => {
              var Pe = LD(), _e = $a(Pe);
              _e.__change = p;
              var je = kf(_e);
              Za(
                (Qe) => {
                  Hl(Pe, "for", n.name), Hl(_e, "id", Qe), Lh(je, ` ${n.actionOption.label ?? ""}`);
                },
                [() => String(n.name)]
              ), wD(_e, () => fr(l), (Qe) => ps(l, Qe)), Gn(re, Pe);
            };
            Ys(
              ce,
              (re) => {
                n.actionOption.type === "toggle" && typeof fr(l) == "boolean" && re(me);
              },
              !0
            );
          }
          Gn(ee, oe);
        };
        Ys(z, (ee) => {
          n.actionOption.type === "select" ? ee(U) : ee($, !1);
        });
      }
      Gn(u, R);
    };
    Ys(M, (u) => {
      n.actionOption && u(T);
    });
  }
  Gn(a, x), Yh();
}
Jg(["change"]);
var FD = /* @__PURE__ */ xa('<button type="submit" class="sub-action svelte-1xmw7n6"> </button>');
function ND(a, n) {
  Hh(n, !0);
  const l = (T) => {
    if (T.preventDefault(), !n.actionInstance || !n.subAction) {
      It.error("Can't run a SubAction", n.actionInstance, n.subAction);
      return;
    }
    n.subAction.method();
  };
  var p = ul(), x = Wa(p);
  {
    var M = (T) => {
      var u = FD();
      u.__click = l;
      var R = $a(u);
      Za(() => {
        Hl(u, "id", `subaction-${n.name}`), Hl(u, "title", n.subAction.label), Lh(R, n.subAction.label);
      }), Gn(T, u);
    };
    Ys(x, (T) => {
      n.subAction && T(M);
    });
  }
  Gn(a, p), Yh();
}
Jg(["click"]);
var OD = /* @__PURE__ */ xa("<!> <!>", 1);
function zD(a, n) {
  Hh(n, !0);
  const l = Aw("gm"), p = /* @__PURE__ */ qa(() => n.control.type), x = /* @__PURE__ */ qa(() => n.control.targetMode), M = /* @__PURE__ */ qa(() => fr(p) && fr(x) && l.actionInstances[`${fr(p)}__${fr(x)}`] || null);
  var T = ul(), u = Wa(T);
  {
    var R = (z) => {
      var U = OD(), $ = Wa(U);
      Af($, 17, () => Object.entries(fr(M).options), ([oe, ce]) => oe, (oe, ce) => {
        var me = /* @__PURE__ */ qa(() => Sg(fr(ce), 2));
        let re = () => fr(me)[0], Pe = () => fr(me)[1];
        RD(oe, {
          get name() {
            return re();
          },
          get actionInstance() {
            return fr(M);
          },
          get actionOption() {
            return Pe();
          }
        });
      });
      var ee = kf($, 2);
      Af(ee, 17, () => Object.entries(fr(M).actions), ([oe, ce]) => oe, (oe, ce) => {
        var me = /* @__PURE__ */ qa(() => Sg(fr(ce), 2));
        let re = () => fr(me)[0], Pe = () => fr(me)[1];
        ND(oe, {
          get name() {
            return re();
          },
          get actionInstance() {
            return fr(M);
          },
          get subAction() {
            return Pe();
          }
        });
      }), Gn(z, U);
    };
    Ys(u, (z) => {
      fr(M) && z(R);
    });
  }
  Gn(a, T), Yh();
}
const {
  entries: y2,
  setPrototypeOf: A1,
  isFrozen: BD,
  getPrototypeOf: GD,
  getOwnPropertyDescriptor: jD
} = Object;
let {
  freeze: _s,
  seal: va,
  create: fy
} = Object, {
  apply: py,
  construct: gy
} = typeof Reflect < "u" && Reflect;
_s || (_s = function(a) {
  return a;
});
va || (va = function(a) {
  return a;
});
py || (py = function(a, n) {
  for (var l = arguments.length, p = new Array(l > 2 ? l - 2 : 0), x = 2; x < l; x++)
    p[x - 2] = arguments[x];
  return a.apply(n, p);
});
gy || (gy = function(a) {
  for (var n = arguments.length, l = new Array(n > 1 ? n - 1 : 0), p = 1; p < n; p++)
    l[p - 1] = arguments[p];
  return new a(...l);
});
const Xp = ys(Array.prototype.forEach), VD = ys(Array.prototype.lastIndexOf), L1 = ys(Array.prototype.pop), Yd = ys(Array.prototype.push), UD = ys(Array.prototype.splice), pg = ys(String.prototype.toLowerCase), S_ = ys(String.prototype.toString), k_ = ys(String.prototype.match), Wd = ys(String.prototype.replace), qD = ys(String.prototype.indexOf), $D = ys(String.prototype.trim), Ga = ys(Object.prototype.hasOwnProperty), hs = ys(RegExp.prototype.test), Xd = ZD(TypeError);
function ys(a) {
  return function(n) {
    n instanceof RegExp && (n.lastIndex = 0);
    for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), x = 1; x < l; x++)
      p[x - 1] = arguments[x];
    return py(a, n, p);
  };
}
function ZD(a) {
  return function() {
    for (var n = arguments.length, l = new Array(n), p = 0; p < n; p++)
      l[p] = arguments[p];
    return gy(a, l);
  };
}
function kr(a, n) {
  let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : pg;
  A1 && A1(a, null);
  let p = n.length;
  for (; p--; ) {
    let x = n[p];
    if (typeof x == "string") {
      const M = l(x);
      M !== x && (BD(n) || (n[p] = M), x = M);
    }
    a[x] = !0;
  }
  return a;
}
function HD(a) {
  for (let n = 0; n < a.length; n++)
    Ga(a, n) || (a[n] = null);
  return a;
}
function _o(a) {
  const n = fy(null);
  for (const [l, p] of y2(a))
    Ga(a, l) && (Array.isArray(p) ? n[l] = HD(p) : p && typeof p == "object" && p.constructor === Object ? n[l] = _o(p) : n[l] = p);
  return n;
}
function Jd(a, n) {
  for (; a !== null; ) {
    const p = jD(a, n);
    if (p) {
      if (p.get)
        return ys(p.get);
      if (typeof p.value == "function")
        return ys(p.value);
    }
    a = GD(a);
  }
  function l() {
    return null;
  }
  return l;
}
const D1 = _s(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), I_ = _s(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), M_ = _s(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), YD = _s(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), C_ = _s(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), WD = _s(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), R1 = _s(["#text"]), F1 = _s(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), P_ = _s(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), N1 = _s(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Jp = _s(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), XD = va(/\{\{[\w\W]*|[\w\W]*\}\}/gm), JD = va(/<%[\w\W]*|[\w\W]*%>/gm), KD = va(/\$\{[\w\W]*/gm), QD = va(/^data-[\-\w.\u00B7-\uFFFF]+$/), eR = va(/^aria-[\-\w]+$/), v2 = va(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), tR = va(/^(?:\w+script|data):/i), rR = va(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), x2 = va(/^html$/i), nR = va(/^[a-z][.\w]*(-[.\w]+)+$/i);
var O1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: eR,
  ATTR_WHITESPACE: rR,
  CUSTOM_ELEMENT: nR,
  DATA_ATTR: QD,
  DOCTYPE_NAME: x2,
  ERB_EXPR: JD,
  IS_ALLOWED_URI: v2,
  IS_SCRIPT_OR_DATA: tR,
  MUSTACHE_EXPR: XD,
  TMPLIT_EXPR: KD
});
const Kd = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, iR = function() {
  return typeof window > "u" ? null : window;
}, sR = function(a, n) {
  if (typeof a != "object" || typeof a.createPolicy != "function")
    return null;
  let l = null;
  const p = "data-tt-policy-suffix";
  n && n.hasAttribute(p) && (l = n.getAttribute(p));
  const x = "dompurify" + (l ? "#" + l : "");
  try {
    return a.createPolicy(x, {
      createHTML(M) {
        return M;
      },
      createScriptURL(M) {
        return M;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + x + " could not be created."), null;
  }
}, z1 = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function b2() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iR();
  const n = (Ee) => b2(Ee);
  if (n.version = "3.3.1", n.removed = [], !a || !a.document || a.document.nodeType !== Kd.document || !a.Element)
    return n.isSupported = !1, n;
  let {
    document: l
  } = a;
  const p = l, x = p.currentScript, {
    DocumentFragment: M,
    HTMLTemplateElement: T,
    Node: u,
    Element: R,
    NodeFilter: z,
    NamedNodeMap: U = a.NamedNodeMap || a.MozNamedAttrMap,
    HTMLFormElement: $,
    DOMParser: ee,
    trustedTypes: oe
  } = a, ce = R.prototype, me = Jd(ce, "cloneNode"), re = Jd(ce, "remove"), Pe = Jd(ce, "nextSibling"), _e = Jd(ce, "childNodes"), je = Jd(ce, "parentNode");
  if (typeof T == "function") {
    const Ee = l.createElement("template");
    Ee.content && Ee.content.ownerDocument && (l = Ee.content.ownerDocument);
  }
  let Qe, et = "";
  const {
    implementation: Ye,
    createNodeIterator: ot,
    createDocumentFragment: Q,
    getElementsByTagName: ie
  } = l, {
    importNode: ge
  } = p;
  let Se = z1();
  n.isSupported = typeof y2 == "function" && typeof je == "function" && Ye && Ye.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: Ie,
    ERB_EXPR: Oe,
    TMPLIT_EXPR: Re,
    DATA_ATTR: De,
    ARIA_ATTR: Fe,
    IS_SCRIPT_OR_DATA: Ue,
    ATTR_WHITESPACE: Ve,
    CUSTOM_ELEMENT: We
  } = O1;
  let {
    IS_ALLOWED_URI: dt
  } = O1, Tt = null;
  const Ht = kr({}, [...D1, ...I_, ...M_, ...C_, ...R1]);
  let Ot = null;
  const Pt = kr({}, [...F1, ...P_, ...N1, ...Jp]);
  let Mt = Object.seal(fy(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Kt = null, gr = null;
  const Ze = Object.seal(fy(null, {
    tagCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    }
  }));
  let ri = !0, lr = !0, Ut = !1, Me = !0, br = !1, ur = !0, tr = !1, mi = !1, Nr = !1, _i = !1, St = !1, $i = !1, Zi = !0, In = !1;
  const Ks = "user-content-";
  let er = !0, Kr = !1, He = {}, K = null;
  const J = kr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let le = null;
  const be = kr({}, ["audio", "video", "img", "source", "image", "track"]);
  let ye = null;
  const Je = kr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), qe = "http://www.w3.org/1998/Math/MathML", Be = "http://www.w3.org/2000/svg", ze = "http://www.w3.org/1999/xhtml";
  let ft = ze, ct = !1, Lt = null;
  const Nt = kr({}, [qe, Be, ze], S_);
  let Wt = kr({}, ["mi", "mo", "mn", "ms", "mtext"]), cr = kr({}, ["annotation-xml"]);
  const wr = kr({}, ["title", "style", "font", "a", "script"]);
  let Xe = null;
  const Rr = ["application/xhtml+xml", "text/html"], Mn = "text/html";
  let qt = null, mt = null;
  const fn = l.createElement("form"), Ir = function(Ee) {
    return Ee instanceof RegExp || Ee instanceof Function;
  }, Pr = function() {
    let Ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(mt && mt === Ee)) {
      if ((!Ee || typeof Ee != "object") && (Ee = {}), Ee = _o(Ee), Xe = // eslint-disable-next-line unicorn/prefer-includes
      Rr.indexOf(Ee.PARSER_MEDIA_TYPE) === -1 ? Mn : Ee.PARSER_MEDIA_TYPE, qt = Xe === "application/xhtml+xml" ? S_ : pg, Tt = Ga(Ee, "ALLOWED_TAGS") ? kr({}, Ee.ALLOWED_TAGS, qt) : Ht, Ot = Ga(Ee, "ALLOWED_ATTR") ? kr({}, Ee.ALLOWED_ATTR, qt) : Pt, Lt = Ga(Ee, "ALLOWED_NAMESPACES") ? kr({}, Ee.ALLOWED_NAMESPACES, S_) : Nt, ye = Ga(Ee, "ADD_URI_SAFE_ATTR") ? kr(_o(Je), Ee.ADD_URI_SAFE_ATTR, qt) : Je, le = Ga(Ee, "ADD_DATA_URI_TAGS") ? kr(_o(be), Ee.ADD_DATA_URI_TAGS, qt) : be, K = Ga(Ee, "FORBID_CONTENTS") ? kr({}, Ee.FORBID_CONTENTS, qt) : J, Kt = Ga(Ee, "FORBID_TAGS") ? kr({}, Ee.FORBID_TAGS, qt) : _o({}), gr = Ga(Ee, "FORBID_ATTR") ? kr({}, Ee.FORBID_ATTR, qt) : _o({}), He = Ga(Ee, "USE_PROFILES") ? Ee.USE_PROFILES : !1, ri = Ee.ALLOW_ARIA_ATTR !== !1, lr = Ee.ALLOW_DATA_ATTR !== !1, Ut = Ee.ALLOW_UNKNOWN_PROTOCOLS || !1, Me = Ee.ALLOW_SELF_CLOSE_IN_ATTR !== !1, br = Ee.SAFE_FOR_TEMPLATES || !1, ur = Ee.SAFE_FOR_XML !== !1, tr = Ee.WHOLE_DOCUMENT || !1, _i = Ee.RETURN_DOM || !1, St = Ee.RETURN_DOM_FRAGMENT || !1, $i = Ee.RETURN_TRUSTED_TYPE || !1, Nr = Ee.FORCE_BODY || !1, Zi = Ee.SANITIZE_DOM !== !1, In = Ee.SANITIZE_NAMED_PROPS || !1, er = Ee.KEEP_CONTENT !== !1, Kr = Ee.IN_PLACE || !1, dt = Ee.ALLOWED_URI_REGEXP || v2, ft = Ee.NAMESPACE || ze, Wt = Ee.MATHML_TEXT_INTEGRATION_POINTS || Wt, cr = Ee.HTML_INTEGRATION_POINTS || cr, Mt = Ee.CUSTOM_ELEMENT_HANDLING || {}, Ee.CUSTOM_ELEMENT_HANDLING && Ir(Ee.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Mt.tagNameCheck = Ee.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Ee.CUSTOM_ELEMENT_HANDLING && Ir(Ee.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Mt.attributeNameCheck = Ee.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Ee.CUSTOM_ELEMENT_HANDLING && typeof Ee.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Mt.allowCustomizedBuiltInElements = Ee.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), br && (lr = !1), St && (_i = !0), He && (Tt = kr({}, R1), Ot = [], He.html === !0 && (kr(Tt, D1), kr(Ot, F1)), He.svg === !0 && (kr(Tt, I_), kr(Ot, P_), kr(Ot, Jp)), He.svgFilters === !0 && (kr(Tt, M_), kr(Ot, P_), kr(Ot, Jp)), He.mathMl === !0 && (kr(Tt, C_), kr(Ot, N1), kr(Ot, Jp))), Ee.ADD_TAGS && (typeof Ee.ADD_TAGS == "function" ? Ze.tagCheck = Ee.ADD_TAGS : (Tt === Ht && (Tt = _o(Tt)), kr(Tt, Ee.ADD_TAGS, qt))), Ee.ADD_ATTR && (typeof Ee.ADD_ATTR == "function" ? Ze.attributeCheck = Ee.ADD_ATTR : (Ot === Pt && (Ot = _o(Ot)), kr(Ot, Ee.ADD_ATTR, qt))), Ee.ADD_URI_SAFE_ATTR && kr(ye, Ee.ADD_URI_SAFE_ATTR, qt), Ee.FORBID_CONTENTS && (K === J && (K = _o(K)), kr(K, Ee.FORBID_CONTENTS, qt)), Ee.ADD_FORBID_CONTENTS && (K === J && (K = _o(K)), kr(K, Ee.ADD_FORBID_CONTENTS, qt)), er && (Tt["#text"] = !0), tr && kr(Tt, ["html", "head", "body"]), Tt.table && (kr(Tt, ["tbody"]), delete Kt.tbody), Ee.TRUSTED_TYPES_POLICY) {
        if (typeof Ee.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Xd('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof Ee.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Xd('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        Qe = Ee.TRUSTED_TYPES_POLICY, et = Qe.createHTML("");
      } else
        Qe === void 0 && (Qe = sR(oe, x)), Qe !== null && typeof et == "string" && (et = Qe.createHTML(""));
      _s && _s(Ee), mt = Ee;
    }
  }, Mr = kr({}, [...I_, ...M_, ...YD]), Yr = kr({}, [...C_, ...WD]), Qs = function(Ee) {
    let zt = je(Ee);
    (!zt || !zt.tagName) && (zt = {
      namespaceURI: ft,
      tagName: "template"
    });
    const bt = pg(Ee.tagName), Tr = pg(zt.tagName);
    return Lt[Ee.namespaceURI] ? Ee.namespaceURI === Be ? zt.namespaceURI === ze ? bt === "svg" : zt.namespaceURI === qe ? bt === "svg" && (Tr === "annotation-xml" || Wt[Tr]) : !!Mr[bt] : Ee.namespaceURI === qe ? zt.namespaceURI === ze ? bt === "math" : zt.namespaceURI === Be ? bt === "math" && cr[Tr] : !!Yr[bt] : Ee.namespaceURI === ze ? zt.namespaceURI === Be && !cr[Tr] || zt.namespaceURI === qe && !Wt[Tr] ? !1 : !Yr[bt] && (wr[bt] || !Mr[bt]) : !!(Xe === "application/xhtml+xml" && Lt[Ee.namespaceURI]) : !1;
  }, Rn = function(Ee) {
    Yd(n.removed, {
      element: Ee
    });
    try {
      je(Ee).removeChild(Ee);
    } catch {
      re(Ee);
    }
  }, yt = function(Ee, zt) {
    try {
      Yd(n.removed, {
        attribute: zt.getAttributeNode(Ee),
        from: zt
      });
    } catch {
      Yd(n.removed, {
        attribute: null,
        from: zt
      });
    }
    if (zt.removeAttribute(Ee), Ee === "is")
      if (_i || St)
        try {
          Rn(zt);
        } catch {
        }
      else
        try {
          zt.setAttribute(Ee, "");
        } catch {
        }
  }, bn = function(Ee) {
    let zt = null, bt = null;
    if (Nr)
      Ee = "<remove></remove>" + Ee;
    else {
      const Cr = k_(Ee, /^[\r\n\t ]+/);
      bt = Cr && Cr[0];
    }
    Xe === "application/xhtml+xml" && ft === ze && (Ee = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Ee + "</body></html>");
    const Tr = Qe ? Qe.createHTML(Ee) : Ee;
    if (ft === ze)
      try {
        zt = new ee().parseFromString(Tr, Xe);
      } catch {
      }
    if (!zt || !zt.documentElement) {
      zt = Ye.createDocument(ft, "template", null);
      try {
        zt.documentElement.innerHTML = ct ? et : Tr;
      } catch {
      }
    }
    const Qr = zt.body || zt.documentElement;
    return Ee && bt && Qr.insertBefore(l.createTextNode(bt), Qr.childNodes[0] || null), ft === ze ? ie.call(zt, tr ? "html" : "body")[0] : tr ? zt.documentElement : Qr;
  }, Un = function(Ee) {
    return ot.call(
      Ee.ownerDocument || Ee,
      Ee,
      // eslint-disable-next-line no-bitwise
      z.SHOW_ELEMENT | z.SHOW_COMMENT | z.SHOW_TEXT | z.SHOW_PROCESSING_INSTRUCTION | z.SHOW_CDATA_SECTION,
      null
    );
  }, Ps = function(Ee) {
    return Ee instanceof $ && (typeof Ee.nodeName != "string" || typeof Ee.textContent != "string" || typeof Ee.removeChild != "function" || !(Ee.attributes instanceof U) || typeof Ee.removeAttribute != "function" || typeof Ee.setAttribute != "function" || typeof Ee.namespaceURI != "string" || typeof Ee.insertBefore != "function" || typeof Ee.hasChildNodes != "function");
  }, yi = function(Ee) {
    return typeof u == "function" && Ee instanceof u;
  };
  function xt(Ee, zt, bt) {
    Xp(Ee, (Tr) => {
      Tr.call(n, zt, bt, mt);
    });
  }
  const ir = function(Ee) {
    let zt = null;
    if (xt(Se.beforeSanitizeElements, Ee, null), Ps(Ee))
      return Rn(Ee), !0;
    const bt = qt(Ee.nodeName);
    if (xt(Se.uponSanitizeElement, Ee, {
      tagName: bt,
      allowedTags: Tt
    }), ur && Ee.hasChildNodes() && !yi(Ee.firstElementChild) && hs(/<[/\w!]/g, Ee.innerHTML) && hs(/<[/\w!]/g, Ee.textContent) || Ee.nodeType === Kd.progressingInstruction || ur && Ee.nodeType === Kd.comment && hs(/<[/\w]/g, Ee.data))
      return Rn(Ee), !0;
    if (!(Ze.tagCheck instanceof Function && Ze.tagCheck(bt)) && (!Tt[bt] || Kt[bt])) {
      if (!Kt[bt] && pn(bt) && (Mt.tagNameCheck instanceof RegExp && hs(Mt.tagNameCheck, bt) || Mt.tagNameCheck instanceof Function && Mt.tagNameCheck(bt)))
        return !1;
      if (er && !K[bt]) {
        const Tr = je(Ee) || Ee.parentNode, Qr = _e(Ee) || Ee.childNodes;
        if (Qr && Tr) {
          const Cr = Qr.length;
          for (let Cn = Cr - 1; Cn >= 0; --Cn) {
            const Fn = me(Qr[Cn], !0);
            Fn.__removalCount = (Ee.__removalCount || 0) + 1, Tr.insertBefore(Fn, Pe(Ee));
          }
        }
      }
      return Rn(Ee), !0;
    }
    return Ee instanceof R && !Qs(Ee) || (bt === "noscript" || bt === "noembed" || bt === "noframes") && hs(/<\/no(script|embed|frames)/i, Ee.innerHTML) ? (Rn(Ee), !0) : (br && Ee.nodeType === Kd.text && (zt = Ee.textContent, Xp([Ie, Oe, Re], (Tr) => {
      zt = Wd(zt, Tr, " ");
    }), Ee.textContent !== zt && (Yd(n.removed, {
      element: Ee.cloneNode()
    }), Ee.textContent = zt)), xt(Se.afterSanitizeElements, Ee, null), !1);
  }, rr = function(Ee, zt, bt) {
    if (Zi && (zt === "id" || zt === "name") && (bt in l || bt in fn))
      return !1;
    if (!(lr && !gr[zt] && hs(De, zt)) && !(ri && hs(Fe, zt)) && !(Ze.attributeCheck instanceof Function && Ze.attributeCheck(zt, Ee))) {
      if (!Ot[zt] || gr[zt]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          !(pn(Ee) && (Mt.tagNameCheck instanceof RegExp && hs(Mt.tagNameCheck, Ee) || Mt.tagNameCheck instanceof Function && Mt.tagNameCheck(Ee)) && (Mt.attributeNameCheck instanceof RegExp && hs(Mt.attributeNameCheck, zt) || Mt.attributeNameCheck instanceof Function && Mt.attributeNameCheck(zt, Ee)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          zt === "is" && Mt.allowCustomizedBuiltInElements && (Mt.tagNameCheck instanceof RegExp && hs(Mt.tagNameCheck, bt) || Mt.tagNameCheck instanceof Function && Mt.tagNameCheck(bt)))
        ) return !1;
      } else if (!ye[zt] && !hs(dt, Wd(bt, Ve, "")) && !((zt === "src" || zt === "xlink:href" || zt === "href") && Ee !== "script" && qD(bt, "data:") === 0 && le[Ee]) && !(Ut && !hs(Ue, Wd(bt, Ve, ""))) && bt)
        return !1;
    }
    return !0;
  }, pn = function(Ee) {
    return Ee !== "annotation-xml" && k_(Ee, We);
  }, zi = function(Ee) {
    xt(Se.beforeSanitizeAttributes, Ee, null);
    const {
      attributes: zt
    } = Ee;
    if (!zt || Ps(Ee))
      return;
    const bt = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: Ot,
      forceKeepAttr: void 0
    };
    let Tr = zt.length;
    for (; Tr--; ) {
      const Qr = zt[Tr], {
        name: Cr,
        namespaceURI: Cn,
        value: Fn
      } = Qr, Or = qt(Cr), Er = Fn;
      let gn = Cr === "value" ? Er : $D(Er);
      if (bt.attrName = Or, bt.attrValue = gn, bt.keepAttr = !0, bt.forceKeepAttr = void 0, xt(Se.uponSanitizeAttribute, Ee, bt), gn = bt.attrValue, In && (Or === "id" || Or === "name") && (yt(Cr, Ee), gn = Ks + gn), ur && hs(/((--!?|])>)|<\/(style|title|textarea)/i, gn)) {
        yt(Cr, Ee);
        continue;
      }
      if (Or === "attributename" && k_(gn, "href")) {
        yt(Cr, Ee);
        continue;
      }
      if (bt.forceKeepAttr)
        continue;
      if (!bt.keepAttr) {
        yt(Cr, Ee);
        continue;
      }
      if (!Me && hs(/\/>/i, gn)) {
        yt(Cr, Ee);
        continue;
      }
      br && Xp([Ie, Oe, Re], (Hi) => {
        gn = Wd(gn, Hi, " ");
      });
      const Nn = qt(Ee.nodeName);
      if (!rr(Nn, Or, gn)) {
        yt(Cr, Ee);
        continue;
      }
      if (Qe && typeof oe == "object" && typeof oe.getAttributeType == "function" && !Cn)
        switch (oe.getAttributeType(Nn, Or)) {
          case "TrustedHTML": {
            gn = Qe.createHTML(gn);
            break;
          }
          case "TrustedScriptURL": {
            gn = Qe.createScriptURL(gn);
            break;
          }
        }
      if (gn !== Er)
        try {
          Cn ? Ee.setAttributeNS(Cn, Cr, gn) : Ee.setAttribute(Cr, gn), Ps(Ee) ? Rn(Ee) : L1(n.removed);
        } catch {
          yt(Cr, Ee);
        }
    }
    xt(Se.afterSanitizeAttributes, Ee, null);
  }, Bi = function Ee(zt) {
    let bt = null;
    const Tr = Un(zt);
    for (xt(Se.beforeSanitizeShadowDOM, zt, null); bt = Tr.nextNode(); )
      xt(Se.uponSanitizeShadowNode, bt, null), ir(bt), zi(bt), bt.content instanceof M && Ee(bt.content);
    xt(Se.afterSanitizeShadowDOM, zt, null);
  };
  return n.sanitize = function(Ee) {
    let zt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bt = null, Tr = null, Qr = null, Cr = null;
    if (ct = !Ee, ct && (Ee = "<!-->"), typeof Ee != "string" && !yi(Ee))
      if (typeof Ee.toString == "function") {
        if (Ee = Ee.toString(), typeof Ee != "string")
          throw Xd("dirty is not a string, aborting");
      } else
        throw Xd("toString is not a function");
    if (!n.isSupported)
      return Ee;
    if (mi || Pr(zt), n.removed = [], typeof Ee == "string" && (Kr = !1), Kr) {
      if (Ee.nodeName) {
        const Or = qt(Ee.nodeName);
        if (!Tt[Or] || Kt[Or])
          throw Xd("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Ee instanceof u)
      bt = bn("<!---->"), Tr = bt.ownerDocument.importNode(Ee, !0), Tr.nodeType === Kd.element && Tr.nodeName === "BODY" || Tr.nodeName === "HTML" ? bt = Tr : bt.appendChild(Tr);
    else {
      if (!_i && !br && !tr && // eslint-disable-next-line unicorn/prefer-includes
      Ee.indexOf("<") === -1)
        return Qe && $i ? Qe.createHTML(Ee) : Ee;
      if (bt = bn(Ee), !bt)
        return _i ? null : $i ? et : "";
    }
    bt && Nr && Rn(bt.firstChild);
    const Cn = Un(Kr ? Ee : bt);
    for (; Qr = Cn.nextNode(); )
      ir(Qr), zi(Qr), Qr.content instanceof M && Bi(Qr.content);
    if (Kr)
      return Ee;
    if (_i) {
      if (St)
        for (Cr = Q.call(bt.ownerDocument); bt.firstChild; )
          Cr.appendChild(bt.firstChild);
      else
        Cr = bt;
      return (Ot.shadowroot || Ot.shadowrootmode) && (Cr = ge.call(p, Cr, !0)), Cr;
    }
    let Fn = tr ? bt.outerHTML : bt.innerHTML;
    return tr && Tt["!doctype"] && bt.ownerDocument && bt.ownerDocument.doctype && bt.ownerDocument.doctype.name && hs(x2, bt.ownerDocument.doctype.name) && (Fn = "<!DOCTYPE " + bt.ownerDocument.doctype.name + `>
` + Fn), br && Xp([Ie, Oe, Re], (Or) => {
      Fn = Wd(Fn, Or, " ");
    }), Qe && $i ? Qe.createHTML(Fn) : Fn;
  }, n.setConfig = function() {
    let Ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Pr(Ee), mi = !0;
  }, n.clearConfig = function() {
    mt = null, mi = !1;
  }, n.isValidAttribute = function(Ee, zt, bt) {
    mt || Pr({});
    const Tr = qt(Ee), Qr = qt(zt);
    return rr(Tr, Qr, bt);
  }, n.addHook = function(Ee, zt) {
    typeof zt == "function" && Yd(Se[Ee], zt);
  }, n.removeHook = function(Ee, zt) {
    if (zt !== void 0) {
      const bt = VD(Se[Ee], zt);
      return bt === -1 ? void 0 : UD(Se[Ee], bt, 1)[0];
    }
    return L1(Se[Ee]);
  }, n.removeHooks = function(Ee) {
    Se[Ee] = [];
  }, n.removeAllHooks = function() {
    Se = z1();
  }, n;
}
var w2 = b2(), aR = /* @__PURE__ */ xa("<div><!></div>"), oR = /* @__PURE__ */ xa('<div><button type="button"><!></button> <!></div>');
function lR(a, n) {
  Hh(n, !0);
  const l = () => g2(ov, "$controlsStore", p), [p, x] = m2(), M = /* @__PURE__ */ qa(() => n.controlOptions?.icon ? w2.sanitize(n.controlOptions.icon.trim()) : null), T = Aw("gm"), u = T.control.getDefaultPosition(), R = () => {
    n.control && n.controlOptions ? T.options.toggleMode(n.control.type, n.control.targetMode) : It.error("Control or controlOptions not defined", n.control, n.controlOptions);
  };
  var z = ul(), U = Wa(z);
  {
    var $ = (ee) => {
      var oe = oR(), ce = $a(oe);
      let me;
      ce.__click = R;
      var re = $a(ce);
      {
        var Pe = (et) => {
          var Ye = ul(), ot = Wa(Ye);
          h2(ot, () => fr(M)), Gn(et, Ye);
        }, _e = (et) => {
          var Ye = ul(), ot = Wa(Ye);
          {
            var Q = (ge) => {
              var Se = S1();
              Za((Ie) => Lh(Se, Ie), [() => n.controlOptions.title.slice(0, 2)]), Gn(ge, Se);
            }, ie = (ge) => {
              var Se = S1();
              Za(() => Lh(Se, n.control.targetMode)), Gn(ge, Se);
            };
            Ys(
              ot,
              (ge) => {
                n.controlOptions.title ? ge(Q) : ge(ie, !1);
              },
              !0
            );
          }
          Gn(et, Ye);
        };
        Ys(re, (et) => {
          n.controlOptions.icon ? et(Pe) : et(_e, !1);
        });
      }
      var je = kf(ce, 2);
      {
        var Qe = (et) => {
          var Ye = aR();
          let ot;
          var Q = $a(Ye);
          zD(Q, {
            get control() {
              return n.control;
            }
          }), Za((ie) => ot = yf(Ye, 1, "control-menu svelte-1q85gr9", null, ot, ie), [
            () => ({
              "menu-right": u.endsWith("left"),
              "menu-left": u.endsWith("right")
            })
          ]), Gn(et, Ye);
        };
        Ys(je, (et) => {
          n.controlOptions.active && et(Qe);
        });
      }
      Za(() => {
        yf(oe, 1, pD(l().settings.controlsStyles.controlContainerClass), "svelte-1q85gr9"), Hl(ce, "id", `id_${n.control.type}_${n.control.targetMode}`), me = yf(ce, 1, `${l().settings.controlsStyles.controlButtonClass} ${n.control.type}-${n.control.targetMode}`, "svelte-1q85gr9", me, { active: n.controlOptions.active }), Hl(ce, "title", n.controlOptions.title);
      }), Gn(ee, oe);
    };
    Ys(U, (ee) => {
      n.control && n.controlOptions && n.controlOptions.uiEnabled && ee($);
    });
  }
  Gn(a, z), Yh(), x();
}
Jg(["click"]);
function uR(a) {
  const n = a - 1;
  return n * n * n + 1;
}
function B1(a, { delay: n = 0, duration: l = 400, easing: p = uR, axis: x = "y" } = {}) {
  const M = getComputedStyle(a), T = +M.opacity, u = x === "y" ? "height" : "width", R = parseFloat(M[u]), z = x === "y" ? ["top", "bottom"] : ["left", "right"], U = z.map(
    (Pe) => (
      /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */
      `${Pe[0].toUpperCase()}${Pe.slice(1)}`
    )
  ), $ = parseFloat(M[`padding${U[0]}`]), ee = parseFloat(M[`padding${U[1]}`]), oe = parseFloat(M[`margin${U[0]}`]), ce = parseFloat(M[`margin${U[1]}`]), me = parseFloat(
    M[`border${U[0]}Width`]
  ), re = parseFloat(
    M[`border${U[1]}Width`]
  );
  return {
    delay: n,
    duration: l,
    easing: p,
    css: (Pe) => `overflow: hidden;opacity: ${Math.min(Pe * 20, 1) * T};${u}: ${Pe * R}px;padding-${z[0]}: ${Pe * $}px;padding-${z[1]}: ${Pe * ee}px;margin-${z[0]}: ${Pe * oe}px;margin-${z[1]}: ${Pe * ce}px;border-${z[0]}-width: ${Pe * me}px;border-${z[1]}-width: ${Pe * re}px;min-${u}: 0`
  };
}
var cR = /* @__PURE__ */ xa('<div><button class="gm-control-button"><!></button></div>'), hR = /* @__PURE__ */ xa("<div></div>"), dR = /* @__PURE__ */ xa("<div></div>"), fR = /* @__PURE__ */ xa('<div class="gm-reactive-controls"><!> <!></div>');
function pR(a, n) {
  Hh(n, !0);
  const l = () => g2(ov, "$controlsStore", p), [p, x] = m2();
  let M = /* @__PURE__ */ yo(!0), T = /* @__PURE__ */ qa(() => l().settings.controlsCollapsible), u = /* @__PURE__ */ qa(() => l().settings.controlsStyles);
  const R = (Pe, _e) => l().controls?.[Pe]?.[_e] || null, z = (Pe, _e) => Object.entries(_e).some(([je, Qe]) => R(Pe, je) && Qe && Qe.uiEnabled), U = () => {
    ps(M, !fr(M));
  }, $ = () => w2.sanitize(fr(M) ? MD : CD);
  var ee = fR(), oe = $a(ee);
  {
    var ce = (Pe) => {
      var _e = cR(), je = $a(_e);
      je.__click = U;
      var Qe = $a(je);
      h2(Qe, $), Za(() => yf(_e, 1, `${fr(u).controlGroupClass} group-settings`)), Gn(Pe, _e);
    };
    Ys(oe, (Pe) => {
      fr(T) && Pe(ce);
    });
  }
  var me = kf(oe, 2);
  {
    var re = (Pe) => {
      var _e = dR();
      Af(_e, 5, () => Object.entries(l().options), ([je, Qe]) => je, (je, Qe) => {
        var et = /* @__PURE__ */ qa(() => Sg(fr(Qe), 2));
        let Ye = () => fr(et)[0], ot = () => fr(et)[1];
        var Q = ul(), ie = Wa(Q);
        {
          var ge = (Se) => {
            var Ie = hR();
            Af(Ie, 21, () => Object.entries(ot()), ([Oe, Re]) => Oe, (Oe, Re) => {
              var De = /* @__PURE__ */ qa(() => Sg(fr(Re), 2));
              let Fe = () => fr(De)[0], Ue = () => fr(De)[1];
              const Ve = /* @__PURE__ */ qa(() => R(Ye(), Fe()));
              var We = ul(), dt = Wa(We);
              {
                var Tt = (Ht) => {
                  lR(Ht, {
                    get control() {
                      return fr(Ve);
                    },
                    get controlOptions() {
                      return Ue();
                    }
                  });
                };
                Ys(dt, (Ht) => {
                  fr(Ve) && Ht(Tt);
                });
              }
              Gn(Oe, We);
            }), Za(() => yf(Ie, 1, `${fr(u).controlGroupClass} group-${Ye()}`)), Gn(Se, Ie);
          };
          Ys(ie, (Se) => {
            z(Ye(), ot()) && Se(ge);
          });
        }
        Gn(je, Q);
      }), M1(1, _e, () => B1, () => ({ duration: 180 })), M1(2, _e, () => B1, () => ({ duration: 140 })), Gn(Pe, _e);
    };
    Ys(me, (Pe) => {
      fr(M) && Pe(re);
    });
  }
  Gn(a, ee), Yh(), x();
}
Jg(["click"]);
class gR {
  gm;
  constructor(n) {
    this.gm = n;
  }
}
const ei = (a) => Object.keys(a), my = (a) => Object.values(a), Kl = (a, n) => n.includes(a);
class mR extends gR {
  controls = Js(jb);
  reactiveControls = null;
  container = void 0;
  eventHandlers = {
    [`${Ft}:draw`]: this.handleModeEvent.bind(this),
    [`${Ft}:edit`]: this.handleModeEvent.bind(this),
    [`${Ft}:helper`]: this.handleModeEvent.bind(this)
  };
  onAdd() {
    if (this.createControls(), this.gm.events.bus.attachEvents(this.eventHandlers), !this.container)
      throw new Error("Controls container is not initialized");
    return this.container;
  }
  createControls(n = void 0) {
    if (this.controlsAdded()) {
      It.warn("Can't add controls: controls already added");
      return;
    }
    this.container = n || this.createHtmlContainer(), this.createReactivePanel();
  }
  onRemove() {
    this.gm.events.bus.detachEvents(this.eventHandlers), this.reactiveControls && (nD(this.reactiveControls), this.reactiveControls = null), this.container && this.container.parentNode && this.container.parentNode.removeChild(this.container), this.container = void 0;
  }
  handleModeEvent(n) {
    return Ev(n) ? (["mode_started", "mode_ended"].includes(n.action) && this.updateReactivePanel(), { next: !0 }) : { next: !0 };
  }
  controlsAdded() {
    return !!this.reactiveControls;
  }
  createReactivePanel() {
    if (!this.container) {
      It.error("Can't create reactive panel: container is not initialized");
      return;
    }
    this.syncModeStates();
    const n = /* @__PURE__ */ new Map();
    n.set("gm", this.gm), this.reactiveControls = tD(pR, {
      target: this.container,
      context: n
    }), this.updateReactivePanel();
  }
  updateReactivePanel() {
    ov.update(() => ({
      controls: this.controls,
      options: this.gm.options.controls,
      settings: this.gm.options.settings
    }));
  }
  createHtmlContainer() {
    const n = document.createElement("div");
    return n.classList.add("geoman-controls"), n;
  }
  syncModeStates() {
    this.eachControlWithOptions(({ control: n }) => {
      this.gm.options.syncModeState(n.type, n.targetMode);
    });
  }
  eachControlWithOptions(n) {
    return ei(this.controls).forEach((l) => {
      const p = this.controls[l];
      return Object.keys(p).forEach((x) => {
        const M = x, T = this.getControl({ modeType: l, modeName: M }), u = this.gm.options.getControlOptions({
          modeType: l,
          modeName: M
        });
        T && u && n({ control: T, controlOptions: u });
      });
    });
  }
  getControl({
    modeType: n,
    modeName: l
  }) {
    return n && l && this.controls[n][l] || null;
  }
  getDefaultPosition() {
    return this.gm.options.settings.controlsPosition;
  }
}
class _R {
  gm;
  globalEventsListener = null;
  constructor(n) {
    this.gm = n;
  }
  get map() {
    return this.gm.mapAdapter.getMapInstance();
  }
  async processEvent(n, l) {
    await this.fireToMap({
      type: "system",
      eventName: n.split(":")[1],
      payload: {
        ...l,
        level: "user"
      }
    }), l.action === "mode_start" || l.action === "mode_end" ? await this.forwardModeToggledEvent(l) : l.action === "feature_created" ? await this.forwardFeatureCreated(l) : l.action === "feature_removed" ? await this.forwardFeatureRemoved(l) : l.action === "feature_updated" ? await this.forwardFeatureUpdated(l) : l.action === "feature_edit_start" ? await this.forwardFeatureEditStart(l) : l.action === "feature_edit_end" ? await this.forwardFeatureEditEnd(l) : (l.action === "loaded" || l.action === "unloaded") && await this.forwardGeomanLoaded(l);
  }
  async forwardModeToggledEvent(n) {
    const l = n.action === "mode_start";
    if (n.actionType === "draw") {
      const p = "globaldrawmodetoggled", x = {
        name: `${Fi}:${p}`,
        actionType: n.actionType,
        action: n.action,
        enabled: l,
        shape: n.mode,
        map: this.map
      };
      await this.fireToMap({ type: "converted", eventName: p, payload: x });
      const M = l ? "drawstart" : "drawend", T = {
        name: `${Fi}:${M}`,
        actionType: n.actionType,
        action: n.action,
        shape: n.mode,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: M,
        payload: T
      });
    } else if (n.actionType === "edit") {
      const p = `global${this.getConvertedEditModeName(n.mode)}modetoggled`, x = {
        name: `${Fi}:${p}`,
        actionType: n.actionType,
        action: n.action,
        enabled: l,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: p,
        payload: x
      });
    } else if (n.actionType === "helper") {
      const p = `global${n.mode}modetoggled`, x = {
        name: `${Fi}:${p}`,
        actionType: n.actionType,
        action: n.action,
        enabled: l,
        map: this.map
      };
      await this.fireToMap({
        type: "converted",
        eventName: p,
        payload: x
      });
    }
  }
  async forwardFeatureCreated(n) {
    const l = {
      name: `${Fi}:create`,
      actionType: n.actionType,
      action: n.action,
      shape: n.mode,
      feature: n.featureData,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: "create", payload: l });
  }
  async forwardFeatureRemoved(n) {
    const l = {
      name: `${Fi}:remove`,
      actionType: n.actionType,
      action: n.action,
      shape: n.mode,
      feature: n.featureData,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: "remove", payload: l });
  }
  async forwardFeatureUpdated(n) {
    const l = this.getConvertedEditModeName(n.mode), p = ["lasso"], x = {
      name: `${Fi}:${l}`,
      actionType: n.actionType,
      action: n.action,
      map: this.map
    };
    n.sourceFeatures.length === 1 && !p.includes(n.mode) ? x.originalFeature = n.sourceFeatures[0] : x.originalFeatures = n.sourceFeatures, n.targetFeatures.length === 1 && !p.includes(n.mode) ? (x.feature = n.targetFeatures[0], x.shape = x.feature.shape) : x.features = n.targetFeatures, await this.fireToMap({ type: "converted", eventName: `${l}`, payload: x });
  }
  async forwardFeatureEditStart(n) {
    const l = this.getConvertedEditModeName(n.mode), p = {
      name: `${Fi}:${l}start`,
      actionType: n.actionType,
      action: n.action,
      shape: n.feature.shape,
      feature: n.feature,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: `${l}start`, payload: p });
  }
  async forwardFeatureEditEnd(n) {
    const l = this.getConvertedEditModeName(n.mode), p = {
      name: `${Fi}:${l}end`,
      actionType: n.actionType,
      action: n.action,
      shape: n.feature.shape,
      feature: n.feature,
      map: this.map
    };
    await this.fireToMap({ type: "converted", eventName: `${l}end`, payload: p });
  }
  async forwardGeomanLoaded(n) {
    const l = {
      name: `${Fi}:${n.action}`,
      actionType: n.actionType,
      action: n.action,
      map: this.map,
      [Fi]: this.gm
    };
    await this.fireToMap({
      type: "converted",
      eventName: `${l.action}`,
      payload: l
    });
  }
  async fireToMap({
    type: n,
    eventName: l,
    payload: p
  }) {
    const x = `${n === "system" ? Ft : Fi}:${l}`;
    if (this.gm.options.settings.awaitDataUpdatesOnEvents && "feature" in p && p.feature?.source) {
      const M = p.feature.source.id;
      await this.gm.features.updateManager.waitForPendingUpdates(M);
    }
    this.globalEventsListener?.(p), this.gm.mapAdapter.fire(x, p);
  }
  getConvertedEditModeName(n) {
    return n === "change" ? "edit" : n;
  }
}
const E2 = (a) => hl(a) && a.name === `${Ft}:control:switch`, hl = (a) => !!(a && typeof a == "object" && ["level", "name", "actionType", "action"].every((n) => n in a)), yR = (a) => !!(a && typeof a == "object" && ["type", "originalEvent", "target"].every((n) => n in a));
class vR {
  gm;
  forwarder;
  mapEventHandlers = {};
  gmEventHandlers = {};
  constructor(n) {
    this.gm = n, this.forwarder = new _R(n);
  }
  // Track pending event forwarding to maintain event ordering
  // Events are processed sequentially to ensure dragstart fires before drag, etc.
  pendingForward = Promise.resolve();
  fireEvent(n, l) {
    const p = this.gmEventHandlers[n];
    if (!p)
      return;
    const { controlHandler: x } = p;
    x(l), this.pendingForward = this.pendingForward.then(
      () => this.forwarder.processEvent(n, l)
    );
  }
  attachEvents(n) {
    ei(n).forEach((l) => {
      const p = n[l];
      p && this.on(l, p);
    });
  }
  detachEvents(n) {
    ei(n).forEach((l) => {
      const p = n[l];
      p && this.off(l, p);
    });
  }
  detachAllEvents() {
    ei(this.gmEventHandlers).forEach((n) => {
      Array.from(this.gmEventHandlers[n]?.handlers || []).forEach((l) => {
        this.off(n, l);
      });
    }), ei(this.mapEventHandlers).forEach((n) => {
      Array.from(this.mapEventHandlers[n]?.handlers || []).forEach((l) => {
        this.off(n, l);
      });
    });
  }
  on(n, l) {
    n.startsWith(Ft) ? this.onGmEvent(n, l) : this.onMapEvent(n, l);
  }
  onGmEvent(n, l) {
    this.gmEventHandlers[n] || (this.gmEventHandlers[n] = this.createEventSection(n)), this.gmEventHandlers[n]?.handlers.unshift(l);
  }
  onMapEvent(n, l) {
    if (!this.mapEventHandlers[n]) {
      const p = this.createEventSection(n);
      this.gm.mapAdapter.on(n, p.controlHandler), this.mapEventHandlers[n] = p;
    }
    this.mapEventHandlers[n]?.handlers.unshift(l);
  }
  off(n, l) {
    n.startsWith(`${Ft}`) ? this.offGmEvent(n, l) : this.offMapEvent(n, l);
  }
  offGmEvent(n, l) {
    const p = this.gmEventHandlers[n]?.handlers || [], x = p.findIndex((M) => l === M);
    x === -1 ? It.warn("MapEvents: handler not found", n, l) : (p.splice(x, 1), p.length === 0 && delete this.gmEventHandlers[n]);
  }
  offMapEvent(n, l) {
    const p = this.mapEventHandlers[n]?.handlers || [], x = p.findIndex((M) => l === M);
    if (x === -1)
      It.warn("MapEvents: handler not found", n, l);
    else if (p.splice(x, 1), p.length === 0) {
      const M = this.mapEventHandlers[n]?.controlHandler;
      M && this.gm.mapAdapter.off(n, M), delete this.mapEventHandlers[n];
    }
  }
  createEventSection(n) {
    return {
      handlers: [],
      controlHandler: (l) => {
        let p;
        if (hl(l) && n.startsWith(`${Ft}`) ? p = this.gmEventHandlers[n] : p = this.mapEventHandlers[n], !p) {
          It.debug(`No handlers for eventName: "${n}"`);
          return;
        }
        p.handlers.some((x) => {
          let M;
          return hl(l) || yR(l) ? M = x(l) : It.error("EventsBus: unknown event type", l), M && typeof M == "object" && "next" in M ? !M.next : (It.error('EventsBus: handler should return an object with a "next" property'), !1);
        });
      }
    };
  }
}
class Kg {
  gm;
  constructor(n) {
    this.gm = n;
  }
  trackExclusiveModes(n) {
    if (n.action !== "mode_start")
      return;
    const { sectionName: l, modeName: p } = this.getControlIds(n) || {};
    this.getControl(n)?.settings.exclusive && this.gm.control.eachControlWithOptions((x) => {
      const M = x.control.type, T = x.control.targetMode;
      M === l && T === p || x.controlOptions.active && x.control.settings.exclusive && this.gm.options.disableMode(M, T);
    });
  }
  trackRelatedModes(n) {
    Ev(n) && this.gm.control.eachControlWithOptions((l) => {
      const p = l.control, { type: x, targetMode: M } = p;
      p.settings.enabledBy?.includes(n.mode) && (n.action === "mode_start" ? (this.gm.options.isModeEnabled(x, M) && this.gm.options.disableMode(x, M), this.gm.options.enableMode(x, M)) : n.action === "mode_end" ? this.gm.options.disableMode(x, M) : It.error("Unknown mode action", n.action));
    });
  }
  getControl(n) {
    const { modeName: l, sectionName: p } = this.getControlIds(n) || {};
    return l && p ? this.gm.control.getControl({ modeType: p, modeName: l }) : null;
  }
  getControlOptions(n) {
    const { modeName: l, sectionName: p } = this.getControlIds(n) || {};
    return l && p ? this.gm.options.getControlOptions({ modeType: p, modeName: l }) : null;
  }
  getControlIds(n) {
    let l = null, p = null;
    return n.action === "mode_start" ? (l = n.actionType, p = n.mode) : E2(n) && (l = n.section, p = n.mode), l && p ? { sectionName: l, modeName: p } : null;
  }
}
class xR extends Kg {
  eventHandlers = {
    [`${Ft}:control`]: this.handleControlEvent.bind(this)
  };
  constructor(n, l) {
    super(n), l.attachEvents(this.eventHandlers);
  }
  handleControlEvent(n) {
    return E2(n) ? (this.getControl(n) || It.error("Control not found, event payload", n), { next: !0 }) : { next: !0 };
  }
}
const bR = ["draw", "edit", "helper"], ol = [
  // shapes
  "marker",
  "circle",
  "circle_marker",
  "ellipse",
  "text_marker",
  "line",
  "rectangle",
  "polygon"
], wR = [
  "dom_marker",
  "vertex_marker",
  "center_marker",
  "edge_marker",
  "snap_guide"
], T2 = [...ol, ...wR], ER = ["freehand", "custom_shape"], S2 = [...ol, ...ER], k2 = [
  "shape_markers",
  "pin",
  "snapping",
  "snap_guides",
  "measurements",
  "auto_trace",
  "geofencing",
  "zoom_to_features",
  "click_to_edit"
], I2 = [
  "drag",
  "change",
  "rotate",
  "scale",
  "copy",
  "cut",
  "split",
  "union",
  "difference",
  "line_simplification",
  "lasso",
  "delete"
], TR = (a) => Array.isArray(a) && a.length === 2 && typeof a[0] == "number" && typeof a[1] == "number", A_ = {
  id: (a) => typeof a == "string" || typeof a == "number",
  shape: (a) => typeof a == "string" && Kl(a, T2),
  center: (a) => TR(a),
  xSemiAxis: (a) => typeof a == "number",
  ySemiAxis: (a) => typeof a == "number",
  angle: (a) => typeof a == "number",
  text: (a) => typeof a == "string",
  disableEdit: (a) => typeof a == "boolean"
};
class lv {
  isMarkerInstanceAvailable() {
    return this.markerInstance ? !0 : (It.error("Marker instance is not available"), !1);
  }
}
var Ri = 63710088e-1, M2 = {
  centimeters: Ri * 100,
  centimetres: Ri * 100,
  degrees: 360 / (2 * Math.PI),
  feet: Ri * 3.28084,
  inches: Ri * 39.37,
  kilometers: Ri / 1e3,
  kilometres: Ri / 1e3,
  meters: Ri,
  metres: Ri,
  miles: Ri / 1609.344,
  millimeters: Ri * 1e3,
  millimetres: Ri * 1e3,
  nauticalmiles: Ri / 1852,
  radians: 1,
  yards: Ri * 1.0936
};
function Ja(a, n, l = {}) {
  const p = { type: "Feature" };
  return (l.id === 0 || l.id) && (p.id = l.id), l.bbox && (p.bbox = l.bbox), p.properties = n || {}, p.geometry = a, p;
}
function Ha(a, n, l = {}) {
  if (!a)
    throw new Error("coordinates is required");
  if (!Array.isArray(a))
    throw new Error("coordinates must be an Array");
  if (a.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Cg(a[0]) || !Cg(a[1]))
    throw new Error("coordinates must contain numbers");
  return Ja({
    type: "Point",
    coordinates: a
  }, n, l);
}
function Ql(a, n, l = {}) {
  for (const p of a) {
    if (p.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (p[p.length - 1].length !== p[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let x = 0; x < p[p.length - 1].length; x++)
      if (p[p.length - 1][x] !== p[0][x])
        throw new Error("First and last Position are not equivalent.");
  }
  return Ja({
    type: "Polygon",
    coordinates: a
  }, n, l);
}
function eu(a, n, l = {}) {
  if (a.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return Ja({
    type: "LineString",
    coordinates: a
  }, n, l);
}
function gi(a, n = {}) {
  const l = { type: "FeatureCollection" };
  return n.id && (l.id = n.id), n.bbox && (l.bbox = n.bbox), l.features = a, l;
}
function SR(a, n, l = {}) {
  return Ja({
    type: "MultiLineString",
    coordinates: a
  }, n, l);
}
function C2(a, n, l = {}) {
  return Ja({
    type: "MultiPolygon",
    coordinates: a
  }, n, l);
}
function uv(a, n = "kilometers") {
  const l = M2[n];
  if (!l)
    throw new Error(n + " units is invalid");
  return a * l;
}
function cv(a, n = "kilometers") {
  const l = M2[n];
  if (!l)
    throw new Error(n + " units is invalid");
  return a / l;
}
function fc(a) {
  return a % (2 * Math.PI) * 180 / Math.PI;
}
function Ni(a) {
  return a % 360 * Math.PI / 180;
}
function P2(a, n = "kilometers", l = "kilometers") {
  if (!(a >= 0))
    throw new Error("length must be a positive number");
  return uv(cv(a, n), l);
}
function Cg(a) {
  return !isNaN(a) && a !== null && !Array.isArray(a);
}
function Qg(a) {
  return a !== null && typeof a == "object" && !Array.isArray(a);
}
function ru(a, n, l) {
  if (a !== null)
    for (var p, x, M, T, u, R, z, U = 0, $ = 0, ee, oe = a.type, ce = oe === "FeatureCollection", me = oe === "Feature", re = ce ? a.features.length : 1, Pe = 0; Pe < re; Pe++) {
      z = ce ? a.features[Pe].geometry : me ? a.geometry : a, ee = z ? z.type === "GeometryCollection" : !1, u = ee ? z.geometries.length : 1;
      for (var _e = 0; _e < u; _e++) {
        var je = 0, Qe = 0;
        if (T = ee ? z.geometries[_e] : z, T !== null) {
          R = T.coordinates;
          var et = T.type;
          switch (U = l && (et === "Polygon" || et === "MultiPolygon") ? 1 : 0, et) {
            case null:
              break;
            case "Point":
              if (n(
                R,
                $,
                Pe,
                je,
                Qe
              ) === !1)
                return !1;
              $++, je++;
              break;
            case "LineString":
            case "MultiPoint":
              for (p = 0; p < R.length; p++) {
                if (n(
                  R[p],
                  $,
                  Pe,
                  je,
                  Qe
                ) === !1)
                  return !1;
                $++, et === "MultiPoint" && je++;
              }
              et === "LineString" && je++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (p = 0; p < R.length; p++) {
                for (x = 0; x < R[p].length - U; x++) {
                  if (n(
                    R[p][x],
                    $,
                    Pe,
                    je,
                    Qe
                  ) === !1)
                    return !1;
                  $++;
                }
                et === "MultiLineString" && je++, et === "Polygon" && Qe++;
              }
              et === "Polygon" && je++;
              break;
            case "MultiPolygon":
              for (p = 0; p < R.length; p++) {
                for (Qe = 0, x = 0; x < R[p].length; x++) {
                  for (M = 0; M < R[p][x].length - U; M++) {
                    if (n(
                      R[p][x][M],
                      $,
                      Pe,
                      je,
                      Qe
                    ) === !1)
                      return !1;
                    $++;
                  }
                  Qe++;
                }
                je++;
              }
              break;
            case "GeometryCollection":
              for (p = 0; p < T.geometries.length; p++)
                if (ru(T.geometries[p], n, l) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function Mo(a, n) {
  if (a.type === "Feature")
    n(a, 0);
  else if (a.type === "FeatureCollection")
    for (var l = 0; l < a.features.length && n(a.features[l], l) !== !1; l++)
      ;
}
function kR(a, n, l) {
  var p = l;
  return Mo(a, function(x, M) {
    M === 0 && l === void 0 ? p = x : p = n(p, x, M);
  }), p;
}
function xc(a, n) {
  var l, p, x, M, T, u, R, z, U, $, ee = 0, oe = a.type === "FeatureCollection", ce = a.type === "Feature", me = oe ? a.features.length : 1;
  for (l = 0; l < me; l++) {
    for (u = oe ? a.features[l].geometry : ce ? a.geometry : a, z = oe ? a.features[l].properties : ce ? a.properties : {}, U = oe ? a.features[l].bbox : ce ? a.bbox : void 0, $ = oe ? a.features[l].id : ce ? a.id : void 0, R = u ? u.type === "GeometryCollection" : !1, T = R ? u.geometries.length : 1, x = 0; x < T; x++) {
      if (M = R ? u.geometries[x] : u, M === null) {
        if (n(
          null,
          ee,
          z,
          U,
          $
        ) === !1)
          return !1;
        continue;
      }
      switch (M.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (n(
            M,
            ee,
            z,
            U,
            $
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (p = 0; p < M.geometries.length; p++)
            if (n(
              M.geometries[p],
              ee,
              z,
              U,
              $
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    ee++;
  }
}
function IR(a, n, l) {
  var p = l;
  return xc(
    a,
    function(x, M, T, u, R) {
      p = n(
        p,
        x,
        M,
        T,
        u,
        R
      );
    }
  ), p;
}
function tu(a, n) {
  xc(a, function(l, p, x, M, T) {
    var u = l === null ? null : l.type;
    switch (u) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return n(
          Ja(l, x, { bbox: M, id: T }),
          p,
          0
        ) === !1 ? !1 : void 0;
    }
    var R;
    switch (u) {
      case "MultiPoint":
        R = "Point";
        break;
      case "MultiLineString":
        R = "LineString";
        break;
      case "MultiPolygon":
        R = "Polygon";
        break;
    }
    for (var z = 0; z < l.coordinates.length; z++) {
      var U = l.coordinates[z], $ = {
        type: R,
        coordinates: U
      };
      if (n(Ja($, x), p, z) === !1)
        return !1;
    }
  });
}
function il(a, n = {}) {
  if (a.bbox != null && n.recompute !== !0)
    return a.bbox;
  const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return ru(a, (p) => {
    l[0] > p[0] && (l[0] = p[0]), l[1] > p[1] && (l[1] = p[1]), l[2] < p[0] && (l[2] = p[0]), l[3] < p[1] && (l[3] = p[1]);
  }), l;
}
var A2 = il;
function ti(a) {
  if (!a)
    throw new Error("coord is required");
  if (!Array.isArray(a)) {
    if (a.type === "Feature" && a.geometry !== null && a.geometry.type === "Point")
      return [...a.geometry.coordinates];
    if (a.type === "Point")
      return [...a.coordinates];
  }
  if (Array.isArray(a) && a.length >= 2 && !Array.isArray(a[0]) && !Array.isArray(a[1]))
    return [...a];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function Ws(a) {
  if (Array.isArray(a))
    return a;
  if (a.type === "Feature") {
    if (a.geometry !== null)
      return a.geometry.coordinates;
  } else if (a.coordinates)
    return a.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function jf(a) {
  return a.type === "Feature" ? a.geometry : a;
}
function G1(a, n) {
  return a.type === "FeatureCollection" ? "FeatureCollection" : a.type === "GeometryCollection" ? "GeometryCollection" : a.type === "Feature" && a.geometry !== null ? a.geometry.type : a.type;
}
function L2(a, n, l, p = {}) {
  const x = ti(a), M = Ni(x[0]), T = Ni(x[1]), u = Ni(l), R = cv(n, p.units), z = Math.asin(
    Math.sin(T) * Math.cos(R) + Math.cos(T) * Math.sin(R) * Math.cos(u)
  ), U = M + Math.atan2(
    Math.sin(u) * Math.sin(R) * Math.cos(T),
    Math.cos(R) - Math.sin(T) * Math.sin(z)
  ), $ = fc(U), ee = fc(z);
  return x[2] !== void 0 ? Ha([$, ee, x[2]], p.properties) : Ha([$, ee], p.properties);
}
function MR(a, n, l = {}) {
  const p = l.steps || 64, x = l.properties ? l.properties : !Array.isArray(a) && a.type === "Feature" && a.properties ? a.properties : {}, M = [];
  for (let T = 0; T < p; T++)
    M.push(
      L2(a, n, T * -360 / p, l).geometry.coordinates
    );
  return M.push(M[0]), Ql([M], x);
}
var CR = MR;
function D2(a, n = {}) {
  let l = 0, p = 0, x = 0;
  return ru(
    a,
    function(M) {
      l += M[0], p += M[1], x++;
    },
    !0
  ), Ha([l / x, p / x], n.properties);
}
var _y = D2;
function PR(a, n, l = {}) {
  let p;
  return l.final ? p = j1(ti(n), ti(a)) : p = j1(ti(a), ti(n)), p > 180 ? -(360 - p) : p;
}
function j1(a, n) {
  const l = Ni(a[1]), p = Ni(n[1]);
  let x = Ni(n[0] - a[0]);
  x > Math.PI && (x -= 2 * Math.PI), x < -Math.PI && (x += 2 * Math.PI);
  const M = Math.log(
    Math.tan(p / 2 + Math.PI / 4) / Math.tan(l / 2 + Math.PI / 4)
  ), T = Math.atan2(x, M);
  return (fc(T) + 360) % 360;
}
function AR(a, n, l = {}) {
  const p = ti(a), x = ti(n);
  x[0] += x[0] - p[0] > 180 ? -360 : p[0] - x[0] > 180 ? 360 : 0;
  const M = LR(p, x);
  return P2(M, "meters", l.units);
}
function LR(a, n, l) {
  l = l === void 0 ? Ri : Number(l);
  const p = l, x = a[1] * Math.PI / 180, M = n[1] * Math.PI / 180, T = M - x;
  let u = Math.abs(n[0] - a[0]) * Math.PI / 180;
  u > Math.PI && (u -= 2 * Math.PI);
  const R = Math.log(
    Math.tan(M / 2 + Math.PI / 4) / Math.tan(x / 2 + Math.PI / 4)
  ), z = Math.abs(R) > 1e-11 ? T / R : Math.cos(x);
  return Math.sqrt(
    T * T + z * z * u * u
  ) * p;
}
function DR(a, n, l, p = {}) {
  const x = n < 0;
  let M = P2(
    Math.abs(n),
    p.units,
    "meters"
  );
  x && (M = -Math.abs(M));
  const T = ti(a), u = RR(
    T,
    M,
    l
  );
  return u[0] += u[0] - T[0] > 180 ? -360 : T[0] - u[0] > 180 ? 360 : 0, Ha(u, p.properties);
}
function RR(a, n, l, p) {
  p = p === void 0 ? Ri : Number(p);
  const x = n / p, M = a[0] * Math.PI / 180, T = Ni(a[1]), u = Ni(l), R = x * Math.cos(u);
  let z = T + R;
  Math.abs(z) > Math.PI / 2 && (z = z > 0 ? Math.PI - z : -Math.PI - z);
  const U = Math.log(
    Math.tan(z / 2 + Math.PI / 4) / Math.tan(T / 2 + Math.PI / 4)
  ), $ = Math.abs(U) > 1e-11 ? R / U : Math.cos(T), ee = x * Math.sin(u) / $;
  return [
    ((M + ee) * 180 / Math.PI + 540) % 360 - 180,
    z * 180 / Math.PI
  ];
}
function em(a) {
  if (!a)
    throw new Error("geojson is required");
  switch (a.type) {
    case "Feature":
      return R2(a);
    case "FeatureCollection":
      return FR(a);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return hv(a);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function R2(a) {
  const n = { type: "Feature" };
  return Object.keys(a).forEach((l) => {
    switch (l) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        n[l] = a[l];
    }
  }), n.properties = F2(a.properties), a.geometry == null ? n.geometry = null : n.geometry = hv(a.geometry), n;
}
function F2(a) {
  const n = {};
  return a && Object.keys(a).forEach((l) => {
    const p = a[l];
    typeof p == "object" ? p === null ? n[l] = null : Array.isArray(p) ? n[l] = p.map((x) => x) : n[l] = F2(p) : n[l] = p;
  }), n;
}
function FR(a) {
  const n = { type: "FeatureCollection" };
  return Object.keys(a).forEach((l) => {
    switch (l) {
      case "type":
      case "features":
        return;
      default:
        n[l] = a[l];
    }
  }), n.features = a.features.map((l) => R2(l)), n;
}
function hv(a) {
  const n = { type: a.type };
  return a.bbox && (n.bbox = a.bbox), a.type === "GeometryCollection" ? (n.geometries = a.geometries.map((l) => hv(l)), n) : (n.coordinates = N2(a.coordinates), n);
}
function N2(a) {
  const n = a;
  return typeof n[0] != "object" ? n.slice() : n.map((l) => N2(l));
}
var NR = em;
function O2(a, n, l) {
  if (l = l || {}, !Qg(l)) throw new Error("options is invalid");
  const p = l.pivot, x = l.mutate;
  if (!a) throw new Error("geojson is required");
  if (n == null || isNaN(n))
    throw new Error("angle is required");
  if (n === 0) return a;
  const M = p ?? D2(a);
  return (x === !1 || x === void 0) && (a = em(a)), ru(a, function(T) {
    const u = PR(M, T) + n, R = AR(M, T), z = Ws(
      DR(M, R, u)
    );
    T[0] = z[0], T[1] = z[1];
  }), a;
}
var OR = O2;
function V1(a, n, l, p) {
  p = p || {};
  let x = p.steps || 64;
  const M = p.units || "kilometers";
  let T = p.angle || 0;
  const u = p.pivot || a, R = p.properties || {};
  if (!a) throw new Error("center is required");
  if (!n) throw new Error("xSemiAxis is required");
  if (!l) throw new Error("ySemiAxis is required");
  if (!Qg(p)) throw new Error("options must be an object");
  if (!Cg(x)) throw new Error("steps must be a number");
  if (!Cg(T)) throw new Error("angle must be a number");
  const z = ti(O2(Ha(ti(a)), T, { pivot: u }));
  T = -90 + T, x = Math.ceil(x / 4);
  const U = [], $ = [], ee = n, oe = l, ce = oe, me = (ee - oe) / (Math.PI / 2), re = (ee + oe) * Math.PI / 4, Pe = 0.5, _e = x;
  let je = 0, Qe = 0;
  for (let Ye = 0; Ye < x; Ye++)
    Qe += je, me === 0 ? je = re / _e / ce : je = (-(me * Qe + ce) + Math.sqrt(Math.pow(me * Qe + ce, 2) - 4 * (Pe * me) * -(re / _e))) / (2 * (Pe * me)), Qe != 0 && U.push(Qe);
  $.push(0);
  for (let Ye = 0; Ye < U.length; Ye++)
    $.push(U[Ye]);
  $.push(Math.PI / 2);
  for (let Ye = 0; Ye < U.length; Ye++)
    $.push(Math.PI - U[U.length - Ye - 1]);
  $.push(Math.PI);
  for (let Ye = 0; Ye < U.length; Ye++)
    $.push(Math.PI + U[Ye]);
  $.push(3 * Math.PI / 2);
  for (let Ye = 0; Ye < U.length; Ye++)
    $.push(2 * Math.PI - U[U.length - Ye - 1]);
  $.push(0);
  const et = [];
  for (const Ye of $) {
    const ot = Math.atan2(oe * Math.sin(Ye), ee * Math.cos(Ye)), Q = Math.sqrt(
      Math.pow(ee, 2) * Math.pow(oe, 2) / (Math.pow(ee * Math.sin(ot), 2) + Math.pow(oe * Math.cos(ot), 2))
    );
    et.push(
      L2(z, Q, T + fc(ot), {
        units: M
      }).geometry.coordinates
    );
  }
  return Ql([et], R);
}
function z2(a, n, l = {}) {
  if (l.final === !0)
    return zR(a, n);
  const p = ti(a), x = ti(n), M = Ni(p[0]), T = Ni(x[0]), u = Ni(p[1]), R = Ni(x[1]), z = Math.sin(T - M) * Math.cos(R), U = Math.cos(u) * Math.sin(R) - Math.sin(u) * Math.cos(R) * Math.cos(T - M);
  return fc(Math.atan2(z, U));
}
function zR(a, n) {
  let l = z2(n, a);
  return l = (l + 180) % 360, l;
}
var Pg = z2;
function Dh(a, n, l = {}) {
  var p = ti(a), x = ti(n), M = Ni(x[1] - p[1]), T = Ni(x[0] - p[0]), u = Ni(p[1]), R = Ni(x[1]), z = Math.pow(Math.sin(M / 2), 2) + Math.pow(Math.sin(T / 2), 2) * Math.cos(u) * Math.cos(R);
  return uv(
    2 * Math.atan2(Math.sqrt(z), Math.sqrt(1 - z)),
    l.units
  );
}
var B2 = Dh;
function yy(a, n = {}) {
  const l = jf(a);
  switch (!n.properties && a.type === "Feature" && (n.properties = a.properties), l.type) {
    case "Polygon":
      return BR(l, n);
    case "MultiPolygon":
      return GR(l, n);
    default:
      throw new Error("invalid poly");
  }
}
function BR(a, n = {}) {
  const l = jf(a).coordinates, p = n.properties ? n.properties : a.type === "Feature" ? a.properties : {};
  return G2(l, p);
}
function GR(a, n = {}) {
  const l = jf(a).coordinates, p = n.properties ? n.properties : a.type === "Feature" ? a.properties : {}, x = [];
  return l.forEach((M) => {
    x.push(G2(M, p));
  }), gi(x);
}
function G2(a, n) {
  return a.length > 1 ? SR(a, n) : eu(a[0], n);
}
const U1 = (a, n) => a[0] === n[0] && a[1] === n[1], j2 = (a) => a.type === "Feature" && a.geometry.type === "LineString", V2 = (a) => a.type === "Feature" && a.geometry.type === "Polygon", U2 = (a) => a.type === "Feature" && a.geometry.type === "MultiPolygon", L_ = (a, n) => ({
  lng: n[0] - a[0],
  lat: n[1] - a[1]
}), Ag = (a) => Array.isArray(a) && a.length >= 2 && a.length <= 3 && a.every((n) => typeof n == "number"), Vf = (a, n, l = !1) => {
  let p = 0;
  const x = ["features", "geometries", "geometry", "coordinates"], M = (T, u, R = !1) => {
    Ag(T) ? (n({ coordinate: T, path: u }, p), p += 1) : Array.isArray(T) ? T.forEach((z, U) => {
      R && l && U === T.length - 1 && Ag(z) || M(z, [...u, U], R);
    }) : typeof T == "object" && T !== null && ei(T).forEach((z) => {
      const U = T[z];
      if (x.includes(z) && U) {
        const $ = "type" in T && T.type, ee = $ === "Polygon" || $ === "MultiPolygon";
        M(U, [...u, z], ee);
      }
    });
  };
  M(a, []);
}, jR = (a, n) => {
  let l = { coordinate: [0, 0], path: [] }, p = -1;
  try {
    Vf(a, (x, M) => {
      if (n[0] === x.coordinate[0] && n[1] === x.coordinate[1])
        throw p = M, l = x, new Error("stop");
    });
  } catch {
    if (l)
      return {
        index: p,
        coordinate: l.coordinate,
        path: l.path
      };
  }
  return null;
}, q2 = (a, n) => {
  let l = 0;
  const p = ["features", "geometries", "geometry", "coordinates"], x = (M, T, u, R) => {
    Ag(M) && Ag(T) ? (n(
      {
        start: { coordinate: [...M], path: u },
        end: { coordinate: [...T], path: R }
      },
      l
    ), l += 1) : Array.isArray(M) ? M.forEach((z, U) => {
      x(
        z,
        M[U + 1],
        [...u, U],
        [...u, U + 1]
      );
    }) : typeof M == "object" && M !== null && ei(M).forEach((z) => {
      const U = M[z];
      p.includes(z) && U && x(U, void 0, [...u, z], []);
    });
  };
  x(a, void 0, [], []);
}, tm = (a, n) => {
  let l = {
    absCoordIndex: -1,
    featureIndex: -1,
    multiFeatureIndex: -1,
    geometryIndex: -1
  };
  try {
    ru(
      a,
      (p, x, M, T, u) => {
        if (p[0] === n[0] && p[1] === n[1])
          throw l = { absCoordIndex: x, featureIndex: M, multiFeatureIndex: T, geometryIndex: u }, new Error("found");
      }
    );
  } catch {
  }
  return l;
}, Sh = (a, n) => {
  const [l, p] = a, [x, M] = n, T = Math.min(l, x), u = Math.min(p, M), R = Math.max(l, x), z = Math.max(p, M);
  return [T, u, R, z];
}, vy = (a, n) => {
  const l = Sh(a, n), p = [l[0], l[1]], x = [l[2], l[3]], M = p[0], T = p[1], u = x[0], R = x[1];
  return {
    type: "Feature",
    properties: {
      shape: "rectangle"
    },
    geometry: {
      type: "Polygon",
      coordinates: [
        [
          [M, T],
          [u, T],
          [u, R],
          [M, R],
          [M, T]
        ]
      ]
    }
  };
}, xy = (a) => [a.geometry.coordinates[0], a.geometry.coordinates[1]], dv = (a) => {
  const n = A2(a);
  return [
    [n[0], n[1]],
    // South-West (min-x, min-y)
    [n[2], n[3]]
    // North-East (max-x, max-y)
  ];
}, D_ = (a) => {
  let n = 0;
  return ru(
    a,
    () => {
      n += 1;
    },
    !0
  ), n;
}, VR = (a) => {
  const n = [];
  return ru(
    a,
    (l) => {
      n.push([l[0], l[1]]);
    },
    !0
  ), n;
}, fv = (a) => {
  const n = VR(a);
  return n.some((l) => !$h(n[0], l));
}, $2 = (a) => {
  let n = null;
  try {
    Vf(a, (l) => {
      throw n = l.coordinate, new Error("found");
    });
  } catch {
    return n;
  }
  return null;
}, gg = (a, n) => Math.sqrt((a[0] - n[0]) ** 2 + (a[1] - n[1]) ** 2), UR = (a, n, l) => {
  const [p, x] = [a[0], a[1]], [M, T] = [n[0], n[1]], [u, R] = [l[0], l[1]], z = M - p, U = T - x, $ = u - p, ee = R - x, oe = $ * z + ee * U, ce = z * z + U * U;
  let me = oe / ce;
  return me = Math.max(0, Math.min(1, me)), [p + me * z, x + me * U];
}, qR = (a, n) => {
  const { absCoordIndex: l } = tm(a, n);
  return l !== -1 ? (a.geometry.coordinates.splice(l, 1), !0) : !1;
}, $R = (a, n) => {
  const l = tm(a, n);
  if (l.absCoordIndex !== -1) {
    const p = [l.geometryIndex], x = Nh(
      a.geometry.coordinates,
      p
    ), M = x.findIndex((T) => $h(T, n));
    return x.length <= 4 ? (a.geometry.coordinates.splice(l.geometryIndex, 1), !0) : (x.splice(M, 1), M === 0 && (x[x.length - 1] = [...x[0]]), !0);
  }
  return !1;
}, ZR = (a, n) => {
  const l = tm(a, n);
  if (l.absCoordIndex !== -1) {
    const p = [
      l.multiFeatureIndex,
      l.geometryIndex
    ], x = Nh(
      a.geometry.coordinates,
      p
    ), M = x.findIndex((T) => $h(T, n));
    if (x.length <= 4) {
      p.pop();
      const T = Nh(
        a.geometry.coordinates,
        l.multiFeatureIndex
      );
      return T.splice(l.geometryIndex, 1), T.length === 0 && a.geometry.coordinates.splice(l.multiFeatureIndex, 1), !0;
    }
    return x.splice(M, 1), M === 0 && (x[x.length - 1] = [...x[0]]), !0;
  }
  return !1;
}, HR = (a, n) => j2(a) ? qR(a, n) : V2(a) ? $R(a, n) : U2(a) ? ZR(a, n) : !1, YR = (a, n = "marker") => ({
  type: "Feature",
  properties: {
    shape: n
  },
  geometry: {
    type: "Point",
    coordinates: a
  }
}), pv = ({
  center: a,
  radius: n,
  steps: l = 80
}) => {
  const p = CR(a, n, {
    steps: l,
    units: "meters"
  });
  return p.geometry.coordinates[0][0] = [...p.geometry.coordinates[0][0]], p;
}, q1 = ({
  center: a,
  xSemiAxisLngLat: n,
  rimLngLat: l
}) => {
  let p = Dh(a, n, { units: "meters" });
  p === 0 && (p = 1);
  const x = Pg(a, n) - 90;
  let M = 0;
  if (l) {
    const T = -x * Math.PI / 180, u = -(Pg(a, l) - 90) * Math.PI / 180, R = Dh(a, l, { units: "meters" }), z = R * Math.cos(u), U = R * Math.sin(u), $ = z * Math.cos(T) + U * Math.sin(T), ee = z * -Math.sin(T) + U * Math.cos(T), oe = $ * $ / (p * p);
    M = Math.abs(ee) / Math.sqrt(1 - oe), isNaN(M) && (M = 0);
  }
  return {
    xSemiAxis: p,
    ySemiAxis: M,
    angle: x
  };
}, Z2 = 80, rm = ({
  center: a,
  xSemiAxis: n,
  ySemiAxis: l,
  angle: p,
  properties: x = {}
}) => {
  const M = {
    steps: Z2,
    angle: p,
    units: "meters"
  };
  if (l === void 0 || l === 0) {
    const u = V1(a, n, 1, M);
    return eu(u.geometry.coordinates[0].slice(0, 41), {
      shape: "line"
    });
  }
  const T = V1(a, n, l, {
    ...M,
    properties: {
      ...x,
      [`${rs}shape`]: "ellipse",
      [`${rs}center`]: a,
      [`${rs}xSemiAxis`]: n,
      [`${rs}ySemiAxis`]: l,
      [`${rs}angle`]: p
    }
  });
  return T.geometry.coordinates[0][0] = [...T.geometry.coordinates[0][0]], T;
}, WR = [
  "circle",
  "ellipse",
  "rectangle"
];
class xf {
  gm;
  id = "no-id";
  parent = null;
  markers;
  source;
  _geoJson = null;
  constructor(n) {
    this.gm = n.gm, this.id = n.id, this.source = n.source, this.parent = n.parent, this.markers = /* @__PURE__ */ new Map();
    const l = {
      ...n.geoJsonShapeFeature,
      properties: {
        ...this.parseExtraProperties(n.geoJsonShapeFeature),
        ...this.parseGmShapeProperties(n.geoJsonShapeFeature)
      }
    };
    if (n.skipSourceUpdate) {
      if (this._geoJson = {
        ...l,
        id: this.id
      }, this.shape === "circle") {
        const p = xy(_y(this._geoJson));
        this._geoJson.properties[`${rs}center`] = p;
      }
    } else
      this.addGeoJson(l);
  }
  get shape() {
    const n = this.getShapeProperty("shape");
    if (typeof n == "string" && Kl(n, T2))
      return n;
    throw new Error(`Wrong shape type: "${n}"`);
  }
  set shape(n) {
    this.setShapeProperty("shape", n);
  }
  get temporary() {
    return this.source.id === wt.temporary;
  }
  get sourceName() {
    return this.source.id;
  }
  getShapeProperty(n, l) {
    const p = l?.properties || this._geoJson?.properties || {}, x = A_[n], M = p[`${rs}${n}`] ?? p[n];
    if (x && x(M))
      return M;
  }
  setShapeProperty(n, l) {
    if (!this._geoJson) {
      It.error("FeatureData.setShapeProperty(): geojson is not set");
      return;
    }
    this._geoJson.properties[`${rs}${n}`] = l, this._updateAllProperties(this._geoJson.properties);
  }
  deleteShapeProperty(n) {
    if (!this._geoJson) {
      It.error("FeatureData.deleteShapeProperty(): geojson is not set");
      return;
    }
    delete this._geoJson.properties[`${rs}${n}`], this._updateAllProperties(this._geoJson.properties);
  }
  parseGmShapeProperties(n) {
    const l = this.getShapeProperty("shape", n) || this.gm.features.getFeatureShapeByGeoJson(n);
    l || It.error(`FeatureData.importGmShapeProperties(): unknown shape: ${l}`);
    const p = {
      ...Object.fromEntries(
        ei(A_).map((x) => [x, this.getShapeProperty(x, n)])
      ),
      id: this.id,
      shape: l || void 0
    };
    return Object.fromEntries(
      ei(p).filter((x) => p[x] !== void 0).map((x) => [`${rs}${x}`, p[x]])
    );
  }
  parseExtraProperties(n) {
    const l = Js(n.properties) || {};
    return ei(A_).forEach((p) => {
      delete l[p], delete l[`${rs}${p}`];
    }), l;
  }
  getGeoJson() {
    if (this._geoJson)
      return this._geoJson;
    throw new Error(`Missing GeoJSON for feature: "${this.shape}:${this.id}"`);
  }
  addGeoJson(n) {
    if (this._geoJson = {
      ...n,
      id: this.id
    }, this.shape === "circle") {
      const l = xy(_y(this._geoJson));
      this._geoJson.properties[`${rs}center`] = l;
    }
    this.gm.features.updateManager.updateSource({
      diff: { add: [this._geoJson] },
      sourceName: this.sourceName
    });
  }
  removeGeoJson() {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    this.gm.features.updateManager.updateSource({
      diff: { remove: [this.id] },
      sourceName: this.sourceName
    });
  }
  removeMarkers() {
    this.markers.forEach((n) => {
      n.instance instanceof lv ? n.instance.remove() : this.gm.features.delete(n.instance);
    }), this.markers = /* @__PURE__ */ new Map();
  }
  /**
   * Updates the geometry of this feature.
   *
   * @param geometry - The new geometry for the feature
   *
   * @example
   * // Update a marker's position
   * feature.updateGeometry({ type: 'Point', coordinates: [10, 52] });
   *
   * // Update a polygon's coordinates
   * feature.updateGeometry({
   *   type: 'Polygon',
   *   coordinates: [[[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]]
   * });
   */
  updateGeometry(n) {
    const l = this.getGeoJson();
    if (!l)
      throw new Error(`Feature not found: "${this.id}"`);
    this._geoJson = { ...l, geometry: n };
    const p = {
      update: [this._geoJson]
    };
    this.gm.features.updateManager.updateSource({
      diff: p,
      sourceName: this.sourceName
    });
  }
  /**
   * @deprecated Use `updateGeometry()` instead.
   */
  updateGeoJsonGeometry(n) {
    this.updateGeometry(n);
  }
  /**
   * Updates custom properties on this feature. Properties are merged with existing ones.
   * Set a property value to `undefined` to delete it.
   *
   * Internal Geoman properties (prefixed with `gm_`) cannot be modified through this method
   * and will be preserved.
   *
   * @param properties - Object containing properties to update or delete (set to undefined)
   *
   * @example
   * // Add or update properties
   * feature.updateProperties({ color: 'red', size: 10 });
   *
   * // Delete a property
   * feature.updateProperties({ color: undefined });
   *
   * // Mix of updates and deletions
   * feature.updateProperties({ color: 'blue', oldProp: undefined });
   */
  updateProperties(n) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    const l = this.parseGmShapeProperties(this._geoJson), p = new Set(Object.keys(l)), x = {};
    for (const [u, R] of Object.entries(this._geoJson.properties))
      u in n || (x[u] = R);
    for (const [u, R] of Object.entries(n))
      p.has(u) || R !== void 0 && (x[u] = R);
    Object.assign(x, l), this._geoJson.properties = x;
    const M = { ...x };
    for (const [u, R] of Object.entries(n))
      p.has(u) || R === void 0 && (M[u] = void 0);
    const T = { update: [{ ...this._geoJson, properties: M }] };
    this.gm.features.updateManager.updateSource({
      diff: T,
      sourceName: this.sourceName
    });
  }
  /**
   * Replaces all custom properties on this feature. Existing custom properties are removed
   * and replaced with the provided ones.
   *
   * Internal Geoman properties (prefixed with `gm_`) cannot be modified and will be preserved.
   *
   * @param properties - Object containing the new properties (replaces all existing custom properties)
   *
   * @example
   * // Replace all custom properties
   * feature.setProperties({ name: 'New Feature', category: 'poi' });
   */
  setProperties(n) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    const l = this.parseGmShapeProperties(this._geoJson), p = {};
    for (const [M, T] of Object.entries(n))
      T !== void 0 && !(M in l) && (p[M] = T);
    this._geoJson.properties = {
      ...p,
      ...l
    };
    const x = { update: [this._geoJson] };
    this.gm.features.updateManager.updateSource({
      diff: x,
      sourceName: this.sourceName
    });
  }
  /**
   * Internal method to update all properties including Geoman system properties.
   * This should only be used by internal Geoman code (edit modes, draw modes, etc.).
   *
   * @internal
   * @param properties - Properties to merge with existing ones
   */
  _updateAllProperties(n) {
    if (!this._geoJson)
      throw new Error(`Feature not found: "${this.id}"`);
    this._geoJson.properties = { ...this._geoJson.properties, ...n };
    const l = { update: [this._geoJson] };
    this.gm.features.updateManager.updateSource({
      diff: l,
      sourceName: this.sourceName
    });
  }
  /**
   * @deprecated Use `updateProperties()` instead. Set property value to `undefined` to delete it.
   */
  updateGeoJsonProperties(n) {
    this._updateAllProperties(n);
  }
  /**
   * @deprecated Use `setProperties()` instead.
   */
  setGeoJsonCustomProperties(n) {
    this.setProperties(n || {});
  }
  /**
   * @deprecated Use `updateProperties()` instead.
   */
  updateGeoJsonCustomProperties(n) {
    this.updateProperties(n || {});
  }
  /**
   * @deprecated Use `updateProperties({ propName: undefined })` instead.
   */
  deleteGeoJsonCustomProperties(n) {
    const l = {};
    for (const p of n)
      l[p] = void 0;
    this.updateProperties(l);
  }
  convertToPolygon() {
    return this.isConvertableToPolygon() ? (this.shape = "polygon", this.deleteShapeProperty("center"), this.deleteShapeProperty("angle"), this.deleteShapeProperty("xSemiAxis"), this.deleteShapeProperty("ySemiAxis"), !0) : !1;
  }
  isConvertableToPolygon() {
    return WR.includes(this.shape);
  }
  // changeSource({ sourceName, atomic }: { sourceName: FeatureSourceName; atomic: boolean }) {
  //   if (atomic) {
  //     this.gm.features.updateManager.withAtomicSourcesUpdate(() =>
  //       this.actualChangeSource({ sourceName, atomic }),
  //     );
  //   } else {
  //     this.actualChangeSource({ sourceName, atomic });
  //   }
  // }
  changeSource({ sourceName: n, atomic: l }) {
    if (this.source.id === n) {
      It.error(
        `FeatureData.changeSource: feature "${this.id}" already has the source "${n}"`
      );
      return;
    }
    const p = this.gm.features.sources[n];
    if (!p) {
      It.error(`FeatureData.changeSource: missing source "${n}"`);
      return;
    }
    const x = this.getGeoJson();
    if (!x) {
      It.error("FeatureData.changeSource: missing shape GeoJSON");
      return;
    }
    this.removeGeoJson(), this.source = p, this.addGeoJson(x), this.markers.forEach((M) => {
      M.instance instanceof xf && M.instance.changeSource({ sourceName: n, atomic: l });
    });
  }
  fireFeatureUpdatedEvent({ mode: n }) {
    const l = {
      name: `${Ft}:edit:feature_updated`,
      level: "system",
      actionType: "edit",
      action: "feature_updated",
      mode: n,
      sourceFeatures: [this],
      targetFeatures: [this],
      markerData: null
    };
    this.gm.events.fire(`${Ft}:edit`, l);
  }
  delete() {
    this.removeGeoJson(), this.removeMarkers();
  }
}
const gv = (a) => hl(a) && a.actionType === "helper", XR = (a) => hl(a) && a.name === `${Ft}:helper:geofencing_violation`;
class mv {
  gm;
  options = {};
  settings = {};
  actions = {};
  flags = {
    featureCreateAllowed: !0,
    featureUpdateAllowed: !0,
    actionInProgress: !1
  };
  internalEventHandlers = {
    [`${Ft}:helper`]: this.handleHelperEvent.bind(this)
  };
  constructor(n) {
    this.gm = n;
  }
  get snappingHelper() {
    return this.gm.actionInstances.helper__snapping || null;
  }
  startAction() {
    this.gm.events.bus.attachEvents(this.internalEventHandlers), this.gm.events.bus.attachEvents(this.eventHandlers), this.onStartAction();
  }
  endAction() {
    this.onEndAction(), this.gm.events.bus.detachEvents(this.eventHandlers), this.gm.events.bus.detachEvents(this.internalEventHandlers);
  }
  getOptionValue(n) {
    const l = this.options[n];
    if (!l)
      throw new Error(`Option ${n} not found`);
    if (["toggle", "hidden"].includes(l.type))
      return l.value;
    if (l.type === "select")
      return l.value.value;
    throw new Error(`Unknown option type: ${JSON.stringify(l)}`);
  }
  getSettingValue(n) {
    if (n in this.settings)
      return this.settings[n];
  }
  applyOptionValue(n, l) {
    const p = this.options[n];
    if (!p) {
      It.error("Option not found", n, l);
      return;
    }
    if (p.type === "toggle" && typeof l == "boolean")
      p.value = l;
    else if (p.type === "select") {
      const x = p.choices.find((M) => M.value === l);
      x && (p.value = x);
    } else p.type === "hidden" ? p.value = l : It.error("Can't apply option value", n, l, p);
  }
  handleHelperEvent(n) {
    return XR(n) ? this.handleGeofencingViolationEvent(n) : { next: !0 };
  }
  handleGeofencingViolationEvent(n) {
    return n.actionType === "draw" ? this.flags.featureCreateAllowed = !1 : n.actionType === "edit" && (this.flags.featureUpdateAllowed = !1), { next: !0 };
  }
}
const _v = (a) => hl(a) && a.actionType === "draw", JR = (a) => hl(a) && (a.name === `${Ft}:draw:shape` || a.name === `${Ft}:draw:shape_with_data`), H2 = (a) => JR(a) && a.variant === "line_drawer";
class _l extends mv {
  actionType = "draw";
  shape = null;
  featureData = null;
  saveFeature() {
    if (this.featureData) {
      const n = this.featureData.getGeoJson();
      this.removeTmpFeature(), this.gm.features.createFeature({
        sourceName: wt.main,
        shapeGeoJson: n
      });
    } else
      It.error("BaseDraw.saveFeature: no featureData to save");
  }
  removeTmpFeature() {
    this.featureData && (this.featureData.temporary || It.error("Not a temporary feature to remove", this.featureData), this.gm.features.delete(this.featureData), this.featureData = null);
  }
  fireBeforeFeatureCreate({
    geoJsonFeatures: n,
    forceMode: l = void 0
  }) {
    this.flags.featureCreateAllowed = !0;
    const p = {
      name: `${Ft}:feature:before_create`,
      level: "system",
      actionType: "draw",
      mode: l || this.mode,
      action: "before_create",
      geoJsonFeatures: n
    };
    this.gm.events.fire(`${Ft}:${this.actionType}`, p);
  }
  fireMarkerPointerStartEvent() {
    if (!this.gm.markerPointer.marker || !this.shape)
      return;
    const n = this.gm.markerPointer.marker, l = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "start",
      markerData: {
        type: "dom",
        instance: n,
        position: {
          coordinate: n.getLngLat(),
          path: [-1]
        }
      },
      featureData: this.featureData
    };
    this.gm.events.fire(`${Ft}:draw`, l);
  }
  fireMarkerPointerUpdateEvent() {
    if (!this.gm.markerPointer.marker || !this.shape)
      return;
    const n = this.gm.markerPointer.marker, l = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "update",
      markerData: {
        type: "dom",
        instance: n,
        position: {
          coordinate: n.getLngLat(),
          path: [-1]
        }
      },
      featureData: this.featureData
    };
    this.gm.events.fire(`${Ft}:draw`, l);
  }
  fireMarkerPointerFinishEvent() {
    if (!this.shape)
      return;
    const n = {
      name: `${Ft}:draw:shape`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.shape,
      action: "finish"
    };
    this.gm.events.fire(`${Ft}:draw`, n);
  }
  forwardLineDrawerEvent(n) {
    if (!H2(n) || !this.shape)
      return { next: !0 };
    if (n.action === "start" || n.action === "update") {
      const l = {
        name: `${Ft}:draw:shape_with_data`,
        level: "system",
        actionType: "draw",
        mode: this.shape,
        variant: null,
        action: n.action,
        featureData: n.featureData,
        markerData: n.markerData
      };
      this.gm.events.fire(`${Ft}:draw`, l);
    } else if (n.action === "finish" || n.action === "cancel") {
      const l = {
        name: `${Ft}:draw:shape`,
        level: "system",
        actionType: "draw",
        mode: this.shape,
        variant: null,
        action: n.action
      };
      this.gm.events.fire(`${Ft}:draw`, l);
    }
    return { next: !0 };
  }
  fireStartEvent(n, l = null) {
    if (!this.shape)
      return;
    const p = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "start",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ft}:draw`, p);
  }
  fireUpdateEvent(n, l = null) {
    if (!this.shape)
      return;
    const p = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "update",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ft}:draw`, p);
  }
  fireFinishEvent() {
    if (!this.shape)
      return;
    const n = {
      name: `${Ft}:draw:shape`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "finish"
    };
    this.gm.events.fire(`${Ft}:draw`, n);
  }
}
class yv extends _l {
  mode = "circle";
  shape = "circle";
  eventHandlers = {
    mousemove: this.onMouseMove.bind(this),
    click: this.onMouseClick.bind(this)
  };
  circleCenterPoint = null;
  circleCenterLngLat = null;
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.removeTmpFeature(), this.gm.markerPointer.disable(), this.fireFinishEvent();
  }
  getFeatureGeoJson(n) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "Point",
        coordinates: n
      }
    };
  }
  getControlMarkerData() {
    const n = this.gm.markerPointer.marker;
    return n ? {
      type: "dom",
      instance: n,
      position: {
        coordinate: n.getLngLat(),
        path: [-1]
      }
    } : null;
  }
  createFeature() {
    const n = this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(this.circleCenterLngLat || [0, 0]),
      sourceName: wt.temporary
    });
    return n && this.circleCenterLngLat && n.setShapeProperty("center", this.circleCenterLngLat), n;
  }
  createMarker() {
    const n = document.createElement("div");
    n.innerHTML = Vb;
    const l = n.firstChild;
    return l.style.color = "#278cda", l.style.width = "28px", l.style.height = "28px", l.style.pointerEvents = "none", this.gm.mapAdapter.createDomMarker(
      {
        draggable: !1,
        anchor: "center",
        element: l
      },
      [0, 0]
    );
  }
}
class KR extends yv {
  mode = "circle_marker";
  shape = "circle_marker";
  onStartAction() {
    this.gm.markerPointer.enable({
      customMarker: this.createMarker()
    });
  }
  onEndAction() {
    this.fireMarkerPointerFinishEvent(), super.onEndAction();
  }
  onMouseMove() {
    return this.fireMarkerPointerUpdateEvent(), { next: !0 };
  }
  onMouseClick(n) {
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    return this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(l)] }), this.flags.featureCreateAllowed && (this.featureData = this.createFeature(), this.circleCenterLngLat = l, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.updateFeaturePosition(this.circleCenterLngLat), this.saveFeature()), { next: !1 };
  }
  updateFeaturePosition(n) {
    if (!this.featureData)
      return;
    const l = this.getFeatureGeoJson(n);
    this.featureData.updateGeoJsonGeometry(l.geometry);
  }
}
const QR = () => window.PointerEvent && "maxTouchPoints" in navigator ? navigator.maxTouchPoints > 0 ? !window.matchMedia("(hover: hover)").matches : !1 : matchMedia("(hover: none)").matches || "ontouchstart" in window ? !0 : "msMaxTouchPoints" in navigator && typeof navigator.msMaxTouchPoints == "number" && navigator.msMaxTouchPoints > 0, bc = (a, n, l = 10) => {
  const p = { ...a };
  return ei(a).forEach((x) => {
    const M = a[x];
    typeof M == "function" ? p[x] = xw(M.bind(n), l, {
      leading: !0,
      trailing: !1
    }) : It.error("convertToThrottled: item is not a function", a[x]);
  }), p;
}, eF = (a, n, l = 10) => {
  const p = { ...a };
  return ei(a).forEach((x) => {
    const M = a[x];
    typeof M == "function" ? p[x] = yw(M.bind(n), l, {
      leading: !1,
      trailing: !0
    }) : It.error("convertToDebounced: item is not a function", a[x]);
  }), p;
}, $1 = async (a, n) => {
  const l = "Promise race timeout";
  await Promise.race([
    a,
    new Promise((p, x) => {
      setTimeout(
        () => x(
          new Error(
            `Timeout ${Nx / 1e3} seconds: ${n || l}`
          )
        ),
        Nx
      );
    })
  ]);
}, tF = [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchmove",
  "touchcancel"
], rF = (a) => !!(a && typeof a == "object" && "once" in a && typeof a.once == "function"), Yn = (a, n = { warning: !1 }) => {
  if (!a)
    return n.warning && It.warn("Empty event", a), !1;
  const l = typeof a == "object" && "lngLat" in a && "point" in a && "type" in a && "originalEvent" in a && typeof a.type == "string" && tF.includes(a.type);
  return !l && n.warning && It.warn("Not a pointer event", a), l;
}, nF = (a) => a.originalEvent.ctrlKey || a.originalEvent.shiftKey || a.originalEvent.altKey || a.originalEvent.metaKey, iF = (a) => {
  const n = ["symbol", "fill", "line", "circle"];
  return !!a && typeof a == "object" && "type" in a && n.includes(a.type);
};
class sF extends yv {
  mode = "circle";
  shape = "circle";
  throttledMethods = bc(
    {
      updateFeatureGeoJson: this.updateFeatureGeoJson
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  onMouseClick(n) {
    if (!Yn(n))
      return { next: !0 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    if (this.circleCenterPoint && this.circleCenterLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getCircleGeoJson(this.circleCenterLngLat, l)]
      }), this.flags.featureCreateAllowed && (this.saveCircleFeature(l), this.circleCenterLngLat = null, this.circleCenterPoint = null, this.fireFinishEvent());
    else if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(l)] }), this.flags.featureCreateAllowed) {
      this.circleCenterLngLat = l, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.featureData = this.createFeature();
      const p = this.getControlMarkerData();
      this.featureData && p && this.fireStartEvent(this.featureData, p);
    }
    return { next: !1 };
  }
  onMouseMove() {
    if (this.circleCenterLngLat && this.gm.markerPointer.marker) {
      const n = this.gm.markerPointer.marker.getLngLat();
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getCircleGeoJson(this.circleCenterLngLat, n)]
      }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeatureGeoJson(n);
    }
    return this.circleCenterPoint || this.fireMarkerPointerUpdateEvent(), { next: !1 };
  }
  updateFeatureGeoJson(n) {
    if (this.featureData && this.circleCenterLngLat) {
      const l = this.getCircleGeoJson(this.circleCenterLngLat, n);
      this.featureData.updateGeoJsonGeometry(l.geometry);
      const p = this.getControlMarkerData();
      p && this.fireUpdateEvent(this.featureData, p);
    }
  }
  saveCircleFeature(n) {
    if (this.circleCenterLngLat && this.featureData) {
      const l = this.gm.markerPointer.marker?.getLngLat() || n;
      this.updateFeatureGeoJson(l), this.featureData.setShapeProperty("center", this.circleCenterLngLat), this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature();
    }
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? fv(this.featureData.getGeoJson()) : !1;
  }
  getCircleGeoJson(n, l) {
    const p = this.gm.mapAdapter.getDistance(n, l);
    return {
      ...pv({ center: n, radius: p }),
      properties: {
        shape: this.shape
      }
    };
  }
}
class nu extends mv {
  actionType = "helper";
}
const Y2 = (a) => !!a && typeof a == "object" && a instanceof nu && "removeSnapGuides" in a && "updateSnapGuides" in a && a.mode === "snap_guides" && typeof a.removeSnapGuides == "function" && typeof a.updateSnapGuides == "function", aF = (a) => !!a && typeof a == "object" && a instanceof nu && "getShortestPath" in a && a.mode === "auto_trace" && typeof a.getShortestPath == "function", oF = (a) => !!a && typeof a == "object" && a instanceof nu && "getSharedMarkers" in a && a.mode === "pin" && typeof a.getSharedMarkers == "function";
function lF(a, n = {}) {
  var l, p, x, M = n.properties, T = (l = n.autoComplete) != null ? l : !0, u = (p = n.orderCoords) != null ? p : !0, R = (x = n.mutate) != null ? x : !1;
  switch (R || (a = em(a)), a.type) {
    case "FeatureCollection":
      var z = [];
      return a.features.forEach(function(U) {
        z.push(
          Ws(Z1(U, {}, T, u))
        );
      }), C2(z, M);
    default:
      return Z1(a, M, T, u);
  }
}
function Z1(a, n, l, p) {
  n = n || (a.type === "Feature" ? a.properties : {});
  var x = jf(a), M = x.coordinates, T = x.type;
  if (!M.length) throw new Error("line must contain coordinates");
  switch (T) {
    case "LineString":
      return l && (M = H1(M)), Ql([M], n);
    case "MultiLineString":
      var u = [], R = 0;
      return M.forEach(function(z) {
        if (l && (z = H1(z)), p) {
          var U = uF(il(eu(z)));
          U > R ? (u.unshift(z), R = U) : u.push(z);
        } else
          u.push(z);
      }), Ql(u, n);
    default:
      throw new Error("geometry type " + T + " is not supported");
  }
}
function H1(a) {
  var n = a[0], l = n[0], p = n[1], x = a[a.length - 1], M = x[0], T = x[1];
  return (l !== M || p !== T) && a.push(n), a;
}
function uF(a) {
  var n = a[0], l = a[1], p = a[2], x = a[3];
  return Math.abs(n - p) * Math.abs(l - x);
}
var vv = lF;
class xv extends _l {
  mode = "line";
  snappingKey = "line_drawer";
  drawOptions;
  shapeLngLats = [];
  throttledMethods = bc(
    {
      onMouseMove: this.onMouseMove
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  eventHandlers = {
    [`${Ft}:helper`]: this.handleGmHelperEvent.bind(this),
    click: this.onMouseClick.bind(this),
    mousemove: this.throttledMethods.onMouseMove.bind(this)
  };
  drawerEventHandlers = {
    firstMarkerClick: null,
    lastMarkerClick: null,
    nMarkerClick: null
  };
  constructor(n, l = {
    snappingMarkers: "none",
    targetShape: "line"
  }) {
    super(n), this.drawOptions = l;
  }
  get snapGuidesInstance() {
    const n = this.gm.actionInstances.helper__snap_guides;
    return Y2(n) ? n : null;
  }
  get autoTraceEnabled() {
    return this.gm.options.controls.helper.auto_trace?.active || !1;
  }
  get autoTraceHelperInstance() {
    return this.autoTraceEnabled && Object.values(this.gm.actionInstances).find(aF) || null;
  }
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.endShape(), this.snapGuidesInstance?.removeSnapGuides(), this.clearDrawerHandlers();
  }
  clearDrawerHandlers() {
    this.drawerEventHandlers.firstMarkerClick = null, this.drawerEventHandlers.lastMarkerClick = null, this.drawerEventHandlers.nMarkerClick = null;
  }
  handleGmHelperEvent(n) {
    return gv(n) ? (n.mode === "snap_guides" && n.action === "mode_start" && this.updateSnapGuides(), { next: !0 }) : (It.error("LineDrawer.handleGmHelperEvent: invalid event", n), { next: !0 });
  }
  updateSnapGuides() {
    if (this.snapGuidesInstance) {
      const n = this.featureData?.getGeoJson();
      n && n.geometry.coordinates.pop(), this.snapGuidesInstance.updateSnapGuides(
        n || null,
        this.shapeLngLats.at(-1) || null,
        !0
      );
    }
  }
  on(n, l) {
    this.drawerEventHandlers[n] = l;
  }
  onMouseClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !0 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    if (this.featureData) {
      const p = this.getClickedMarkerInfo(n);
      this.handleNextVertex(l, p);
    } else this.isFeatureAllowed(YR(l)) && this.startShape(l);
    return this.updateSnapGuides(), { next: !0 };
  }
  handleNextVertex(n, l) {
    if (!this.featureData) {
      It.error("LineDrawer.handleNextVertex: no featureData");
      return;
    }
    const p = this.featureData.markers.size, x = this.getMarkerClickEventData(l.index);
    l.index < p - 1 && this.addPoint(n, l), l.index !== -1 && (l.index === 0 ? this.drawerEventHandlers.firstMarkerClick?.(x) : l.index > 0 && l.index === p - 1 && this.drawerEventHandlers.lastMarkerClick?.(x), l.index >= 0 && this.drawerEventHandlers.nMarkerClick?.(x));
  }
  getMarkerClickEventData(n) {
    const l = this.getFeatureGeoJson({ withControlMarker: !1 });
    return {
      markerIndex: n,
      shapeCoordinates: this.getShapeCoordinates({ withControlMarker: !1 }),
      geoJson: l,
      bounds: dv(l)
    };
  }
  onMouseMove(n) {
    return Yn(n, { warning: !0 }) ? (this.featureData && this.shapeLngLats.length && this.updateFeatureSource(), { next: !0 }) : { next: !0 };
  }
  startShape(n) {
    this.shapeLngLats = [n], this.featureData = this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson({ withControlMarker: !0 }),
      sourceName: wt.temporary
    });
    const l = {
      type: "dom",
      instance: this.createMarker(n),
      position: {
        coordinate: n,
        path: ["geometry", "coordinates", 0]
      }
    };
    this.featureData && (this.featureData.markers.set(l.position.path.join("."), l), this.setSnapping(), this.fireStartEvent(this.featureData, l)), this.gm.mapAdapter.disableMapInteractions(["doubleClickZoom"]);
  }
  endShape() {
    const n = this.getFeatureGeoJson({ withControlMarker: !1 });
    this.removeSnapping(), this.removeTmpFeature(), this.shapeLngLats = [], this.gm.mapAdapter.enableMapInteractions(["doubleClickZoom"]), this.fireStopEvent(n);
  }
  setSnapping() {
    if (!this.snappingHelper)
      return;
    const n = this.drawOptions.snappingMarkers;
    n === "none" ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, []) : n === "all" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, this.shapeLngLats) : n === "first" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, [this.shapeLngLats[0]]) : n === "last" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, [
      this.shapeLngLats[this.shapeLngLats.length - 1]
    ]) : It.error("LineDrawer.setSnapping: invalid data", n, this.shapeLngLats);
  }
  removeSnapping() {
    this.snappingHelper && this.snappingHelper.clearCustomSnappingCoordinates(this.snappingKey);
  }
  getClickedMarkerInfo(n) {
    if (!this.featureData)
      return { index: -1, path: null };
    let l = 0, p = null;
    try {
      this.featureData.markers.forEach((x, M) => {
        if (x.instance instanceof lv) {
          const T = x.instance.getElement() || null, u = n.originalEvent.target, R = u instanceof Element ? u : null;
          if (T && T.contains(R))
            throw p = M, new Error("stop");
        }
        l += 1;
      });
    } catch {
      if (p)
        return { index: l, path: p };
    }
    return { index: -1, path: null };
  }
  addPoint(n, l) {
    const p = this.featureData;
    if (!p) {
      It.error("LineDrawer.addPoint: no featureData");
      return;
    }
    const x = this.getAddedLngLats(n, l), M = this.getFeatureGeoJsonWithType({
      withControlMarker: !0,
      coordinates: this.shapeLngLats.concat(x)
    });
    this.isFeatureAllowed(M) && (x.forEach((T) => {
      this.shapeLngLats.push(T);
      const u = this.addMarker(T, p);
      this.fireUpdateEvent(p, u);
    }), this.updateFeatureSource());
  }
  isFeatureAllowed(n) {
    return this.gm.getActiveDrawModes().length ? (this.fireBeforeFeatureCreate({ geoJsonFeatures: [n] }), this.flags.featureCreateAllowed) : !0;
  }
  getAddedLngLats(n, l) {
    if (!this.featureData)
      return It.error("LineDrawer.getCurrentLngLats: no featureData"), [];
    const p = this.getMarkerInfoLngLat(l) || n;
    return [...this.getAutoTracePath(p)?.slice(1, -1) || [], p];
  }
  getAutoTracePath(n) {
    const l = this.shapeLngLats.at(-1);
    return this.autoTraceEnabled && this.autoTraceHelperInstance && l && this.autoTraceHelperInstance.getShortestPath(l, n) || null;
  }
  getMarkerInfoLngLat(n) {
    if (this.featureData && n.path) {
      const l = this.featureData.markers.get(n.path);
      if (l && l.type === "dom")
        return l.instance.getLngLat();
      It.error("LineDrawer.addPoint: no markerData", n);
    }
    return null;
  }
  addMarker(n, l) {
    const p = {
      type: "dom",
      instance: this.createMarker(n),
      position: {
        coordinate: n,
        path: ["geometry", "coordinates", this.shapeLngLats.length]
      }
    };
    return l.markers.set(p.position.path.join("."), {
      type: "dom",
      instance: p.instance,
      position: {
        coordinate: n,
        path: []
      }
    }), p;
  }
  createMarker(n) {
    return this.gm.mapAdapter.createDomMarker(
      {
        element: this.gm.createSvgMarkerElement("control", {
          pointerEvents: "auto",
          cursor: "pointer"
        }),
        anchor: "center"
      },
      n
    );
  }
  updateFeatureSource() {
    if (this.featureData && (this.featureData.updateGeoJsonGeometry(
      this.getFeatureGeoJson({ withControlMarker: !0 }).geometry
    ), this.gm.markerPointer.marker)) {
      const n = {
        type: "dom",
        instance: this.gm.markerPointer.marker,
        position: {
          coordinate: this.gm.markerPointer.marker.getLngLat(),
          path: ["geometry", "coordinates", this.shapeLngLats.length]
        }
      };
      this.fireUpdateEvent(this.featureData, n);
    }
  }
  getFeatureGeoJson({
    withControlMarker: n,
    coordinates: l = void 0
  }) {
    return {
      type: "Feature",
      properties: {
        shape: "line"
      },
      geometry: {
        type: "LineString",
        coordinates: l || this.getShapeCoordinates({ withControlMarker: n })
      }
    };
  }
  getFeatureGeoJsonWithType({
    withControlMarker: n,
    coordinates: l = void 0
  }) {
    const p = this.getFeatureGeoJson({ withControlMarker: n, coordinates: l });
    return this.drawOptions.targetShape === "polygon" && p.geometry.coordinates.length > 3 ? vv(p, {
      properties: p.properties
    }) : p;
  }
  getShapeCoordinates({ withControlMarker: n }) {
    const l = [...this.shapeLngLats];
    return n && this.gm.markerPointer.marker && l.push(this.gm.markerPointer.marker.getLngLat()), l;
  }
  fireStartEvent(n, l) {
    const p = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      variant: "line_drawer",
      action: "start",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ft}:draw`, p);
  }
  fireUpdateEvent(n, l) {
    const p = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      variant: "line_drawer",
      action: "update",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ft}:draw`, p);
  }
  fireStopEvent(n) {
    const l = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: "line",
      action: "finish",
      variant: "line_drawer",
      geoJsonFeature: n,
      markerData: null,
      featureData: null
    };
    this.gm.events.fire(`${Ft}:draw`, l);
  }
}
class cF extends _l {
  mode = "line";
  shape = "line";
  lineDrawer = new xv(this.gm, { snappingMarkers: "first", targetShape: "line" });
  eventHandlers = {
    [`${Ft}:draw`]: this.forwardLineDrawerEvent.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("nMarkerClick", this.lineFinished.bind(this));
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onMouseMove(n) {
    return Yn(n) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  lineFinished(n) {
    this.lineDrawer.endShape();
    let l = n.shapeCoordinates;
    return n.markerIndex > 0 && (l = l.slice(0, n.markerIndex + 1)), l.length < 2 ? null : this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(l),
      sourceName: wt.main
    });
  }
  getFeatureGeoJson(n) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "LineString",
        coordinates: n
      }
    };
  }
}
class hF extends _l {
  mode = "marker";
  shape = "marker";
  eventHandlers = {
    click: this.onMouseClick.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onStartAction() {
    const n = this.createMarker();
    this.gm.markerPointer.enable({ customMarker: n }), this.fireMarkerPointerStartEvent();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent();
  }
  onMouseClick(n) {
    return Yn(n) && (this.featureData = this.createFeature(n), this.featureData && this.saveFeature()), { next: !1 };
  }
  onMouseMove(n) {
    return !Yn(n) || !this.gm.markerPointer.marker ? { next: !0 } : (this.fireMarkerPointerUpdateEvent(), { next: !0 });
  }
  createFeature(n) {
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray(), p = this.getFeatureGeoJson(l);
    return p && (this.fireBeforeFeatureCreate({ geoJsonFeatures: [p] }), this.flags.featureCreateAllowed) ? this.gm.features.createFeature({
      shapeGeoJson: p,
      sourceName: wt.temporary
    }) : null;
  }
  getFeatureGeoJson(n) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "Point",
        coordinates: n
      }
    };
  }
  createMarker(n = wt.temporary) {
    const l = this.gm.options.layerStyles.marker[n]?.find((R) => R.type === "symbol"), p = l?.paint && "icon-opacity" in l.paint ? l.paint["icon-opacity"] : void 0, x = l?.layout && "icon-size" in l.layout ? l.layout["icon-size"] : void 0, M = 36, T = `${x !== void 0 ? Math.round(M * (x / 0.18)) : M}px`, u = this.gm.createSvgMarkerElement("default", {
      width: T,
      height: T,
      pointerEvents: "none",
      ...p !== void 0 && { opacity: String(p) }
    });
    return this.gm.mapAdapter.createDomMarker(
      {
        draggable: !1,
        anchor: "bottom",
        element: u
      },
      [0, 0]
    );
  }
}
function dF(a) {
  var n = {
    MultiPoint: {
      coordinates: [],
      properties: []
    },
    MultiLineString: {
      coordinates: [],
      properties: []
    },
    MultiPolygon: {
      coordinates: [],
      properties: []
    }
  };
  return Mo(a, (l) => {
    var p;
    switch ((p = l.geometry) == null ? void 0 : p.type) {
      case "Point":
        n.MultiPoint.coordinates.push(l.geometry.coordinates), n.MultiPoint.properties.push(l.properties);
        break;
      case "MultiPoint":
        n.MultiPoint.coordinates.push(...l.geometry.coordinates), n.MultiPoint.properties.push(l.properties);
        break;
      case "LineString":
        n.MultiLineString.coordinates.push(l.geometry.coordinates), n.MultiLineString.properties.push(l.properties);
        break;
      case "MultiLineString":
        n.MultiLineString.coordinates.push(
          ...l.geometry.coordinates
        ), n.MultiLineString.properties.push(l.properties);
        break;
      case "Polygon":
        n.MultiPolygon.coordinates.push(l.geometry.coordinates), n.MultiPolygon.properties.push(l.properties);
        break;
      case "MultiPolygon":
        n.MultiPolygon.coordinates.push(...l.geometry.coordinates), n.MultiPolygon.properties.push(l.properties);
        break;
    }
  }), gi(
    Object.keys(n).filter(function(l) {
      return n[l].coordinates.length;
    }).sort().map(function(l) {
      var p = { type: l, coordinates: n[l].coordinates }, x = { collectedProperties: n[l].properties };
      return Ja(p, x);
    })
  );
}
var fF = dF;
function pF(a, n, l, p, x) {
  W2(a, n, l || 0, p || a.length - 1, x || gF);
}
function W2(a, n, l, p, x) {
  for (; p > l; ) {
    if (p - l > 600) {
      var M = p - l + 1, T = n - l + 1, u = Math.log(M), R = 0.5 * Math.exp(2 * u / 3), z = 0.5 * Math.sqrt(u * R * (M - R) / M) * (T - M / 2 < 0 ? -1 : 1), U = Math.max(l, Math.floor(n - T * R / M + z)), $ = Math.min(p, Math.floor(n + (M - T) * R / M + z));
      W2(a, n, U, $, x);
    }
    var ee = a[n], oe = l, ce = p;
    for (Qd(a, l, n), x(a[p], ee) > 0 && Qd(a, l, p); oe < ce; ) {
      for (Qd(a, oe, ce), oe++, ce--; x(a[oe], ee) < 0; ) oe++;
      for (; x(a[ce], ee) > 0; ) ce--;
    }
    x(a[l], ee) === 0 ? Qd(a, l, ce) : (ce++, Qd(a, ce, p)), ce <= n && (l = ce + 1), n <= ce && (p = ce - 1);
  }
}
function Qd(a, n, l) {
  var p = a[n];
  a[n] = a[l], a[l] = p;
}
function gF(a, n) {
  return a < n ? -1 : a > n ? 1 : 0;
}
class pa {
  constructor(n = 9) {
    this._maxEntries = Math.max(4, n), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(n) {
    let l = this.data;
    const p = [];
    if (!Qp(n, l)) return p;
    const x = this.toBBox, M = [];
    for (; l; ) {
      for (let T = 0; T < l.children.length; T++) {
        const u = l.children[T], R = l.leaf ? x(u) : u;
        Qp(n, R) && (l.leaf ? p.push(u) : F_(n, R) ? this._all(u, p) : M.push(u));
      }
      l = M.pop();
    }
    return p;
  }
  collides(n) {
    let l = this.data;
    if (!Qp(n, l)) return !1;
    const p = [];
    for (; l; ) {
      for (let x = 0; x < l.children.length; x++) {
        const M = l.children[x], T = l.leaf ? this.toBBox(M) : M;
        if (Qp(n, T)) {
          if (l.leaf || F_(n, T)) return !0;
          p.push(M);
        }
      }
      l = p.pop();
    }
    return !1;
  }
  load(n) {
    if (!(n && n.length)) return this;
    if (n.length < this._minEntries) {
      for (let p = 0; p < n.length; p++)
        this.insert(n[p]);
      return this;
    }
    let l = this._build(n.slice(), 0, n.length - 1, 0);
    if (!this.data.children.length)
      this.data = l;
    else if (this.data.height === l.height)
      this._splitRoot(this.data, l);
    else {
      if (this.data.height < l.height) {
        const p = this.data;
        this.data = l, l = p;
      }
      this._insert(l, this.data.height - l.height - 1, !0);
    }
    return this;
  }
  insert(n) {
    return n && this._insert(n, this.data.height - 1), this;
  }
  clear() {
    return this.data = kh([]), this;
  }
  remove(n, l) {
    if (!n) return this;
    let p = this.data;
    const x = this.toBBox(n), M = [], T = [];
    let u, R, z;
    for (; p || M.length; ) {
      if (p || (p = M.pop(), R = M[M.length - 1], u = T.pop(), z = !0), p.leaf) {
        const U = mF(n, p.children, l);
        if (U !== -1)
          return p.children.splice(U, 1), M.push(p), this._condense(M), this;
      }
      !z && !p.leaf && F_(p, x) ? (M.push(p), T.push(u), u = 0, R = p, p = p.children[0]) : R ? (u++, p = R.children[u], z = !1) : p = null;
    }
    return this;
  }
  toBBox(n) {
    return n;
  }
  compareMinX(n, l) {
    return n.minX - l.minX;
  }
  compareMinY(n, l) {
    return n.minY - l.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(n) {
    return this.data = n, this;
  }
  _all(n, l) {
    const p = [];
    for (; n; )
      n.leaf ? l.push(...n.children) : p.push(...n.children), n = p.pop();
    return l;
  }
  _build(n, l, p, x) {
    const M = p - l + 1;
    let T = this._maxEntries, u;
    if (M <= T)
      return u = kh(n.slice(l, p + 1)), Eh(u, this.toBBox), u;
    x || (x = Math.ceil(Math.log(M) / Math.log(T)), T = Math.ceil(M / Math.pow(T, x - 1))), u = kh([]), u.leaf = !1, u.height = x;
    const R = Math.ceil(M / T), z = R * Math.ceil(Math.sqrt(T));
    Y1(n, l, p, z, this.compareMinX);
    for (let U = l; U <= p; U += z) {
      const $ = Math.min(U + z - 1, p);
      Y1(n, U, $, R, this.compareMinY);
      for (let ee = U; ee <= $; ee += R) {
        const oe = Math.min(ee + R - 1, $);
        u.children.push(this._build(n, ee, oe, x - 1));
      }
    }
    return Eh(u, this.toBBox), u;
  }
  _chooseSubtree(n, l, p, x) {
    for (; x.push(l), !(l.leaf || x.length - 1 === p); ) {
      let M = 1 / 0, T = 1 / 0, u;
      for (let R = 0; R < l.children.length; R++) {
        const z = l.children[R], U = R_(z), $ = vF(n, z) - U;
        $ < T ? (T = $, M = U < M ? U : M, u = z) : $ === T && U < M && (M = U, u = z);
      }
      l = u || l.children[0];
    }
    return l;
  }
  _insert(n, l, p) {
    const x = p ? n : this.toBBox(n), M = [], T = this._chooseSubtree(x, this.data, l, M);
    for (T.children.push(n), of(T, x); l >= 0 && M[l].children.length > this._maxEntries; )
      this._split(M, l), l--;
    this._adjustParentBBoxes(x, M, l);
  }
  // split overflowed node into two
  _split(n, l) {
    const p = n[l], x = p.children.length, M = this._minEntries;
    this._chooseSplitAxis(p, M, x);
    const T = this._chooseSplitIndex(p, M, x), u = kh(p.children.splice(T, p.children.length - T));
    u.height = p.height, u.leaf = p.leaf, Eh(p, this.toBBox), Eh(u, this.toBBox), l ? n[l - 1].children.push(u) : this._splitRoot(p, u);
  }
  _splitRoot(n, l) {
    this.data = kh([n, l]), this.data.height = n.height + 1, this.data.leaf = !1, Eh(this.data, this.toBBox);
  }
  _chooseSplitIndex(n, l, p) {
    let x, M = 1 / 0, T = 1 / 0;
    for (let u = l; u <= p - l; u++) {
      const R = af(n, 0, u, this.toBBox), z = af(n, u, p, this.toBBox), U = xF(R, z), $ = R_(R) + R_(z);
      U < M ? (M = U, x = u, T = $ < T ? $ : T) : U === M && $ < T && (T = $, x = u);
    }
    return x || p - l;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(n, l, p) {
    const x = n.leaf ? this.compareMinX : _F, M = n.leaf ? this.compareMinY : yF, T = this._allDistMargin(n, l, p, x), u = this._allDistMargin(n, l, p, M);
    T < u && n.children.sort(x);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(n, l, p, x) {
    n.children.sort(x);
    const M = this.toBBox, T = af(n, 0, l, M), u = af(n, p - l, p, M);
    let R = Kp(T) + Kp(u);
    for (let z = l; z < p - l; z++) {
      const U = n.children[z];
      of(T, n.leaf ? M(U) : U), R += Kp(T);
    }
    for (let z = p - l - 1; z >= l; z--) {
      const U = n.children[z];
      of(u, n.leaf ? M(U) : U), R += Kp(u);
    }
    return R;
  }
  _adjustParentBBoxes(n, l, p) {
    for (let x = p; x >= 0; x--)
      of(l[x], n);
  }
  _condense(n) {
    for (let l = n.length - 1, p; l >= 0; l--)
      n[l].children.length === 0 ? l > 0 ? (p = n[l - 1].children, p.splice(p.indexOf(n[l]), 1)) : this.clear() : Eh(n[l], this.toBBox);
  }
}
function mF(a, n, l) {
  if (!l) return n.indexOf(a);
  for (let p = 0; p < n.length; p++)
    if (l(a, n[p])) return p;
  return -1;
}
function Eh(a, n) {
  af(a, 0, a.children.length, n, a);
}
function af(a, n, l, p, x) {
  x || (x = kh(null)), x.minX = 1 / 0, x.minY = 1 / 0, x.maxX = -1 / 0, x.maxY = -1 / 0;
  for (let M = n; M < l; M++) {
    const T = a.children[M];
    of(x, a.leaf ? p(T) : T);
  }
  return x;
}
function of(a, n) {
  return a.minX = Math.min(a.minX, n.minX), a.minY = Math.min(a.minY, n.minY), a.maxX = Math.max(a.maxX, n.maxX), a.maxY = Math.max(a.maxY, n.maxY), a;
}
function _F(a, n) {
  return a.minX - n.minX;
}
function yF(a, n) {
  return a.minY - n.minY;
}
function R_(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function Kp(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function vF(a, n) {
  return (Math.max(n.maxX, a.maxX) - Math.min(n.minX, a.minX)) * (Math.max(n.maxY, a.maxY) - Math.min(n.minY, a.minY));
}
function xF(a, n) {
  const l = Math.max(a.minX, n.minX), p = Math.max(a.minY, n.minY), x = Math.min(a.maxX, n.maxX), M = Math.min(a.maxY, n.maxY);
  return Math.max(0, x - l) * Math.max(0, M - p);
}
function F_(a, n) {
  return a.minX <= n.minX && a.minY <= n.minY && n.maxX <= a.maxX && n.maxY <= a.maxY;
}
function Qp(a, n) {
  return n.minX <= a.maxX && n.minY <= a.maxY && n.maxX >= a.minX && n.maxY >= a.minY;
}
function kh(a) {
  return {
    children: a,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Y1(a, n, l, p, x) {
  const M = [n, l];
  for (; M.length; ) {
    if (l = M.pop(), n = M.pop(), l - n <= p) continue;
    const T = n + Math.ceil((l - n) / p / 2) * p;
    pF(a, T, n, l, x), M.push(n, T, T, l);
  }
}
function bF(a) {
  return IR(
    a,
    (n, l) => n + wF(l),
    0
  );
}
function wF(a) {
  let n = 0, l;
  switch (a.type) {
    case "Polygon":
      return W1(a.coordinates);
    case "MultiPolygon":
      for (l = 0; l < a.coordinates.length; l++)
        n += W1(a.coordinates[l]);
      return n;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function W1(a) {
  let n = 0;
  if (a && a.length > 0) {
    n += Math.abs(X1(a[0]));
    for (let l = 1; l < a.length; l++)
      n -= Math.abs(X1(a[l]));
  }
  return n;
}
var EF = Ri * Ri / 2, N_ = Math.PI / 180;
function X1(a) {
  const n = a.length - 1;
  if (n <= 2) return 0;
  let l = 0, p = 0;
  for (; p < n; ) {
    const x = a[p], M = a[p + 1 === n ? 0 : p + 1], T = a[p + 2 >= n ? (p + 2) % n : p + 2], u = x[0] * N_, R = M[1] * N_, z = T[0] * N_;
    l += (z - u) * Math.sin(R), p++;
  }
  return l * EF;
}
const cl = 11102230246251565e-32, es = 134217729, TF = (3 + 8 * cl) * cl;
function O_(a, n, l, p, x) {
  let M, T, u, R, z = n[0], U = p[0], $ = 0, ee = 0;
  U > z == U > -z ? (M = z, z = n[++$]) : (M = U, U = p[++ee]);
  let oe = 0;
  if ($ < a && ee < l)
    for (U > z == U > -z ? (T = z + M, u = M - (T - z), z = n[++$]) : (T = U + M, u = M - (T - U), U = p[++ee]), M = T, u !== 0 && (x[oe++] = u); $ < a && ee < l; )
      U > z == U > -z ? (T = M + z, R = T - M, u = M - (T - R) + (z - R), z = n[++$]) : (T = M + U, R = T - M, u = M - (T - R) + (U - R), U = p[++ee]), M = T, u !== 0 && (x[oe++] = u);
  for (; $ < a; )
    T = M + z, R = T - M, u = M - (T - R) + (z - R), z = n[++$], M = T, u !== 0 && (x[oe++] = u);
  for (; ee < l; )
    T = M + U, R = T - M, u = M - (T - R) + (U - R), U = p[++ee], M = T, u !== 0 && (x[oe++] = u);
  return (M !== 0 || oe === 0) && (x[oe++] = M), oe;
}
function SF(a, n) {
  let l = n[0];
  for (let p = 1; p < a; p++) l += n[p];
  return l;
}
function Uf(a) {
  return new Float64Array(a);
}
const kF = (3 + 16 * cl) * cl, IF = (2 + 12 * cl) * cl, MF = (9 + 64 * cl) * cl * cl, Th = Uf(4), J1 = Uf(8), K1 = Uf(12), Q1 = Uf(16), ds = Uf(4);
function CF(a, n, l, p, x, M, T) {
  let u, R, z, U, $, ee, oe, ce, me, re, Pe, _e, je, Qe, et, Ye, ot, Q;
  const ie = a - x, ge = l - x, Se = n - M, Ie = p - M;
  Qe = ie * Ie, ee = es * ie, oe = ee - (ee - ie), ce = ie - oe, ee = es * Ie, me = ee - (ee - Ie), re = Ie - me, et = ce * re - (Qe - oe * me - ce * me - oe * re), Ye = Se * ge, ee = es * Se, oe = ee - (ee - Se), ce = Se - oe, ee = es * ge, me = ee - (ee - ge), re = ge - me, ot = ce * re - (Ye - oe * me - ce * me - oe * re), Pe = et - ot, $ = et - Pe, Th[0] = et - (Pe + $) + ($ - ot), _e = Qe + Pe, $ = _e - Qe, je = Qe - (_e - $) + (Pe - $), Pe = je - Ye, $ = je - Pe, Th[1] = je - (Pe + $) + ($ - Ye), Q = _e + Pe, $ = Q - _e, Th[2] = _e - (Q - $) + (Pe - $), Th[3] = Q;
  let Oe = SF(4, Th), Re = IF * T;
  if (Oe >= Re || -Oe >= Re || ($ = a - ie, u = a - (ie + $) + ($ - x), $ = l - ge, z = l - (ge + $) + ($ - x), $ = n - Se, R = n - (Se + $) + ($ - M), $ = p - Ie, U = p - (Ie + $) + ($ - M), u === 0 && R === 0 && z === 0 && U === 0) || (Re = MF * T + TF * Math.abs(Oe), Oe += ie * U + Ie * u - (Se * z + ge * R), Oe >= Re || -Oe >= Re)) return Oe;
  Qe = u * Ie, ee = es * u, oe = ee - (ee - u), ce = u - oe, ee = es * Ie, me = ee - (ee - Ie), re = Ie - me, et = ce * re - (Qe - oe * me - ce * me - oe * re), Ye = R * ge, ee = es * R, oe = ee - (ee - R), ce = R - oe, ee = es * ge, me = ee - (ee - ge), re = ge - me, ot = ce * re - (Ye - oe * me - ce * me - oe * re), Pe = et - ot, $ = et - Pe, ds[0] = et - (Pe + $) + ($ - ot), _e = Qe + Pe, $ = _e - Qe, je = Qe - (_e - $) + (Pe - $), Pe = je - Ye, $ = je - Pe, ds[1] = je - (Pe + $) + ($ - Ye), Q = _e + Pe, $ = Q - _e, ds[2] = _e - (Q - $) + (Pe - $), ds[3] = Q;
  const De = O_(4, Th, 4, ds, J1);
  Qe = ie * U, ee = es * ie, oe = ee - (ee - ie), ce = ie - oe, ee = es * U, me = ee - (ee - U), re = U - me, et = ce * re - (Qe - oe * me - ce * me - oe * re), Ye = Se * z, ee = es * Se, oe = ee - (ee - Se), ce = Se - oe, ee = es * z, me = ee - (ee - z), re = z - me, ot = ce * re - (Ye - oe * me - ce * me - oe * re), Pe = et - ot, $ = et - Pe, ds[0] = et - (Pe + $) + ($ - ot), _e = Qe + Pe, $ = _e - Qe, je = Qe - (_e - $) + (Pe - $), Pe = je - Ye, $ = je - Pe, ds[1] = je - (Pe + $) + ($ - Ye), Q = _e + Pe, $ = Q - _e, ds[2] = _e - (Q - $) + (Pe - $), ds[3] = Q;
  const Fe = O_(De, J1, 4, ds, K1);
  Qe = u * U, ee = es * u, oe = ee - (ee - u), ce = u - oe, ee = es * U, me = ee - (ee - U), re = U - me, et = ce * re - (Qe - oe * me - ce * me - oe * re), Ye = R * z, ee = es * R, oe = ee - (ee - R), ce = R - oe, ee = es * z, me = ee - (ee - z), re = z - me, ot = ce * re - (Ye - oe * me - ce * me - oe * re), Pe = et - ot, $ = et - Pe, ds[0] = et - (Pe + $) + ($ - ot), _e = Qe + Pe, $ = _e - Qe, je = Qe - (_e - $) + (Pe - $), Pe = je - Ye, $ = je - Pe, ds[1] = je - (Pe + $) + ($ - Ye), Q = _e + Pe, $ = Q - _e, ds[2] = _e - (Q - $) + (Pe - $), ds[3] = Q;
  const Ue = O_(Fe, K1, 4, ds, Q1);
  return Q1[Ue - 1];
}
function PF(a, n, l, p, x, M) {
  const T = (n - M) * (l - x), u = (a - x) * (p - M), R = T - u, z = Math.abs(T + u);
  return Math.abs(R) >= kF * z ? R : -CF(a, n, l, p, x, M, z);
}
function AF(a, n) {
  var l, p, x = 0, M, T, u, R, z, U, $, ee = a[0], oe = a[1], ce = n.length;
  for (l = 0; l < ce; l++) {
    p = 0;
    var me = n[l], re = me.length - 1;
    if (U = me[0], U[0] !== me[re][0] && U[1] !== me[re][1])
      throw new Error("First and last coordinates in a ring must be the same");
    for (T = U[0] - ee, u = U[1] - oe, p; p < re; p++) {
      if ($ = me[p + 1], R = $[0] - ee, z = $[1] - oe, u === 0 && z === 0) {
        if (R <= 0 && T >= 0 || T <= 0 && R >= 0)
          return 0;
      } else if (z >= 0 && u <= 0 || z <= 0 && u >= 0) {
        if (M = PF(T, R, u, z, 0, 0), M === 0)
          return 0;
        (M > 0 && z > 0 && u <= 0 || M < 0 && z <= 0 && u > 0) && x++;
      }
      U = $, u = z, T = R;
    }
  }
  return x % 2 !== 0;
}
function pc(a, n, l = {}) {
  if (!a)
    throw new Error("point is required");
  if (!n)
    throw new Error("polygon is required");
  const p = ti(a), x = jf(n), M = x.type, T = n.bbox;
  let u = x.coordinates;
  if (T && LF(p, T) === !1)
    return !1;
  M === "Polygon" && (u = [u]);
  let R = !1;
  for (var z = 0; z < u.length; ++z) {
    const U = AF(p, u[z]);
    if (U === 0) return !l.ignoreBoundary;
    U && (R = !0);
  }
  return R;
}
function LF(a, n) {
  return n[0] <= a[0] && n[1] <= a[1] && n[2] >= a[0] && n[3] >= a[1];
}
function DF(a, n, l) {
  if (a.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  l === void 0 && (l = 1);
  var p = a.geometry.coordinates, x = [], M = {};
  if (l) {
    for (var T = [], u = 0; u < p.length; u++)
      for (var R = 0; R < p[u].length - 1; R++)
        T.push(re(u, R));
    var z = new pa();
    z.load(T);
  }
  for (var U = 0; U < p.length; U++)
    for (var $ = 0; $ < p[U].length - 1; $++)
      if (l) {
        var ee = z.search(re(U, $));
        ee.forEach(function(Pe) {
          var _e = Pe.ring, je = Pe.edge;
          me(U, $, _e, je);
        });
      } else
        for (var oe = 0; oe < p.length; oe++)
          for (var ce = 0; ce < p[oe].length - 1; ce++)
            me(U, $, oe, ce);
  return n || (x = {
    type: "Feature",
    geometry: { type: "MultiPoint", coordinates: x }
  }), x;
  function me(Pe, _e, je, Qe) {
    var et = p[Pe][_e], Ye = p[Pe][_e + 1], ot = p[je][Qe], Q = p[je][Qe + 1], ie = RF(et, Ye, ot, Q);
    if (ie !== null) {
      var ge, Se;
      if (Ye[0] !== et[0] ? ge = (ie[0] - et[0]) / (Ye[0] - et[0]) : ge = (ie[1] - et[1]) / (Ye[1] - et[1]), Q[0] !== ot[0] ? Se = (ie[0] - ot[0]) / (Q[0] - ot[0]) : Se = (ie[1] - ot[1]) / (Q[1] - ot[1]), !(ge >= 1 || ge <= 0 || Se >= 1 || Se <= 0)) {
        var Ie = ie, Oe = !M[Ie];
        Oe && (M[Ie] = !0), n ? x.push(
          n(
            ie,
            Pe,
            _e,
            et,
            Ye,
            ge,
            je,
            Qe,
            ot,
            Q,
            Se,
            Oe
          )
        ) : x.push(ie);
      }
    }
  }
  function re(Pe, _e) {
    var je = p[Pe][_e], Qe = p[Pe][_e + 1], et, Ye, ot, Q;
    return je[0] < Qe[0] ? (et = je[0], Ye = Qe[0]) : (et = Qe[0], Ye = je[0]), je[1] < Qe[1] ? (ot = je[1], Q = Qe[1]) : (ot = Qe[1], Q = je[1]), {
      minX: et,
      minY: ot,
      maxX: Ye,
      maxY: Q,
      ring: Pe,
      edge: _e
    };
  }
}
function RF(a, n, l, p) {
  if (lf(a, l) || lf(a, p) || lf(n, l) || lf(p, l))
    return null;
  var x = a[0], M = a[1], T = n[0], u = n[1], R = l[0], z = l[1], U = p[0], $ = p[1], ee = (x - T) * (z - $) - (M - u) * (R - U);
  if (ee === 0) return null;
  var oe = ((x * u - M * T) * (R - U) - (x - T) * (R * $ - z * U)) / ee, ce = ((x * u - M * T) * (z - $) - (M - u) * (R * $ - z * U)) / ee;
  return [oe, ce];
}
function lf(a, n) {
  if (!a || !n || a.length !== n.length) return !1;
  for (var l = 0, p = a.length; l < p; l++)
    if (a[l] instanceof Array && n[l] instanceof Array) {
      if (!lf(a[l], n[l])) return !1;
    } else if (a[l] !== n[l])
      return !1;
  return !0;
}
function FF(a) {
  if (a.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (a.geometry === void 0 || a.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (a.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  for (var n = a.geometry.coordinates.length, l = [], p = 0; p < n; p++) {
    var x = a.geometry.coordinates[p];
    uf(x[0], x[x.length - 1]) || x.push(x[0]);
    for (var M = 0; M < x.length - 1; M++)
      l.push(x[M]);
  }
  if (!OF(l))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var T = l.length, u = DF(
    a,
    function(Ot, Pt, Mt, Kt, gr, Ze, ri, lr, Ut, Me, br, ur) {
      return [
        Ot,
        Pt,
        Mt,
        Kt,
        gr,
        Ze,
        ri,
        lr,
        Ut,
        Me,
        br,
        ur
      ];
    }
  ), R = u.length;
  if (R == 0) {
    for (var z = [], p = 0; p < n; p++)
      z.push(
        Ql([a.geometry.coordinates[p]], {
          parent: -1,
          winding: NF(a.geometry.coordinates[p])
        })
      );
    var We = gi(z);
    return dt(), Tt(), We;
  }
  for (var U = [], $ = [], p = 0; p < n; p++) {
    U.push([]);
    for (var M = 0; M < a.geometry.coordinates[p].length - 1; M++)
      U[p].push([
        new eb(
          a.geometry.coordinates[p][Ch(M + 1, a.geometry.coordinates[p].length - 1)],
          1,
          [p, M],
          [p, Ch(M + 1, a.geometry.coordinates[p].length - 1)],
          void 0
        )
      ]), $.push(
        new tb(
          a.geometry.coordinates[p][M],
          [p, Ch(M - 1, a.geometry.coordinates[p].length - 1)],
          [p, M],
          void 0,
          void 0,
          !1,
          !0
        )
      );
  }
  for (var p = 0; p < R; p++)
    U[u[p][1]][u[p][2]].push(
      new eb(
        u[p][0],
        u[p][5],
        [u[p][1], u[p][2]],
        [u[p][6], u[p][7]],
        void 0
      )
    ), u[p][11] && $.push(
      new tb(
        u[p][0],
        [u[p][1], u[p][2]],
        [u[p][6], u[p][7]],
        void 0,
        void 0,
        !0,
        !0
      )
    );
  for (var ee = $.length, p = 0; p < U.length; p++)
    for (var M = 0; M < U[p].length; M++)
      U[p][M].sort(function(Mt, Kt) {
        return Mt.param < Kt.param ? -1 : 1;
      });
  for (var oe = [], p = 0; p < ee; p++)
    oe.push({
      minX: $[p].coord[0],
      minY: $[p].coord[1],
      maxX: $[p].coord[0],
      maxY: $[p].coord[1],
      index: p
    });
  var ce = new pa();
  ce.load(oe);
  for (var p = 0; p < U.length; p++)
    for (var M = 0; M < U[p].length; M++)
      for (var me = 0; me < U[p][M].length; me++) {
        var re;
        me == U[p][M].length - 1 ? re = U[p][Ch(M + 1, a.geometry.coordinates[p].length - 1)][0].coord : re = U[p][M][me + 1].coord;
        var Pe = ce.search({
          minX: re[0],
          minY: re[1],
          maxX: re[0],
          maxY: re[1]
        })[0];
        U[p][M][me].nxtIsectAlongEdgeIn = Pe.index;
      }
  for (var p = 0; p < U.length; p++)
    for (var M = 0; M < U[p].length; M++)
      for (var me = 0; me < U[p][M].length; me++) {
        var re = U[p][M][me].coord, Pe = ce.search({
          minX: re[0],
          minY: re[1],
          maxX: re[0],
          maxY: re[1]
        })[0], _e = Pe.index;
        _e < T ? $[_e].nxtIsectAlongRingAndEdge2 = U[p][M][me].nxtIsectAlongEdgeIn : uf(
          $[_e].ringAndEdge1,
          U[p][M][me].ringAndEdgeIn
        ) ? $[_e].nxtIsectAlongRingAndEdge1 = U[p][M][me].nxtIsectAlongEdgeIn : $[_e].nxtIsectAlongRingAndEdge2 = U[p][M][me].nxtIsectAlongEdgeIn;
      }
  for (var je = [], p = 0, M = 0; M < n; M++) {
    for (var Qe = p, me = 0; me < a.geometry.coordinates[M].length - 1; me++)
      $[p].coord[0] < $[Qe].coord[0] && (Qe = p), p++;
    for (var et = $[Qe].nxtIsectAlongRingAndEdge2, me = 0; me < $.length; me++)
      if ($[me].nxtIsectAlongRingAndEdge1 == Qe || $[me].nxtIsectAlongRingAndEdge2 == Qe) {
        var Ye = me;
        break;
      }
    var ot = mg(
      [
        $[Ye].coord,
        $[Qe].coord,
        $[et].coord
      ],
      !0
    ) ? 1 : -1;
    je.push({ isect: Qe, parent: -1, winding: ot });
  }
  je.sort(function(Ot, Pt) {
    return $[Ot.isect].coord > $[Pt.isect].coord ? -1 : 1;
  });
  for (var z = []; je.length > 0; ) {
    var Q = je.pop(), ie = Q.isect, ge = Q.parent, Se = Q.winding, Ie = z.length, Oe = [$[ie].coord], Re = ie;
    if ($[ie].ringAndEdge1Walkable)
      var De = $[ie].ringAndEdge1, Fe = $[ie].nxtIsectAlongRingAndEdge1;
    else
      var De = $[ie].ringAndEdge2, Fe = $[ie].nxtIsectAlongRingAndEdge2;
    for (; !uf($[ie].coord, $[Fe].coord); ) {
      Oe.push($[Fe].coord);
      for (var Ue = void 0, p = 0; p < je.length; p++)
        if (je[p].isect == Fe) {
          Ue = p;
          break;
        }
      if (Ue != null && je.splice(Ue, 1), uf(De, $[Fe].ringAndEdge1)) {
        if (De = $[Fe].ringAndEdge2, $[Fe].ringAndEdge2Walkable = !1, $[Fe].ringAndEdge1Walkable) {
          var Ve = { isect: Fe };
          mg(
            [
              $[Re].coord,
              $[Fe].coord,
              $[$[Fe].nxtIsectAlongRingAndEdge2].coord
            ],
            Se == 1
          ) ? (Ve.parent = ge, Ve.winding = -Se) : (Ve.parent = Ie, Ve.winding = Se), je.push(Ve);
        }
        Re = Fe, Fe = $[Fe].nxtIsectAlongRingAndEdge2;
      } else {
        if (De = $[Fe].ringAndEdge1, $[Fe].ringAndEdge1Walkable = !1, $[Fe].ringAndEdge2Walkable) {
          var Ve = { isect: Fe };
          mg(
            [
              $[Re].coord,
              $[Fe].coord,
              $[$[Fe].nxtIsectAlongRingAndEdge1].coord
            ],
            Se == 1
          ) ? (Ve.parent = ge, Ve.winding = -Se) : (Ve.parent = Ie, Ve.winding = Se), je.push(Ve);
        }
        Re = Fe, Fe = $[Fe].nxtIsectAlongRingAndEdge1;
      }
    }
    Oe.push($[Fe].coord), z.push(
      Ql([Oe], {
        index: Ie,
        parent: ge,
        winding: Se,
        netWinding: void 0
      })
    );
  }
  var We = gi(z);
  dt(), Tt();
  function dt() {
    for (var Ot = [], Pt = 0; Pt < We.features.length; Pt++)
      We.features[Pt].properties.parent == -1 && Ot.push(Pt);
    if (Ot.length > 1)
      for (var Pt = 0; Pt < Ot.length; Pt++) {
        for (var Mt = -1, Kt = 1 / 0, gr = 0; gr < We.features.length; gr++)
          Ot[Pt] != gr && pc(
            We.features[Ot[Pt]].geometry.coordinates[0][0],
            We.features[gr],
            { ignoreBoundary: !0 }
          ) && bF(We.features[gr]) < Kt && (Mt = gr);
        We.features[Ot[Pt]].properties.parent = Mt;
      }
  }
  function Tt() {
    for (var Ot = 0; Ot < We.features.length; Ot++)
      if (We.features[Ot].properties.parent == -1) {
        var Pt = We.features[Ot].properties.winding;
        We.features[Ot].properties.netWinding = Pt, Ht(Ot, Pt);
      }
  }
  function Ht(Ot, Pt) {
    for (var Mt = 0; Mt < We.features.length; Mt++)
      if (We.features[Mt].properties.parent == Ot) {
        var Kt = Pt + We.features[Mt].properties.winding;
        We.features[Mt].properties.netWinding = Kt, Ht(Mt, Kt);
      }
  }
  return We;
}
var eb = function(a, n, l, p, x) {
  this.coord = a, this.param = n, this.ringAndEdgeIn = l, this.ringAndEdgeOut = p, this.nxtIsectAlongEdgeIn = x;
}, tb = function(a, n, l, p, x, M, T) {
  this.coord = a, this.ringAndEdge1 = n, this.ringAndEdge2 = l, this.nxtIsectAlongRingAndEdge1 = p, this.nxtIsectAlongRingAndEdge2 = x, this.ringAndEdge1Walkable = M, this.ringAndEdge2Walkable = T;
};
function mg(a, n) {
  if (typeof n > "u" && (n = !0), a.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var l = (a[1][0] - a[0][0]) * (a[2][1] - a[0][1]) - (a[1][1] - a[0][1]) * (a[2][0] - a[0][0]);
  return l >= 0 == n;
}
function NF(a) {
  for (var n = 0, l = 0; l < a.length - 1; l++)
    a[l][0] < a[n][0] && (n = l);
  if (mg(
    [
      a[Ch(n - 1, a.length - 1)],
      a[n],
      a[Ch(n + 1, a.length - 1)]
    ],
    !0
  ))
    var p = 1;
  else
    var p = -1;
  return p;
}
function uf(a, n) {
  if (!a || !n || a.length != n.length) return !1;
  for (var l = 0, p = a.length; l < p; l++)
    if (a[l] instanceof Array && n[l] instanceof Array) {
      if (!uf(a[l], n[l])) return !1;
    } else if (a[l] != n[l])
      return !1;
  return !0;
}
function Ch(a, n) {
  return (a % n + n) % n;
}
function OF(a) {
  for (var n = {}, l = 1, p = 0, x = a.length; p < x; ++p) {
    if (Object.prototype.hasOwnProperty.call(n, a[p])) {
      l = 0;
      break;
    }
    n[a[p]] = 1;
  }
  return l;
}
function zF(a) {
  var n = [];
  return tu(a, function(l) {
    l.geometry.type === "Polygon" && Mo(FF(l), function(p) {
      n.push(Ql(p.geometry.coordinates, l.properties));
    });
  }), gi(n);
}
var BF = zF;
class GF extends _l {
  mode = "polygon";
  shape = "polygon";
  lineDrawer = new xv(this.gm, { snappingMarkers: "first", targetShape: "polygon" });
  eventHandlers = {
    [`${Ft}:draw`]: this.forwardLineDrawerEvent.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("firstMarkerClick", this.polygonFinished.bind(this));
  }
  onMouseMove(n) {
    return Yn(n) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  polygonFinished(n) {
    if (this.lineDrawer.endShape(), n.shapeCoordinates.length < 3)
      return;
    const l = this.fixShapeGeoJson(vv(n.geoJson));
    l && this.gm.features.createFeature({
      shapeGeoJson: {
        ...l,
        properties: {
          // we don't need to have collected properties for a new polygon
          // ...geoJsonPolygon.properties,
          shape: this.shape
        }
      },
      sourceName: wt.main
    });
  }
  fixShapeGeoJson(n) {
    try {
      return NR(fF(BF(n))).features[0];
    } catch {
      return null;
    }
  }
}
class jF extends _l {
  mode = "rectangle";
  shape = "rectangle";
  startLngLat = null;
  eventHandlers = {
    mousemove: this.onMouseMove.bind(this),
    click: this.onMouseClick.bind(this)
  };
  throttledMethods = bc(
    {
      updateFeaturePosition: this.updateFeaturePosition
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.removeTmpFeature(), this.startLngLat = null, this.gm.markerPointer.disable(), this.fireFinishEvent();
  }
  onMouseClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !1 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    if (this.startLngLat) {
      const p = this.getFeatureGeoJson(Sh(this.startLngLat, l));
      this.fireBeforeFeatureCreate({ geoJsonFeatures: [p] }), this.flags.featureCreateAllowed && this.finishShape(l);
    } else {
      const p = this.getFeatureGeoJson(Sh(l, l));
      if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [p] }), this.flags.featureCreateAllowed) {
        const x = this.startShape(l);
        if (x) {
          const M = this.getControlMarkerData(["geometry", "coordinates", 4]);
          this.fireStartEvent(x, M);
        }
      }
    }
    return { next: !1 };
  }
  onMouseMove(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !1 };
    if (!this.startLngLat)
      return this.fireMarkerPointerUpdateEvent(), { next: !1 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray(), p = Sh(this.startLngLat, l), x = this.getFeatureGeoJson(p);
    return this.fireBeforeFeatureCreate({ geoJsonFeatures: [x] }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeaturePosition(p), { next: !1 };
  }
  startShape(n) {
    this.startLngLat = n;
    const l = Sh(this.startLngLat, this.startLngLat);
    return this.featureData = this.createFeature(l), this.featureData;
  }
  finishShape(n) {
    if (this.startLngLat) {
      const l = Sh(this.startLngLat, n);
      this.throttledMethods.updateFeaturePosition(l);
    }
    this.featureData && (this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature()), this.startLngLat = null, this.fireFinishEvent();
  }
  createFeature(n) {
    return this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(n),
      sourceName: wt.temporary
    });
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? fv(this.featureData.getGeoJson()) : !1;
  }
  getFeatureGeoJson(n) {
    return {
      ...vy(
        [n[0], n[1]],
        [n[2], n[3]]
      ),
      properties: {
        shape: this.shape
      }
    };
  }
  updateFeaturePosition(n) {
    if (!this.featureData)
      return;
    const l = vy(
      [n[0], n[1]],
      [n[2], n[3]]
    );
    this.featureData.updateGeoJsonGeometry(l.geometry);
    const p = this.getControlMarkerData(["geometry", "coordinates", 4]);
    this.fireUpdateEvent(this.featureData, p);
  }
  getControlMarkerData(n) {
    const l = this.gm.markerPointer.marker;
    return l ? {
      type: "dom",
      instance: l,
      position: {
        coordinate: l.getLngLat(),
        path: n
      }
    } : null;
  }
  fireStartEvent(n, l) {
    const p = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "start",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ft}:draw`, p);
  }
  fireUpdateEvent(n, l) {
    const p = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "update",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ft}:draw`, p);
  }
  fireFinishEvent() {
    const n = {
      name: `${Ft}:draw:shape`,
      level: "system",
      actionType: "draw",
      mode: this.shape,
      variant: null,
      action: "finish"
    };
    this.gm.events.fire(`${Ft}:draw`, n);
  }
}
class VF extends _l {
  mode = "text_marker";
  shape = "text_marker";
  textarea = null;
  eventHandlers = {
    click: this.onMouseClick.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onStartAction() {
    this.gm.markerPointer.enable({ invisibleMarker: !0 });
  }
  onEndAction() {
    this.removeTextarea(), this.removeTmpFeature(), this.featureData = null, this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent();
  }
  onMouseMove(n) {
    return Yn(n, { warning: !0 }) ? (this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  onMouseClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !0 };
    if (this.textarea)
      this.endShape(), this.gm.markerPointer.enable({ invisibleMarker: !0, lngLat: n.lngLat.toArray() }), this.fireMarkerPointerUpdateEvent();
    else {
      const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
      this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(l)] }), this.flags.featureCreateAllowed && (this.featureData = this.createFeature(l), this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent());
    }
    return { next: !1 };
  }
  createFeature(n) {
    const l = this.gm.mapAdapter.project(n);
    return this.createTextarea(l), this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(n),
      sourceName: wt.temporary
    });
  }
  endShape() {
    const n = this.textarea?.value || "";
    this.removeTextarea(), n.trim() ? (this.updateFeatureSource(n), this.saveFeature()) : this.removeTmpFeature();
  }
  createTextarea(n) {
    this.textarea = document.createElement("textarea"), this.textarea.style.position = "absolute", this.textarea.style.left = `${n[0]}px`, this.textarea.style.top = `${n[1]}px`, this.textarea.style.opacity = "0.7", this.gm.mapAdapter.getContainer().appendChild(this.textarea), this.textarea.focus();
  }
  removeTextarea() {
    this.textarea?.remove(), this.textarea = null;
  }
  getFeatureGeoJson(n) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape,
        text: ""
      },
      geometry: {
        type: "Point",
        coordinates: n
      }
    };
  }
  updateFeatureSource(n) {
    this.featureData && this.featureData._updateAllProperties({ shape: this.shape, text: n });
  }
}
class UF extends yv {
  mode = "ellipse";
  shape = "ellipse";
  xSemiAxisPoint = null;
  xSemiAxisLngLat = null;
  throttledMethods = bc(
    {
      updateFeatureGeoJson: this.updateFeatureGeoJson
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  onMouseClick(n) {
    if (!Yn(n))
      return { next: !0 };
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    if (this.circleCenterLngLat && this.xSemiAxisLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [
          this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, l)
        ]
      }), this.flags.featureCreateAllowed && (this.saveEllipseFeature(l), this.circleCenterLngLat = null, this.circleCenterPoint = null, this.xSemiAxisPoint = null, this.xSemiAxisLngLat = null, this.fireFinishEvent());
    else if (this.circleCenterLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getEllipseGeoJson(this.circleCenterLngLat, l)]
      }), this.flags.featureCreateAllowed && (this.xSemiAxisLngLat = l, this.xSemiAxisPoint = this.gm.mapAdapter.project(this.circleCenterLngLat));
    else if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(l)] }), this.flags.featureCreateAllowed) {
      this.circleCenterLngLat = l, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.featureData = this.createFeature();
      const p = this.getControlMarkerData();
      this.featureData && p && this.fireStartEvent(this.featureData, p);
    }
    return { next: !1 };
  }
  onMouseMove() {
    if (this.circleCenterLngLat && this.gm.markerPointer.marker) {
      const n = this.gm.markerPointer.marker.getLngLat();
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [
          this.xSemiAxisLngLat ? this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, n) : this.getEllipseGeoJson(this.circleCenterLngLat, n)
        ]
      }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeatureGeoJson(n);
    }
    return this.circleCenterLngLat || this.fireMarkerPointerUpdateEvent(), { next: !1 };
  }
  updateFeatureGeoJson(n) {
    if (!this.featureData || !this.circleCenterLngLat)
      return;
    const l = this.xSemiAxisLngLat ? this.getEllipseGeoJson(this.circleCenterLngLat, this.xSemiAxisLngLat, n) : this.getEllipseGeoJson(this.circleCenterLngLat, n);
    this.featureData.updateGeoJsonGeometry(l.geometry), this.featureData._updateAllProperties({
      shape: l.properties.shape
    });
    const p = this.getControlMarkerData();
    p && this.fireUpdateEvent(this.featureData, p);
  }
  saveEllipseFeature(n) {
    if (!(!this.circleCenterLngLat || !this.xSemiAxisLngLat) && this.featureData) {
      const l = this.gm.markerPointer.marker?.getLngLat() || n;
      this.updateFeatureGeoJson(l);
      const { xSemiAxis: p, ySemiAxis: x, angle: M } = q1({
        center: this.circleCenterLngLat,
        xSemiAxisLngLat: this.xSemiAxisLngLat,
        rimLngLat: l
      });
      this.featureData.setShapeProperty("center", this.circleCenterLngLat), this.featureData.setShapeProperty("xSemiAxis", p), this.featureData.setShapeProperty("ySemiAxis", x), this.featureData.setShapeProperty("angle", M), this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature();
    }
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? fv(this.featureData.getGeoJson()) : !1;
  }
  getEllipseGeoJson(n, l, p) {
    const { xSemiAxis: x, ySemiAxis: M, angle: T } = q1({
      center: n,
      xSemiAxisLngLat: l,
      rimLngLat: p
    });
    return rm({ center: n, xSemiAxis: x, ySemiAxis: M, angle: T });
  }
}
const by = {
  marker: hF,
  ellipse: UF,
  circle: sF,
  circle_marker: KR,
  text_marker: VF,
  line: cF,
  rectangle: jF,
  polygon: GF,
  freehand: null,
  custom_shape: null
}, qF = (a, n) => by[n] ? new by[n](a) : (It.error(`Draw "${n}" is not available`), null), Xh = (a) => hl(a) && a.actionType === "edit", $F = (a) => bR.includes(a), ZF = (a) => S2.includes(a), HF = (a) => I2.includes(a), YF = (a) => k2.includes(a), WF = (a) => ZF(a) || HF(a) || YF(a);
class XF extends Kg {
  eventHandlers = {
    [`${Ft}:draw`]: this.handleDrawEvent.bind(this)
  };
  constructor(n, l) {
    super(n), l.attachEvents(this.eventHandlers);
  }
  handleDrawEvent(n) {
    if (!_v(n))
      return { next: !0 };
    const l = `${n.actionType}__${n.mode}`;
    return n.action === "mode_start" ? (this.trackExclusiveModes(n), this.start(l, n), this.trackRelatedModes(n)) : n.action === "mode_end" && (this.trackRelatedModes(n), this.end(l)), { next: !0 };
  }
  start(n, l) {
    const p = qF(this.gm, l.mode);
    p && (n in this.gm.actionInstances && It.error(`Action instance "${n}" already exists`), this.gm.actionInstances[n] = p, p.startAction());
  }
  end(n) {
    const l = this.gm.actionInstances[n];
    l instanceof _l ? (l.endAction(), delete this.gm.actionInstances[n]) : console.error(`Wrong action instance for draw event "${n}":`, l);
  }
}
class qf extends mv {
  actionType = "edit";
  featureData = null;
  cursorExcludedLayerIds = ["rectangle-line", "polygon-line", "circle-line"];
  layerEventHandlersData = [];
  startAction() {
    this.setEventsForLayers("mouseenter", this.setCursorToPointer.bind(this)), this.setEventsForLayers("mouseleave", this.setCursorToEmpty.bind(this)), super.startAction();
  }
  endAction() {
    this.clearEventsForLayers(), super.endAction();
  }
  setCursorToPointer() {
    this.flags.actionInProgress || this.gm.mapAdapter.setCursor("pointer");
  }
  setCursorToEmpty() {
    this.flags.actionInProgress || this.gm.mapAdapter.setCursor("");
  }
  getFeatureByMouseEvent({
    event: n,
    sourceNames: l
  }) {
    const p = this.gm.features.getFeatureByMouseEvent({
      event: n,
      sourceNames: l
    });
    return !p || p.getShapeProperty("disableEdit") === !0 ? null : p;
  }
  setEventsForLayers(n, l) {
    this.gm.features.layers.map((p) => p.id).filter(
      (p) => !this.cursorExcludedLayerIds.some((x) => p.includes(x))
    ).forEach((p) => {
      this.gm.mapAdapter.on(n, p, l), this.layerEventHandlersData.push({ eventName: n, layerId: p, callback: l });
    });
  }
  clearEventsForLayers() {
    this.layerEventHandlersData.forEach(({ eventName: n, layerId: l, callback: p }) => {
      this.gm.mapAdapter.off(n, l, p);
    }), this.layerEventHandlersData = [];
  }
  updateFeatureGeoJson({
    featureData: n,
    featureGeoJson: l,
    forceMode: p = void 0
  }) {
    return this.flags.featureUpdateAllowed ? (n.updateGeoJsonGeometry(l.geometry), $h(n.getGeoJson().properties, l.properties) || n._updateAllProperties(l.properties), this.fireFeatureUpdatedEvent({
      sourceFeatures: [n],
      targetFeatures: [n],
      forceMode: p
    }), !0) : !1;
  }
  fireBeforeFeatureUpdate({
    features: n,
    geoJsonFeatures: l,
    forceMode: p = void 0
  }) {
    this.flags.featureUpdateAllowed = !0;
    const x = {
      name: `${Ft}:feature:before_update`,
      level: "system",
      actionType: "edit",
      mode: p || this.mode,
      action: "before_update",
      features: n,
      geoJsonFeatures: l
    };
    this.gm.events.fire(`${Ft}:${this.actionType}`, x);
  }
  fireFeatureUpdatedEvent({
    sourceFeatures: n,
    targetFeatures: l,
    markerData: p = void 0,
    forceMode: x = void 0
  }) {
    const M = {
      name: `${Ft}:edit:feature_updated`,
      level: "system",
      actionType: "edit",
      action: "feature_updated",
      mode: x || this.mode,
      sourceFeatures: n,
      targetFeatures: l,
      markerData: p || null
    };
    this.gm.events.fire(`${Ft}:edit`, M);
  }
  fireFeatureEditStartEvent({
    feature: n,
    forceMode: l = void 0
  }) {
    const p = {
      name: `${Ft}:edit:feature_edit_start`,
      level: "system",
      actionType: "edit",
      action: "feature_edit_start",
      mode: l || this.mode,
      feature: n
    };
    this.gm.events.fire(`${Ft}:edit`, p);
  }
  fireFeatureEditEndEvent({
    feature: n,
    forceMode: l = void 0
  }) {
    const p = {
      name: `${Ft}:edit:feature_edit_end`,
      level: "system",
      actionType: "edit",
      action: "feature_edit_end",
      mode: l || this.mode,
      feature: n
    };
    this.gm.events.fire(`${Ft}:edit`, p);
  }
  fireMarkerPointerUpdateEvent() {
    if (!this.gm.markerPointer.marker)
      return;
    const n = this.gm.markerPointer.marker, l = {
      name: `${Ft}:draw:shape_with_data`,
      level: "system",
      variant: null,
      actionType: "draw",
      mode: this.getLineDrawerMode(),
      action: "update",
      markerData: {
        type: "dom",
        instance: n,
        position: {
          coordinate: n.getLngLat(),
          path: [-1]
        }
      },
      featureData: null
    };
    this.gm.events.fire(`${Ft}:draw`, l);
  }
  forwardLineDrawerEvent(n) {
    if (!H2(n) || !["cut", "split"].includes(this.mode))
      return { next: !0 };
    if (n.action === "start" || n.action === "update") {
      const l = {
        name: `${Ft}:draw:shape_with_data`,
        level: "system",
        actionType: "draw",
        mode: this.getLineDrawerMode(),
        variant: null,
        action: n.action,
        featureData: n.featureData,
        markerData: n.markerData
      };
      this.gm.events.fire(`${Ft}:draw`, l);
    } else if (n.action === "finish" || n.action === "cancel") {
      const l = {
        name: `${Ft}:draw:shape`,
        level: "system",
        actionType: "draw",
        mode: this.getLineDrawerMode(),
        variant: null,
        action: n.action
      };
      this.gm.events.fire(`${Ft}:draw`, l);
    }
    return { next: !0 };
  }
  fireFeatureRemovedEvent(n) {
    if (Kl(n.shape, ol)) {
      const l = {
        name: `${Ft}:edit:feature_removed`,
        level: "system",
        actionType: "edit",
        mode: n.shape,
        action: "feature_removed",
        featureData: n
      };
      this.gm.events.fire(`${Ft}:edit`, l);
    }
  }
  getLineDrawerMode() {
    return this.mode === "cut" ? "polygon" : (this.mode, "line");
  }
}
function JF(a, n = {}) {
  const l = il(a), p = (l[0] + l[2]) / 2, x = (l[1] + l[3]) / 2;
  return Ha([p, x], n.properties, n);
}
var wy = { exports: {} }, KF = wy.exports, rb;
function QF() {
  return rb || (rb = 1, (function(a, n) {
    (function(l, p) {
      a.exports = p();
    })(KF, (function() {
      function l(y, o) {
        (o == null || o > y.length) && (o = y.length);
        for (var h = 0, _ = Array(o); h < o; h++) _[h] = y[h];
        return _;
      }
      function p(y, o, h) {
        return o = U(o), (function(_, I) {
          if (I && (typeof I == "object" || typeof I == "function")) return I;
          if (I !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
          return (function(D) {
            if (D === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return D;
          })(_);
        })(y, ee() ? Reflect.construct(o, h || [], U(y).constructor) : o.apply(y, h));
      }
      function x(y, o) {
        if (!(y instanceof o)) throw new TypeError("Cannot call a class as a function");
      }
      function M(y, o, h) {
        if (ee()) return Reflect.construct.apply(null, arguments);
        var _ = [null];
        _.push.apply(_, o);
        var I = new (y.bind.apply(y, _))();
        return h && oe(I, h.prototype), I;
      }
      function T(y, o) {
        for (var h = 0; h < o.length; h++) {
          var _ = o[h];
          _.enumerable = _.enumerable || !1, _.configurable = !0, "value" in _ && (_.writable = !0), Object.defineProperty(y, re(_.key), _);
        }
      }
      function u(y, o, h) {
        return o && T(y.prototype, o), h && T(y, h), Object.defineProperty(y, "prototype", { writable: !1 }), y;
      }
      function R(y, o) {
        var h = typeof Symbol < "u" && y[Symbol.iterator] || y["@@iterator"];
        if (!h) {
          if (Array.isArray(y) || (h = Pe(y)) || o) {
            h && (y = h);
            var _ = 0, I = function() {
            };
            return { s: I, n: function() {
              return _ >= y.length ? { done: !0 } : { done: !1, value: y[_++] };
            }, e: function(se) {
              throw se;
            }, f: I };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var D, B = !0, H = !1;
        return { s: function() {
          h = h.call(y);
        }, n: function() {
          var se = h.next();
          return B = se.done, se;
        }, e: function(se) {
          H = !0, D = se;
        }, f: function() {
          try {
            B || h.return == null || h.return();
          } finally {
            if (H) throw D;
          }
        } };
      }
      function z() {
        return z = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(y, o, h) {
          var _ = (function(D, B) {
            for (; !{}.hasOwnProperty.call(D, B) && (D = U(D)) !== null; ) ;
            return D;
          })(y, o);
          if (_) {
            var I = Object.getOwnPropertyDescriptor(_, o);
            return I.get ? I.get.call(arguments.length < 3 ? y : h) : I.value;
          }
        }, z.apply(null, arguments);
      }
      function U(y) {
        return U = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        }, U(y);
      }
      function $(y, o) {
        if (typeof o != "function" && o !== null) throw new TypeError("Super expression must either be null or a function");
        y.prototype = Object.create(o && o.prototype, { constructor: { value: y, writable: !0, configurable: !0 } }), Object.defineProperty(y, "prototype", { writable: !1 }), o && oe(y, o);
      }
      function ee() {
        try {
          var y = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
          })));
        } catch {
        }
        return (ee = function() {
          return !!y;
        })();
      }
      function oe(y, o) {
        return oe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(h, _) {
          return h.__proto__ = _, h;
        }, oe(y, o);
      }
      function ce(y, o, h, _) {
        var I = z(U(1 & _ ? y.prototype : y), o, h);
        return 2 & _ && typeof I == "function" ? function(D) {
          return I.apply(h, D);
        } : I;
      }
      function me(y) {
        return (function(o) {
          if (Array.isArray(o)) return l(o);
        })(y) || (function(o) {
          if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null) return Array.from(o);
        })(y) || Pe(y) || (function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        })();
      }
      function re(y) {
        var o = (function(h, _) {
          if (typeof h != "object" || !h) return h;
          var I = h[Symbol.toPrimitive];
          if (I !== void 0) {
            var D = I.call(h, _);
            if (typeof D != "object") return D;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(h);
        })(y, "string");
        return typeof o == "symbol" ? o : o + "";
      }
      function Pe(y, o) {
        if (y) {
          if (typeof y == "string") return l(y, o);
          var h = {}.toString.call(y).slice(8, -1);
          return h === "Object" && y.constructor && (h = y.constructor.name), h === "Map" || h === "Set" ? Array.from(y) : h === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h) ? l(y, o) : void 0;
        }
      }
      function _e(y) {
        var o = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
        return _e = function(h) {
          if (h === null || !(function(I) {
            try {
              return Function.toString.call(I).indexOf("[native code]") !== -1;
            } catch {
              return typeof I == "function";
            }
          })(h)) return h;
          if (typeof h != "function") throw new TypeError("Super expression must either be null or a function");
          if (o !== void 0) {
            if (o.has(h)) return o.get(h);
            o.set(h, _);
          }
          function _() {
            return M(h, arguments, U(this).constructor);
          }
          return _.prototype = Object.create(h.prototype, { constructor: { value: _, enumerable: !1, writable: !0, configurable: !0 } }), oe(_, h);
        }, _e(y);
      }
      var je = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getEndCapStyle", value: function() {
          return this._endCapStyle;
        } }, { key: "isSingleSided", value: function() {
          return this._isSingleSided;
        } }, { key: "setQuadrantSegments", value: function(o) {
          this._quadrantSegments = o, this._quadrantSegments === 0 && (this._joinStyle = y.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = y.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), o <= 0 && (this._quadrantSegments = 1), this._joinStyle !== y.JOIN_ROUND && (this._quadrantSegments = y.DEFAULT_QUADRANT_SEGMENTS);
        } }, { key: "getJoinStyle", value: function() {
          return this._joinStyle;
        } }, { key: "setJoinStyle", value: function(o) {
          this._joinStyle = o;
        } }, { key: "setSimplifyFactor", value: function(o) {
          this._simplifyFactor = o < 0 ? 0 : o;
        } }, { key: "getSimplifyFactor", value: function() {
          return this._simplifyFactor;
        } }, { key: "getQuadrantSegments", value: function() {
          return this._quadrantSegments;
        } }, { key: "setEndCapStyle", value: function(o) {
          this._endCapStyle = o;
        } }, { key: "getMitreLimit", value: function() {
          return this._mitreLimit;
        } }, { key: "setMitreLimit", value: function(o) {
          this._mitreLimit = o;
        } }, { key: "setSingleSided", value: function(o) {
          this._isSingleSided = o;
        } }], [{ key: "constructor_", value: function() {
          if (this._quadrantSegments = y.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = y.CAP_ROUND, this._joinStyle = y.JOIN_ROUND, this._mitreLimit = y.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = y.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
            if (arguments.length === 1) {
              var o = arguments[0];
              this.setQuadrantSegments(o);
            } else if (arguments.length === 2) {
              var h = arguments[0], _ = arguments[1];
              this.setQuadrantSegments(h), this.setEndCapStyle(_);
            } else if (arguments.length === 4) {
              var I = arguments[0], D = arguments[1], B = arguments[2], H = arguments[3];
              this.setQuadrantSegments(I), this.setEndCapStyle(D), this.setJoinStyle(B), this.setMitreLimit(H);
            }
          }
        } }, { key: "bufferDistanceError", value: function(o) {
          var h = Math.PI / 2 / o;
          return 1 - Math.cos(h / 2);
        } }]);
      })();
      je.CAP_ROUND = 1, je.CAP_FLAT = 2, je.CAP_SQUARE = 3, je.JOIN_ROUND = 1, je.JOIN_MITRE = 2, je.JOIN_BEVEL = 3, je.DEFAULT_QUADRANT_SEGMENTS = 8, je.DEFAULT_MITRE_LIMIT = 5, je.DEFAULT_SIMPLIFY_FACTOR = 0.01;
      var Qe = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ Exception: o })[0], _;
        }
        return $(o, y), u(o, [{ key: "toString", value: function() {
          return this.message;
        } }]);
      })(_e(Error)), et = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ IllegalArgumentException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), Ye = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "filter", value: function(y) {
        } }]);
      })();
      function ot() {
      }
      function Q() {
      }
      function ie() {
      }
      var ge, Se, Ie, Oe, Re, De, Fe, Ue, Ve = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "equalsWithTolerance", value: function(y, o, h) {
          return Math.abs(y - o) <= h;
        } }]);
      })(), We = (function() {
        return u((function y(o, h) {
          x(this, y), this.low = h || 0, this.high = o || 0;
        }), null, [{ key: "toBinaryString", value: function(y) {
          var o, h = "";
          for (o = 2147483648; o > 0; o >>>= 1) h += (y.high & o) === o ? "1" : "0";
          for (o = 2147483648; o > 0; o >>>= 1) h += (y.low & o) === o ? "1" : "0";
          return h;
        } }]);
      })();
      function dt() {
      }
      function Tt() {
      }
      dt.NaN = NaN, dt.isNaN = function(y) {
        return Number.isNaN(y);
      }, dt.isInfinite = function(y) {
        return !Number.isFinite(y);
      }, dt.MAX_VALUE = Number.MAX_VALUE, dt.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, dt.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, typeof Float64Array == "function" && typeof Int32Array == "function" ? (De = 2146435072, Fe = new Float64Array(1), Ue = new Int32Array(Fe.buffer), dt.doubleToLongBits = function(y) {
        Fe[0] = y;
        var o = 0 | Ue[0], h = 0 | Ue[1];
        return (h & De) === De && 1048575 & h && o !== 0 && (o = 0, h = 2146959360), new We(h, o);
      }, dt.longBitsToDouble = function(y) {
        return Ue[0] = y.low, Ue[1] = y.high, Fe[0];
      }) : (ge = 1023, Se = Math.log2, Ie = Math.floor, Oe = Math.pow, Re = (function() {
        for (var y = 53; y > 0; y--) {
          var o = Oe(2, y) - 1;
          if (Ie(Se(o)) + 1 === y) return o;
        }
        return 0;
      })(), dt.doubleToLongBits = function(y) {
        var o, h, _, I, D, B, H, se, de;
        if (y < 0 || 1 / y === Number.NEGATIVE_INFINITY ? (B = 1 << 31, y = -y) : B = 0, y === 0) return new We(se = B, de = 0);
        if (y === 1 / 0) return new We(se = 2146435072 | B, de = 0);
        if (y != y) return new We(se = 2146959360, de = 0);
        if (I = 0, de = 0, (o = Ie(y)) > 1) if (o <= Re) (I = Ie(Se(o))) <= 20 ? (de = 0, se = o << 20 - I & 1048575) : (de = o % (h = Oe(2, _ = I - 20)) << 32 - _, se = o / h & 1048575);
        else for (_ = o, de = 0; (_ = Ie(h = _ / 2)) !== 0; ) I++, de >>>= 1, de |= (1 & se) << 31, se >>>= 1, h !== _ && (se |= 524288);
        if (H = I + ge, D = o === 0, o = y - o, I < 52 && o !== 0) for (_ = 0; ; ) {
          if ((h = 2 * o) >= 1 ? (o = h - 1, D ? (H--, D = !1) : (_ <<= 1, _ |= 1, I++)) : (o = h, D ? --H == 0 && (I++, D = !1) : (_ <<= 1, I++)), I === 20) se |= _, _ = 0;
          else if (I === 52) {
            de |= _;
            break;
          }
          if (h === 1) {
            I < 20 ? se |= _ << 20 - I : I < 52 && (de |= _ << 52 - I);
            break;
          }
        }
        return se |= H << 20, new We(se |= B, de);
      }, dt.longBitsToDouble = function(y) {
        var o, h, _, I, D = y.high, B = y.low, H = D & 1 << 31 ? -1 : 1;
        for (_ = ((2146435072 & D) >> 20) - ge, I = 0, h = 1 << 19, o = 1; o <= 20; o++) D & h && (I += Oe(2, -o)), h >>>= 1;
        for (h = 1 << 31, o = 21; o <= 52; o++) B & h && (I += Oe(2, -o)), h >>>= 1;
        if (_ === -1023) {
          if (I === 0) return 0 * H;
          _ = -1022;
        } else {
          if (_ === 1024) return I === 0 ? H / 0 : NaN;
          I += 1;
        }
        return H * I * Oe(2, _);
      });
      var Ht = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ RuntimeException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), Ot = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, null, [{ key: "constructor_", value: function() {
          if (arguments.length === 0) Ht.constructor_.call(this);
          else if (arguments.length === 1) {
            var h = arguments[0];
            Ht.constructor_.call(this, h);
          }
        } }]);
      })(Ht), Pt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "shouldNeverReachHere", value: function() {
          if (arguments.length === 0) y.shouldNeverReachHere(null);
          else if (arguments.length === 1) {
            var o = arguments[0];
            throw new Ot("Should never reach here" + (o !== null ? ": " + o : ""));
          }
        } }, { key: "isTrue", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            y.isTrue(o, null);
          } else if (arguments.length === 2) {
            var h = arguments[1];
            if (!arguments[0]) throw h === null ? new Ot() : new Ot(h);
          }
        } }, { key: "equals", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            y.equals(o, h, null);
          } else if (arguments.length === 3) {
            var _ = arguments[0], I = arguments[1], D = arguments[2];
            if (!I.equals(_)) throw new Ot("Expected " + _ + " but encountered " + I + (D !== null ? ": " + D : ""));
          }
        } }]);
      })(), Mt = new ArrayBuffer(8), Kt = new Float64Array(Mt), gr = new Int32Array(Mt), Ze = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getM", value: function() {
          return dt.NaN;
        } }, { key: "setOrdinate", value: function(o, h) {
          switch (o) {
            case y.X:
              this.x = h;
              break;
            case y.Y:
              this.y = h;
              break;
            case y.Z:
              this.setZ(h);
              break;
            default:
              throw new et("Invalid ordinate index: " + o);
          }
        } }, { key: "equals2D", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return this.x === o.x && this.y === o.y;
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            return !!Ve.equalsWithTolerance(this.x, h.x, _) && !!Ve.equalsWithTolerance(this.y, h.y, _);
          }
        } }, { key: "setM", value: function(o) {
          throw new et("Invalid ordinate index: " + y.M);
        } }, { key: "getZ", value: function() {
          return this.z;
        } }, { key: "getOrdinate", value: function(o) {
          switch (o) {
            case y.X:
              return this.x;
            case y.Y:
              return this.y;
            case y.Z:
              return this.getZ();
          }
          throw new et("Invalid ordinate index: " + o);
        } }, { key: "equals3D", value: function(o) {
          return this.x === o.x && this.y === o.y && (this.getZ() === o.getZ() || dt.isNaN(this.getZ()) && dt.isNaN(o.getZ()));
        } }, { key: "equals", value: function(o) {
          return o instanceof y && this.equals2D(o);
        } }, { key: "equalInZ", value: function(o, h) {
          return Ve.equalsWithTolerance(this.getZ(), o.getZ(), h);
        } }, { key: "setX", value: function(o) {
          this.x = o;
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this.x < h.x ? -1 : this.x > h.x ? 1 : this.y < h.y ? -1 : this.y > h.y ? 1 : 0;
        } }, { key: "getX", value: function() {
          return this.x;
        } }, { key: "setZ", value: function(o) {
          this.z = o;
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (o) {
            if (o instanceof CloneNotSupportedException) return Pt.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
            throw o;
          }
        } }, { key: "copy", value: function() {
          return new y(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
        } }, { key: "distance3D", value: function(o) {
          var h = this.x - o.x, _ = this.y - o.y, I = this.getZ() - o.getZ();
          return Math.sqrt(h * h + _ * _ + I * I);
        } }, { key: "getY", value: function() {
          return this.y;
        } }, { key: "setY", value: function(o) {
          this.y = o;
        } }, { key: "distance", value: function(o) {
          var h = this.x - o.x, _ = this.y - o.y;
          return Math.sqrt(h * h + _ * _);
        } }, { key: "hashCode", value: function() {
          var o = 17;
          return o = 37 * (o = 37 * o + y.hashCode(this.x)) + y.hashCode(this.y);
        } }, { key: "setCoordinate", value: function(o) {
          this.x = o.x, this.y = o.y, this.z = o.getZ();
        } }, { key: "interfaces_", get: function() {
          return [ot, Q, ie];
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.z = null, arguments.length === 0) y.constructor_.call(this, 0, 0);
          else if (arguments.length === 1) {
            var o = arguments[0];
            y.constructor_.call(this, o.x, o.y, o.getZ());
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            y.constructor_.call(this, h, _, y.NULL_ORDINATE);
          } else if (arguments.length === 3) {
            var I = arguments[0], D = arguments[1], B = arguments[2];
            this.x = I, this.y = D, this.z = B;
          }
        } }, { key: "hashCode", value: function(o) {
          return Kt[0] = o, gr[0] ^ gr[1];
        } }]);
      })(), ri = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "compare", value: function(o, h) {
          var _ = y.compare(o.x, h.x);
          if (_ !== 0) return _;
          var I = y.compare(o.y, h.y);
          return I !== 0 ? I : this._dimensionsToTest <= 2 ? 0 : y.compare(o.getZ(), h.getZ());
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimensionsToTest = 2, arguments.length === 0) y.constructor_.call(this, 2);
          else if (arguments.length === 1) {
            var o = arguments[0];
            if (o !== 2 && o !== 3) throw new et("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = o;
          }
        } }, { key: "compare", value: function(o, h) {
          return o < h ? -1 : o > h ? 1 : dt.isNaN(o) ? dt.isNaN(h) ? 0 : -1 : dt.isNaN(h) ? 1 : 0;
        } }]);
      })();
      Ze.DimensionalComparator = ri, Ze.NULL_ORDINATE = dt.NaN, Ze.X = 0, Ze.Y = 1, Ze.Z = 2, Ze.M = 3;
      var lr = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getArea", value: function() {
          return this.getWidth() * this.getHeight();
        } }, { key: "equals", value: function(o) {
          if (!(o instanceof y)) return !1;
          var h = o;
          return this.isNull() ? h.isNull() : this._maxx === h.getMaxX() && this._maxy === h.getMaxY() && this._minx === h.getMinX() && this._miny === h.getMinY();
        } }, { key: "intersection", value: function(o) {
          if (this.isNull() || o.isNull() || !this.intersects(o)) return new y();
          var h = this._minx > o._minx ? this._minx : o._minx, _ = this._miny > o._miny ? this._miny : o._miny;
          return new y(h, this._maxx < o._maxx ? this._maxx : o._maxx, _, this._maxy < o._maxy ? this._maxy : o._maxy);
        } }, { key: "isNull", value: function() {
          return this._maxx < this._minx;
        } }, { key: "getMaxX", value: function() {
          return this._maxx;
        } }, { key: "covers", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof Ze) {
              var o = arguments[0];
              return this.covers(o.x, o.y);
            }
            if (arguments[0] instanceof y) {
              var h = arguments[0];
              return !this.isNull() && !h.isNull() && h.getMinX() >= this._minx && h.getMaxX() <= this._maxx && h.getMinY() >= this._miny && h.getMaxY() <= this._maxy;
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            return !this.isNull() && _ >= this._minx && _ <= this._maxx && I >= this._miny && I <= this._maxy;
          }
        } }, { key: "intersects", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return !this.isNull() && !o.isNull() && !(o._minx > this._maxx || o._maxx < this._minx || o._miny > this._maxy || o._maxy < this._miny);
            }
            if (arguments[0] instanceof Ze) {
              var h = arguments[0];
              return this.intersects(h.x, h.y);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof Ze && arguments[1] instanceof Ze) {
              var _ = arguments[0], I = arguments[1];
              return !this.isNull() && !((_.x < I.x ? _.x : I.x) > this._maxx) && !((_.x > I.x ? _.x : I.x) < this._minx) && !((_.y < I.y ? _.y : I.y) > this._maxy) && !((_.y > I.y ? _.y : I.y) < this._miny);
            }
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var D = arguments[0], B = arguments[1];
              return !this.isNull() && !(D > this._maxx || D < this._minx || B > this._maxy || B < this._miny);
            }
          }
        } }, { key: "getMinY", value: function() {
          return this._miny;
        } }, { key: "getDiameter", value: function() {
          if (this.isNull()) return 0;
          var o = this.getWidth(), h = this.getHeight();
          return Math.sqrt(o * o + h * h);
        } }, { key: "getMinX", value: function() {
          return this._minx;
        } }, { key: "expandToInclude", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof Ze) {
              var o = arguments[0];
              this.expandToInclude(o.x, o.y);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              if (h.isNull()) return null;
              this.isNull() ? (this._minx = h.getMinX(), this._maxx = h.getMaxX(), this._miny = h.getMinY(), this._maxy = h.getMaxY()) : (h._minx < this._minx && (this._minx = h._minx), h._maxx > this._maxx && (this._maxx = h._maxx), h._miny < this._miny && (this._miny = h._miny), h._maxy > this._maxy && (this._maxy = h._maxy));
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.isNull() ? (this._minx = _, this._maxx = _, this._miny = I, this._maxy = I) : (_ < this._minx && (this._minx = _), _ > this._maxx && (this._maxx = _), I < this._miny && (this._miny = I), I > this._maxy && (this._maxy = I));
          }
        } }, { key: "minExtent", value: function() {
          if (this.isNull()) return 0;
          var o = this.getWidth(), h = this.getHeight();
          return o < h ? o : h;
        } }, { key: "getWidth", value: function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this.isNull() ? h.isNull() ? 0 : -1 : h.isNull() ? 1 : this._minx < h._minx ? -1 : this._minx > h._minx ? 1 : this._miny < h._miny ? -1 : this._miny > h._miny ? 1 : this._maxx < h._maxx ? -1 : this._maxx > h._maxx ? 1 : this._maxy < h._maxy ? -1 : this._maxy > h._maxy ? 1 : 0;
        } }, { key: "translate", value: function(o, h) {
          if (this.isNull()) return null;
          this.init(this.getMinX() + o, this.getMaxX() + o, this.getMinY() + h, this.getMaxY() + h);
        } }, { key: "copy", value: function() {
          return new y(this);
        } }, { key: "toString", value: function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        } }, { key: "setToNull", value: function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        } }, { key: "disjoint", value: function(o) {
          return !(!this.isNull() && !o.isNull()) || o._minx > this._maxx || o._maxx < this._minx || o._miny > this._maxy || o._maxy < this._miny;
        } }, { key: "getHeight", value: function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        } }, { key: "maxExtent", value: function() {
          if (this.isNull()) return 0;
          var o = this.getWidth(), h = this.getHeight();
          return o > h ? o : h;
        } }, { key: "expandBy", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.expandBy(o, o);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            if (this.isNull()) return null;
            this._minx -= h, this._maxx += h, this._miny -= _, this._maxy += _, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        } }, { key: "contains", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return this.covers(o);
            }
            if (arguments[0] instanceof Ze) {
              var h = arguments[0];
              return this.covers(h);
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            return this.covers(_, I);
          }
        } }, { key: "centre", value: function() {
          return this.isNull() ? null : new Ze((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        } }, { key: "init", value: function() {
          if (arguments.length === 0) this.setToNull();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof Ze) {
              var o = arguments[0];
              this.init(o.x, o.x, o.y, o.y);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this._minx = h._minx, this._maxx = h._maxx, this._miny = h._miny, this._maxy = h._maxy;
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.init(_.x, I.x, _.y, I.y);
          } else if (arguments.length === 4) {
            var D = arguments[0], B = arguments[1], H = arguments[2], se = arguments[3];
            D < B ? (this._minx = D, this._maxx = B) : (this._minx = B, this._maxx = D), H < se ? (this._miny = H, this._maxy = se) : (this._miny = se, this._maxy = H);
          }
        } }, { key: "getMaxY", value: function() {
          return this._maxy;
        } }, { key: "distance", value: function(o) {
          if (this.intersects(o)) return 0;
          var h = 0;
          this._maxx < o._minx ? h = o._minx - this._maxx : this._minx > o._maxx && (h = this._minx - o._maxx);
          var _ = 0;
          return this._maxy < o._miny ? _ = o._miny - this._maxy : this._miny > o._maxy && (_ = this._miny - o._maxy), h === 0 ? _ : _ === 0 ? h : Math.sqrt(h * h + _ * _);
        } }, { key: "hashCode", value: function() {
          var o = 17;
          return o = 37 * (o = 37 * (o = 37 * (o = 37 * o + Ze.hashCode(this._minx)) + Ze.hashCode(this._maxx)) + Ze.hashCode(this._miny)) + Ze.hashCode(this._maxy);
        } }, { key: "interfaces_", get: function() {
          return [ot, ie];
        } }], [{ key: "constructor_", value: function() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof Ze) {
              var o = arguments[0];
              this.init(o.x, o.x, o.y, o.y);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this.init(h);
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.init(_.x, I.x, _.y, I.y);
          } else if (arguments.length === 4) {
            var D = arguments[0], B = arguments[1], H = arguments[2], se = arguments[3];
            this.init(D, B, H, se);
          }
        } }, { key: "intersects", value: function() {
          if (arguments.length === 3) {
            var o = arguments[0], h = arguments[1], _ = arguments[2];
            return _.x >= (o.x < h.x ? o.x : h.x) && _.x <= (o.x > h.x ? o.x : h.x) && _.y >= (o.y < h.y ? o.y : h.y) && _.y <= (o.y > h.y ? o.y : h.y);
          }
          if (arguments.length === 4) {
            var I = arguments[0], D = arguments[1], B = arguments[2], H = arguments[3], se = Math.min(B.x, H.x), de = Math.max(B.x, H.x), $e = Math.min(I.x, D.x), rt = Math.max(I.x, D.x);
            return !($e > de) && !(rt < se) && (se = Math.min(B.y, H.y), de = Math.max(B.y, H.y), $e = Math.min(I.y, D.y), rt = Math.max(I.y, D.y), !($e > de) && !(rt < se));
          }
        } }]);
      })(), Ut = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "isGeometryCollection", value: function() {
          return this.getTypeCode() === y.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getFactory", value: function() {
          return this._factory;
        } }, { key: "getGeometryN", value: function(o) {
          return this;
        } }, { key: "getArea", value: function() {
          return 0;
        } }, { key: "isRectangle", value: function() {
          return !1;
        } }, { key: "equalsExact", value: function(o) {
          return this === o || this.equalsExact(o, 0);
        } }, { key: "geometryChanged", value: function() {
          this.apply(y.geometryChangedFilter);
        } }, { key: "geometryChangedAction", value: function() {
          this._envelope = null;
        } }, { key: "equalsNorm", value: function(o) {
          return o !== null && this.norm().equalsExact(o.norm());
        } }, { key: "getLength", value: function() {
          return 0;
        } }, { key: "getNumGeometries", value: function() {
          return 1;
        } }, { key: "compareTo", value: function() {
          var o;
          if (arguments.length === 1) {
            var h = arguments[0];
            return o = h, this.getTypeCode() !== o.getTypeCode() ? this.getTypeCode() - o.getTypeCode() : this.isEmpty() && o.isEmpty() ? 0 : this.isEmpty() ? -1 : o.isEmpty() ? 1 : this.compareToSameClass(h);
          }
          if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            return o = _, this.getTypeCode() !== o.getTypeCode() ? this.getTypeCode() - o.getTypeCode() : this.isEmpty() && o.isEmpty() ? 0 : this.isEmpty() ? -1 : o.isEmpty() ? 1 : this.compareToSameClass(_, I);
          }
        } }, { key: "getUserData", value: function() {
          return this._userData;
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "getEnvelope", value: function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        } }, { key: "checkNotGeometryCollection", value: function(o) {
          if (o.getTypeCode() === y.TYPECODE_GEOMETRYCOLLECTION) throw new et("This method does not support GeometryCollection arguments");
        } }, { key: "equal", value: function(o, h, _) {
          return _ === 0 ? o.equals(h) : o.distance(h) <= _;
        } }, { key: "norm", value: function() {
          var o = this.copy();
          return o.normalize(), o;
        } }, { key: "reverse", value: function() {
          var o = this.reverseInternal();
          return this.envelope != null && (o.envelope = this.envelope.copy()), o.setSRID(this.getSRID()), o;
        } }, { key: "copy", value: function() {
          var o = this.copyInternal();
          return o.envelope = this._envelope == null ? null : this._envelope.copy(), o._SRID = this._SRID, o._userData = this._userData, o;
        } }, { key: "getPrecisionModel", value: function() {
          return this._factory.getPrecisionModel();
        } }, { key: "getEnvelopeInternal", value: function() {
          return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new lr(this._envelope);
        } }, { key: "setSRID", value: function(o) {
          this._SRID = o;
        } }, { key: "setUserData", value: function(o) {
          this._userData = o;
        } }, { key: "compare", value: function(o, h) {
          for (var _ = o.iterator(), I = h.iterator(); _.hasNext() && I.hasNext(); ) {
            var D = _.next(), B = I.next(), H = D.compareTo(B);
            if (H !== 0) return H;
          }
          return _.hasNext() ? 1 : I.hasNext() ? -1 : 0;
        } }, { key: "hashCode", value: function() {
          return this.getEnvelopeInternal().hashCode();
        } }, { key: "isEquivalentClass", value: function(o) {
          return this.getClass() === o.getClass();
        } }, { key: "isGeometryCollectionOrDerived", value: function() {
          return this.getTypeCode() === y.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === y.TYPECODE_MULTIPOINT || this.getTypeCode() === y.TYPECODE_MULTILINESTRING || this.getTypeCode() === y.TYPECODE_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [Q, ot, ie];
        } }, { key: "getClass", value: function() {
          return y;
        } }], [{ key: "hasNonEmptyElements", value: function(o) {
          for (var h = 0; h < o.length; h++) if (!o[h].isEmpty()) return !0;
          return !1;
        } }, { key: "hasNullElements", value: function(o) {
          for (var h = 0; h < o.length; h++) if (o[h] === null) return !0;
          return !1;
        } }]);
      })();
      Ut.constructor_ = function(y) {
        y && (this._envelope = null, this._userData = null, this._factory = y, this._SRID = y.getSRID());
      }, Ut.TYPECODE_POINT = 0, Ut.TYPECODE_MULTIPOINT = 1, Ut.TYPECODE_LINESTRING = 2, Ut.TYPECODE_LINEARRING = 3, Ut.TYPECODE_MULTILINESTRING = 4, Ut.TYPECODE_POLYGON = 5, Ut.TYPECODE_MULTIPOLYGON = 6, Ut.TYPECODE_GEOMETRYCOLLECTION = 7, Ut.TYPENAME_POINT = "Point", Ut.TYPENAME_MULTIPOINT = "MultiPoint", Ut.TYPENAME_LINESTRING = "LineString", Ut.TYPENAME_LINEARRING = "LinearRing", Ut.TYPENAME_MULTILINESTRING = "MultiLineString", Ut.TYPENAME_POLYGON = "Polygon", Ut.TYPENAME_MULTIPOLYGON = "MultiPolygon", Ut.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", Ut.geometryChangedFilter = { get interfaces_() {
        return [Ye];
      }, filter: function(y) {
        y.geometryChangedAction();
      } };
      var Me = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "toLocationSymbol", value: function(o) {
          switch (o) {
            case y.EXTERIOR:
              return "e";
            case y.BOUNDARY:
              return "b";
            case y.INTERIOR:
              return "i";
            case y.NONE:
              return "-";
          }
          throw new et("Unknown location value: " + o);
        } }]);
      })();
      Me.INTERIOR = 0, Me.BOUNDARY = 1, Me.EXTERIOR = 2, Me.NONE = -1;
      var br = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "add", value: function() {
        } }, { key: "addAll", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }, { key: "iterator", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "toArray", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      })(), ur = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ NoSuchElementException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), tr = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ UnsupportedOperationException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), mi = (function(y) {
        function o() {
          return x(this, o), p(this, o, arguments);
        }
        return $(o, y), u(o, [{ key: "contains", value: function() {
        } }]);
      })(br), Nr = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o)).map = /* @__PURE__ */ new Map(), h instanceof br && _.addAll(h), _;
        }
        return $(o, y), u(o, [{ key: "contains", value: function(h) {
          var _ = h.hashCode ? h.hashCode() : h;
          return !!this.map.has(_);
        } }, { key: "add", value: function(h) {
          var _ = h.hashCode ? h.hashCode() : h;
          return !this.map.has(_) && !!this.map.set(_, h);
        } }, { key: "addAll", value: function(h) {
          var _, I = R(h);
          try {
            for (I.s(); !(_ = I.n()).done; ) {
              var D = _.value;
              this.add(D);
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
          return !0;
        } }, { key: "remove", value: function() {
          throw new tr();
        } }, { key: "size", value: function() {
          return this.map.size;
        } }, { key: "isEmpty", value: function() {
          return this.map.size === 0;
        } }, { key: "toArray", value: function() {
          return Array.from(this.map.values());
        } }, { key: "iterator", value: function() {
          return new _i(this.map);
        } }, { key: Symbol.iterator, value: function() {
          return this.map;
        } }]);
      })(mi), _i = (function() {
        return u((function y(o) {
          x(this, y), this.iterator = o.values();
          var h = this.iterator.next(), _ = h.done, I = h.value;
          this.done = _, this.value = I;
        }), [{ key: "next", value: function() {
          if (this.done) throw new ur();
          var y = this.value, o = this.iterator.next(), h = o.done, _ = o.value;
          return this.done = h, this.value = _, y;
        } }, { key: "hasNext", value: function() {
          return !this.done;
        } }, { key: "remove", value: function() {
          throw new tr();
        } }]);
      })(), St = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "opposite", value: function(o) {
          return o === y.LEFT ? y.RIGHT : o === y.RIGHT ? y.LEFT : o;
        } }]);
      })();
      St.ON = 0, St.LEFT = 1, St.RIGHT = 2;
      var $i = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ EmptyStackException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), Zi = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o, [h])).name = Object.keys({ IndexOutOfBoundsException: o })[0], _;
        }
        return $(o, y), u(o);
      })(Qe), In = (function(y) {
        function o() {
          return x(this, o), p(this, o, arguments);
        }
        return $(o, y), u(o, [{ key: "get", value: function() {
        } }, { key: "set", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }]);
      })(br), Ks = (function(y) {
        function o() {
          var h;
          return x(this, o), (h = p(this, o)).array = [], h;
        }
        return $(o, y), u(o, [{ key: "add", value: function(h) {
          return this.array.push(h), !0;
        } }, { key: "get", value: function(h) {
          if (h < 0 || h >= this.size()) throw new Zi();
          return this.array[h];
        } }, { key: "push", value: function(h) {
          return this.array.push(h), h;
        } }, { key: "pop", value: function() {
          if (this.array.length === 0) throw new $i();
          return this.array.pop();
        } }, { key: "peek", value: function() {
          if (this.array.length === 0) throw new $i();
          return this.array[this.array.length - 1];
        } }, { key: "empty", value: function() {
          return this.array.length === 0;
        } }, { key: "isEmpty", value: function() {
          return this.empty();
        } }, { key: "search", value: function(h) {
          return this.array.indexOf(h);
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }]);
      })(In);
      function er(y, o) {
        return y.interfaces_ && y.interfaces_.indexOf(o) > -1;
      }
      var Kr = (function() {
        return u((function y(o) {
          x(this, y), this.str = o;
        }), [{ key: "append", value: function(y) {
          this.str += y;
        } }, { key: "setCharAt", value: function(y, o) {
          this.str = this.str.substr(0, y) + o + this.str.substr(y + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      })(), He = (function() {
        function y(o) {
          x(this, y), this.value = o;
        }
        return u(y, [{ key: "intValue", value: function() {
          return this.value;
        } }, { key: "compareTo", value: function(o) {
          return this.value < o ? -1 : this.value > o ? 1 : 0;
        } }], [{ key: "compare", value: function(o, h) {
          return o < h ? -1 : o > h ? 1 : 0;
        } }, { key: "isNan", value: function(o) {
          return Number.isNaN(o);
        } }, { key: "valueOf", value: function(o) {
          return new y(o);
        } }]);
      })(), K = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "isWhitespace", value: function(y) {
          return y <= 32 && y >= 0 || y === 127;
        } }, { key: "toUpperCase", value: function(y) {
          return y.toUpperCase();
        } }]);
      })(), J = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "le", value: function(o) {
          return this._hi < o._hi || this._hi === o._hi && this._lo <= o._lo;
        } }, { key: "extractSignificantDigits", value: function(o, h) {
          var _ = this.abs(), I = y.magnitude(_._hi), D = y.TEN.pow(I);
          (_ = _.divide(D)).gt(y.TEN) ? (_ = _.divide(y.TEN), I += 1) : _.lt(y.ONE) && (_ = _.multiply(y.TEN), I -= 1);
          for (var B = I + 1, H = new Kr(), se = y.MAX_PRINT_DIGITS - 1, de = 0; de <= se; de++) {
            o && de === B && H.append(".");
            var $e = Math.trunc(_._hi);
            if ($e < 0) break;
            var rt = !1, vt = 0;
            $e > 9 ? (rt = !0, vt = "9") : vt = "0" + $e, H.append(vt), _ = _.subtract(y.valueOf($e)).multiply(y.TEN), rt && _.selfAdd(y.TEN);
            var Gt = !0, $t = y.magnitude(_._hi);
            if ($t < 0 && Math.abs($t) >= se - de && (Gt = !1), !Gt) break;
          }
          return h[0] = I, H.toString();
        } }, { key: "sqr", value: function() {
          return this.multiply(this);
        } }, { key: "doubleValue", value: function() {
          return this._hi + this._lo;
        } }, { key: "subtract", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return this.add(o.negate());
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return this.add(-h);
          }
        } }, { key: "equals", value: function() {
          if (arguments.length === 1 && arguments[0] instanceof y) {
            var o = arguments[0];
            return this._hi === o._hi && this._lo === o._lo;
          }
        } }, { key: "isZero", value: function() {
          return this._hi === 0 && this._lo === 0;
        } }, { key: "selfSubtract", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-o._hi, -o._lo);
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-h, 0);
          }
        } }, { key: "getSpecialNumberString", value: function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        } }, { key: "min", value: function(o) {
          return this.le(o) ? this : o;
        } }, { key: "selfDivide", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return this.selfDivide(o._hi, o._lo);
            }
            if (typeof arguments[0] == "number") {
              var h = arguments[0];
              return this.selfDivide(h, 0);
            }
          } else if (arguments.length === 2) {
            var _, I, D, B, H = arguments[0], se = arguments[1], de = null, $e = null, rt = null, vt = null;
            return D = this._hi / H, vt = (de = (rt = y.SPLIT * D) - (de = rt - D)) * ($e = (vt = y.SPLIT * H) - ($e = vt - H)) - (B = D * H) + de * (I = H - $e) + (_ = D - de) * $e + _ * I, vt = D + (rt = (this._hi - B - vt + this._lo - D * se) / H), this._hi = vt, this._lo = D - vt + rt, this;
          }
        } }, { key: "dump", value: function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        } }, { key: "divide", value: function() {
          if (arguments[0] instanceof y) {
            var o, h, _, I, D = arguments[0], B = null, H = null, se = null, de = null;
            return o = (_ = this._hi / D._hi) - (B = (se = y.SPLIT * _) - (B = se - _)), de = B * (H = (de = y.SPLIT * D._hi) - (H = de - D._hi)) - (I = _ * D._hi) + B * (h = D._hi - H) + o * H + o * h, new y(de = _ + (se = (this._hi - I - de + this._lo - _ * D._lo) / D._hi), _ - de + se);
          }
          if (typeof arguments[0] == "number") {
            var $e = arguments[0];
            return dt.isNaN($e) ? y.createNaN() : y.copy(this).selfDivide($e, 0);
          }
        } }, { key: "ge", value: function(o) {
          return this._hi > o._hi || this._hi === o._hi && this._lo >= o._lo;
        } }, { key: "pow", value: function(o) {
          if (o === 0) return y.valueOf(1);
          var h = new y(this), _ = y.valueOf(1), I = Math.abs(o);
          if (I > 1) for (; I > 0; ) I % 2 == 1 && _.selfMultiply(h), (I /= 2) > 0 && (h = h.sqr());
          else _ = h;
          return o < 0 ? _.reciprocal() : _;
        } }, { key: "ceil", value: function() {
          if (this.isNaN()) return y.NaN;
          var o = Math.ceil(this._hi), h = 0;
          return o === this._hi && (h = Math.ceil(this._lo)), new y(o, h);
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this._hi < h._hi ? -1 : this._hi > h._hi ? 1 : this._lo < h._lo ? -1 : this._lo > h._lo ? 1 : 0;
        } }, { key: "rint", value: function() {
          return this.isNaN() ? this : this.add(0.5).floor();
        } }, { key: "setValue", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return this.init(o), this;
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return this.init(h), this;
          }
        } }, { key: "max", value: function(o) {
          return this.ge(o) ? this : o;
        } }, { key: "sqrt", value: function() {
          if (this.isZero()) return y.valueOf(0);
          if (this.isNegative()) return y.NaN;
          var o = 1 / Math.sqrt(this._hi), h = this._hi * o, _ = y.valueOf(h), I = this.subtract(_.sqr())._hi * (0.5 * o);
          return _.add(I);
        } }, { key: "selfAdd", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return this.selfAdd(o._hi, o._lo);
            }
            if (typeof arguments[0] == "number") {
              var h, _, I, D, B, H = arguments[0], se = null;
              return se = (I = this._hi + H) - (D = I - this._hi), _ = (B = (se = H - D + (this._hi - se)) + this._lo) + (I - (h = I + B)), this._hi = h + _, this._lo = _ + (h - this._hi), this;
            }
          } else if (arguments.length === 2) {
            var de, $e, rt, vt, Gt = arguments[0], $t = arguments[1], Xt = null, _r = null, or = null;
            rt = this._hi + Gt, $e = this._lo + $t, _r = rt - (or = rt - this._hi), Xt = $e - (vt = $e - this._lo);
            var Gr = (de = rt + (or = (_r = Gt - or + (this._hi - _r)) + $e)) + (or = (Xt = $t - vt + (this._lo - Xt)) + (or + (rt - de))), qn = or + (de - Gr);
            return this._hi = Gr, this._lo = qn, this;
          }
        } }, { key: "selfMultiply", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof y) {
              var o = arguments[0];
              return this.selfMultiply(o._hi, o._lo);
            }
            if (typeof arguments[0] == "number") {
              var h = arguments[0];
              return this.selfMultiply(h, 0);
            }
          } else if (arguments.length === 2) {
            var _, I, D = arguments[0], B = arguments[1], H = null, se = null, de = null, $e = null;
            H = (de = y.SPLIT * this._hi) - this._hi, $e = y.SPLIT * D, H = de - H, _ = this._hi - H, se = $e - D;
            var rt = (de = this._hi * D) + ($e = H * (se = $e - se) - de + H * (I = D - se) + _ * se + _ * I + (this._hi * B + this._lo * D)), vt = $e + (H = de - rt);
            return this._hi = rt, this._lo = vt, this;
          }
        } }, { key: "selfSqr", value: function() {
          return this.selfMultiply(this);
        } }, { key: "floor", value: function() {
          if (this.isNaN()) return y.NaN;
          var o = Math.floor(this._hi), h = 0;
          return o === this._hi && (h = Math.floor(this._lo)), new y(o, h);
        } }, { key: "negate", value: function() {
          return this.isNaN() ? this : new y(-this._hi, -this._lo);
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (o) {
            if (o instanceof CloneNotSupportedException) return null;
            throw o;
          }
        } }, { key: "multiply", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return o.isNaN() ? y.createNaN() : y.copy(this).selfMultiply(o);
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return dt.isNaN(h) ? y.createNaN() : y.copy(this).selfMultiply(h, 0);
          }
        } }, { key: "isNaN", value: function() {
          return dt.isNaN(this._hi);
        } }, { key: "intValue", value: function() {
          return Math.trunc(this._hi);
        } }, { key: "toString", value: function() {
          var o = y.magnitude(this._hi);
          return o >= -3 && o <= 20 ? this.toStandardNotation() : this.toSciNotation();
        } }, { key: "toStandardNotation", value: function() {
          var o = this.getSpecialNumberString();
          if (o !== null) return o;
          var h = new Array(1).fill(null), _ = this.extractSignificantDigits(!0, h), I = h[0] + 1, D = _;
          if (_.charAt(0) === ".") D = "0" + _;
          else if (I < 0) D = "0." + y.stringOfChar("0", -I) + _;
          else if (_.indexOf(".") === -1) {
            var B = I - _.length;
            D = _ + y.stringOfChar("0", B) + ".0";
          }
          return this.isNegative() ? "-" + D : D;
        } }, { key: "reciprocal", value: function() {
          var o, h, _, I, D = null, B = null, H = null, se = null;
          o = (_ = 1 / this._hi) - (D = (H = y.SPLIT * _) - (D = H - _)), B = (se = y.SPLIT * this._hi) - this._hi;
          var de = _ + (H = (1 - (I = _ * this._hi) - (se = D * (B = se - B) - I + D * (h = this._hi - B) + o * B + o * h) - _ * this._lo) / this._hi);
          return new y(de, _ - de + H);
        } }, { key: "toSciNotation", value: function() {
          if (this.isZero()) return y.SCI_NOT_ZERO;
          var o = this.getSpecialNumberString();
          if (o !== null) return o;
          var h = new Array(1).fill(null), _ = this.extractSignificantDigits(!1, h), I = y.SCI_NOT_EXPONENT_CHAR + h[0];
          if (_.charAt(0) === "0") throw new IllegalStateException("Found leading zero: " + _);
          var D = "";
          _.length > 1 && (D = _.substring(1));
          var B = _.charAt(0) + "." + D;
          return this.isNegative() ? "-" + B + I : B + I;
        } }, { key: "abs", value: function() {
          return this.isNaN() ? y.NaN : this.isNegative() ? this.negate() : new y(this);
        } }, { key: "isPositive", value: function() {
          return this._hi > 0 || this._hi === 0 && this._lo > 0;
        } }, { key: "lt", value: function(o) {
          return this._hi < o._hi || this._hi === o._hi && this._lo < o._lo;
        } }, { key: "add", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return y.copy(this).selfAdd(o);
          }
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return y.copy(this).selfAdd(h);
          }
        } }, { key: "init", value: function() {
          if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var o = arguments[0];
              this._hi = o, this._lo = 0;
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this._hi = h._hi, this._lo = h._lo;
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this._hi = _, this._lo = I;
          }
        } }, { key: "gt", value: function(o) {
          return this._hi > o._hi || this._hi === o._hi && this._lo > o._lo;
        } }, { key: "isNegative", value: function() {
          return this._hi < 0 || this._hi === 0 && this._lo < 0;
        } }, { key: "trunc", value: function() {
          return this.isNaN() ? y.NaN : this.isPositive() ? this.floor() : this.ceil();
        } }, { key: "signum", value: function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [ie, ot, Q];
        } }], [{ key: "constructor_", value: function() {
          if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var o = arguments[0];
              this.init(o);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this.init(h);
            } else if (typeof arguments[0] == "string") {
              var _ = arguments[0];
              y.constructor_.call(this, y.parse(_));
            }
          } else if (arguments.length === 2) {
            var I = arguments[0], D = arguments[1];
            this.init(I, D);
          }
        } }, { key: "determinant", value: function() {
          if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], h = arguments[1], _ = arguments[2], I = arguments[3];
            return y.determinant(y.valueOf(o), y.valueOf(h), y.valueOf(_), y.valueOf(I));
          }
          if (arguments[3] instanceof y && arguments[2] instanceof y && arguments[0] instanceof y && arguments[1] instanceof y) {
            var D = arguments[1], B = arguments[2], H = arguments[3];
            return arguments[0].multiply(H).selfSubtract(D.multiply(B));
          }
        } }, { key: "sqr", value: function(o) {
          return y.valueOf(o).selfMultiply(o);
        } }, { key: "valueOf", value: function() {
          if (typeof arguments[0] == "string") {
            var o = arguments[0];
            return y.parse(o);
          }
          if (typeof arguments[0] == "number") return new y(arguments[0]);
        } }, { key: "sqrt", value: function(o) {
          return y.valueOf(o).sqrt();
        } }, { key: "parse", value: function(o) {
          for (var h = 0, _ = o.length; K.isWhitespace(o.charAt(h)); ) h++;
          var I = !1;
          if (h < _) {
            var D = o.charAt(h);
            D !== "-" && D !== "+" || (h++, D === "-" && (I = !0));
          }
          for (var B = new y(), H = 0, se = 0, de = 0, $e = !1; !(h >= _); ) {
            var rt = o.charAt(h);
            if (h++, K.isDigit(rt)) {
              var vt = rt - "0";
              B.selfMultiply(y.TEN), B.selfAdd(vt), H++;
            } else {
              if (rt !== ".") {
                if (rt === "e" || rt === "E") {
                  var Gt = o.substring(h);
                  try {
                    de = He.parseInt(Gt);
                  } catch (Gr) {
                    throw Gr instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + Gt + " in string " + o) : Gr;
                  }
                  break;
                }
                throw new NumberFormatException("Unexpected character '" + rt + "' at position " + h + " in string " + o);
              }
              se = H, $e = !0;
            }
          }
          var $t = B;
          $e || (se = H);
          var Xt = H - se - de;
          if (Xt === 0) $t = B;
          else if (Xt > 0) {
            var _r = y.TEN.pow(Xt);
            $t = B.divide(_r);
          } else if (Xt < 0) {
            var or = y.TEN.pow(-Xt);
            $t = B.multiply(or);
          }
          return I ? $t.negate() : $t;
        } }, { key: "createNaN", value: function() {
          return new y(dt.NaN, dt.NaN);
        } }, { key: "copy", value: function(o) {
          return new y(o);
        } }, { key: "magnitude", value: function(o) {
          var h = Math.abs(o), _ = Math.log(h) / Math.log(10), I = Math.trunc(Math.floor(_));
          return 10 * Math.pow(10, I) <= h && (I += 1), I;
        } }, { key: "stringOfChar", value: function(o, h) {
          for (var _ = new Kr(), I = 0; I < h; I++) _.append(o);
          return _.toString();
        } }]);
      })();
      J.PI = new J(3.141592653589793, 12246467991473532e-32), J.TWO_PI = new J(6.283185307179586, 24492935982947064e-32), J.PI_2 = new J(1.5707963267948966, 6123233995736766e-32), J.E = new J(2.718281828459045, 14456468917292502e-32), J.NaN = new J(dt.NaN, dt.NaN), J.EPS = 123259516440783e-46, J.SPLIT = 134217729, J.MAX_PRINT_DIGITS = 32, J.TEN = J.valueOf(10), J.ONE = J.valueOf(1), J.SCI_NOT_EXPONENT_CHAR = "E", J.SCI_NOT_ZERO = "0.0E0";
      var le = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "orientationIndex", value: function(o, h, _) {
          var I = y.orientationIndexFilter(o, h, _);
          if (I <= 1) return I;
          var D = J.valueOf(h.x).selfAdd(-o.x), B = J.valueOf(h.y).selfAdd(-o.y), H = J.valueOf(_.x).selfAdd(-h.x), se = J.valueOf(_.y).selfAdd(-h.y);
          return D.selfMultiply(se).selfSubtract(B.selfMultiply(H)).signum();
        } }, { key: "signOfDet2x2", value: function() {
          if (arguments[3] instanceof J && arguments[2] instanceof J && arguments[0] instanceof J && arguments[1] instanceof J) {
            var o = arguments[1], h = arguments[2], _ = arguments[3];
            return arguments[0].multiply(_).selfSubtract(o.multiply(h)).signum();
          }
          if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var I = arguments[0], D = arguments[1], B = arguments[2], H = arguments[3], se = J.valueOf(I), de = J.valueOf(D), $e = J.valueOf(B), rt = J.valueOf(H);
            return se.multiply(rt).selfSubtract(de.multiply($e)).signum();
          }
        } }, { key: "intersection", value: function(o, h, _, I) {
          var D = new J(o.y).selfSubtract(h.y), B = new J(h.x).selfSubtract(o.x), H = new J(o.x).selfMultiply(h.y).selfSubtract(new J(h.x).selfMultiply(o.y)), se = new J(_.y).selfSubtract(I.y), de = new J(I.x).selfSubtract(_.x), $e = new J(_.x).selfMultiply(I.y).selfSubtract(new J(I.x).selfMultiply(_.y)), rt = B.multiply($e).selfSubtract(de.multiply(H)), vt = se.multiply(H).selfSubtract(D.multiply($e)), Gt = D.multiply(de).selfSubtract(se.multiply(B)), $t = rt.selfDivide(Gt).doubleValue(), Xt = vt.selfDivide(Gt).doubleValue();
          return dt.isNaN($t) || dt.isInfinite($t) || dt.isNaN(Xt) || dt.isInfinite(Xt) ? null : new Ze($t, Xt);
        } }, { key: "orientationIndexFilter", value: function(o, h, _) {
          var I = null, D = (o.x - _.x) * (h.y - _.y), B = (o.y - _.y) * (h.x - _.x), H = D - B;
          if (D > 0) {
            if (B <= 0) return y.signum(H);
            I = D + B;
          } else {
            if (!(D < 0) || B >= 0) return y.signum(H);
            I = -D - B;
          }
          var se = y.DP_SAFE_EPSILON * I;
          return H >= se || -H >= se ? y.signum(H) : 2;
        } }, { key: "signum", value: function(o) {
          return o > 0 ? 1 : o < 0 ? -1 : 0;
        } }]);
      })();
      le.DP_SAFE_EPSILON = 1e-15;
      var be = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "getM", value: function(y) {
          if (this.hasM()) {
            var o = this.getDimension() - this.getMeasures();
            return this.getOrdinate(y, o);
          }
          return dt.NaN;
        } }, { key: "setOrdinate", value: function(y, o, h) {
        } }, { key: "getZ", value: function(y) {
          return this.hasZ() ? this.getOrdinate(y, 2) : dt.NaN;
        } }, { key: "size", value: function() {
        } }, { key: "getOrdinate", value: function(y, o) {
        } }, { key: "getCoordinate", value: function() {
        } }, { key: "getCoordinateCopy", value: function(y) {
        } }, { key: "createCoordinate", value: function() {
        } }, { key: "getDimension", value: function() {
        } }, { key: "hasM", value: function() {
          return this.getMeasures() > 0;
        } }, { key: "getX", value: function(y) {
        } }, { key: "hasZ", value: function() {
          return this.getDimension() - this.getMeasures() > 2;
        } }, { key: "getMeasures", value: function() {
          return 0;
        } }, { key: "expandEnvelope", value: function(y) {
        } }, { key: "copy", value: function() {
        } }, { key: "getY", value: function(y) {
        } }, { key: "toCoordinateArray", value: function() {
        } }, { key: "interfaces_", get: function() {
          return [Q];
        } }]);
      })();
      be.X = 0, be.Y = 1, be.Z = 2, be.M = 3;
      var ye = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "index", value: function(o, h, _) {
          return le.orientationIndex(o, h, _);
        } }, { key: "isCCW", value: function() {
          if (arguments[0] instanceof Array) {
            var o = arguments[0], h = o.length - 1;
            if (h < 3) throw new et("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var _ = o[0], I = 0, D = 1; D <= h; D++) {
              var B = o[D];
              B.y > _.y && (_ = B, I = D);
            }
            var H = I;
            do
              (H -= 1) < 0 && (H = h);
            while (o[H].equals2D(_) && H !== I);
            var se = I;
            do
              se = (se + 1) % h;
            while (o[se].equals2D(_) && se !== I);
            var de = o[H], $e = o[se];
            if (de.equals2D(_) || $e.equals2D(_) || de.equals2D($e)) return !1;
            var rt = y.index(de, _, $e);
            return rt === 0 ? de.x > $e.x : rt > 0;
          }
          if (er(arguments[0], be)) {
            var vt = arguments[0], Gt = vt.size() - 1;
            if (Gt < 3) throw new et("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var $t = vt.getCoordinate(0), Xt = 0, _r = 1; _r <= Gt; _r++) {
              var or = vt.getCoordinate(_r);
              or.y > $t.y && ($t = or, Xt = _r);
            }
            var Gr = null, qn = Xt;
            do
              (qn -= 1) < 0 && (qn = Gt), Gr = vt.getCoordinate(qn);
            while (Gr.equals2D($t) && qn !== Xt);
            var $n = null, ji = Xt;
            do
              ji = (ji + 1) % Gt, $n = vt.getCoordinate(ji);
            while ($n.equals2D($t) && ji !== Xt);
            if (Gr.equals2D($t) || $n.equals2D($t) || Gr.equals2D($n)) return !1;
            var aa = y.index(Gr, $t, $n);
            return aa === 0 ? Gr.x > $n.x : aa > 0;
          }
        } }]);
      })();
      ye.CLOCKWISE = -1, ye.RIGHT = ye.CLOCKWISE, ye.COUNTERCLOCKWISE = 1, ye.LEFT = ye.COUNTERCLOCKWISE, ye.COLLINEAR = 0, ye.STRAIGHT = ye.COLLINEAR;
      var Je = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinate", value: function() {
          return this._minCoord;
        } }, { key: "getRightmostSide", value: function(y, o) {
          var h = this.getRightmostSideOfSegment(y, o);
          return h < 0 && (h = this.getRightmostSideOfSegment(y, o - 1)), h < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(y)), h;
        } }, { key: "findRightmostEdgeAtVertex", value: function() {
          var y = this._minDe.getEdge().getCoordinates();
          Pt.isTrue(this._minIndex > 0 && this._minIndex < y.length, "rightmost point expected to be interior vertex of edge");
          var o = y[this._minIndex - 1], h = y[this._minIndex + 1], _ = ye.index(this._minCoord, h, o), I = !1;
          (o.y < this._minCoord.y && h.y < this._minCoord.y && _ === ye.COUNTERCLOCKWISE || o.y > this._minCoord.y && h.y > this._minCoord.y && _ === ye.CLOCKWISE) && (I = !0), I && (this._minIndex = this._minIndex - 1);
        } }, { key: "getRightmostSideOfSegment", value: function(y, o) {
          var h = y.getEdge().getCoordinates();
          if (o < 0 || o + 1 >= h.length || h[o].y === h[o + 1].y) return -1;
          var _ = St.LEFT;
          return h[o].y < h[o + 1].y && (_ = St.RIGHT), _;
        } }, { key: "getEdge", value: function() {
          return this._orientedDe;
        } }, { key: "checkForRightmostCoordinate", value: function(y) {
          for (var o = y.getEdge().getCoordinates(), h = 0; h < o.length - 1; h++) (this._minCoord === null || o[h].x > this._minCoord.x) && (this._minDe = y, this._minIndex = h, this._minCoord = o[h]);
        } }, { key: "findRightmostEdgeAtNode", value: function() {
          var y = this._minDe.getNode().getEdges();
          this._minDe = y.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        } }, { key: "findEdge", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); ) {
            var h = o.next();
            h.isForward() && this.checkForRightmostCoordinate(h);
          }
          Pt.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === St.LEFT && (this._orientedDe = this._minDe.getSym());
        } }], [{ key: "constructor_", value: function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        } }]);
      })(), qe = (function(y) {
        function o(h, _) {
          var I;
          return x(this, o), (I = p(this, o, [_ ? h + " [ " + _ + " ]" : h])).pt = _ ? new Ze(_) : void 0, I.name = Object.keys({ TopologyException: o })[0], I;
        }
        return $(o, y), u(o, [{ key: "getCoordinate", value: function() {
          return this.pt;
        } }]);
      })(Ht), Be = (function() {
        return u((function y() {
          x(this, y), this.array = [];
        }), [{ key: "addLast", value: function(y) {
          this.array.push(y);
        } }, { key: "removeFirst", value: function() {
          return this.array.shift();
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }]);
      })(), ze = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o)).array = [], h instanceof br && _.addAll(h), _;
        }
        return $(o, y), u(o, [{ key: "interfaces_", get: function() {
          return [In, br];
        } }, { key: "ensureCapacity", value: function() {
        } }, { key: "add", value: function(h) {
          return arguments.length === 1 ? this.array.push(h) : this.array.splice(arguments[0], 0, arguments[1]), !0;
        } }, { key: "clear", value: function() {
          this.array = [];
        } }, { key: "addAll", value: function(h) {
          var _, I = R(h);
          try {
            for (I.s(); !(_ = I.n()).done; ) {
              var D = _.value;
              this.array.push(D);
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
        } }, { key: "set", value: function(h, _) {
          var I = this.array[h];
          return this.array[h] = _, I;
        } }, { key: "iterator", value: function() {
          return new ft(this);
        } }, { key: "get", value: function(h) {
          if (h < 0 || h >= this.size()) throw new Zi();
          return this.array[h];
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }, { key: "sort", value: function(h) {
          h ? this.array.sort((function(_, I) {
            return h.compare(_, I);
          })) : this.array.sort();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "remove", value: function(h) {
          for (var _ = 0, I = this.array.length; _ < I; _++) if (this.array[_] === h) return !!this.array.splice(_, 1);
          return !1;
        } }, { key: Symbol.iterator, value: function() {
          return this.array.values();
        } }]);
      })(In), ft = (function() {
        return u((function y(o) {
          x(this, y), this.arrayList = o, this.position = 0;
        }), [{ key: "next", value: function() {
          if (this.position === this.arrayList.size()) throw new ur();
          return this.arrayList.get(this.position++);
        } }, { key: "hasNext", value: function() {
          return this.position < this.arrayList.size();
        } }, { key: "set", value: function(y) {
          return this.arrayList.set(this.position - 1, y);
        } }, { key: "remove", value: function() {
          this.arrayList.remove(this.arrayList.get(this.position));
        } }]);
      })(), ct = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "clearVisitedEdges", value: function() {
          for (var y = this._dirEdgeList.iterator(); y.hasNext(); )
            y.next().setVisited(!1);
        } }, { key: "getRightmostCoordinate", value: function() {
          return this._rightMostCoord;
        } }, { key: "computeNodeDepth", value: function(y) {
          for (var o = null, h = y.getEdges().iterator(); h.hasNext(); ) {
            var _ = h.next();
            if (_.isVisited() || _.getSym().isVisited()) {
              o = _;
              break;
            }
          }
          if (o === null) throw new qe("unable to find edge to compute depths at " + y.getCoordinate());
          y.getEdges().computeDepths(o);
          for (var I = y.getEdges().iterator(); I.hasNext(); ) {
            var D = I.next();
            D.setVisited(!0), this.copySymDepths(D);
          }
        } }, { key: "computeDepth", value: function(y) {
          this.clearVisitedEdges();
          var o = this._finder.getEdge();
          o.getNode(), o.getLabel(), o.setEdgeDepths(St.RIGHT, y), this.copySymDepths(o), this.computeDepths(o);
        } }, { key: "create", value: function(y) {
          this.addReachable(y), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        } }, { key: "findResultEdges", value: function() {
          for (var y = this._dirEdgeList.iterator(); y.hasNext(); ) {
            var o = y.next();
            o.getDepth(St.RIGHT) >= 1 && o.getDepth(St.LEFT) <= 0 && !o.isInteriorAreaEdge() && o.setInResult(!0);
          }
        } }, { key: "computeDepths", value: function(y) {
          var o = new Nr(), h = new Be(), _ = y.getNode();
          for (h.addLast(_), o.add(_), y.setVisited(!0); !h.isEmpty(); ) {
            var I = h.removeFirst();
            o.add(I), this.computeNodeDepth(I);
            for (var D = I.getEdges().iterator(); D.hasNext(); ) {
              var B = D.next().getSym();
              if (!B.isVisited()) {
                var H = B.getNode();
                o.contains(H) || (h.addLast(H), o.add(H));
              }
            }
          }
        } }, { key: "compareTo", value: function(y) {
          var o = y;
          return this._rightMostCoord.x < o._rightMostCoord.x ? -1 : this._rightMostCoord.x > o._rightMostCoord.x ? 1 : 0;
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            for (var y = new lr(), o = this._dirEdgeList.iterator(); o.hasNext(); ) for (var h = o.next().getEdge().getCoordinates(), _ = 0; _ < h.length - 1; _++) y.expandToInclude(h[_]);
            this._env = y;
          }
          return this._env;
        } }, { key: "addReachable", value: function(y) {
          var o = new Ks();
          for (o.add(y); !o.empty(); ) {
            var h = o.pop();
            this.add(h, o);
          }
        } }, { key: "copySymDepths", value: function(y) {
          var o = y.getSym();
          o.setDepth(St.LEFT, y.getDepth(St.RIGHT)), o.setDepth(St.RIGHT, y.getDepth(St.LEFT));
        } }, { key: "add", value: function(y, o) {
          y.setVisited(!0), this._nodes.add(y);
          for (var h = y.getEdges().iterator(); h.hasNext(); ) {
            var _ = h.next();
            this._dirEdgeList.add(_);
            var I = _.getSym().getNode();
            I.isVisited() || o.push(I);
          }
        } }, { key: "getNodes", value: function() {
          return this._nodes;
        } }, { key: "getDirectedEdges", value: function() {
          return this._dirEdgeList;
        } }, { key: "interfaces_", get: function() {
          return [ot];
        } }], [{ key: "constructor_", value: function() {
          this._finder = null, this._dirEdgeList = new ze(), this._nodes = new ze(), this._rightMostCoord = null, this._env = null, this._finder = new Je();
        } }]);
      })(), Lt = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "intersection", value: function(y, o, h, _) {
          var I = y.x < o.x ? y.x : o.x, D = y.y < o.y ? y.y : o.y, B = y.x > o.x ? y.x : o.x, H = y.y > o.y ? y.y : o.y, se = h.x < _.x ? h.x : _.x, de = h.y < _.y ? h.y : _.y, $e = h.x > _.x ? h.x : _.x, rt = h.y > _.y ? h.y : _.y, vt = ((I > se ? I : se) + (B < $e ? B : $e)) / 2, Gt = ((D > de ? D : de) + (H < rt ? H : rt)) / 2, $t = y.x - vt, Xt = y.y - Gt, _r = o.x - vt, or = o.y - Gt, Gr = h.x - vt, qn = h.y - Gt, $n = _.x - vt, ji = _.y - Gt, aa = Xt - or, Go = _r - $t, so = $t * or - _r * Xt, jo = qn - ji, Tu = $n - Gr, Pa = Gr * ji - $n * qn, Aa = aa * Tu - jo * Go, Cl = (Go * Pa - Tu * so) / Aa, Vo = (jo * so - aa * Pa) / Aa;
          return dt.isNaN(Cl) || dt.isInfinite(Cl) || dt.isNaN(Vo) || dt.isInfinite(Vo) ? null : new Ze(Cl + vt, Vo + Gt);
        } }]);
      })(), Nt = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "arraycopy", value: function(y, o, h, _, I) {
          for (var D = 0, B = o; B < o + I; B++) h[_ + D] = y[B], D++;
        } }, { key: "getProperty", value: function(y) {
          return { "line.separator": `
` }[y];
        } }]);
      })(), Wt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "log10", value: function(o) {
          var h = Math.log(o);
          return dt.isInfinite(h) || dt.isNaN(h) ? h : h / y.LOG_10;
        } }, { key: "min", value: function(o, h, _, I) {
          var D = o;
          return h < D && (D = h), _ < D && (D = _), I < D && (D = I), D;
        } }, { key: "clamp", value: function() {
          if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], h = arguments[1], _ = arguments[2];
            return o < h ? h : o > _ ? _ : o;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var I = arguments[0], D = arguments[1], B = arguments[2];
            return I < D ? D : I > B ? B : I;
          }
        } }, { key: "wrap", value: function(o, h) {
          return o < 0 ? h - -o % h : o % h;
        } }, { key: "max", value: function() {
          if (arguments.length === 3) {
            var o = arguments[1], h = arguments[2], _ = arguments[0];
            return o > _ && (_ = o), h > _ && (_ = h), _;
          }
          if (arguments.length === 4) {
            var I = arguments[1], D = arguments[2], B = arguments[3], H = arguments[0];
            return I > H && (H = I), D > H && (H = D), B > H && (H = B), H;
          }
        } }, { key: "average", value: function(o, h) {
          return (o + h) / 2;
        } }]);
      })();
      Wt.LOG_10 = Math.log(10);
      var cr = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "segmentToSegment", value: function(o, h, _, I) {
          if (o.equals(h)) return y.pointToSegment(o, _, I);
          if (_.equals(I)) return y.pointToSegment(I, o, h);
          var D = !1;
          if (lr.intersects(o, h, _, I)) {
            var B = (h.x - o.x) * (I.y - _.y) - (h.y - o.y) * (I.x - _.x);
            if (B === 0) D = !0;
            else {
              var H = (o.y - _.y) * (I.x - _.x) - (o.x - _.x) * (I.y - _.y), se = ((o.y - _.y) * (h.x - o.x) - (o.x - _.x) * (h.y - o.y)) / B, de = H / B;
              (de < 0 || de > 1 || se < 0 || se > 1) && (D = !0);
            }
          } else D = !0;
          return D ? Wt.min(y.pointToSegment(o, _, I), y.pointToSegment(h, _, I), y.pointToSegment(_, o, h), y.pointToSegment(I, o, h)) : 0;
        } }, { key: "pointToSegment", value: function(o, h, _) {
          if (h.x === _.x && h.y === _.y) return o.distance(h);
          var I = (_.x - h.x) * (_.x - h.x) + (_.y - h.y) * (_.y - h.y), D = ((o.x - h.x) * (_.x - h.x) + (o.y - h.y) * (_.y - h.y)) / I;
          if (D <= 0) return o.distance(h);
          if (D >= 1) return o.distance(_);
          var B = ((h.y - o.y) * (_.x - h.x) - (h.x - o.x) * (_.y - h.y)) / I;
          return Math.abs(B) * Math.sqrt(I);
        } }, { key: "pointToLinePerpendicular", value: function(o, h, _) {
          var I = (_.x - h.x) * (_.x - h.x) + (_.y - h.y) * (_.y - h.y), D = ((h.y - o.y) * (_.x - h.x) - (h.x - o.x) * (_.y - h.y)) / I;
          return Math.abs(D) * Math.sqrt(I);
        } }, { key: "pointToSegmentString", value: function(o, h) {
          if (h.length === 0) throw new et("Line array must contain at least one vertex");
          for (var _ = o.distance(h[0]), I = 0; I < h.length - 1; I++) {
            var D = y.pointToSegment(o, h[I], h[I + 1]);
            D < _ && (_ = D);
          }
          return _;
        } }]);
      })(), wr = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "create", value: function() {
          if (arguments.length === 1) arguments[0] instanceof Array || er(arguments[0], be);
          else if (arguments.length !== 2 && arguments.length === 3) {
            var y = arguments[0], o = arguments[1];
            return this.create(y, o);
          }
        } }]);
      })(), Xe = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "filter", value: function(y) {
        } }]);
      })(), Rr = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "ofLine", value: function(y) {
          var o = y.size();
          if (o <= 1) return 0;
          var h = 0, _ = new Ze();
          y.getCoordinate(0, _);
          for (var I = _.x, D = _.y, B = 1; B < o; B++) {
            y.getCoordinate(B, _);
            var H = _.x, se = _.y, de = H - I, $e = se - D;
            h += Math.sqrt(de * de + $e * $e), I = H, D = se;
          }
          return h;
        } }]);
      })(), Mn = u((function y() {
        x(this, y);
      })), qt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "copyCoord", value: function(o, h, _, I) {
          for (var D = Math.min(o.getDimension(), _.getDimension()), B = 0; B < D; B++) _.setOrdinate(I, B, o.getOrdinate(h, B));
        } }, { key: "isRing", value: function(o) {
          var h = o.size();
          return h === 0 || !(h <= 3) && o.getOrdinate(0, be.X) === o.getOrdinate(h - 1, be.X) && o.getOrdinate(0, be.Y) === o.getOrdinate(h - 1, be.Y);
        } }, { key: "scroll", value: function() {
          if (arguments.length === 2) {
            if (er(arguments[0], be) && Number.isInteger(arguments[1])) {
              var o = arguments[0], h = arguments[1];
              y.scroll(o, h, y.isRing(o));
            } else if (er(arguments[0], be) && arguments[1] instanceof Ze) {
              var _ = arguments[0], I = arguments[1], D = y.indexOf(I, _);
              if (D <= 0) return null;
              y.scroll(_, D);
            }
          } else if (arguments.length === 3) {
            var B = arguments[0], H = arguments[1], se = arguments[2];
            if (H <= 0) return null;
            for (var de = B.copy(), $e = se ? B.size() - 1 : B.size(), rt = 0; rt < $e; rt++) for (var vt = 0; vt < B.getDimension(); vt++) B.setOrdinate(rt, vt, de.getOrdinate((H + rt) % $e, vt));
            if (se) for (var Gt = 0; Gt < B.getDimension(); Gt++) B.setOrdinate($e, Gt, B.getOrdinate(0, Gt));
          }
        } }, { key: "isEqual", value: function(o, h) {
          var _ = o.size();
          if (_ !== h.size()) return !1;
          for (var I = Math.min(o.getDimension(), h.getDimension()), D = 0; D < _; D++) for (var B = 0; B < I; B++) {
            var H = o.getOrdinate(D, B), se = h.getOrdinate(D, B);
            if (o.getOrdinate(D, B) !== h.getOrdinate(D, B) && (!dt.isNaN(H) || !dt.isNaN(se))) return !1;
          }
          return !0;
        } }, { key: "minCoordinateIndex", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return y.minCoordinateIndex(o, 0, o.size() - 1);
          }
          if (arguments.length === 3) {
            for (var h = arguments[0], _ = arguments[2], I = -1, D = null, B = arguments[1]; B <= _; B++) {
              var H = h.getCoordinate(B);
              (D === null || D.compareTo(H) > 0) && (D = H, I = B);
            }
            return I;
          }
        } }, { key: "extend", value: function(o, h, _) {
          var I = o.create(_, h.getDimension()), D = h.size();
          if (y.copy(h, 0, I, 0, D), D > 0) for (var B = D; B < _; B++) y.copy(h, D - 1, I, B, 1);
          return I;
        } }, { key: "reverse", value: function(o) {
          for (var h = o.size() - 1, _ = Math.trunc(h / 2), I = 0; I <= _; I++) y.swap(o, I, h - I);
        } }, { key: "swap", value: function(o, h, _) {
          if (h === _) return null;
          for (var I = 0; I < o.getDimension(); I++) {
            var D = o.getOrdinate(h, I);
            o.setOrdinate(h, I, o.getOrdinate(_, I)), o.setOrdinate(_, I, D);
          }
        } }, { key: "copy", value: function(o, h, _, I, D) {
          for (var B = 0; B < D; B++) y.copyCoord(o, h + B, _, I + B);
        } }, { key: "ensureValidRing", value: function(o, h) {
          var _ = h.size();
          return _ === 0 ? h : _ <= 3 ? y.createClosedRing(o, h, 4) : h.getOrdinate(0, be.X) === h.getOrdinate(_ - 1, be.X) && h.getOrdinate(0, be.Y) === h.getOrdinate(_ - 1, be.Y) ? h : y.createClosedRing(o, h, _ + 1);
        } }, { key: "indexOf", value: function(o, h) {
          for (var _ = 0; _ < h.size(); _++) if (o.x === h.getOrdinate(_, be.X) && o.y === h.getOrdinate(_, be.Y)) return _;
          return -1;
        } }, { key: "createClosedRing", value: function(o, h, _) {
          var I = o.create(_, h.getDimension()), D = h.size();
          y.copy(h, 0, I, 0, D);
          for (var B = D; B < _; B++) y.copy(h, 0, I, B, 1);
          return I;
        } }, { key: "minCoordinate", value: function(o) {
          for (var h = null, _ = 0; _ < o.size(); _++) {
            var I = o.getCoordinate(_);
            (h === null || h.compareTo(I) > 0) && (h = I);
          }
          return h;
        } }]);
      })(), mt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "toDimensionSymbol", value: function(o) {
          switch (o) {
            case y.FALSE:
              return y.SYM_FALSE;
            case y.TRUE:
              return y.SYM_TRUE;
            case y.DONTCARE:
              return y.SYM_DONTCARE;
            case y.P:
              return y.SYM_P;
            case y.L:
              return y.SYM_L;
            case y.A:
              return y.SYM_A;
          }
          throw new et("Unknown dimension value: " + o);
        } }, { key: "toDimensionValue", value: function(o) {
          switch (K.toUpperCase(o)) {
            case y.SYM_FALSE:
              return y.FALSE;
            case y.SYM_TRUE:
              return y.TRUE;
            case y.SYM_DONTCARE:
              return y.DONTCARE;
            case y.SYM_P:
              return y.P;
            case y.SYM_L:
              return y.L;
            case y.SYM_A:
              return y.A;
          }
          throw new et("Unknown dimension symbol: " + o);
        } }]);
      })();
      mt.P = 0, mt.L = 1, mt.A = 2, mt.FALSE = -1, mt.TRUE = -2, mt.DONTCARE = -3, mt.SYM_FALSE = "F", mt.SYM_TRUE = "T", mt.SYM_DONTCARE = "*", mt.SYM_P = "0", mt.SYM_L = "1", mt.SYM_A = "2";
      var fn = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "filter", value: function(y) {
        } }]);
      })(), Ir = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "filter", value: function(y, o) {
        } }, { key: "isDone", value: function() {
        } }, { key: "isGeometryChanged", value: function() {
        } }]);
      })(), Pr = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeEnvelopeInternal", value: function() {
          return this.isEmpty() ? new lr() : this._points.expandEnvelope(new lr());
        } }, { key: "isRing", value: function() {
          return this.isClosed() && this.isSimple();
        } }, { key: "getCoordinates", value: function() {
          return this._points.toCoordinateArray();
        } }, { key: "copyInternal", value: function() {
          return new o(this._points.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Ut) {
            var h = arguments[0], _ = arguments[1];
            if (!this.isEquivalentClass(h)) return !1;
            var I = h;
            if (this._points.size() !== I._points.size()) return !1;
            for (var D = 0; D < this._points.size(); D++) if (!this.equal(this._points.getCoordinate(D), I._points.getCoordinate(D), _)) return !1;
            return !0;
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var h = 0; h < Math.trunc(this._points.size() / 2); h++) {
            var _ = this._points.size() - 1 - h;
            if (!this._points.getCoordinate(h).equals(this._points.getCoordinate(_))) {
              if (this._points.getCoordinate(h).compareTo(this._points.getCoordinate(_)) > 0) {
                var I = this._points.copy();
                qt.reverse(I), this._points = I;
              }
              return null;
            }
          }
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._points.getCoordinate(0);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? mt.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
        } }, { key: "reverseInternal", value: function() {
          var h = this._points.copy();
          return qt.reverse(h), this.getFactory().createLineString(h);
        } }, { key: "getEndPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
        } }, { key: "getTypeCode", value: function() {
          return Ut.TYPECODE_LINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getLength", value: function() {
          return Rr.ofLine(this._points);
        } }, { key: "getNumPoints", value: function() {
          return this._points.size();
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            for (var h = arguments[0], _ = 0, I = 0; _ < this._points.size() && I < h._points.size(); ) {
              var D = this._points.getCoordinate(_).compareTo(h._points.getCoordinate(I));
              if (D !== 0) return D;
              _++, I++;
            }
            return _ < this._points.size() ? 1 : I < h._points.size() ? -1 : 0;
          }
          if (arguments.length === 2) {
            var B = arguments[0];
            return arguments[1].compare(this._points, B._points);
          }
        } }, { key: "apply", value: function() {
          if (er(arguments[0], Xe)) for (var h = arguments[0], _ = 0; _ < this._points.size(); _++) h.filter(this._points.getCoordinate(_));
          else if (er(arguments[0], Ir)) {
            var I = arguments[0];
            if (this._points.size() === 0) return null;
            for (var D = 0; D < this._points.size() && (I.filter(this._points, D), !I.isDone()); D++) ;
            I.isGeometryChanged() && this.geometryChanged();
          } else er(arguments[0], fn) ? arguments[0].filter(this) : er(arguments[0], Ye) && arguments[0].filter(this);
        } }, { key: "getBoundary", value: function() {
          throw new tr();
        } }, { key: "isEquivalentClass", value: function(h) {
          return h instanceof o;
        } }, { key: "getCoordinateN", value: function(h) {
          return this._points.getCoordinate(h);
        } }, { key: "getGeometryType", value: function() {
          return Ut.TYPENAME_LINESTRING;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._points;
        } }, { key: "isEmpty", value: function() {
          return this._points.size() === 0;
        } }, { key: "init", value: function(h) {
          if (h === null && (h = this.getFactory().getCoordinateSequenceFactory().create([])), h.size() === 1) throw new et("Invalid number of points in LineString (found " + h.size() + " - must be 0 or >= 2)");
          this._points = h;
        } }, { key: "isCoordinate", value: function(h) {
          for (var _ = 0; _ < this._points.size(); _++) if (this._points.getCoordinate(_).equals(h)) return !0;
          return !1;
        } }, { key: "getStartPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(0);
        } }, { key: "getPointN", value: function(h) {
          return this.getFactory().createPoint(this._points.getCoordinate(h));
        } }, { key: "interfaces_", get: function() {
          return [Mn];
        } }], [{ key: "constructor_", value: function() {
          if (this._points = null, arguments.length !== 0 && arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            Ut.constructor_.call(this, _), this.init(h);
          }
        } }]);
      })(Ut), Mr = u((function y() {
        x(this, y);
      })), Yr = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeEnvelopeInternal", value: function() {
          if (this.isEmpty()) return new lr();
          var h = new lr();
          return h.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), h;
        } }, { key: "getCoordinates", value: function() {
          return this.isEmpty() ? [] : [this.getCoordinate()];
        } }, { key: "copyInternal", value: function() {
          return new o(this._coordinates.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Ut) {
            var h = arguments[0], _ = arguments[1];
            return !!this.isEquivalentClass(h) && (!(!this.isEmpty() || !h.isEmpty()) || this.isEmpty() === h.isEmpty() && this.equal(h.getCoordinate(), this.getCoordinate(), _));
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
        } }, { key: "getCoordinate", value: function() {
          return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
        } }, { key: "getBoundaryDimension", value: function() {
          return mt.FALSE;
        } }, { key: "reverseInternal", value: function() {
          return this.getFactory().createPoint(this._coordinates.copy());
        } }, { key: "getTypeCode", value: function() {
          return Ut.TYPECODE_POINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getNumPoints", value: function() {
          return this.isEmpty() ? 0 : 1;
        } }, { key: "getX", value: function() {
          if (this.getCoordinate() === null) throw new IllegalStateException("getX called on empty Point");
          return this.getCoordinate().x;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return this.getCoordinate().compareTo(h.getCoordinate());
          }
          if (arguments.length === 2) {
            var _ = arguments[0];
            return arguments[1].compare(this._coordinates, _._coordinates);
          }
        } }, { key: "apply", value: function() {
          if (er(arguments[0], Xe)) {
            var h = arguments[0];
            if (this.isEmpty()) return null;
            h.filter(this.getCoordinate());
          } else if (er(arguments[0], Ir)) {
            var _ = arguments[0];
            if (this.isEmpty()) return null;
            _.filter(this._coordinates, 0), _.isGeometryChanged() && this.geometryChanged();
          } else er(arguments[0], fn) ? arguments[0].filter(this) : er(arguments[0], Ye) && arguments[0].filter(this);
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return Ut.TYPENAME_POINT;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._coordinates;
        } }, { key: "getY", value: function() {
          if (this.getCoordinate() === null) throw new IllegalStateException("getY called on empty Point");
          return this.getCoordinate().y;
        } }, { key: "isEmpty", value: function() {
          return this._coordinates.size() === 0;
        } }, { key: "init", value: function(h) {
          h === null && (h = this.getFactory().getCoordinateSequenceFactory().create([])), Pt.isTrue(h.size() <= 1), this._coordinates = h;
        } }, { key: "isSimple", value: function() {
          return !0;
        } }, { key: "interfaces_", get: function() {
          return [Mr];
        } }], [{ key: "constructor_", value: function() {
          this._coordinates = null;
          var h = arguments[0], _ = arguments[1];
          Ut.constructor_.call(this, _), this.init(h);
        } }]);
      })(Ut), Qs = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "ofRing", value: function() {
          if (arguments[0] instanceof Array) {
            var o = arguments[0];
            return Math.abs(y.ofRingSigned(o));
          }
          if (er(arguments[0], be)) {
            var h = arguments[0];
            return Math.abs(y.ofRingSigned(h));
          }
        } }, { key: "ofRingSigned", value: function() {
          if (arguments[0] instanceof Array) {
            var o = arguments[0];
            if (o.length < 3) return 0;
            for (var h = 0, _ = o[0].x, I = 1; I < o.length - 1; I++) {
              var D = o[I].x - _, B = o[I + 1].y;
              h += D * (o[I - 1].y - B);
            }
            return h / 2;
          }
          if (er(arguments[0], be)) {
            var H = arguments[0], se = H.size();
            if (se < 3) return 0;
            var de = new Ze(), $e = new Ze(), rt = new Ze();
            H.getCoordinate(0, $e), H.getCoordinate(1, rt);
            var vt = $e.x;
            rt.x -= vt;
            for (var Gt = 0, $t = 1; $t < se - 1; $t++) de.y = $e.y, $e.x = rt.x, $e.y = rt.y, H.getCoordinate($t + 1, rt), rt.x -= vt, Gt += $e.x * (de.y - rt.y);
            return Gt / 2;
          }
        } }]);
      })(), Rn = (function() {
        return u((function y() {
          x(this, y);
        }), null, [{ key: "sort", value: function() {
          var y = arguments, o = arguments[0];
          if (arguments.length === 1) o.sort((function(vt, Gt) {
            return vt.compareTo(Gt);
          }));
          else if (arguments.length === 2) o.sort((function(vt, Gt) {
            return y[1].compare(vt, Gt);
          }));
          else if (arguments.length === 3) {
            var h = o.slice(arguments[1], arguments[2]);
            h.sort();
            var _ = o.slice(0, arguments[1]).concat(h, o.slice(arguments[2], o.length));
            o.splice(0, o.length);
            var I, D = R(_);
            try {
              for (D.s(); !(I = D.n()).done; ) {
                var B = I.value;
                o.push(B);
              }
            } catch (vt) {
              D.e(vt);
            } finally {
              D.f();
            }
          } else if (arguments.length === 4) {
            var H = o.slice(arguments[1], arguments[2]);
            H.sort((function(vt, Gt) {
              return y[3].compare(vt, Gt);
            }));
            var se = o.slice(0, arguments[1]).concat(H, o.slice(arguments[2], o.length));
            o.splice(0, o.length);
            var de, $e = R(se);
            try {
              for ($e.s(); !(de = $e.n()).done; ) {
                var rt = de.value;
                o.push(rt);
              }
            } catch (vt) {
              $e.e(vt);
            } finally {
              $e.f();
            }
          }
        } }, { key: "asList", value: function(y) {
          var o, h = new ze(), _ = R(y);
          try {
            for (_.s(); !(o = _.n()).done; ) {
              var I = o.value;
              h.add(I);
            }
          } catch (D) {
            _.e(D);
          } finally {
            _.f();
          }
          return h;
        } }, { key: "copyOf", value: function(y, o) {
          return y.slice(0, o);
        } }]);
      })(), yt = u((function y() {
        x(this, y);
      })), bn = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeEnvelopeInternal", value: function() {
          return this._shell.getEnvelopeInternal();
        } }, { key: "getCoordinates", value: function() {
          if (this.isEmpty()) return [];
          for (var h = new Array(this.getNumPoints()).fill(null), _ = -1, I = this._shell.getCoordinates(), D = 0; D < I.length; D++) h[++_] = I[D];
          for (var B = 0; B < this._holes.length; B++) for (var H = this._holes[B].getCoordinates(), se = 0; se < H.length; se++) h[++_] = H[se];
          return h;
        } }, { key: "getArea", value: function() {
          var h = 0;
          h += Qs.ofRing(this._shell.getCoordinateSequence());
          for (var _ = 0; _ < this._holes.length; _++) h -= Qs.ofRing(this._holes[_].getCoordinateSequence());
          return h;
        } }, { key: "copyInternal", value: function() {
          for (var h = this._shell.copy(), _ = new Array(this._holes.length).fill(null), I = 0; I < this._holes.length; I++) _[I] = this._holes[I].copy();
          return new o(h, _, this._factory);
        } }, { key: "isRectangle", value: function() {
          if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5) return !1;
          for (var h = this._shell.getCoordinateSequence(), _ = this.getEnvelopeInternal(), I = 0; I < 5; I++) {
            var D = h.getX(I);
            if (D !== _.getMinX() && D !== _.getMaxX()) return !1;
            var B = h.getY(I);
            if (B !== _.getMinY() && B !== _.getMaxY()) return !1;
          }
          for (var H = h.getX(0), se = h.getY(0), de = 1; de <= 4; de++) {
            var $e = h.getX(de), rt = h.getY(de);
            if ($e !== H == (rt !== se)) return !1;
            H = $e, se = rt;
          }
          return !0;
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Ut) {
            var h = arguments[0], _ = arguments[1];
            if (!this.isEquivalentClass(h)) return !1;
            var I = h, D = this._shell, B = I._shell;
            if (!D.equalsExact(B, _) || this._holes.length !== I._holes.length) return !1;
            for (var H = 0; H < this._holes.length; H++) if (!this._holes[H].equalsExact(I._holes[H], _)) return !1;
            return !0;
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          if (arguments.length === 0) {
            this._shell = this.normalized(this._shell, !0);
            for (var h = 0; h < this._holes.length; h++) this._holes[h] = this.normalized(this._holes[h], !1);
            Rn.sort(this._holes);
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            if (_.isEmpty()) return null;
            var D = _.getCoordinateSequence(), B = qt.minCoordinateIndex(D, 0, D.size() - 2);
            qt.scroll(D, B, !0), ye.isCCW(D) === I && qt.reverse(D);
          }
        } }, { key: "getCoordinate", value: function() {
          return this._shell.getCoordinate();
        } }, { key: "getNumInteriorRing", value: function() {
          return this._holes.length;
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "reverseInternal", value: function() {
          for (var h = this.getExteriorRing().reverse(), _ = new Array(this.getNumInteriorRing()).fill(null), I = 0; I < _.length; I++) _[I] = this.getInteriorRingN(I).reverse();
          return this.getFactory().createPolygon(h, _);
        } }, { key: "getTypeCode", value: function() {
          return Ut.TYPECODE_POLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getLength", value: function() {
          var h = 0;
          h += this._shell.getLength();
          for (var _ = 0; _ < this._holes.length; _++) h += this._holes[_].getLength();
          return h;
        } }, { key: "getNumPoints", value: function() {
          for (var h = this._shell.getNumPoints(), _ = 0; _ < this._holes.length; _++) h += this._holes[_].getNumPoints();
          return h;
        } }, { key: "convexHull", value: function() {
          return this.getExteriorRing().convexHull();
        } }, { key: "normalized", value: function(h, _) {
          var I = h.copy();
          return this.normalize(I, _), I;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0], _ = this._shell, I = h._shell;
            return _.compareToSameClass(I);
          }
          if (arguments.length === 2) {
            var D = arguments[1], B = arguments[0], H = this._shell, se = B._shell, de = H.compareToSameClass(se, D);
            if (de !== 0) return de;
            for (var $e = this.getNumInteriorRing(), rt = B.getNumInteriorRing(), vt = 0; vt < $e && vt < rt; ) {
              var Gt = this.getInteriorRingN(vt), $t = B.getInteriorRingN(vt), Xt = Gt.compareToSameClass($t, D);
              if (Xt !== 0) return Xt;
              vt++;
            }
            return vt < $e ? 1 : vt < rt ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (er(arguments[0], Xe)) {
            var h = arguments[0];
            this._shell.apply(h);
            for (var _ = 0; _ < this._holes.length; _++) this._holes[_].apply(h);
          } else if (er(arguments[0], Ir)) {
            var I = arguments[0];
            if (this._shell.apply(I), !I.isDone()) for (var D = 0; D < this._holes.length && (this._holes[D].apply(I), !I.isDone()); D++) ;
            I.isGeometryChanged() && this.geometryChanged();
          } else if (er(arguments[0], fn))
            arguments[0].filter(this);
          else if (er(arguments[0], Ye)) {
            var B = arguments[0];
            B.filter(this), this._shell.apply(B);
            for (var H = 0; H < this._holes.length; H++) this._holes[H].apply(B);
          }
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          var h = new Array(this._holes.length + 1).fill(null);
          h[0] = this._shell;
          for (var _ = 0; _ < this._holes.length; _++) h[_ + 1] = this._holes[_];
          return h.length <= 1 ? this.getFactory().createLinearRing(h[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(h);
        } }, { key: "getGeometryType", value: function() {
          return Ut.TYPENAME_POLYGON;
        } }, { key: "getExteriorRing", value: function() {
          return this._shell;
        } }, { key: "isEmpty", value: function() {
          return this._shell.isEmpty();
        } }, { key: "getInteriorRingN", value: function(h) {
          return this._holes[h];
        } }, { key: "interfaces_", get: function() {
          return [yt];
        } }], [{ key: "constructor_", value: function() {
          this._shell = null, this._holes = null;
          var h = arguments[0], _ = arguments[1], I = arguments[2];
          if (Ut.constructor_.call(this, I), h === null && (h = this.getFactory().createLinearRing()), _ === null && (_ = []), Ut.hasNullElements(_)) throw new et("holes must not contain null elements");
          if (h.isEmpty() && Ut.hasNonEmptyElements(_)) throw new et("shell is empty but holes are not");
          this._shell = h, this._holes = _;
        } }]);
      })(Ut), Un = (function(y) {
        function o() {
          return x(this, o), p(this, o, arguments);
        }
        return $(o, y), u(o);
      })(mi), Ps = (function(y) {
        function o(h) {
          var _;
          return x(this, o), (_ = p(this, o)).array = [], h instanceof br && _.addAll(h), _;
        }
        return $(o, y), u(o, [{ key: "contains", value: function(h) {
          var _, I = R(this.array);
          try {
            for (I.s(); !(_ = I.n()).done; )
              if (_.value.compareTo(h) === 0) return !0;
          } catch (D) {
            I.e(D);
          } finally {
            I.f();
          }
          return !1;
        } }, { key: "add", value: function(h) {
          if (this.contains(h)) return !1;
          for (var _ = 0, I = this.array.length; _ < I; _++)
            if (this.array[_].compareTo(h) === 1) return !!this.array.splice(_, 0, h);
          return this.array.push(h), !0;
        } }, { key: "addAll", value: function(h) {
          var _, I = R(h);
          try {
            for (I.s(); !(_ = I.n()).done; ) {
              var D = _.value;
              this.add(D);
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
          return !0;
        } }, { key: "remove", value: function() {
          throw new tr();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "iterator", value: function() {
          return new yi(this.array);
        } }]);
      })(Un), yi = (function() {
        return u((function y(o) {
          x(this, y), this.array = o, this.position = 0;
        }), [{ key: "next", value: function() {
          if (this.position === this.array.length) throw new ur();
          return this.array[this.position++];
        } }, { key: "hasNext", value: function() {
          return this.position < this.array.length;
        } }, { key: "remove", value: function() {
          throw new tr();
        } }]);
      })(), xt = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeEnvelopeInternal", value: function() {
          for (var h = new lr(), _ = 0; _ < this._geometries.length; _++) h.expandToInclude(this._geometries[_].getEnvelopeInternal());
          return h;
        } }, { key: "getGeometryN", value: function(h) {
          return this._geometries[h];
        } }, { key: "getCoordinates", value: function() {
          for (var h = new Array(this.getNumPoints()).fill(null), _ = -1, I = 0; I < this._geometries.length; I++) for (var D = this._geometries[I].getCoordinates(), B = 0; B < D.length; B++) h[++_] = D[B];
          return h;
        } }, { key: "getArea", value: function() {
          for (var h = 0, _ = 0; _ < this._geometries.length; _++) h += this._geometries[_].getArea();
          return h;
        } }, { key: "copyInternal", value: function() {
          for (var h = new Array(this._geometries.length).fill(null), _ = 0; _ < h.length; _++) h[_] = this._geometries[_].copy();
          return new o(h, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Ut) {
            var h = arguments[0], _ = arguments[1];
            if (!this.isEquivalentClass(h)) return !1;
            var I = h;
            if (this._geometries.length !== I._geometries.length) return !1;
            for (var D = 0; D < this._geometries.length; D++) if (!this._geometries[D].equalsExact(I._geometries[D], _)) return !1;
            return !0;
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var h = 0; h < this._geometries.length; h++) this._geometries[h].normalize();
          Rn.sort(this._geometries);
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._geometries[0].getCoordinate();
        } }, { key: "getBoundaryDimension", value: function() {
          for (var h = mt.FALSE, _ = 0; _ < this._geometries.length; _++) h = Math.max(h, this._geometries[_].getBoundaryDimension());
          return h;
        } }, { key: "reverseInternal", value: function() {
          for (var h = this._geometries.length, _ = new ze(h), I = 0; I < h; I++) _.add(this._geometries[I].reverse());
          return this.getFactory().buildGeometry(_);
        } }, { key: "getTypeCode", value: function() {
          return Ut.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getDimension", value: function() {
          for (var h = mt.FALSE, _ = 0; _ < this._geometries.length; _++) h = Math.max(h, this._geometries[_].getDimension());
          return h;
        } }, { key: "getLength", value: function() {
          for (var h = 0, _ = 0; _ < this._geometries.length; _++) h += this._geometries[_].getLength();
          return h;
        } }, { key: "getNumPoints", value: function() {
          for (var h = 0, _ = 0; _ < this._geometries.length; _++) h += this._geometries[_].getNumPoints();
          return h;
        } }, { key: "getNumGeometries", value: function() {
          return this._geometries.length;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0], _ = new Ps(Rn.asList(this._geometries)), I = new Ps(Rn.asList(h._geometries));
            return this.compare(_, I);
          }
          if (arguments.length === 2) {
            for (var D = arguments[1], B = arguments[0], H = this.getNumGeometries(), se = B.getNumGeometries(), de = 0; de < H && de < se; ) {
              var $e = this.getGeometryN(de), rt = B.getGeometryN(de), vt = $e.compareToSameClass(rt, D);
              if (vt !== 0) return vt;
              de++;
            }
            return de < H ? 1 : de < se ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (er(arguments[0], Xe)) for (var h = arguments[0], _ = 0; _ < this._geometries.length; _++) this._geometries[_].apply(h);
          else if (er(arguments[0], Ir)) {
            var I = arguments[0];
            if (this._geometries.length === 0) return null;
            for (var D = 0; D < this._geometries.length && (this._geometries[D].apply(I), !I.isDone()); D++) ;
            I.isGeometryChanged() && this.geometryChanged();
          } else if (er(arguments[0], fn)) {
            var B = arguments[0];
            B.filter(this);
            for (var H = 0; H < this._geometries.length; H++) this._geometries[H].apply(B);
          } else if (er(arguments[0], Ye)) {
            var se = arguments[0];
            se.filter(this);
            for (var de = 0; de < this._geometries.length; de++) this._geometries[de].apply(se);
          }
        } }, { key: "getBoundary", value: function() {
          return Ut.checkNotGeometryCollection(this), Pt.shouldNeverReachHere(), null;
        } }, { key: "getGeometryType", value: function() {
          return Ut.TYPENAME_GEOMETRYCOLLECTION;
        } }, { key: "isEmpty", value: function() {
          for (var h = 0; h < this._geometries.length; h++) if (!this._geometries[h].isEmpty()) return !1;
          return !0;
        } }], [{ key: "constructor_", value: function() {
          if (this._geometries = null, arguments.length !== 0 && arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            if (Ut.constructor_.call(this, _), h === null && (h = []), Ut.hasNullElements(h)) throw new et("geometries must not contain null elements");
            this._geometries = h;
          }
        } }]);
      })(Ut), ir = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "copyInternal", value: function() {
          for (var h = new Array(this._geometries.length).fill(null), _ = 0; _ < h.length; _++) h[_] = this._geometries[_].copy();
          return new o(h, this._factory);
        } }, { key: "isValid", value: function() {
          return !0;
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Ut) {
            var h = arguments[0], _ = arguments[1];
            return !!this.isEquivalentClass(h) && ce(o, "equalsExact", this, 1).call(this, h, _);
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 1 && Number.isInteger(arguments[0])) {
            var h = arguments[0];
            return this._geometries[h].getCoordinate();
          }
          return ce(o, "getCoordinate", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return mt.FALSE;
        } }, { key: "getTypeCode", value: function() {
          return Ut.TYPECODE_MULTIPOINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return Ut.TYPENAME_MULTIPOINT;
        } }, { key: "interfaces_", get: function() {
          return [Mr];
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          xt.constructor_.call(this, h, _);
        } }]);
      })(xt), rr = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "copyInternal", value: function() {
          return new o(this._points.copy(), this._factory);
        } }, { key: "getBoundaryDimension", value: function() {
          return mt.FALSE;
        } }, { key: "isClosed", value: function() {
          return !!this.isEmpty() || ce(o, "isClosed", this, 1).call(this);
        } }, { key: "reverseInternal", value: function() {
          var h = this._points.copy();
          return qt.reverse(h), this.getFactory().createLinearRing(h);
        } }, { key: "getTypeCode", value: function() {
          return Ut.TYPECODE_LINEARRING;
        } }, { key: "validateConstruction", value: function() {
          if (!this.isEmpty() && !ce(o, "isClosed", this, 1).call(this)) throw new et("Points of LinearRing do not form a closed linestring");
          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < o.MINIMUM_VALID_SIZE) throw new et("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
        } }, { key: "getGeometryType", value: function() {
          return Ut.TYPENAME_LINEARRING;
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          Pr.constructor_.call(this, h, _), this.validateConstruction();
        } }]);
      })(Pr);
      rr.MINIMUM_VALID_SIZE = 4;
      var pn = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "setOrdinate", value: function(h, _) {
          switch (h) {
            case o.X:
              this.x = _;
              break;
            case o.Y:
              this.y = _;
              break;
            default:
              throw new et("Invalid ordinate index: " + h);
          }
        } }, { key: "getZ", value: function() {
          return Ze.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(h) {
          switch (h) {
            case o.X:
              return this.x;
            case o.Y:
              return this.y;
          }
          throw new et("Invalid ordinate index: " + h);
        } }, { key: "setZ", value: function(h) {
          throw new et("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new o(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ")";
        } }, { key: "setCoordinate", value: function(h) {
          this.x = h.x, this.y = h.y, this.z = h.getZ();
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length === 0) Ze.constructor_.call(this);
          else if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var h = arguments[0];
              Ze.constructor_.call(this, h.x, h.y);
            } else if (arguments[0] instanceof Ze) {
              var _ = arguments[0];
              Ze.constructor_.call(this, _.x, _.y);
            }
          } else if (arguments.length === 2) {
            var I = arguments[0], D = arguments[1];
            Ze.constructor_.call(this, I, D, Ze.NULL_ORDINATE);
          }
        } }]);
      })(Ze);
      pn.X = 0, pn.Y = 1, pn.Z = -1, pn.M = -1;
      var zi = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(h, _) {
          switch (h) {
            case o.X:
              this.x = _;
              break;
            case o.Y:
              this.y = _;
              break;
            case o.M:
              this._m = _;
              break;
            default:
              throw new et("Invalid ordinate index: " + h);
          }
        } }, { key: "setM", value: function(h) {
          this._m = h;
        } }, { key: "getZ", value: function() {
          return Ze.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(h) {
          switch (h) {
            case o.X:
              return this.x;
            case o.Y:
              return this.y;
            case o.M:
              return this._m;
          }
          throw new et("Invalid ordinate index: " + h);
        } }, { key: "setZ", value: function(h) {
          throw new et("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new o(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(h) {
          this.x = h.x, this.y = h.y, this.z = h.getZ(), this._m = h.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, arguments.length === 0) Ze.constructor_.call(this), this._m = 0;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var h = arguments[0];
              Ze.constructor_.call(this, h.x, h.y), this._m = h._m;
            } else if (arguments[0] instanceof Ze) {
              var _ = arguments[0];
              Ze.constructor_.call(this, _.x, _.y), this._m = this.getM();
            }
          } else if (arguments.length === 3) {
            var I = arguments[0], D = arguments[1], B = arguments[2];
            Ze.constructor_.call(this, I, D, Ze.NULL_ORDINATE), this._m = B;
          }
        } }]);
      })(Ze);
      zi.X = 0, zi.Y = 1, zi.Z = -1, zi.M = 2;
      var Bi = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(h, _) {
          switch (h) {
            case Ze.X:
              this.x = _;
              break;
            case Ze.Y:
              this.y = _;
              break;
            case Ze.Z:
              this.z = _;
              break;
            case Ze.M:
              this._m = _;
              break;
            default:
              throw new et("Invalid ordinate index: " + h);
          }
        } }, { key: "setM", value: function(h) {
          this._m = h;
        } }, { key: "getOrdinate", value: function(h) {
          switch (h) {
            case Ze.X:
              return this.x;
            case Ze.Y:
              return this.y;
            case Ze.Z:
              return this.getZ();
            case Ze.M:
              return this.getM();
          }
          throw new et("Invalid ordinate index: " + h);
        } }, { key: "copy", value: function() {
          return new o(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(h) {
          this.x = h.x, this.y = h.y, this.z = h.getZ(), this._m = h.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, arguments.length === 0) Ze.constructor_.call(this), this._m = 0;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof o) {
              var h = arguments[0];
              Ze.constructor_.call(this, h), this._m = h._m;
            } else if (arguments[0] instanceof Ze) {
              var _ = arguments[0];
              Ze.constructor_.call(this, _), this._m = this.getM();
            }
          } else if (arguments.length === 4) {
            var I = arguments[0], D = arguments[1], B = arguments[2], H = arguments[3];
            Ze.constructor_.call(this, I, D, B), this._m = H;
          }
        } }]);
      })(Ze), Ee = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "measures", value: function(o) {
          return o instanceof pn ? 0 : o instanceof zi || o instanceof Bi ? 1 : 0;
        } }, { key: "dimension", value: function(o) {
          return o instanceof pn ? 2 : o instanceof zi ? 3 : o instanceof Bi ? 4 : 3;
        } }, { key: "create", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return y.create(o, 0);
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            return h === 2 ? new pn() : h === 3 && _ === 0 ? new Ze() : h === 3 && _ === 1 ? new zi() : h === 4 && _ === 1 ? new Bi() : new Ze();
          }
        } }]);
      })(), zt = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getCoordinate", value: function(h) {
          return this.get(h);
        } }, { key: "addAll", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "boolean" && er(arguments[0], br)) {
            for (var h = arguments[1], _ = !1, I = arguments[0].iterator(); I.hasNext(); ) this.add(I.next(), h), _ = !0;
            return _;
          }
          return ce(o, "addAll", this, 1).apply(this, arguments);
        } }, { key: "clone", value: function() {
          for (var h = ce(o, "clone", this, 1).call(this), _ = 0; _ < this.size(); _++) h.add(_, this.get(_).clone());
          return h;
        } }, { key: "toCoordinateArray", value: function() {
          if (arguments.length === 0) return this.toArray(o.coordArrayType);
          if (arguments.length === 1) {
            if (arguments[0]) return this.toArray(o.coordArrayType);
            for (var h = this.size(), _ = new Array(h).fill(null), I = 0; I < h; I++) _[I] = this.get(h - I - 1);
            return _;
          }
        } }, { key: "add", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return ce(o, "add", this, 1).call(this, h);
          }
          if (arguments.length === 2) {
            if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
              var _ = arguments[0], I = arguments[1];
              return this.add(_, I, !0), !0;
            }
            if (arguments[0] instanceof Ze && typeof arguments[1] == "boolean") {
              var D = arguments[0];
              if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(D)) return null;
              ce(o, "add", this, 1).call(this, D);
            } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
              var B = arguments[0], H = arguments[1];
              return this.add(B, H), !0;
            }
          } else if (arguments.length === 3) {
            if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
              var se = arguments[0], de = arguments[1];
              if (arguments[2]) for (var $e = 0; $e < se.length; $e++) this.add(se[$e], de);
              else for (var rt = se.length - 1; rt >= 0; rt--) this.add(se[rt], de);
              return !0;
            }
            if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof Ze) {
              var vt = arguments[0], Gt = arguments[1];
              if (!arguments[2]) {
                var $t = this.size();
                if ($t > 0 && (vt > 0 && this.get(vt - 1).equals2D(Gt) || vt < $t && this.get(vt).equals2D(Gt)))
                  return null;
              }
              ce(o, "add", this, 1).call(this, vt, Gt);
            }
          } else if (arguments.length === 4) {
            var Xt = arguments[0], _r = arguments[1], or = arguments[2], Gr = arguments[3], qn = 1;
            or > Gr && (qn = -1);
            for (var $n = or; $n !== Gr; $n += qn) this.add(Xt[$n], _r);
            return !0;
          }
        } }, { key: "closeRing", value: function() {
          if (this.size() > 0) {
            var h = this.get(0).copy();
            this.add(h, !1);
          }
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length !== 0) {
            if (arguments.length === 1) {
              var h = arguments[0];
              this.ensureCapacity(h.length), this.add(h, !0);
            } else if (arguments.length === 2) {
              var _ = arguments[0], I = arguments[1];
              this.ensureCapacity(_.length), this.add(_, I);
            }
          }
        } }]);
      })(ze);
      zt.coordArrayType = new Array(0).fill(null);
      var bt = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "isRing", value: function(o) {
          return !(o.length < 4) && !!o[0].equals2D(o[o.length - 1]);
        } }, { key: "ptNotInList", value: function(o, h) {
          for (var _ = 0; _ < o.length; _++) {
            var I = o[_];
            if (y.indexOf(I, h) < 0) return I;
          }
          return null;
        } }, { key: "scroll", value: function(o, h) {
          var _ = y.indexOf(h, o);
          if (_ < 0) return null;
          var I = new Array(o.length).fill(null);
          Nt.arraycopy(o, _, I, 0, o.length - _), Nt.arraycopy(o, 0, I, o.length - _, _), Nt.arraycopy(I, 0, o, 0, o.length);
        } }, { key: "equals", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            if (o === h) return !0;
            if (o === null || h === null || o.length !== h.length) return !1;
            for (var _ = 0; _ < o.length; _++) if (!o[_].equals(h[_])) return !1;
            return !0;
          }
          if (arguments.length === 3) {
            var I = arguments[0], D = arguments[1], B = arguments[2];
            if (I === D) return !0;
            if (I === null || D === null || I.length !== D.length) return !1;
            for (var H = 0; H < I.length; H++) if (B.compare(I[H], D[H]) !== 0) return !1;
            return !0;
          }
        } }, { key: "intersection", value: function(o, h) {
          for (var _ = new zt(), I = 0; I < o.length; I++) h.intersects(o[I]) && _.add(o[I], !0);
          return _.toCoordinateArray();
        } }, { key: "measures", value: function(o) {
          if (o === null || o.length === 0) return 0;
          var h, _ = 0, I = R(o);
          try {
            for (I.s(); !(h = I.n()).done; ) {
              var D = h.value;
              _ = Math.max(_, Ee.measures(D));
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
          return _;
        } }, { key: "hasRepeatedPoints", value: function(o) {
          for (var h = 1; h < o.length; h++) if (o[h - 1].equals(o[h])) return !0;
          return !1;
        } }, { key: "removeRepeatedPoints", value: function(o) {
          return y.hasRepeatedPoints(o) ? new zt(o, !1).toCoordinateArray() : o;
        } }, { key: "reverse", value: function(o) {
          for (var h = o.length - 1, _ = Math.trunc(h / 2), I = 0; I <= _; I++) {
            var D = o[I];
            o[I] = o[h - I], o[h - I] = D;
          }
        } }, { key: "removeNull", value: function(o) {
          for (var h = 0, _ = 0; _ < o.length; _++) o[_] !== null && h++;
          var I = new Array(h).fill(null);
          if (h === 0) return I;
          for (var D = 0, B = 0; B < o.length; B++) o[B] !== null && (I[D++] = o[B]);
          return I;
        } }, { key: "copyDeep", value: function() {
          if (arguments.length === 1) {
            for (var o = arguments[0], h = new Array(o.length).fill(null), _ = 0; _ < o.length; _++) h[_] = o[_].copy();
            return h;
          }
          if (arguments.length === 5) for (var I = arguments[0], D = arguments[1], B = arguments[2], H = arguments[3], se = arguments[4], de = 0; de < se; de++) B[H + de] = I[D + de].copy();
        } }, { key: "isEqualReversed", value: function(o, h) {
          for (var _ = 0; _ < o.length; _++) {
            var I = o[_], D = h[o.length - _ - 1];
            if (I.compareTo(D) !== 0) return !1;
          }
          return !0;
        } }, { key: "envelope", value: function(o) {
          for (var h = new lr(), _ = 0; _ < o.length; _++) h.expandToInclude(o[_]);
          return h;
        } }, { key: "toCoordinateArray", value: function(o) {
          return o.toArray(y.coordArrayType);
        } }, { key: "dimension", value: function(o) {
          if (o === null || o.length === 0) return 3;
          var h, _ = 0, I = R(o);
          try {
            for (I.s(); !(h = I.n()).done; ) {
              var D = h.value;
              _ = Math.max(_, Ee.dimension(D));
            }
          } catch (B) {
            I.e(B);
          } finally {
            I.f();
          }
          return _;
        } }, { key: "atLeastNCoordinatesOrNothing", value: function(o, h) {
          return h.length >= o ? h : [];
        } }, { key: "indexOf", value: function(o, h) {
          for (var _ = 0; _ < h.length; _++) if (o.equals(h[_])) return _;
          return -1;
        } }, { key: "increasingDirection", value: function(o) {
          for (var h = 0; h < Math.trunc(o.length / 2); h++) {
            var _ = o.length - 1 - h, I = o[h].compareTo(o[_]);
            if (I !== 0) return I;
          }
          return 1;
        } }, { key: "compare", value: function(o, h) {
          for (var _ = 0; _ < o.length && _ < h.length; ) {
            var I = o[_].compareTo(h[_]);
            if (I !== 0) return I;
            _++;
          }
          return _ < h.length ? -1 : _ < o.length ? 1 : 0;
        } }, { key: "minCoordinate", value: function(o) {
          for (var h = null, _ = 0; _ < o.length; _++) (h === null || h.compareTo(o[_]) > 0) && (h = o[_]);
          return h;
        } }, { key: "extract", value: function(o, h, _) {
          h = Wt.clamp(h, 0, o.length);
          var I = (_ = Wt.clamp(_, -1, o.length)) - h + 1;
          _ < 0 && (I = 0), h >= o.length && (I = 0), _ < h && (I = 0);
          var D = new Array(I).fill(null);
          if (I === 0) return D;
          for (var B = 0, H = h; H <= _; H++) D[B++] = o[H];
          return D;
        } }]);
      })(), Tr = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "compare", value: function(y, o) {
          var h = y, _ = o;
          return bt.compare(h, _);
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }]);
      })(), Qr = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "compare", value: function(y, o) {
          var h = y, _ = o;
          if (h.length < _.length) return -1;
          if (h.length > _.length) return 1;
          if (h.length === 0) return 0;
          var I = bt.compare(h, _);
          return bt.isEqualReversed(h, _) ? 0 : I;
        } }, { key: "OLDcompare", value: function(y, o) {
          var h = y, _ = o;
          if (h.length < _.length) return -1;
          if (h.length > _.length) return 1;
          if (h.length === 0) return 0;
          for (var I = bt.increasingDirection(h), D = bt.increasingDirection(_), B = I > 0 ? 0 : h.length - 1, H = D > 0 ? 0 : h.length - 1, se = 0; se < h.length; se++) {
            var de = h[B].compareTo(_[H]);
            if (de !== 0) return de;
            B += I, H += D;
          }
          return 0;
        } }, { key: "interfaces_", get: function() {
          return [Tt];
        } }]);
      })();
      bt.ForwardComparator = Tr, bt.BidirectionalComparator = Qr, bt.coordArrayType = new Array(0).fill(null);
      var Cr = (function() {
        return u((function y(o) {
          x(this, y), this.str = o;
        }), [{ key: "append", value: function(y) {
          this.str += y;
        } }, { key: "setCharAt", value: function(y, o) {
          this.str = this.str.substr(0, y) + o + this.str.substr(y + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      })(), Cn = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getM", value: function(o) {
          return this.hasM() ? this._coordinates[o].getM() : dt.NaN;
        } }, { key: "setOrdinate", value: function(o, h, _) {
          switch (h) {
            case be.X:
              this._coordinates[o].x = _;
              break;
            case be.Y:
              this._coordinates[o].y = _;
              break;
            default:
              this._coordinates[o].setOrdinate(h, _);
          }
        } }, { key: "getZ", value: function(o) {
          return this.hasZ() ? this._coordinates[o].getZ() : dt.NaN;
        } }, { key: "size", value: function() {
          return this._coordinates.length;
        } }, { key: "getOrdinate", value: function(o, h) {
          switch (h) {
            case be.X:
              return this._coordinates[o].x;
            case be.Y:
              return this._coordinates[o].y;
            default:
              return this._coordinates[o].getOrdinate(h);
          }
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return this._coordinates[o];
          }
          if (arguments.length === 2) {
            var h = arguments[0];
            arguments[1].setCoordinate(this._coordinates[h]);
          }
        } }, { key: "getCoordinateCopy", value: function(o) {
          var h = this.createCoordinate();
          return h.setCoordinate(this._coordinates[o]), h;
        } }, { key: "createCoordinate", value: function() {
          return Ee.create(this.getDimension(), this.getMeasures());
        } }, { key: "getDimension", value: function() {
          return this._dimension;
        } }, { key: "getX", value: function(o) {
          return this._coordinates[o].x;
        } }, { key: "getMeasures", value: function() {
          return this._measures;
        } }, { key: "expandEnvelope", value: function(o) {
          for (var h = 0; h < this._coordinates.length; h++) o.expandToInclude(this._coordinates[h]);
          return o;
        } }, { key: "copy", value: function() {
          for (var o = new Array(this.size()).fill(null), h = 0; h < this._coordinates.length; h++) {
            var _ = this.createCoordinate();
            _.setCoordinate(this._coordinates[h]), o[h] = _;
          }
          return new y(o, this._dimension, this._measures);
        } }, { key: "toString", value: function() {
          if (this._coordinates.length > 0) {
            var o = new Cr(17 * this._coordinates.length);
            o.append("("), o.append(this._coordinates[0]);
            for (var h = 1; h < this._coordinates.length; h++) o.append(", "), o.append(this._coordinates[h]);
            return o.append(")"), o.toString();
          }
          return "()";
        } }, { key: "getY", value: function(o) {
          return this._coordinates[o].y;
        } }, { key: "toCoordinateArray", value: function() {
          return this._coordinates;
        } }, { key: "interfaces_", get: function() {
          return [be, ie];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimension = 3, this._measures = 0, this._coordinates = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var o = arguments[0];
              y.constructor_.call(this, o, bt.dimension(o), bt.measures(o));
            } else if (Number.isInteger(arguments[0])) {
              var h = arguments[0];
              this._coordinates = new Array(h).fill(null);
              for (var _ = 0; _ < h; _++) this._coordinates[_] = new Ze();
            } else if (er(arguments[0], be)) {
              var I = arguments[0];
              if (I === null) return this._coordinates = new Array(0).fill(null), null;
              this._dimension = I.getDimension(), this._measures = I.getMeasures(), this._coordinates = new Array(I.size()).fill(null);
              for (var D = 0; D < this._coordinates.length; D++) this._coordinates[D] = I.getCoordinateCopy(D);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var B = arguments[0], H = arguments[1];
              y.constructor_.call(this, B, H, bt.measures(B));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var se = arguments[0], de = arguments[1];
              this._coordinates = new Array(se).fill(null), this._dimension = de;
              for (var $e = 0; $e < se; $e++) this._coordinates[$e] = Ee.create(de);
            }
          } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var rt = arguments[0], vt = arguments[1], Gt = arguments[2];
              this._dimension = vt, this._measures = Gt, this._coordinates = rt === null ? new Array(0).fill(null) : rt;
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var $t = arguments[0], Xt = arguments[1], _r = arguments[2];
              this._coordinates = new Array($t).fill(null), this._dimension = Xt, this._measures = _r;
              for (var or = 0; or < $t; or++) this._coordinates[or] = this.createCoordinate();
            }
          }
        } }]);
      })(), Fn = (function() {
        function y() {
          x(this, y);
        }
        return u(y, [{ key: "readResolve", value: function() {
          return y.instance();
        } }, { key: "create", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) return new Cn(arguments[0]);
            if (er(arguments[0], be)) return new Cn(arguments[0]);
          } else {
            if (arguments.length === 2) {
              var o = arguments[1];
              return o > 3 && (o = 3), o < 2 && (o = 2), new Cn(arguments[0], o);
            }
            if (arguments.length === 3) {
              var h = arguments[2], _ = arguments[1] - h;
              return h > 1 && (h = 1), _ > 3 && (_ = 3), _ < 2 && (_ = 2), new Cn(arguments[0], _ + h, h);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [wr, ie];
        } }], [{ key: "instance", value: function() {
          return y.instanceObject;
        } }]);
      })();
      Fn.instanceObject = new Fn();
      var Or = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "copyInternal", value: function() {
          for (var h = new Array(this._geometries.length).fill(null), _ = 0; _ < h.length; _++) h[_] = this._geometries[_].copy();
          return new o(h, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Ut) {
            var h = arguments[0], _ = arguments[1];
            return !!this.isEquivalentClass(h) && ce(o, "equalsExact", this, 1).call(this, h, _);
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "getTypeCode", value: function() {
          return Ut.TYPECODE_MULTIPOLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          for (var h = new ze(), _ = 0; _ < this._geometries.length; _++) for (var I = this._geometries[_].getBoundary(), D = 0; D < I.getNumGeometries(); D++) h.add(I.getGeometryN(D));
          var B = new Array(h.size()).fill(null);
          return this.getFactory().createMultiLineString(h.toArray(B));
        } }, { key: "getGeometryType", value: function() {
          return Ut.TYPENAME_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [yt];
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          xt.constructor_.call(this, h, _);
        } }]);
      })(xt), Er = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "get", value: function() {
        } }, { key: "put", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "values", value: function() {
        } }, { key: "entrySet", value: function() {
        } }]);
      })(), gn = (function(y) {
        function o() {
          var h;
          return x(this, o), (h = p(this, o)).map = /* @__PURE__ */ new Map(), h;
        }
        return $(o, y), u(o, [{ key: "get", value: function(h) {
          return this.map.get(h) || null;
        } }, { key: "put", value: function(h, _) {
          return this.map.set(h, _), _;
        } }, { key: "values", value: function() {
          for (var h = new ze(), _ = this.map.values(), I = _.next(); !I.done; ) h.add(I.value), I = _.next();
          return h;
        } }, { key: "entrySet", value: function() {
          var h = new Nr();
          return this.map.entries().forEach((function(_) {
            return h.add(_);
          })), h;
        } }, { key: "size", value: function() {
          return this.map.size();
        } }]);
      })(Er), Nn = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "equals", value: function(o) {
          if (!(o instanceof y)) return !1;
          var h = o;
          return this._modelType === h._modelType && this._scale === h._scale;
        } }, { key: "compareTo", value: function(o) {
          var h = o, _ = this.getMaximumSignificantDigits(), I = h.getMaximumSignificantDigits();
          return He.compare(_, I);
        } }, { key: "getScale", value: function() {
          return this._scale;
        } }, { key: "isFloating", value: function() {
          return this._modelType === y.FLOATING || this._modelType === y.FLOATING_SINGLE;
        } }, { key: "getType", value: function() {
          return this._modelType;
        } }, { key: "toString", value: function() {
          var o = "UNKNOWN";
          return this._modelType === y.FLOATING ? o = "Floating" : this._modelType === y.FLOATING_SINGLE ? o = "Floating-Single" : this._modelType === y.FIXED && (o = "Fixed (Scale=" + this.getScale() + ")"), o;
        } }, { key: "makePrecise", value: function() {
          if (typeof arguments[0] == "number") {
            var o = arguments[0];
            return dt.isNaN(o) || this._modelType === y.FLOATING_SINGLE ? o : this._modelType === y.FIXED ? Math.round(o * this._scale) / this._scale : o;
          }
          if (arguments[0] instanceof Ze) {
            var h = arguments[0];
            if (this._modelType === y.FLOATING) return null;
            h.x = this.makePrecise(h.x), h.y = this.makePrecise(h.y);
          }
        } }, { key: "getMaximumSignificantDigits", value: function() {
          var o = 16;
          return this._modelType === y.FLOATING ? o = 16 : this._modelType === y.FLOATING_SINGLE ? o = 6 : this._modelType === y.FIXED && (o = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), o;
        } }, { key: "setScale", value: function(o) {
          this._scale = Math.abs(o);
        } }, { key: "interfaces_", get: function() {
          return [ie, ot];
        } }], [{ key: "constructor_", value: function() {
          if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = y.FLOATING;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof Hi) {
              var o = arguments[0];
              this._modelType = o, o === y.FIXED && this.setScale(1);
            } else if (typeof arguments[0] == "number") {
              var h = arguments[0];
              this._modelType = y.FIXED, this.setScale(h);
            } else if (arguments[0] instanceof y) {
              var _ = arguments[0];
              this._modelType = _._modelType, this._scale = _._scale;
            }
          }
        } }, { key: "mostPrecise", value: function(o, h) {
          return o.compareTo(h) >= 0 ? o : h;
        } }]);
      })(), Hi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "readResolve", value: function() {
          return y.nameToTypeMap.get(this._name);
        } }, { key: "toString", value: function() {
          return this._name;
        } }, { key: "interfaces_", get: function() {
          return [ie];
        } }], [{ key: "constructor_", value: function() {
          this._name = null;
          var o = arguments[0];
          this._name = o, y.nameToTypeMap.put(o, this);
        } }]);
      })();
      Hi.nameToTypeMap = new gn(), Nn.Type = Hi, Nn.FIXED = new Hi("FIXED"), Nn.FLOATING = new Hi("FLOATING"), Nn.FLOATING_SINGLE = new Hi("FLOATING SINGLE"), Nn.maximumPreciseValue = 9007199254740992;
      var As = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "copyInternal", value: function() {
          for (var h = new Array(this._geometries.length).fill(null), _ = 0; _ < h.length; _++) h[_] = this._geometries[_].copy();
          return new o(h, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof Ut) {
            var h = arguments[0], _ = arguments[1];
            return !!this.isEquivalentClass(h) && ce(o, "equalsExact", this, 1).call(this, h, _);
          }
          return ce(o, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? mt.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          if (this.isEmpty()) return !1;
          for (var h = 0; h < this._geometries.length; h++) if (!this._geometries[h].isClosed()) return !1;
          return !0;
        } }, { key: "getTypeCode", value: function() {
          return Ut.TYPECODE_MULTILINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getBoundary", value: function() {
          throw new tr();
        } }, { key: "getGeometryType", value: function() {
          return Ut.TYPENAME_MULTILINESTRING;
        } }, { key: "interfaces_", get: function() {
          return [Mn];
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          xt.constructor_.call(this, h, _);
        } }]);
      })(xt), ni = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "createEmpty", value: function(o) {
          switch (o) {
            case -1:
              return this.createGeometryCollection();
            case 0:
              return this.createPoint();
            case 1:
              return this.createLineString();
            case 2:
              return this.createPolygon();
            default:
              throw new et("Invalid dimension: " + o);
          }
        } }, { key: "toGeometry", value: function(o) {
          return o.isNull() ? this.createPoint() : o.getMinX() === o.getMaxX() && o.getMinY() === o.getMaxY() ? this.createPoint(new Ze(o.getMinX(), o.getMinY())) : o.getMinX() === o.getMaxX() || o.getMinY() === o.getMaxY() ? this.createLineString([new Ze(o.getMinX(), o.getMinY()), new Ze(o.getMaxX(), o.getMaxY())]) : this.createPolygon(this.createLinearRing([new Ze(o.getMinX(), o.getMinY()), new Ze(o.getMinX(), o.getMaxY()), new Ze(o.getMaxX(), o.getMaxY()), new Ze(o.getMaxX(), o.getMinY()), new Ze(o.getMinX(), o.getMinY())]), null);
        } }, { key: "createLineString", value: function() {
          if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var o = arguments[0];
              return this.createLineString(o !== null ? this.getCoordinateSequenceFactory().create(o) : null);
            }
            if (er(arguments[0], be)) return new Pr(arguments[0], this);
          }
        } }, { key: "createMultiLineString", value: function() {
          return arguments.length === 0 ? new As(null, this) : arguments.length === 1 ? new As(arguments[0], this) : void 0;
        } }, { key: "buildGeometry", value: function(o) {
          for (var h = null, _ = !1, I = !1, D = o.iterator(); D.hasNext(); ) {
            var B = D.next(), H = B.getTypeCode();
            h === null && (h = H), H !== h && (_ = !0), B instanceof xt && (I = !0);
          }
          if (h === null) return this.createGeometryCollection();
          if (_ || I) return this.createGeometryCollection(y.toGeometryArray(o));
          var se = o.iterator().next();
          if (o.size() > 1) {
            if (se instanceof bn) return this.createMultiPolygon(y.toPolygonArray(o));
            if (se instanceof Pr) return this.createMultiLineString(y.toLineStringArray(o));
            if (se instanceof Yr) return this.createMultiPoint(y.toPointArray(o));
            Pt.shouldNeverReachHere("Unhandled geometry type: " + se.getGeometryType());
          }
          return se;
        } }, { key: "createMultiPointFromCoords", value: function(o) {
          return this.createMultiPoint(o !== null ? this.getCoordinateSequenceFactory().create(o) : null);
        } }, { key: "createPoint", value: function() {
          if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Ze) {
              var o = arguments[0];
              return this.createPoint(o !== null ? this.getCoordinateSequenceFactory().create([o]) : null);
            }
            if (er(arguments[0], be)) return new Yr(arguments[0], this);
          }
        } }, { key: "getCoordinateSequenceFactory", value: function() {
          return this._coordinateSequenceFactory;
        } }, { key: "createPolygon", value: function() {
          if (arguments.length === 0) return this.createPolygon(null, null);
          if (arguments.length === 1) {
            if (er(arguments[0], be)) {
              var o = arguments[0];
              return this.createPolygon(this.createLinearRing(o));
            }
            if (arguments[0] instanceof Array) {
              var h = arguments[0];
              return this.createPolygon(this.createLinearRing(h));
            }
            if (arguments[0] instanceof rr) {
              var _ = arguments[0];
              return this.createPolygon(_, null);
            }
          } else if (arguments.length === 2)
            return new bn(arguments[0], arguments[1], this);
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "createGeometryCollection", value: function() {
          return arguments.length === 0 ? new xt(null, this) : arguments.length === 1 ? new xt(arguments[0], this) : void 0;
        } }, { key: "getPrecisionModel", value: function() {
          return this._precisionModel;
        } }, { key: "createLinearRing", value: function() {
          if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var o = arguments[0];
              return this.createLinearRing(o !== null ? this.getCoordinateSequenceFactory().create(o) : null);
            }
            if (er(arguments[0], be)) return new rr(arguments[0], this);
          }
        } }, { key: "createMultiPolygon", value: function() {
          return arguments.length === 0 ? new Or(null, this) : arguments.length === 1 ? new Or(arguments[0], this) : void 0;
        } }, { key: "createMultiPoint", value: function() {
          if (arguments.length === 0) return new ir(null, this);
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) return new ir(arguments[0], this);
            if (er(arguments[0], be)) {
              var o = arguments[0];
              if (o === null) return this.createMultiPoint(new Array(0).fill(null));
              for (var h = new Array(o.size()).fill(null), _ = 0; _ < o.size(); _++) {
                var I = this.getCoordinateSequenceFactory().create(1, o.getDimension(), o.getMeasures());
                qt.copy(o, _, I, 0, 1), h[_] = this.createPoint(I);
              }
              return this.createMultiPoint(h);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [ie];
        } }], [{ key: "constructor_", value: function() {
          if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, arguments.length === 0) y.constructor_.call(this, new Nn(), 0);
          else if (arguments.length === 1) {
            if (er(arguments[0], wr)) {
              var o = arguments[0];
              y.constructor_.call(this, new Nn(), 0, o);
            } else if (arguments[0] instanceof Nn) {
              var h = arguments[0];
              y.constructor_.call(this, h, 0, y.getDefaultCoordinateSequenceFactory());
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            y.constructor_.call(this, _, I, y.getDefaultCoordinateSequenceFactory());
          } else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], H = arguments[2];
            this._precisionModel = D, this._coordinateSequenceFactory = H, this._SRID = B;
          }
        } }, { key: "toMultiPolygonArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toGeometryArray", value: function(o) {
          if (o === null) return null;
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "getDefaultCoordinateSequenceFactory", value: function() {
          return Fn.instance();
        } }, { key: "toMultiLineStringArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toLineStringArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toMultiPointArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toLinearRingArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toPointArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "toPolygonArray", value: function(o) {
          var h = new Array(o.size()).fill(null);
          return o.toArray(h);
        } }, { key: "createPointFromInternalCoord", value: function(o, h) {
          return h.getPrecisionModel().makePrecise(o), h.getFactory().createPoint(o);
        } }]);
      })(), yl = "XY", ba = "XYZ", vl = "XYM", on = "XYZM", su = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, au = "EMPTY", ea = 1, vs = 2, Ls = 3, ou = 4, Ds = 5, lu = 6;
      for (var uu in su) su[uu].toUpperCase();
      var cu = (function() {
        return u((function y(o) {
          x(this, y), this.wkt = o, this.index_ = -1;
        }), [{ key: "isAlpha_", value: function(y) {
          return y >= "a" && y <= "z" || y >= "A" && y <= "Z";
        } }, { key: "isNumeric_", value: function(y, o) {
          return y >= "0" && y <= "9" || y == "." && !(o !== void 0 && o);
        } }, { key: "isWhiteSpace_", value: function(y) {
          return y == " " || y == "	" || y == "\r" || y == `
`;
        } }, { key: "nextChar_", value: function() {
          return this.wkt.charAt(++this.index_);
        } }, { key: "nextToken", value: function() {
          var y, o = this.nextChar_(), h = this.index_, _ = o;
          if (o == "(") y = vs;
          else if (o == ",") y = Ds;
          else if (o == ")") y = Ls;
          else if (this.isNumeric_(o) || o == "-") y = ou, _ = this.readNumber_();
          else if (this.isAlpha_(o)) y = ea, _ = this.readText_();
          else {
            if (this.isWhiteSpace_(o)) return this.nextToken();
            if (o !== "") throw new Error("Unexpected character: " + o);
            y = lu;
          }
          return { position: h, value: _, type: y };
        } }, { key: "readNumber_", value: function() {
          var y, o = this.index_, h = !1, _ = !1;
          do
            y == "." ? h = !0 : y != "e" && y != "E" || (_ = !0), y = this.nextChar_();
          while (this.isNumeric_(y, h) || !_ && (y == "e" || y == "E") || _ && (y == "-" || y == "+"));
          return parseFloat(this.wkt.substring(o, this.index_--));
        } }, { key: "readText_", value: function() {
          var y, o = this.index_;
          do
            y = this.nextChar_();
          while (this.isAlpha_(y));
          return this.wkt.substring(o, this.index_--).toUpperCase();
        } }]);
      })(), hu = (function() {
        return u((function y(o, h) {
          x(this, y), this.lexer_ = o, this.token_, this.layout_ = yl, this.factory = h;
        }), [{ key: "consume_", value: function() {
          this.token_ = this.lexer_.nextToken();
        } }, { key: "isTokenType", value: function(y) {
          return this.token_.type == y;
        } }, { key: "match", value: function(y) {
          var o = this.isTokenType(y);
          return o && this.consume_(), o;
        } }, { key: "parse", value: function() {
          return this.consume_(), this.parseGeometry_();
        } }, { key: "parseGeometryLayout_", value: function() {
          var y = yl, o = this.token_;
          if (this.isTokenType(ea)) {
            var h = o.value;
            h === "Z" ? y = ba : h === "M" ? y = vl : h === "ZM" && (y = on), y !== yl && this.consume_();
          }
          return y;
        } }, { key: "parseGeometryCollectionText_", value: function() {
          if (this.match(vs)) {
            var y = [];
            do
              y.push(this.parseGeometry_());
            while (this.match(Ds));
            if (this.match(Ls)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointText_", value: function() {
          if (this.match(vs)) {
            var y = this.parsePoint_();
            if (this.match(Ls)) return y;
          } else if (this.isEmptyGeometry_()) return null;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseLineStringText_", value: function() {
          if (this.match(vs)) {
            var y = this.parsePointList_();
            if (this.match(Ls)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePolygonText_", value: function() {
          if (this.match(vs)) {
            var y = this.parseLineStringTextList_();
            if (this.match(Ls)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPointText_", value: function() {
          var y;
          if (this.match(vs)) {
            if (y = this.token_.type == vs ? this.parsePointTextList_() : this.parsePointList_(), this.match(Ls)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiLineStringText_", value: function() {
          if (this.match(vs)) {
            var y = this.parseLineStringTextList_();
            if (this.match(Ls)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPolygonText_", value: function() {
          if (this.match(vs)) {
            var y = this.parsePolygonTextList_();
            if (this.match(Ls)) return y;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePoint_", value: function() {
          for (var y = [], o = this.layout_.length, h = 0; h < o; ++h) {
            var _ = this.token_;
            if (!this.match(ou)) break;
            y.push(_.value);
          }
          if (y.length == o) return y;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointList_", value: function() {
          for (var y = [this.parsePoint_()]; this.match(Ds); ) y.push(this.parsePoint_());
          return y;
        } }, { key: "parsePointTextList_", value: function() {
          for (var y = [this.parsePointText_()]; this.match(Ds); ) y.push(this.parsePointText_());
          return y;
        } }, { key: "parseLineStringTextList_", value: function() {
          for (var y = [this.parseLineStringText_()]; this.match(Ds); ) y.push(this.parseLineStringText_());
          return y;
        } }, { key: "parsePolygonTextList_", value: function() {
          for (var y = [this.parsePolygonText_()]; this.match(Ds); ) y.push(this.parsePolygonText_());
          return y;
        } }, { key: "isEmptyGeometry_", value: function() {
          var y = this.isTokenType(ea) && this.token_.value == au;
          return y && this.consume_(), y;
        } }, { key: "formatErrorMessage_", value: function() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        } }, { key: "parseGeometry_", value: function() {
          var y = this.factory, o = function(Xt) {
            return M(Ze, me(Xt));
          }, h = function(Xt) {
            var _r = Xt.map((function(or) {
              return y.createLinearRing(or.map(o));
            }));
            return _r.length > 1 ? y.createPolygon(_r[0], _r.slice(1)) : y.createPolygon(_r[0]);
          }, _ = this.token_;
          if (this.match(ea)) {
            var I = _.value;
            if (this.layout_ = this.parseGeometryLayout_(), I == "GEOMETRYCOLLECTION") {
              var D = this.parseGeometryCollectionText_();
              return y.createGeometryCollection(D);
            }
            switch (I) {
              case "POINT":
                var B = this.parsePointText_();
                return B ? y.createPoint(M(Ze, me(B))) : y.createPoint();
              case "LINESTRING":
                var H = this.parseLineStringText_().map(o);
                return y.createLineString(H);
              case "LINEARRING":
                var se = this.parseLineStringText_().map(o);
                return y.createLinearRing(se);
              case "POLYGON":
                var de = this.parsePolygonText_();
                return de && de.length !== 0 ? h(de) : y.createPolygon();
              case "MULTIPOINT":
                var $e = this.parseMultiPointText_();
                if (!$e || $e.length === 0) return y.createMultiPoint();
                var rt = $e.map(o).map((function(Xt) {
                  return y.createPoint(Xt);
                }));
                return y.createMultiPoint(rt);
              case "MULTILINESTRING":
                var vt = this.parseMultiLineStringText_().map((function(Xt) {
                  return y.createLineString(Xt.map(o));
                }));
                return y.createMultiLineString(vt);
              case "MULTIPOLYGON":
                var Gt = this.parseMultiPolygonText_();
                if (!Gt || Gt.length === 0) return y.createMultiPolygon();
                var $t = Gt.map(h);
                return y.createMultiPolygon($t);
              default:
                throw new Error("Invalid geometry type: " + I);
            }
          }
          throw new Error(this.formatErrorMessage_());
        } }]);
      })();
      function wc(y) {
        if (y.isEmpty()) return "";
        var o = y.getCoordinate(), h = [o.x, o.y];
        return o.z === void 0 || Number.isNaN(o.z) || h.push(o.z), o.m === void 0 || Number.isNaN(o.m) || h.push(o.m), h.join(" ");
      }
      function Rs(y) {
        for (var o = y.getCoordinates().map((function(D) {
          var B = [D.x, D.y];
          return D.z === void 0 || Number.isNaN(D.z) || B.push(D.z), D.m === void 0 || Number.isNaN(D.m) || B.push(D.m), B;
        })), h = [], _ = 0, I = o.length; _ < I; ++_) h.push(o[_].join(" "));
        return h.join(", ");
      }
      function Ao(y) {
        var o = [];
        o.push("(" + Rs(y.getExteriorRing()) + ")");
        for (var h = 0, _ = y.getNumInteriorRing(); h < _; ++h) o.push("(" + Rs(y.getInteriorRingN(h)) + ")");
        return o.join(", ");
      }
      var Ec = { Point: wc, LineString: Rs, LinearRing: Rs, Polygon: Ao, MultiPoint: function(y) {
        for (var o = [], h = 0, _ = y.getNumGeometries(); h < _; ++h) o.push("(" + wc(y.getGeometryN(h)) + ")");
        return o.join(", ");
      }, MultiLineString: function(y) {
        for (var o = [], h = 0, _ = y.getNumGeometries(); h < _; ++h) o.push("(" + Rs(y.getGeometryN(h)) + ")");
        return o.join(", ");
      }, MultiPolygon: function(y) {
        for (var o = [], h = 0, _ = y.getNumGeometries(); h < _; ++h) o.push("(" + Ao(y.getGeometryN(h)) + ")");
        return o.join(", ");
      }, GeometryCollection: function(y) {
        for (var o = [], h = 0, _ = y.getNumGeometries(); h < _; ++h) o.push(wa(y.getGeometryN(h)));
        return o.join(", ");
      } };
      function wa(y) {
        var o = y.getGeometryType(), h = Ec[o];
        o = o.toUpperCase();
        var _ = (function(I) {
          var D = "";
          if (I.isEmpty()) return D;
          var B = I.getCoordinate();
          return B.z === void 0 || Number.isNaN(B.z) || (D += "Z"), B.m === void 0 || Number.isNaN(B.m) || (D += "M"), D;
        })(y);
        return _.length > 0 && (o += " " + _), y.isEmpty() ? o + " " + au : o + " (" + h(y) + ")";
      }
      var du = (function() {
        return u((function y(o) {
          x(this, y), this.geometryFactory = o || new ni(), this.precisionModel = this.geometryFactory.getPrecisionModel();
        }), [{ key: "read", value: function(y) {
          var o = new cu(y);
          return new hu(o, this.geometryFactory).parse();
        } }, { key: "write", value: function(y) {
          return wa(y);
        } }]);
      })(), Ea = (function() {
        return u((function y(o) {
          x(this, y), this.parser = new du(o);
        }), [{ key: "write", value: function(y) {
          return this.parser.write(y);
        } }], [{ key: "toLineString", value: function(y, o) {
          if (arguments.length !== 2) throw new Error("Not implemented");
          return "LINESTRING ( " + y.x + " " + y.y + ", " + o.x + " " + o.y + " )";
        } }]);
      })(), Ar = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getIndexAlongSegment", value: function(o, h) {
          return this.computeIntLineIndex(), this._intLineIndex[o][h];
        } }, { key: "getTopologySummary", value: function() {
          var o = new Cr();
          return this.isEndPoint() && o.append(" endpoint"), this._isProper && o.append(" proper"), this.isCollinear() && o.append(" collinear"), o.toString();
        } }, { key: "computeIntersection", value: function(o, h, _, I) {
          this._inputLines[0][0] = o, this._inputLines[0][1] = h, this._inputLines[1][0] = _, this._inputLines[1][1] = I, this._result = this.computeIntersect(o, h, _, I);
        } }, { key: "getIntersectionNum", value: function() {
          return this._result;
        } }, { key: "computeIntLineIndex", value: function() {
          if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map((function() {
            return Array(2);
          })), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (arguments.length === 1) {
            var o = arguments[0];
            this.getEdgeDistance(o, 0) > this.getEdgeDistance(o, 1) ? (this._intLineIndex[o][0] = 0, this._intLineIndex[o][1] = 1) : (this._intLineIndex[o][0] = 1, this._intLineIndex[o][1] = 0);
          }
        } }, { key: "isProper", value: function() {
          return this.hasIntersection() && this._isProper;
        } }, { key: "setPrecisionModel", value: function(o) {
          this._precisionModel = o;
        } }, { key: "isInteriorIntersection", value: function() {
          if (arguments.length === 0) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (arguments.length === 1) {
            for (var o = arguments[0], h = 0; h < this._result; h++) if (!this._intPt[h].equals2D(this._inputLines[o][0]) && !this._intPt[h].equals2D(this._inputLines[o][1])) return !0;
            return !1;
          }
        } }, { key: "getIntersection", value: function(o) {
          return this._intPt[o];
        } }, { key: "isEndPoint", value: function() {
          return this.hasIntersection() && !this._isProper;
        } }, { key: "hasIntersection", value: function() {
          return this._result !== y.NO_INTERSECTION;
        } }, { key: "getEdgeDistance", value: function(o, h) {
          return y.computeEdgeDistance(this._intPt[h], this._inputLines[o][0], this._inputLines[o][1]);
        } }, { key: "isCollinear", value: function() {
          return this._result === y.COLLINEAR_INTERSECTION;
        } }, { key: "toString", value: function() {
          return Ea.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Ea.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        } }, { key: "getEndpoint", value: function(o, h) {
          return this._inputLines[o][h];
        } }, { key: "isIntersection", value: function(o) {
          for (var h = 0; h < this._result; h++) if (this._intPt[h].equals2D(o)) return !0;
          return !1;
        } }, { key: "getIntersectionAlongSegment", value: function(o, h) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[o][h]];
        } }], [{ key: "constructor_", value: function() {
          this._result = null, this._inputLines = Array(2).fill().map((function() {
            return Array(2);
          })), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new Ze(), this._intPt[1] = new Ze(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        } }, { key: "computeEdgeDistance", value: function(o, h, _) {
          var I = Math.abs(_.x - h.x), D = Math.abs(_.y - h.y), B = -1;
          if (o.equals(h)) B = 0;
          else if (o.equals(_)) B = I > D ? I : D;
          else {
            var H = Math.abs(o.x - h.x), se = Math.abs(o.y - h.y);
            (B = I > D ? H : se) !== 0 || o.equals(h) || (B = Math.max(H, se));
          }
          return Pt.isTrue(!(B === 0 && !o.equals(h)), "Bad distance calculation"), B;
        } }, { key: "nonRobustComputeEdgeDistance", value: function(o, h, _) {
          var I = o.x - h.x, D = o.y - h.y, B = Math.sqrt(I * I + D * D);
          return Pt.isTrue(!(B === 0 && !o.equals(h)), "Invalid distance calculation"), B;
        } }]);
      })();
      Ar.DONT_INTERSECT = 0, Ar.DO_INTERSECT = 1, Ar.COLLINEAR = 2, Ar.NO_INTERSECTION = 0, Ar.POINT_INTERSECTION = 1, Ar.COLLINEAR_INTERSECTION = 2;
      var Yi = (function(y) {
        function o() {
          return x(this, o), p(this, o);
        }
        return $(o, y), u(o, [{ key: "isInSegmentEnvelopes", value: function(h) {
          var _ = new lr(this._inputLines[0][0], this._inputLines[0][1]), I = new lr(this._inputLines[1][0], this._inputLines[1][1]);
          return _.contains(h) && I.contains(h);
        } }, { key: "computeIntersection", value: function() {
          if (arguments.length !== 3) return ce(o, "computeIntersection", this, 1).apply(this, arguments);
          var h = arguments[0], _ = arguments[1], I = arguments[2];
          if (this._isProper = !1, lr.intersects(_, I, h) && ye.index(_, I, h) === 0 && ye.index(I, _, h) === 0) return this._isProper = !0, (h.equals(_) || h.equals(I)) && (this._isProper = !1), this._result = Ar.POINT_INTERSECTION, null;
          this._result = Ar.NO_INTERSECTION;
        } }, { key: "intersection", value: function(h, _, I, D) {
          var B = this.intersectionSafe(h, _, I, D);
          return this.isInSegmentEnvelopes(B) || (B = new Ze(o.nearestEndpoint(h, _, I, D))), this._precisionModel !== null && this._precisionModel.makePrecise(B), B;
        } }, { key: "checkDD", value: function(h, _, I, D, B) {
          var H = le.intersection(h, _, I, D), se = this.isInSegmentEnvelopes(H);
          Nt.out.println("DD in env = " + se + "  --------------------- " + H), B.distance(H) > 1e-4 && Nt.out.println("Distance = " + B.distance(H));
        } }, { key: "intersectionSafe", value: function(h, _, I, D) {
          var B = Lt.intersection(h, _, I, D);
          return B === null && (B = o.nearestEndpoint(h, _, I, D)), B;
        } }, { key: "computeCollinearIntersection", value: function(h, _, I, D) {
          var B = lr.intersects(h, _, I), H = lr.intersects(h, _, D), se = lr.intersects(I, D, h), de = lr.intersects(I, D, _);
          return B && H ? (this._intPt[0] = I, this._intPt[1] = D, Ar.COLLINEAR_INTERSECTION) : se && de ? (this._intPt[0] = h, this._intPt[1] = _, Ar.COLLINEAR_INTERSECTION) : B && se ? (this._intPt[0] = I, this._intPt[1] = h, !I.equals(h) || H || de ? Ar.COLLINEAR_INTERSECTION : Ar.POINT_INTERSECTION) : B && de ? (this._intPt[0] = I, this._intPt[1] = _, !I.equals(_) || H || se ? Ar.COLLINEAR_INTERSECTION : Ar.POINT_INTERSECTION) : H && se ? (this._intPt[0] = D, this._intPt[1] = h, !D.equals(h) || B || de ? Ar.COLLINEAR_INTERSECTION : Ar.POINT_INTERSECTION) : H && de ? (this._intPt[0] = D, this._intPt[1] = _, !D.equals(_) || B || se ? Ar.COLLINEAR_INTERSECTION : Ar.POINT_INTERSECTION) : Ar.NO_INTERSECTION;
        } }, { key: "computeIntersect", value: function(h, _, I, D) {
          if (this._isProper = !1, !lr.intersects(h, _, I, D)) return Ar.NO_INTERSECTION;
          var B = ye.index(h, _, I), H = ye.index(h, _, D);
          if (B > 0 && H > 0 || B < 0 && H < 0) return Ar.NO_INTERSECTION;
          var se = ye.index(I, D, h), de = ye.index(I, D, _);
          return se > 0 && de > 0 || se < 0 && de < 0 ? Ar.NO_INTERSECTION : B === 0 && H === 0 && se === 0 && de === 0 ? this.computeCollinearIntersection(h, _, I, D) : (B === 0 || H === 0 || se === 0 || de === 0 ? (this._isProper = !1, h.equals2D(I) || h.equals2D(D) ? this._intPt[0] = h : _.equals2D(I) || _.equals2D(D) ? this._intPt[0] = _ : B === 0 ? this._intPt[0] = new Ze(I) : H === 0 ? this._intPt[0] = new Ze(D) : se === 0 ? this._intPt[0] = new Ze(h) : de === 0 && (this._intPt[0] = new Ze(_))) : (this._isProper = !0, this._intPt[0] = this.intersection(h, _, I, D)), Ar.POINT_INTERSECTION);
        } }], [{ key: "nearestEndpoint", value: function(h, _, I, D) {
          var B = h, H = cr.pointToSegment(h, I, D), se = cr.pointToSegment(_, I, D);
          return se < H && (H = se, B = _), (se = cr.pointToSegment(I, h, _)) < H && (H = se, B = I), (se = cr.pointToSegment(D, h, _)) < H && (H = se, B = D), B;
        } }]);
      })(Ar), hr = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "countSegment", value: function(o, h) {
          if (o.x < this._p.x && h.x < this._p.x) return null;
          if (this._p.x === h.x && this._p.y === h.y) return this._isPointOnSegment = !0, null;
          if (o.y === this._p.y && h.y === this._p.y) {
            var _ = o.x, I = h.x;
            return _ > I && (_ = h.x, I = o.x), this._p.x >= _ && this._p.x <= I && (this._isPointOnSegment = !0), null;
          }
          if (o.y > this._p.y && h.y <= this._p.y || h.y > this._p.y && o.y <= this._p.y) {
            var D = ye.index(o, h, this._p);
            if (D === ye.COLLINEAR) return this._isPointOnSegment = !0, null;
            h.y < o.y && (D = -D), D === ye.LEFT && this._crossingCount++;
          }
        } }, { key: "isPointInPolygon", value: function() {
          return this.getLocation() !== Me.EXTERIOR;
        } }, { key: "getLocation", value: function() {
          return this._isPointOnSegment ? Me.BOUNDARY : this._crossingCount % 2 == 1 ? Me.INTERIOR : Me.EXTERIOR;
        } }, { key: "isOnSegment", value: function() {
          return this._isPointOnSegment;
        } }], [{ key: "constructor_", value: function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
          var o = arguments[0];
          this._p = o;
        } }, { key: "locatePointInRing", value: function() {
          if (arguments[0] instanceof Ze && er(arguments[1], be)) {
            for (var o = arguments[1], h = new y(arguments[0]), _ = new Ze(), I = new Ze(), D = 1; D < o.size(); D++) if (o.getCoordinate(D, _), o.getCoordinate(D - 1, I), h.countSegment(_, I), h.isOnSegment()) return h.getLocation();
            return h.getLocation();
          }
          if (arguments[0] instanceof Ze && arguments[1] instanceof Array) {
            for (var B = arguments[1], H = new y(arguments[0]), se = 1; se < B.length; se++) {
              var de = B[se], $e = B[se - 1];
              if (H.countSegment(de, $e), H.isOnSegment()) return H.getLocation();
            }
            return H.getLocation();
          }
        } }]);
      })(), Lo = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "isOnLine", value: function() {
          if (arguments[0] instanceof Ze && er(arguments[1], be)) {
            for (var o = arguments[0], h = arguments[1], _ = new Yi(), I = new Ze(), D = new Ze(), B = h.size(), H = 1; H < B; H++) if (h.getCoordinate(H - 1, I), h.getCoordinate(H, D), _.computeIntersection(o, I, D), _.hasIntersection()) return !0;
            return !1;
          }
          if (arguments[0] instanceof Ze && arguments[1] instanceof Array) {
            for (var se = arguments[0], de = arguments[1], $e = new Yi(), rt = 1; rt < de.length; rt++) {
              var vt = de[rt - 1], Gt = de[rt];
              if ($e.computeIntersection(se, vt, Gt), $e.hasIntersection()) return !0;
            }
            return !1;
          }
        } }, { key: "locateInRing", value: function(o, h) {
          return hr.locatePointInRing(o, h);
        } }, { key: "isInRing", value: function(o, h) {
          return y.locateInRing(o, h) !== Me.EXTERIOR;
        } }]);
      })(), Wi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "setAllLocations", value: function(o) {
          for (var h = 0; h < this.location.length; h++) this.location[h] = o;
        } }, { key: "isNull", value: function() {
          for (var o = 0; o < this.location.length; o++) if (this.location[o] !== Me.NONE) return !1;
          return !0;
        } }, { key: "setAllLocationsIfNull", value: function(o) {
          for (var h = 0; h < this.location.length; h++) this.location[h] === Me.NONE && (this.location[h] = o);
        } }, { key: "isLine", value: function() {
          return this.location.length === 1;
        } }, { key: "merge", value: function(o) {
          if (o.location.length > this.location.length) {
            var h = new Array(3).fill(null);
            h[St.ON] = this.location[St.ON], h[St.LEFT] = Me.NONE, h[St.RIGHT] = Me.NONE, this.location = h;
          }
          for (var _ = 0; _ < this.location.length; _++) this.location[_] === Me.NONE && _ < o.location.length && (this.location[_] = o.location[_]);
        } }, { key: "getLocations", value: function() {
          return this.location;
        } }, { key: "flip", value: function() {
          if (this.location.length <= 1) return null;
          var o = this.location[St.LEFT];
          this.location[St.LEFT] = this.location[St.RIGHT], this.location[St.RIGHT] = o;
        } }, { key: "toString", value: function() {
          var o = new Kr();
          return this.location.length > 1 && o.append(Me.toLocationSymbol(this.location[St.LEFT])), o.append(Me.toLocationSymbol(this.location[St.ON])), this.location.length > 1 && o.append(Me.toLocationSymbol(this.location[St.RIGHT])), o.toString();
        } }, { key: "setLocations", value: function(o, h, _) {
          this.location[St.ON] = o, this.location[St.LEFT] = h, this.location[St.RIGHT] = _;
        } }, { key: "get", value: function(o) {
          return o < this.location.length ? this.location[o] : Me.NONE;
        } }, { key: "isArea", value: function() {
          return this.location.length > 1;
        } }, { key: "isAnyNull", value: function() {
          for (var o = 0; o < this.location.length; o++) if (this.location[o] === Me.NONE) return !0;
          return !1;
        } }, { key: "setLocation", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.setLocation(St.ON, o);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this.location[h] = _;
          }
        } }, { key: "init", value: function(o) {
          this.location = new Array(o).fill(null), this.setAllLocations(Me.NONE);
        } }, { key: "isEqualOnSide", value: function(o, h) {
          return this.location[h] === o.location[h];
        } }, { key: "allPositionsEqual", value: function(o) {
          for (var h = 0; h < this.location.length; h++) if (this.location[h] !== o) return !1;
          return !0;
        } }], [{ key: "constructor_", value: function() {
          if (this.location = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var o = arguments[0];
              this.init(o.length);
            } else if (Number.isInteger(arguments[0])) {
              var h = arguments[0];
              this.init(1), this.location[St.ON] = h;
            } else if (arguments[0] instanceof y) {
              var _ = arguments[0];
              if (this.init(_.location.length), _ !== null) for (var I = 0; I < this.location.length; I++) this.location[I] = _.location[I];
            }
          } else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], H = arguments[2];
            this.init(3), this.location[St.ON] = D, this.location[St.LEFT] = B, this.location[St.RIGHT] = H;
          }
        } }]);
      })(), Si = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getGeometryCount", value: function() {
          var o = 0;
          return this.elt[0].isNull() || o++, this.elt[1].isNull() || o++, o;
        } }, { key: "setAllLocations", value: function(o, h) {
          this.elt[o].setAllLocations(h);
        } }, { key: "isNull", value: function(o) {
          return this.elt[o].isNull();
        } }, { key: "setAllLocationsIfNull", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.setAllLocationsIfNull(0, o), this.setAllLocationsIfNull(1, o);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this.elt[h].setAllLocationsIfNull(_);
          }
        } }, { key: "isLine", value: function(o) {
          return this.elt[o].isLine();
        } }, { key: "merge", value: function(o) {
          for (var h = 0; h < 2; h++) this.elt[h] === null && o.elt[h] !== null ? this.elt[h] = new Wi(o.elt[h]) : this.elt[h].merge(o.elt[h]);
        } }, { key: "flip", value: function() {
          this.elt[0].flip(), this.elt[1].flip();
        } }, { key: "getLocation", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return this.elt[o].get(St.ON);
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            return this.elt[h].get(_);
          }
        } }, { key: "toString", value: function() {
          var o = new Kr();
          return this.elt[0] !== null && (o.append("A:"), o.append(this.elt[0].toString())), this.elt[1] !== null && (o.append(" B:"), o.append(this.elt[1].toString())), o.toString();
        } }, { key: "isArea", value: function() {
          if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
          if (arguments.length === 1) {
            var o = arguments[0];
            return this.elt[o].isArea();
          }
        } }, { key: "isAnyNull", value: function(o) {
          return this.elt[o].isAnyNull();
        } }, { key: "setLocation", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            this.elt[o].setLocation(St.ON, h);
          } else if (arguments.length === 3) {
            var _ = arguments[0], I = arguments[1], D = arguments[2];
            this.elt[_].setLocation(I, D);
          }
        } }, { key: "isEqualOnSide", value: function(o, h) {
          return this.elt[0].isEqualOnSide(o.elt[0], h) && this.elt[1].isEqualOnSide(o.elt[1], h);
        } }, { key: "allPositionsEqual", value: function(o, h) {
          return this.elt[o].allPositionsEqual(h);
        } }, { key: "toLine", value: function(o) {
          this.elt[o].isArea() && (this.elt[o] = new Wi(this.elt[o].location[0]));
        } }], [{ key: "constructor_", value: function() {
          if (this.elt = new Array(2).fill(null), arguments.length === 1) {
            if (Number.isInteger(arguments[0])) {
              var o = arguments[0];
              this.elt[0] = new Wi(o), this.elt[1] = new Wi(o);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              this.elt[0] = new Wi(h.elt[0]), this.elt[1] = new Wi(h.elt[1]);
            }
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.elt[0] = new Wi(Me.NONE), this.elt[1] = new Wi(Me.NONE), this.elt[_].setLocation(I);
          } else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], H = arguments[2];
            this.elt[0] = new Wi(D, B, H), this.elt[1] = new Wi(D, B, H);
          } else if (arguments.length === 4) {
            var se = arguments[0], de = arguments[1], $e = arguments[2], rt = arguments[3];
            this.elt[0] = new Wi(Me.NONE, Me.NONE, Me.NONE), this.elt[1] = new Wi(Me.NONE, Me.NONE, Me.NONE), this.elt[se].setLocations(de, $e, rt);
          }
        } }, { key: "toLineLabel", value: function(o) {
          for (var h = new y(Me.NONE), _ = 0; _ < 2; _++) h.setLocation(_, o.getLocation(_));
          return h;
        } }]);
      })(), Wn = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "computeRing", value: function() {
          if (this._ring !== null) return null;
          for (var y = new Array(this._pts.size()).fill(null), o = 0; o < this._pts.size(); o++) y[o] = this._pts.get(o);
          this._ring = this._geometryFactory.createLinearRing(y), this._isHole = ye.isCCW(this._ring.getCoordinates());
        } }, { key: "isIsolated", value: function() {
          return this._label.getGeometryCount() === 1;
        } }, { key: "computePoints", value: function(y) {
          this._startDe = y;
          var o = y, h = !0;
          do {
            if (o === null) throw new qe("Found null DirectedEdge");
            if (o.getEdgeRing() === this) throw new qe("Directed Edge visited twice during ring-building at " + o.getCoordinate());
            this._edges.add(o);
            var _ = o.getLabel();
            Pt.isTrue(_.isArea()), this.mergeLabel(_), this.addPoints(o.getEdge(), o.isForward(), h), h = !1, this.setEdgeRing(o, this), o = this.getNext(o);
          } while (o !== this._startDe);
        } }, { key: "getLinearRing", value: function() {
          return this._ring;
        } }, { key: "getCoordinate", value: function(y) {
          return this._pts.get(y);
        } }, { key: "computeMaxNodeDegree", value: function() {
          this._maxNodeDegree = 0;
          var y = this._startDe;
          do {
            var o = y.getNode().getEdges().getOutgoingDegree(this);
            o > this._maxNodeDegree && (this._maxNodeDegree = o), y = this.getNext(y);
          } while (y !== this._startDe);
          this._maxNodeDegree *= 2;
        } }, { key: "addPoints", value: function(y, o, h) {
          var _ = y.getCoordinates();
          if (o) {
            var I = 1;
            h && (I = 0);
            for (var D = I; D < _.length; D++) this._pts.add(_[D]);
          } else {
            var B = _.length - 2;
            h && (B = _.length - 1);
            for (var H = B; H >= 0; H--) this._pts.add(_[H]);
          }
        } }, { key: "isHole", value: function() {
          return this._isHole;
        } }, { key: "setInResult", value: function() {
          var y = this._startDe;
          do
            y.getEdge().setInResult(!0), y = y.getNext();
          while (y !== this._startDe);
        } }, { key: "containsPoint", value: function(y) {
          var o = this.getLinearRing();
          if (!o.getEnvelopeInternal().contains(y) || !Lo.isInRing(y, o.getCoordinates())) return !1;
          for (var h = this._holes.iterator(); h.hasNext(); )
            if (h.next().containsPoint(y)) return !1;
          return !0;
        } }, { key: "addHole", value: function(y) {
          this._holes.add(y);
        } }, { key: "isShell", value: function() {
          return this._shell === null;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "getMaxNodeDegree", value: function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        } }, { key: "getShell", value: function() {
          return this._shell;
        } }, { key: "mergeLabel", value: function() {
          if (arguments.length === 1) {
            var y = arguments[0];
            this.mergeLabel(y, 0), this.mergeLabel(y, 1);
          } else if (arguments.length === 2) {
            var o = arguments[1], h = arguments[0].getLocation(o, St.RIGHT);
            if (h === Me.NONE) return null;
            if (this._label.getLocation(o) === Me.NONE) return this._label.setLocation(o, h), null;
          }
        } }, { key: "setShell", value: function(y) {
          this._shell = y, y !== null && y.addHole(this);
        } }, { key: "toPolygon", value: function(y) {
          for (var o = new Array(this._holes.size()).fill(null), h = 0; h < this._holes.size(); h++) o[h] = this._holes.get(h).getLinearRing();
          return y.createPolygon(this.getLinearRing(), o);
        } }], [{ key: "constructor_", value: function() {
          if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new ze(), this._pts = new ze(), this._label = new Si(Me.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new ze(), this._geometryFactory = null, arguments.length !== 0 && arguments.length === 2) {
            var y = arguments[0], o = arguments[1];
            this._geometryFactory = o, this.computePoints(y), this.computeRing();
          }
        } }]);
      })(), ii = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "setEdgeRing", value: function(h, _) {
          h.setMinEdgeRing(_);
        } }, { key: "getNext", value: function(h) {
          return h.getNextMin();
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          Wn.constructor_.call(this, h, _);
        } }]);
      })(Wn), en = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "buildMinimalRings", value: function() {
          var h = new ze(), _ = this._startDe;
          do {
            if (_.getMinEdgeRing() === null) {
              var I = new ii(_, this._geometryFactory);
              h.add(I);
            }
            _ = _.getNext();
          } while (_ !== this._startDe);
          return h;
        } }, { key: "setEdgeRing", value: function(h, _) {
          h.setEdgeRing(_);
        } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function() {
          var h = this._startDe;
          do
            h.getNode().getEdges().linkMinimalDirectedEdges(this), h = h.getNext();
          while (h !== this._startDe);
        } }, { key: "getNext", value: function(h) {
          return h.getNext();
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0], _ = arguments[1];
          Wn.constructor_.call(this, h, _);
        } }]);
      })(Wn), Qt = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "setVisited", value: function(y) {
          this._isVisited = y;
        } }, { key: "setInResult", value: function(y) {
          this._isInResult = y;
        } }, { key: "isCovered", value: function() {
          return this._isCovered;
        } }, { key: "isCoveredSet", value: function() {
          return this._isCoveredSet;
        } }, { key: "setLabel", value: function(y) {
          this._label = y;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "setCovered", value: function(y) {
          this._isCovered = y, this._isCoveredSet = !0;
        } }, { key: "updateIM", value: function(y) {
          Pt.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(y);
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length !== 0 && arguments.length === 1) {
            var y = arguments[0];
            this._label = y;
          }
        } }]);
      })(), Lr = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "isIncidentEdgeInResult", value: function() {
          for (var h = this.getEdges().getEdges().iterator(); h.hasNext(); )
            if (h.next().getEdge().isInResult()) return !0;
          return !1;
        } }, { key: "isIsolated", value: function() {
          return this._label.getGeometryCount() === 1;
        } }, { key: "getCoordinate", value: function() {
          return this._coord;
        } }, { key: "print", value: function(h) {
          h.println("node " + this._coord + " lbl: " + this._label);
        } }, { key: "computeIM", value: function(h) {
        } }, { key: "computeMergedLocation", value: function(h, _) {
          var I = Me.NONE;
          if (I = this._label.getLocation(_), !h.isNull(_)) {
            var D = h.getLocation(_);
            I !== Me.BOUNDARY && (I = D);
          }
          return I;
        } }, { key: "setLabel", value: function() {
          if (arguments.length !== 2 || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return ce(o, "setLabel", this, 1).apply(this, arguments);
          var h = arguments[0], _ = arguments[1];
          this._label === null ? this._label = new Si(h, _) : this._label.setLocation(h, _);
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "mergeLabel", value: function() {
          if (arguments[0] instanceof o) {
            var h = arguments[0];
            this.mergeLabel(h._label);
          } else if (arguments[0] instanceof Si) for (var _ = arguments[0], I = 0; I < 2; I++) {
            var D = this.computeMergedLocation(_, I);
            this._label.getLocation(I) === Me.NONE && this._label.setLocation(I, D);
          }
        } }, { key: "add", value: function(h) {
          this._edges.insert(h), h.setNode(this);
        } }, { key: "setLabelBoundary", value: function(h) {
          if (this._label === null) return null;
          var _ = Me.NONE;
          this._label !== null && (_ = this._label.getLocation(h));
          var I = null;
          switch (_) {
            case Me.BOUNDARY:
              I = Me.INTERIOR;
              break;
            case Me.INTERIOR:
            default:
              I = Me.BOUNDARY;
          }
          this._label.setLocation(h, I);
        } }], [{ key: "constructor_", value: function() {
          this._coord = null, this._edges = null;
          var h = arguments[0], _ = arguments[1];
          this._coord = h, this._edges = _, this._label = new Si(0, Me.NONE);
        } }]);
      })(Qt), ta = (function(y) {
        function o() {
          return x(this, o), p(this, o, arguments);
        }
        return $(o, y), u(o);
      })(Er);
      function si(y) {
        return y == null ? 0 : y.color;
      }
      function dr(y) {
        return y == null ? null : y.parent;
      }
      function tn(y, o) {
        y !== null && (y.color = o);
      }
      function ra(y) {
        return y == null ? null : y.left;
      }
      function Fs(y) {
        return y == null ? null : y.right;
      }
      var Ur = (function(y) {
        function o() {
          var h;
          return x(this, o), (h = p(this, o)).root_ = null, h.size_ = 0, h;
        }
        return $(o, y), u(o, [{ key: "get", value: function(h) {
          for (var _ = this.root_; _ !== null; ) {
            var I = h.compareTo(_.key);
            if (I < 0) _ = _.left;
            else {
              if (!(I > 0)) return _.value;
              _ = _.right;
            }
          }
          return null;
        } }, { key: "put", value: function(h, _) {
          if (this.root_ === null) return this.root_ = { key: h, value: _, left: null, right: null, parent: null, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } }, this.size_ = 1, null;
          var I, D, B = this.root_;
          do
            if (I = B, (D = h.compareTo(B.key)) < 0) B = B.left;
            else {
              if (!(D > 0)) {
                var H = B.value;
                return B.value = _, H;
              }
              B = B.right;
            }
          while (B !== null);
          var se = { key: h, left: null, right: null, value: _, parent: I, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return D < 0 ? I.left = se : I.right = se, this.fixAfterInsertion(se), this.size_++, null;
        } }, { key: "fixAfterInsertion", value: function(h) {
          var _;
          for (h.color = 1; h != null && h !== this.root_ && h.parent.color === 1; ) dr(h) === ra(dr(dr(h))) ? si(_ = Fs(dr(dr(h)))) === 1 ? (tn(dr(h), 0), tn(_, 0), tn(dr(dr(h)), 1), h = dr(dr(h))) : (h === Fs(dr(h)) && (h = dr(h), this.rotateLeft(h)), tn(dr(h), 0), tn(dr(dr(h)), 1), this.rotateRight(dr(dr(h)))) : si(_ = ra(dr(dr(h)))) === 1 ? (tn(dr(h), 0), tn(_, 0), tn(dr(dr(h)), 1), h = dr(dr(h))) : (h === ra(dr(h)) && (h = dr(h), this.rotateRight(h)), tn(dr(h), 0), tn(dr(dr(h)), 1), this.rotateLeft(dr(dr(h))));
          this.root_.color = 0;
        } }, { key: "values", value: function() {
          var h = new ze(), _ = this.getFirstEntry();
          if (_ !== null) for (h.add(_.value); (_ = o.successor(_)) !== null; ) h.add(_.value);
          return h;
        } }, { key: "entrySet", value: function() {
          var h = new Nr(), _ = this.getFirstEntry();
          if (_ !== null) for (h.add(_); (_ = o.successor(_)) !== null; ) h.add(_);
          return h;
        } }, { key: "rotateLeft", value: function(h) {
          if (h != null) {
            var _ = h.right;
            h.right = _.left, _.left != null && (_.left.parent = h), _.parent = h.parent, h.parent == null ? this.root_ = _ : h.parent.left === h ? h.parent.left = _ : h.parent.right = _, _.left = h, h.parent = _;
          }
        } }, { key: "rotateRight", value: function(h) {
          if (h != null) {
            var _ = h.left;
            h.left = _.right, _.right != null && (_.right.parent = h), _.parent = h.parent, h.parent == null ? this.root_ = _ : h.parent.right === h ? h.parent.right = _ : h.parent.left = _, _.right = h, h.parent = _;
          }
        } }, { key: "getFirstEntry", value: function() {
          var h = this.root_;
          if (h != null) for (; h.left != null; ) h = h.left;
          return h;
        } }, { key: "size", value: function() {
          return this.size_;
        } }, { key: "containsKey", value: function(h) {
          for (var _ = this.root_; _ !== null; ) {
            var I = h.compareTo(_.key);
            if (I < 0) _ = _.left;
            else {
              if (!(I > 0)) return !0;
              _ = _.right;
            }
          }
          return !1;
        } }], [{ key: "successor", value: function(h) {
          var _;
          if (h === null) return null;
          if (h.right !== null) {
            for (_ = h.right; _.left !== null; ) _ = _.left;
            return _;
          }
          _ = h.parent;
          for (var I = h; _ !== null && I === _.right; ) I = _, _ = _.parent;
          return _;
        } }]);
      })(ta), na = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "find", value: function(y) {
          return this.nodeMap.get(y);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof Ze) {
            var y = arguments[0], o = this.nodeMap.get(y);
            return o === null && (o = this.nodeFact.createNode(y), this.nodeMap.put(y, o)), o;
          }
          if (arguments[0] instanceof Lr) {
            var h = arguments[0], _ = this.nodeMap.get(h.getCoordinate());
            return _ === null ? (this.nodeMap.put(h.getCoordinate(), h), h) : (_.mergeLabel(h), _);
          }
        } }, { key: "print", value: function(y) {
          for (var o = this.iterator(); o.hasNext(); )
            o.next().print(y);
        } }, { key: "iterator", value: function() {
          return this.nodeMap.values().iterator();
        } }, { key: "values", value: function() {
          return this.nodeMap.values();
        } }, { key: "getBoundaryNodes", value: function(y) {
          for (var o = new ze(), h = this.iterator(); h.hasNext(); ) {
            var _ = h.next();
            _.getLabel().getLocation(y) === Me.BOUNDARY && o.add(_);
          }
          return o;
        } }, { key: "add", value: function(y) {
          var o = y.getCoordinate();
          this.addNode(o).add(y);
        } }], [{ key: "constructor_", value: function() {
          this.nodeMap = new Ur(), this.nodeFact = null;
          var y = arguments[0];
          this.nodeFact = y;
        } }]);
      })(), rn = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "isNorthern", value: function(o) {
          return o === y.NE || o === y.NW;
        } }, { key: "isOpposite", value: function(o, h) {
          return o !== h && (o - h + 4) % 4 === 2;
        } }, { key: "commonHalfPlane", value: function(o, h) {
          if (o === h) return o;
          if ((o - h + 4) % 4 === 2) return -1;
          var _ = o < h ? o : h;
          return _ === 0 && (o > h ? o : h) === 3 ? 3 : _;
        } }, { key: "isInHalfPlane", value: function(o, h) {
          return h === y.SE ? o === y.SE || o === y.SW : o === h || o === h + 1;
        } }, { key: "quadrant", value: function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], h = arguments[1];
            if (o === 0 && h === 0) throw new et("Cannot compute the quadrant for point ( " + o + ", " + h + " )");
            return o >= 0 ? h >= 0 ? y.NE : y.SE : h >= 0 ? y.NW : y.SW;
          }
          if (arguments[0] instanceof Ze && arguments[1] instanceof Ze) {
            var _ = arguments[0], I = arguments[1];
            if (I.x === _.x && I.y === _.y) throw new et("Cannot compute the quadrant for two identical points " + _);
            return I.x >= _.x ? I.y >= _.y ? y.NE : y.SE : I.y >= _.y ? y.NW : y.SW;
          }
        } }]);
      })();
      rn.NE = 0, rn.NW = 1, rn.SW = 2, rn.SE = 3;
      var Do = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "compareDirection", value: function(o) {
          return this._dx === o._dx && this._dy === o._dy ? 0 : this._quadrant > o._quadrant ? 1 : this._quadrant < o._quadrant ? -1 : ye.index(o._p0, o._p1, this._p1);
        } }, { key: "getDy", value: function() {
          return this._dy;
        } }, { key: "getCoordinate", value: function() {
          return this._p0;
        } }, { key: "setNode", value: function(o) {
          this._node = o;
        } }, { key: "print", value: function(o) {
          var h = Math.atan2(this._dy, this._dx), _ = this.getClass().getName(), I = _.lastIndexOf("."), D = _.substring(I + 1);
          o.print("  " + D + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + h + "   " + this._label);
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this.compareDirection(h);
        } }, { key: "getDirectedCoordinate", value: function() {
          return this._p1;
        } }, { key: "getDx", value: function() {
          return this._dx;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "getQuadrant", value: function() {
          return this._quadrant;
        } }, { key: "getNode", value: function() {
          return this._node;
        } }, { key: "toString", value: function() {
          var o = Math.atan2(this._dy, this._dx), h = this.getClass().getName(), _ = h.lastIndexOf(".");
          return "  " + h.substring(_ + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + o + "   " + this._label;
        } }, { key: "computeLabel", value: function(o) {
        } }, { key: "init", value: function(o, h) {
          this._p0 = o, this._p1 = h, this._dx = h.x - o.x, this._dy = h.y - o.y, this._quadrant = rn.quadrant(this._dx, this._dy), Pt.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
        } }, { key: "interfaces_", get: function() {
          return [ot];
        } }], [{ key: "constructor_", value: function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
            var o = arguments[0];
            this._edge = o;
          } else if (arguments.length === 3) {
            var h = arguments[0], _ = arguments[1], I = arguments[2];
            y.constructor_.call(this, h, _, I, null);
          } else if (arguments.length === 4) {
            var D = arguments[0], B = arguments[1], H = arguments[2], se = arguments[3];
            y.constructor_.call(this, D), this.init(B, H), this._label = se;
          }
        } }]);
      })(), ai = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getNextMin", value: function() {
          return this._nextMin;
        } }, { key: "getDepth", value: function(h) {
          return this._depth[h];
        } }, { key: "setVisited", value: function(h) {
          this._isVisited = h;
        } }, { key: "computeDirectedLabel", value: function() {
          this._label = new Si(this._edge.getLabel()), this._isForward || this._label.flip();
        } }, { key: "getNext", value: function() {
          return this._next;
        } }, { key: "setDepth", value: function(h, _) {
          if (this._depth[h] !== -999 && this._depth[h] !== _) throw new qe("assigned depths do not match", this.getCoordinate());
          this._depth[h] = _;
        } }, { key: "isInteriorAreaEdge", value: function() {
          for (var h = !0, _ = 0; _ < 2; _++) this._label.isArea(_) && this._label.getLocation(_, St.LEFT) === Me.INTERIOR && this._label.getLocation(_, St.RIGHT) === Me.INTERIOR || (h = !1);
          return h;
        } }, { key: "setNextMin", value: function(h) {
          this._nextMin = h;
        } }, { key: "print", value: function(h) {
          ce(o, "print", this, 1).call(this, h), h.print(" " + this._depth[St.LEFT] + "/" + this._depth[St.RIGHT]), h.print(" (" + this.getDepthDelta() + ")"), this._isInResult && h.print(" inResult");
        } }, { key: "setMinEdgeRing", value: function(h) {
          this._minEdgeRing = h;
        } }, { key: "isLineEdge", value: function() {
          var h = this._label.isLine(0) || this._label.isLine(1), _ = !this._label.isArea(0) || this._label.allPositionsEqual(0, Me.EXTERIOR), I = !this._label.isArea(1) || this._label.allPositionsEqual(1, Me.EXTERIOR);
          return h && _ && I;
        } }, { key: "setEdgeRing", value: function(h) {
          this._edgeRing = h;
        } }, { key: "getMinEdgeRing", value: function() {
          return this._minEdgeRing;
        } }, { key: "getDepthDelta", value: function() {
          var h = this._edge.getDepthDelta();
          return this._isForward || (h = -h), h;
        } }, { key: "setInResult", value: function(h) {
          this._isInResult = h;
        } }, { key: "getSym", value: function() {
          return this._sym;
        } }, { key: "isForward", value: function() {
          return this._isForward;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "printEdge", value: function(h) {
          this.print(h), h.print(" "), this._isForward ? this._edge.print(h) : this._edge.printReverse(h);
        } }, { key: "setSym", value: function(h) {
          this._sym = h;
        } }, { key: "setVisitedEdge", value: function(h) {
          this.setVisited(h), this._sym.setVisited(h);
        } }, { key: "setEdgeDepths", value: function(h, _) {
          var I = this.getEdge().getDepthDelta();
          this._isForward || (I = -I);
          var D = 1;
          h === St.LEFT && (D = -1);
          var B = St.opposite(h), H = _ + I * D;
          this.setDepth(h, _), this.setDepth(B, H);
        } }, { key: "getEdgeRing", value: function() {
          return this._edgeRing;
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "setNext", value: function(h) {
          this._next = h;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
          var h = arguments[0], _ = arguments[1];
          if (Do.constructor_.call(this, h), this._isForward = _, _) this.init(h.getCoordinate(0), h.getCoordinate(1));
          else {
            var I = h.getNumPoints() - 1;
            this.init(h.getCoordinate(I), h.getCoordinate(I - 1));
          }
          this.computeDirectedLabel();
        } }, { key: "depthFactor", value: function(h, _) {
          return h === Me.EXTERIOR && _ === Me.INTERIOR ? 1 : h === Me.INTERIOR && _ === Me.EXTERIOR ? -1 : 0;
        } }]);
      })(Do), ia = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "createNode", value: function(y) {
          return new Lr(y, null);
        } }]);
      })(), xs = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "printEdges", value: function(y) {
          y.println("Edges:");
          for (var o = 0; o < this._edges.size(); o++) {
            y.println("edge " + o + ":");
            var h = this._edges.get(o);
            h.print(y), h.eiList.print(y);
          }
        } }, { key: "find", value: function(y) {
          return this._nodes.find(y);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof Lr) {
            var y = arguments[0];
            return this._nodes.addNode(y);
          }
          if (arguments[0] instanceof Ze) {
            var o = arguments[0];
            return this._nodes.addNode(o);
          }
        } }, { key: "getNodeIterator", value: function() {
          return this._nodes.iterator();
        } }, { key: "linkResultDirectedEdges", value: function() {
          for (var y = this._nodes.iterator(); y.hasNext(); )
            y.next().getEdges().linkResultDirectedEdges();
        } }, { key: "debugPrintln", value: function(y) {
          Nt.out.println(y);
        } }, { key: "isBoundaryNode", value: function(y, o) {
          var h = this._nodes.find(o);
          if (h === null) return !1;
          var _ = h.getLabel();
          return _ !== null && _.getLocation(y) === Me.BOUNDARY;
        } }, { key: "linkAllDirectedEdges", value: function() {
          for (var y = this._nodes.iterator(); y.hasNext(); )
            y.next().getEdges().linkAllDirectedEdges();
        } }, { key: "matchInSameDirection", value: function(y, o, h, _) {
          return !!y.equals(h) && ye.index(y, o, _) === ye.COLLINEAR && rn.quadrant(y, o) === rn.quadrant(h, _);
        } }, { key: "getEdgeEnds", value: function() {
          return this._edgeEndList;
        } }, { key: "debugPrint", value: function(y) {
          Nt.out.print(y);
        } }, { key: "getEdgeIterator", value: function() {
          return this._edges.iterator();
        } }, { key: "findEdgeInSameDirection", value: function(y, o) {
          for (var h = 0; h < this._edges.size(); h++) {
            var _ = this._edges.get(h), I = _.getCoordinates();
            if (this.matchInSameDirection(y, o, I[0], I[1]) || this.matchInSameDirection(y, o, I[I.length - 1], I[I.length - 2])) return _;
          }
          return null;
        } }, { key: "insertEdge", value: function(y) {
          this._edges.add(y);
        } }, { key: "findEdgeEnd", value: function(y) {
          for (var o = this.getEdgeEnds().iterator(); o.hasNext(); ) {
            var h = o.next();
            if (h.getEdge() === y) return h;
          }
          return null;
        } }, { key: "addEdges", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); ) {
            var h = o.next();
            this._edges.add(h);
            var _ = new ai(h, !0), I = new ai(h, !1);
            _.setSym(I), I.setSym(_), this.add(_), this.add(I);
          }
        } }, { key: "add", value: function(y) {
          this._nodes.add(y), this._edgeEndList.add(y);
        } }, { key: "getNodes", value: function() {
          return this._nodes.values();
        } }, { key: "findEdge", value: function(y, o) {
          for (var h = 0; h < this._edges.size(); h++) {
            var _ = this._edges.get(h), I = _.getCoordinates();
            if (y.equals(I[0]) && o.equals(I[1])) return _;
          }
          return null;
        } }], [{ key: "constructor_", value: function() {
          if (this._edges = new ze(), this._nodes = null, this._edgeEndList = new ze(), arguments.length === 0) this._nodes = new na(new ia());
          else if (arguments.length === 1) {
            var y = arguments[0];
            this._nodes = new na(y);
          }
        } }, { key: "linkResultDirectedEdges", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); )
            o.next().getEdges().linkResultDirectedEdges();
        } }]);
      })(), Tc = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "sortShellsAndHoles", value: function(o, h, _) {
          for (var I = o.iterator(); I.hasNext(); ) {
            var D = I.next();
            D.isHole() ? _.add(D) : h.add(D);
          }
        } }, { key: "computePolygons", value: function(o) {
          for (var h = new ze(), _ = o.iterator(); _.hasNext(); ) {
            var I = _.next().toPolygon(this._geometryFactory);
            h.add(I);
          }
          return h;
        } }, { key: "placeFreeHoles", value: function(o, h) {
          for (var _ = h.iterator(); _.hasNext(); ) {
            var I = _.next();
            if (I.getShell() === null) {
              var D = y.findEdgeRingContaining(I, o);
              if (D === null) throw new qe("unable to assign hole to a shell", I.getCoordinate(0));
              I.setShell(D);
            }
          }
        } }, { key: "buildMinimalEdgeRings", value: function(o, h, _) {
          for (var I = new ze(), D = o.iterator(); D.hasNext(); ) {
            var B = D.next();
            if (B.getMaxNodeDegree() > 2) {
              B.linkDirectedEdgesForMinimalEdgeRings();
              var H = B.buildMinimalRings(), se = this.findShell(H);
              se !== null ? (this.placePolygonHoles(se, H), h.add(se)) : _.addAll(H);
            } else I.add(B);
          }
          return I;
        } }, { key: "buildMaximalEdgeRings", value: function(o) {
          for (var h = new ze(), _ = o.iterator(); _.hasNext(); ) {
            var I = _.next();
            if (I.isInResult() && I.getLabel().isArea() && I.getEdgeRing() === null) {
              var D = new en(I, this._geometryFactory);
              h.add(D), D.setInResult();
            }
          }
          return h;
        } }, { key: "placePolygonHoles", value: function(o, h) {
          for (var _ = h.iterator(); _.hasNext(); ) {
            var I = _.next();
            I.isHole() && I.setShell(o);
          }
        } }, { key: "getPolygons", value: function() {
          return this.computePolygons(this._shellList);
        } }, { key: "findShell", value: function(o) {
          for (var h = 0, _ = null, I = o.iterator(); I.hasNext(); ) {
            var D = I.next();
            D.isHole() || (_ = D, h++);
          }
          return Pt.isTrue(h <= 1, "found two shells in MinimalEdgeRing list"), _;
        } }, { key: "add", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.add(o.getEdgeEnds(), o.getNodes());
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            xs.linkResultDirectedEdges(_);
            var I = this.buildMaximalEdgeRings(h), D = new ze(), B = this.buildMinimalEdgeRings(I, this._shellList, D);
            this.sortShellsAndHoles(B, this._shellList, D), this.placeFreeHoles(this._shellList, D);
          }
        } }], [{ key: "constructor_", value: function() {
          this._geometryFactory = null, this._shellList = new ze();
          var o = arguments[0];
          this._geometryFactory = o;
        } }, { key: "findEdgeRingContaining", value: function(o, h) {
          for (var _ = o.getLinearRing(), I = _.getEnvelopeInternal(), D = _.getCoordinateN(0), B = null, H = null, se = h.iterator(); se.hasNext(); ) {
            var de = se.next(), $e = de.getLinearRing(), rt = $e.getEnvelopeInternal();
            if (!rt.equals(I) && rt.contains(I)) {
              D = bt.ptNotInList(_.getCoordinates(), $e.getCoordinates());
              var vt = !1;
              Lo.isInRing(D, $e.getCoordinates()) && (vt = !0), vt && (B === null || H.contains(rt)) && (H = (B = de).getLinearRing().getEnvelopeInternal());
            }
          }
          return B;
        } }]);
      })(), xl = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "getBounds", value: function() {
        } }]);
      })(), vi = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getItem", value: function() {
          return this._item;
        } }, { key: "getBounds", value: function() {
          return this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [xl, ie];
        } }], [{ key: "constructor_", value: function() {
          this._bounds = null, this._item = null;
          var y = arguments[0], o = arguments[1];
          this._bounds = y, this._item = o;
        } }]);
      })(), Dr = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "poll", value: function() {
          if (this.isEmpty()) return null;
          var y = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), y;
        } }, { key: "size", value: function() {
          return this._size;
        } }, { key: "reorder", value: function(y) {
          for (var o = null, h = this._items.get(y); 2 * y <= this._size && ((o = 2 * y) !== this._size && this._items.get(o + 1).compareTo(this._items.get(o)) < 0 && o++, this._items.get(o).compareTo(h) < 0); y = o) this._items.set(y, this._items.get(o));
          this._items.set(y, h);
        } }, { key: "clear", value: function() {
          this._size = 0, this._items.clear();
        } }, { key: "peek", value: function() {
          return this.isEmpty() ? null : this._items.get(1);
        } }, { key: "isEmpty", value: function() {
          return this._size === 0;
        } }, { key: "add", value: function(y) {
          this._items.add(null), this._size += 1;
          var o = this._size;
          for (this._items.set(0, y); y.compareTo(this._items.get(Math.trunc(o / 2))) < 0; o /= 2) this._items.set(o, this._items.get(Math.trunc(o / 2)));
          this._items.set(o, y);
        } }], [{ key: "constructor_", value: function() {
          this._size = null, this._items = null, this._size = 0, this._items = new ze(), this._items.add(null);
        } }]);
      })(), Qa = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "insert", value: function(y, o) {
        } }, { key: "remove", value: function(y, o) {
        } }, { key: "query", value: function() {
        } }]);
      })(), sr = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getLevel", value: function() {
          return this._level;
        } }, { key: "size", value: function() {
          return this._childBoundables.size();
        } }, { key: "getChildBoundables", value: function() {
          return this._childBoundables;
        } }, { key: "addChildBoundable", value: function(y) {
          Pt.isTrue(this._bounds === null), this._childBoundables.add(y);
        } }, { key: "isEmpty", value: function() {
          return this._childBoundables.isEmpty();
        } }, { key: "getBounds", value: function() {
          return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [xl, ie];
        } }], [{ key: "constructor_", value: function() {
          if (this._childBoundables = new ze(), this._bounds = null, this._level = null, arguments.length !== 0 && arguments.length === 1) {
            var y = arguments[0];
            this._level = y;
          }
        } }]);
      })(), nr = { reverseOrder: function() {
        return { compare: function(y, o) {
          return o.compareTo(y);
        } };
      }, min: function(y) {
        return nr.sort(y), y.get(0);
      }, sort: function(y, o) {
        var h = y.toArray();
        o ? Rn.sort(h, o) : Rn.sort(h);
        for (var _ = y.iterator(), I = 0, D = h.length; I < D; I++) _.next(), _.set(h[I]);
      }, singletonList: function(y) {
        var o = new ze();
        return o.add(y), o;
      } }, eo = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "maxDistance", value: function(o, h, _, I, D, B, H, se) {
          var de = y.distance(o, h, D, B);
          return de = Math.max(de, y.distance(o, h, H, se)), de = Math.max(de, y.distance(_, I, D, B)), de = Math.max(de, y.distance(_, I, H, se));
        } }, { key: "distance", value: function(o, h, _, I) {
          var D = _ - o, B = I - h;
          return Math.sqrt(D * D + B * B);
        } }, { key: "maximumDistance", value: function(o, h) {
          var _ = Math.min(o.getMinX(), h.getMinX()), I = Math.min(o.getMinY(), h.getMinY()), D = Math.max(o.getMaxX(), h.getMaxX()), B = Math.max(o.getMaxY(), h.getMaxY());
          return y.distance(_, I, D, B);
        } }, { key: "minMaxDistance", value: function(o, h) {
          var _ = o.getMinX(), I = o.getMinY(), D = o.getMaxX(), B = o.getMaxY(), H = h.getMinX(), se = h.getMinY(), de = h.getMaxX(), $e = h.getMaxY(), rt = y.maxDistance(_, I, _, B, H, se, H, $e);
          return rt = Math.min(rt, y.maxDistance(_, I, _, B, H, se, de, se)), rt = Math.min(rt, y.maxDistance(_, I, _, B, de, $e, H, $e)), rt = Math.min(rt, y.maxDistance(_, I, _, B, de, $e, de, se)), rt = Math.min(rt, y.maxDistance(_, I, D, I, H, se, H, $e)), rt = Math.min(rt, y.maxDistance(_, I, D, I, H, se, de, se)), rt = Math.min(rt, y.maxDistance(_, I, D, I, de, $e, H, $e)), rt = Math.min(rt, y.maxDistance(_, I, D, I, de, $e, de, se)), rt = Math.min(rt, y.maxDistance(D, B, _, B, H, se, H, $e)), rt = Math.min(rt, y.maxDistance(D, B, _, B, H, se, de, se)), rt = Math.min(rt, y.maxDistance(D, B, _, B, de, $e, H, $e)), rt = Math.min(rt, y.maxDistance(D, B, _, B, de, $e, de, se)), rt = Math.min(rt, y.maxDistance(D, B, D, I, H, se, H, $e)), rt = Math.min(rt, y.maxDistance(D, B, D, I, H, se, de, se)), rt = Math.min(rt, y.maxDistance(D, B, D, I, de, $e, H, $e)), rt = Math.min(rt, y.maxDistance(D, B, D, I, de, $e, de, se));
        } }]);
      })(), pr = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "maximumDistance", value: function() {
          return eo.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
        } }, { key: "expandToQueue", value: function(o, h) {
          var _ = y.isComposite(this._boundable1), I = y.isComposite(this._boundable2);
          if (_ && I) return y.area(this._boundable1) > y.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, o, h), null) : (this.expand(this._boundable2, this._boundable1, !0, o, h), null);
          if (_) return this.expand(this._boundable1, this._boundable2, !1, o, h), null;
          if (I) return this.expand(this._boundable2, this._boundable1, !0, o, h), null;
          throw new et("neither boundable is composite");
        } }, { key: "isLeaves", value: function() {
          return !(y.isComposite(this._boundable1) || y.isComposite(this._boundable2));
        } }, { key: "compareTo", value: function(o) {
          var h = o;
          return this._distance < h._distance ? -1 : this._distance > h._distance ? 1 : 0;
        } }, { key: "expand", value: function(o, h, _, I, D) {
          for (var B = o.getChildBoundables().iterator(); B.hasNext(); ) {
            var H = B.next(), se = null;
            (se = _ ? new y(h, H, this._itemDistance) : new y(H, h, this._itemDistance)).getDistance() < D && I.add(se);
          }
        } }, { key: "getBoundable", value: function(o) {
          return o === 0 ? this._boundable1 : this._boundable2;
        } }, { key: "getDistance", value: function() {
          return this._distance;
        } }, { key: "distance", value: function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        } }, { key: "interfaces_", get: function() {
          return [ot];
        } }], [{ key: "constructor_", value: function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var o = arguments[0], h = arguments[1], _ = arguments[2];
          this._boundable1 = o, this._boundable2 = h, this._itemDistance = _, this._distance = this.distance();
        } }, { key: "area", value: function(o) {
          return o.getBounds().getArea();
        } }, { key: "isComposite", value: function(o) {
          return o instanceof sr;
        } }]);
      })(), to = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "visitItem", value: function(y) {
        } }]);
      })(), Xn = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "queryInternal", value: function() {
          if (er(arguments[2], to) && arguments[0] instanceof Object && arguments[1] instanceof sr) for (var o = arguments[0], h = arguments[2], _ = arguments[1].getChildBoundables(), I = 0; I < _.size(); I++) {
            var D = _.get(I);
            this.getIntersectsOp().intersects(D.getBounds(), o) && (D instanceof sr ? this.queryInternal(o, D, h) : D instanceof vi ? h.visitItem(D.getItem()) : Pt.shouldNeverReachHere());
          }
          else if (er(arguments[2], In) && arguments[0] instanceof Object && arguments[1] instanceof sr) for (var B = arguments[0], H = arguments[2], se = arguments[1].getChildBoundables(), de = 0; de < se.size(); de++) {
            var $e = se.get(de);
            this.getIntersectsOp().intersects($e.getBounds(), B) && ($e instanceof sr ? this.queryInternal(B, $e, H) : $e instanceof vi ? H.add($e.getItem()) : Pt.shouldNeverReachHere());
          }
        } }, { key: "getNodeCapacity", value: function() {
          return this._nodeCapacity;
        } }, { key: "lastNode", value: function(o) {
          return o.get(o.size() - 1);
        } }, { key: "size", value: function() {
          if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (arguments.length === 1) {
            for (var o = 0, h = arguments[0].getChildBoundables().iterator(); h.hasNext(); ) {
              var _ = h.next();
              _ instanceof sr ? o += this.size(_) : _ instanceof vi && (o += 1);
            }
            return o;
          }
        } }, { key: "removeItem", value: function(o, h) {
          for (var _ = null, I = o.getChildBoundables().iterator(); I.hasNext(); ) {
            var D = I.next();
            D instanceof vi && D.getItem() === h && (_ = D);
          }
          return _ !== null && (o.getChildBoundables().remove(_), !0);
        } }, { key: "itemsTree", value: function() {
          if (arguments.length === 0) {
            this.build();
            var o = this.itemsTree(this._root);
            return o === null ? new ze() : o;
          }
          if (arguments.length === 1) {
            for (var h = arguments[0], _ = new ze(), I = h.getChildBoundables().iterator(); I.hasNext(); ) {
              var D = I.next();
              if (D instanceof sr) {
                var B = this.itemsTree(D);
                B !== null && _.add(B);
              } else D instanceof vi ? _.add(D.getItem()) : Pt.shouldNeverReachHere();
            }
            return _.size() <= 0 ? null : _;
          }
        } }, { key: "insert", value: function(o, h) {
          Pt.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new vi(o, h));
        } }, { key: "boundablesAtLevel", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0], h = new ze();
            return this.boundablesAtLevel(o, this._root, h), h;
          }
          if (arguments.length === 3) {
            var _ = arguments[0], I = arguments[1], D = arguments[2];
            if (Pt.isTrue(_ > -2), I.getLevel() === _) return D.add(I), null;
            for (var B = I.getChildBoundables().iterator(); B.hasNext(); ) {
              var H = B.next();
              H instanceof sr ? this.boundablesAtLevel(_, H, D) : (Pt.isTrue(H instanceof vi), _ === -1 && D.add(H));
            }
            return null;
          }
        } }, { key: "query", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.build();
            var h = new ze();
            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), o) && this.queryInternal(o, this._root, h), h;
          }
          if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            if (this.build(), this.isEmpty()) return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), _) && this.queryInternal(_, this._root, I);
          }
        } }, { key: "build", value: function() {
          if (this._built) return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
        } }, { key: "getRoot", value: function() {
          return this.build(), this._root;
        } }, { key: "remove", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), o) && this.remove(o, this._root, h);
          }
          if (arguments.length === 3) {
            var _ = arguments[0], I = arguments[1], D = arguments[2], B = this.removeItem(I, D);
            if (B) return !0;
            for (var H = null, se = I.getChildBoundables().iterator(); se.hasNext(); ) {
              var de = se.next();
              if (this.getIntersectsOp().intersects(de.getBounds(), _) && de instanceof sr && (B = this.remove(_, de, D))) {
                H = de;
                break;
              }
            }
            return H !== null && H.getChildBoundables().isEmpty() && I.getChildBoundables().remove(H), B;
          }
        } }, { key: "createHigherLevels", value: function(o, h) {
          Pt.isTrue(!o.isEmpty());
          var _ = this.createParentBoundables(o, h + 1);
          return _.size() === 1 ? _.get(0) : this.createHigherLevels(_, h + 1);
        } }, { key: "depth", value: function() {
          if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (arguments.length === 1) {
            for (var o = 0, h = arguments[0].getChildBoundables().iterator(); h.hasNext(); ) {
              var _ = h.next();
              if (_ instanceof sr) {
                var I = this.depth(_);
                I > o && (o = I);
              }
            }
            return o + 1;
          }
        } }, { key: "createParentBoundables", value: function(o, h) {
          Pt.isTrue(!o.isEmpty());
          var _ = new ze();
          _.add(this.createNode(h));
          var I = new ze(o);
          nr.sort(I, this.getComparator());
          for (var D = I.iterator(); D.hasNext(); ) {
            var B = D.next();
            this.lastNode(_).getChildBoundables().size() === this.getNodeCapacity() && _.add(this.createNode(h)), this.lastNode(_).addChildBoundable(B);
          }
          return _;
        } }, { key: "isEmpty", value: function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        } }, { key: "interfaces_", get: function() {
          return [ie];
        } }], [{ key: "constructor_", value: function() {
          if (this._root = null, this._built = !1, this._itemBoundables = new ze(), this._nodeCapacity = null, arguments.length === 0) y.constructor_.call(this, y.DEFAULT_NODE_CAPACITY);
          else if (arguments.length === 1) {
            var o = arguments[0];
            Pt.isTrue(o > 1, "Node capacity must be greater than 1"), this._nodeCapacity = o;
          }
        } }, { key: "compareDoubles", value: function(o, h) {
          return o > h ? 1 : o < h ? -1 : 0;
        } }]);
      })();
      Xn.IntersectsOp = function() {
      }, Xn.DEFAULT_NODE_CAPACITY = 10;
      var ro = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "distance", value: function(y, o) {
        } }]);
      })(), Jn = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "createParentBoundablesFromVerticalSlices", value: function(h, _) {
          Pt.isTrue(h.length > 0);
          for (var I = new ze(), D = 0; D < h.length; D++) I.addAll(this.createParentBoundablesFromVerticalSlice(h[D], _));
          return I;
        } }, { key: "nearestNeighbourK", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            return this.nearestNeighbourK(h, dt.POSITIVE_INFINITY, _);
          }
          if (arguments.length === 3) {
            var I = arguments[0], D = arguments[2], B = arguments[1], H = new Dr();
            H.add(I);
            for (var se = new Dr(); !H.isEmpty() && B >= 0; ) {
              var de = H.poll(), $e = de.getDistance();
              if ($e >= B) break;
              de.isLeaves() ? se.size() < D ? se.add(de) : (se.peek().getDistance() > $e && (se.poll(), se.add(de)), B = se.peek().getDistance()) : de.expandToQueue(H, B);
            }
            return o.getItems(se);
          }
        } }, { key: "createNode", value: function(h) {
          return new fu(h);
        } }, { key: "size", value: function() {
          return arguments.length === 0 ? ce(o, "size", this, 1).call(this) : ce(o, "size", this, 1).apply(this, arguments);
        } }, { key: "insert", value: function() {
          if (!(arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof lr)) return ce(o, "insert", this, 1).apply(this, arguments);
          var h = arguments[0], _ = arguments[1];
          if (h.isNull()) return null;
          ce(o, "insert", this, 1).call(this, h, _);
        } }, { key: "getIntersectsOp", value: function() {
          return o.intersectsOp;
        } }, { key: "verticalSlices", value: function(h, _) {
          for (var I = Math.trunc(Math.ceil(h.size() / _)), D = new Array(_).fill(null), B = h.iterator(), H = 0; H < _; H++) {
            D[H] = new ze();
            for (var se = 0; B.hasNext() && se < I; ) {
              var de = B.next();
              D[H].add(de), se++;
            }
          }
          return D;
        } }, { key: "query", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return ce(o, "query", this, 1).call(this, h);
          }
          if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            ce(o, "query", this, 1).call(this, _, I);
          }
        } }, { key: "getComparator", value: function() {
          return o.yComparator;
        } }, { key: "createParentBoundablesFromVerticalSlice", value: function(h, _) {
          return ce(o, "createParentBoundables", this, 1).call(this, h, _);
        } }, { key: "remove", value: function() {
          if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof lr) {
            var h = arguments[0], _ = arguments[1];
            return ce(o, "remove", this, 1).call(this, h, _);
          }
          return ce(o, "remove", this, 1).apply(this, arguments);
        } }, { key: "depth", value: function() {
          return arguments.length === 0 ? ce(o, "depth", this, 1).call(this) : ce(o, "depth", this, 1).apply(this, arguments);
        } }, { key: "createParentBoundables", value: function(h, _) {
          Pt.isTrue(!h.isEmpty());
          var I = Math.trunc(Math.ceil(h.size() / this.getNodeCapacity())), D = new ze(h);
          nr.sort(D, o.xComparator);
          var B = this.verticalSlices(D, Math.trunc(Math.ceil(Math.sqrt(I))));
          return this.createParentBoundablesFromVerticalSlices(B, _);
        } }, { key: "nearestNeighbour", value: function() {
          if (arguments.length === 1) {
            if (er(arguments[0], ro)) {
              var h = arguments[0];
              if (this.isEmpty()) return null;
              var _ = new pr(this.getRoot(), this.getRoot(), h);
              return this.nearestNeighbour(_);
            }
            if (arguments[0] instanceof pr) {
              var I = arguments[0], D = dt.POSITIVE_INFINITY, B = null, H = new Dr();
              for (H.add(I); !H.isEmpty() && D > 0; ) {
                var se = H.poll(), de = se.getDistance();
                if (de >= D) break;
                se.isLeaves() ? (D = de, B = se) : se.expandToQueue(H, D);
              }
              return B === null ? null : [B.getBoundable(0).getItem(), B.getBoundable(1).getItem()];
            }
          } else {
            if (arguments.length === 2) {
              var $e = arguments[0], rt = arguments[1];
              if (this.isEmpty() || $e.isEmpty()) return null;
              var vt = new pr(this.getRoot(), $e.getRoot(), rt);
              return this.nearestNeighbour(vt);
            }
            if (arguments.length === 3) {
              var Gt = arguments[2], $t = new vi(arguments[0], arguments[1]), Xt = new pr(this.getRoot(), $t, Gt);
              return this.nearestNeighbour(Xt)[0];
            }
            if (arguments.length === 4) {
              var _r = arguments[2], or = arguments[3], Gr = new vi(arguments[0], arguments[1]), qn = new pr(this.getRoot(), Gr, _r);
              return this.nearestNeighbourK(qn, or);
            }
          }
        } }, { key: "isWithinDistance", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1], I = dt.POSITIVE_INFINITY, D = new Dr();
            for (D.add(h); !D.isEmpty(); ) {
              var B = D.poll(), H = B.getDistance();
              if (H > _) return !1;
              if (B.maximumDistance() <= _) return !0;
              if (B.isLeaves()) {
                if ((I = H) <= _) return !0;
              } else B.expandToQueue(D, I);
            }
            return !1;
          }
          if (arguments.length === 3) {
            var se = arguments[0], de = arguments[1], $e = arguments[2], rt = new pr(this.getRoot(), se.getRoot(), de);
            return this.isWithinDistance(rt, $e);
          }
        } }, { key: "interfaces_", get: function() {
          return [Qa, ie];
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length === 0) o.constructor_.call(this, o.DEFAULT_NODE_CAPACITY);
          else if (arguments.length === 1) {
            var h = arguments[0];
            Xn.constructor_.call(this, h);
          }
        } }, { key: "centreX", value: function(h) {
          return o.avg(h.getMinX(), h.getMaxX());
        } }, { key: "avg", value: function(h, _) {
          return (h + _) / 2;
        } }, { key: "getItems", value: function(h) {
          for (var _ = new Array(h.size()).fill(null), I = 0; !h.isEmpty(); ) {
            var D = h.poll();
            _[I] = D.getBoundable(0).getItem(), I++;
          }
          return _;
        } }, { key: "centreY", value: function(h) {
          return o.avg(h.getMinY(), h.getMaxY());
        } }]);
      })(Xn), fu = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "computeBounds", value: function() {
          for (var h = null, _ = this.getChildBoundables().iterator(); _.hasNext(); ) {
            var I = _.next();
            h === null ? h = new lr(I.getBounds()) : h.expandToInclude(I.getBounds());
          }
          return h;
        } }], [{ key: "constructor_", value: function() {
          var h = arguments[0];
          sr.constructor_.call(this, h);
        } }]);
      })(sr);
      Jn.STRtreeNode = fu, Jn.xComparator = new ((function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "interfaces_", get: function() {
          return [Tt];
        } }, { key: "compare", value: function(y, o) {
          return Xn.compareDoubles(Jn.centreX(y.getBounds()), Jn.centreX(o.getBounds()));
        } }]);
      })())(), Jn.yComparator = new ((function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "interfaces_", get: function() {
          return [Tt];
        } }, { key: "compare", value: function(y, o) {
          return Xn.compareDoubles(Jn.centreY(y.getBounds()), Jn.centreY(o.getBounds()));
        } }]);
      })())(), Jn.intersectsOp = new ((function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "interfaces_", get: function() {
          return [IntersectsOp];
        } }, { key: "intersects", value: function(y, o) {
          return y.intersects(o);
        } }]);
      })())(), Jn.DEFAULT_NODE_CAPACITY = 10;
      var Ro = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "relativeSign", value: function(o, h) {
          return o < h ? -1 : o > h ? 1 : 0;
        } }, { key: "compare", value: function(o, h, _) {
          if (h.equals2D(_)) return 0;
          var I = y.relativeSign(h.x, _.x), D = y.relativeSign(h.y, _.y);
          switch (o) {
            case 0:
              return y.compareValue(I, D);
            case 1:
              return y.compareValue(D, I);
            case 2:
              return y.compareValue(D, -I);
            case 3:
              return y.compareValue(-I, D);
            case 4:
              return y.compareValue(-I, -D);
            case 5:
              return y.compareValue(-D, -I);
            case 6:
              return y.compareValue(-D, I);
            case 7:
              return y.compareValue(I, -D);
          }
          return Pt.shouldNeverReachHere("invalid octant value"), 0;
        } }, { key: "compareValue", value: function(o, h) {
          return o < 0 ? -1 : o > 0 ? 1 : h < 0 ? -1 : h > 0 ? 1 : 0;
        } }]);
      })(), pu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(y) {
          y.print(this.coord), y.print(" seg # = " + this.segmentIndex);
        } }, { key: "compareTo", value: function(y) {
          var o = y;
          return this.segmentIndex < o.segmentIndex ? -1 : this.segmentIndex > o.segmentIndex ? 1 : this.coord.equals2D(o.coord) ? 0 : this._isInterior ? o._isInterior ? Ro.compare(this._segmentOctant, this.coord, o.coord) : 1 : -1;
        } }, { key: "isEndPoint", value: function(y) {
          return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === y;
        } }, { key: "toString", value: function() {
          return this.segmentIndex + ":" + this.coord.toString();
        } }, { key: "isInterior", value: function() {
          return this._isInterior;
        } }, { key: "interfaces_", get: function() {
          return [ot];
        } }], [{ key: "constructor_", value: function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var y = arguments[0], o = arguments[1], h = arguments[2], _ = arguments[3];
          this._segString = y, this.coord = new Ze(o), this.segmentIndex = h, this._segmentOctant = _, this._isInterior = !o.equals2D(y.getCoordinate(h));
        } }]);
      })(), Kh = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "hasNext", value: function() {
        } }, { key: "next", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      })(), Sc = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getSplitCoordinates", value: function() {
          var y = new zt();
          this.addEndpoints();
          for (var o = this.iterator(), h = o.next(); o.hasNext(); ) {
            var _ = o.next();
            this.addEdgeCoordinates(h, _, y), h = _;
          }
          return y.toCoordinateArray();
        } }, { key: "addCollapsedNodes", value: function() {
          var y = new ze();
          this.findCollapsesFromInsertedNodes(y), this.findCollapsesFromExistingVertices(y);
          for (var o = y.iterator(); o.hasNext(); ) {
            var h = o.next().intValue();
            this.add(this._edge.getCoordinate(h), h);
          }
        } }, { key: "createSplitEdgePts", value: function(y, o) {
          var h = o.segmentIndex - y.segmentIndex + 2;
          if (h === 2) return [new Ze(y.coord), new Ze(o.coord)];
          var _ = this._edge.getCoordinate(o.segmentIndex), I = o.isInterior() || !o.coord.equals2D(_);
          I || h--;
          var D = new Array(h).fill(null), B = 0;
          D[B++] = new Ze(y.coord);
          for (var H = y.segmentIndex + 1; H <= o.segmentIndex; H++) D[B++] = this._edge.getCoordinate(H);
          return I && (D[B] = new Ze(o.coord)), D;
        } }, { key: "print", value: function(y) {
          y.println("Intersections:");
          for (var o = this.iterator(); o.hasNext(); )
            o.next().print(y);
        } }, { key: "findCollapsesFromExistingVertices", value: function(y) {
          for (var o = 0; o < this._edge.size() - 2; o++) {
            var h = this._edge.getCoordinate(o);
            this._edge.getCoordinate(o + 1);
            var _ = this._edge.getCoordinate(o + 2);
            h.equals2D(_) && y.add(He.valueOf(o + 1));
          }
        } }, { key: "addEdgeCoordinates", value: function(y, o, h) {
          var _ = this.createSplitEdgePts(y, o);
          h.add(_, !1);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(y) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var o = this.iterator(), h = o.next(); o.hasNext(); ) {
            var _ = o.next(), I = this.createSplitEdge(h, _);
            y.add(I), h = _;
          }
        } }, { key: "findCollapseIndex", value: function(y, o, h) {
          if (!y.coord.equals2D(o.coord)) return !1;
          var _ = o.segmentIndex - y.segmentIndex;
          return o.isInterior() || _--, _ === 1 && (h[0] = y.segmentIndex + 1, !0);
        } }, { key: "findCollapsesFromInsertedNodes", value: function(y) {
          for (var o = new Array(1).fill(null), h = this.iterator(), _ = h.next(); h.hasNext(); ) {
            var I = h.next();
            this.findCollapseIndex(_, I, o) && y.add(He.valueOf(o[0])), _ = I;
          }
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "addEndpoints", value: function() {
          var y = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(y), y);
        } }, { key: "createSplitEdge", value: function(y, o) {
          var h = this.createSplitEdgePts(y, o);
          return new Gi(h, this._edge.getData());
        } }, { key: "add", value: function(y, o) {
          var h = new pu(this._edge, y, o, this._edge.getSegmentOctant(o)), _ = this._nodeMap.get(h);
          return _ !== null ? (Pt.isTrue(_.coord.equals2D(y), "Found equal nodes with different coordinates"), _) : (this._nodeMap.put(h, h), h);
        } }, { key: "checkSplitEdgesCorrectness", value: function(y) {
          var o = this._edge.getCoordinates(), h = y.get(0).getCoordinate(0);
          if (!h.equals2D(o[0])) throw new Ht("bad split edge start point at " + h);
          var _ = y.get(y.size() - 1).getCoordinates(), I = _[_.length - 1];
          if (!I.equals2D(o[o.length - 1])) throw new Ht("bad split edge end point at " + I);
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new Ur(), this._edge = null;
          var y = arguments[0];
          this._edge = y;
        } }]);
      })(), xi = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "octant", value: function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var o = arguments[0], h = arguments[1];
            if (o === 0 && h === 0) throw new et("Cannot compute the octant for point ( " + o + ", " + h + " )");
            var _ = Math.abs(o), I = Math.abs(h);
            return o >= 0 ? h >= 0 ? _ >= I ? 0 : 1 : _ >= I ? 7 : 6 : h >= 0 ? _ >= I ? 3 : 2 : _ >= I ? 4 : 5;
          }
          if (arguments[0] instanceof Ze && arguments[1] instanceof Ze) {
            var D = arguments[0], B = arguments[1], H = B.x - D.x, se = B.y - D.y;
            if (H === 0 && se === 0) throw new et("Cannot compute the octant for two identical points " + D);
            return y.octant(H, se);
          }
        } }]);
      })(), bs = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "getCoordinates", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "getCoordinate", value: function(y) {
        } }, { key: "isClosed", value: function() {
        } }, { key: "setData", value: function(y) {
        } }, { key: "getData", value: function() {
        } }]);
      })(), Wr = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "addIntersection", value: function(y, o) {
        } }, { key: "interfaces_", get: function() {
          return [bs];
        } }]);
      })(), Gi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getCoordinates", value: function() {
          return this._pts;
        } }, { key: "size", value: function() {
          return this._pts.length;
        } }, { key: "getCoordinate", value: function(o) {
          return this._pts[o];
        } }, { key: "isClosed", value: function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        } }, { key: "getSegmentOctant", value: function(o) {
          return o === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(o), this.getCoordinate(o + 1));
        } }, { key: "setData", value: function(o) {
          this._data = o;
        } }, { key: "safeOctant", value: function(o, h) {
          return o.equals2D(h) ? 0 : xi.octant(o, h);
        } }, { key: "getData", value: function() {
          return this._data;
        } }, { key: "addIntersection", value: function() {
          if (arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            this.addIntersectionNode(o, h);
          } else if (arguments.length === 4) {
            var _ = arguments[1], I = arguments[3], D = new Ze(arguments[0].getIntersection(I));
            this.addIntersection(D, _);
          }
        } }, { key: "toString", value: function() {
          return Ea.toLineString(new Cn(this._pts));
        } }, { key: "getNodeList", value: function() {
          return this._nodeList;
        } }, { key: "addIntersectionNode", value: function(o, h) {
          var _ = h, I = _ + 1;
          if (I < this._pts.length) {
            var D = this._pts[I];
            o.equals2D(D) && (_ = I);
          }
          return this._nodeList.add(o, _);
        } }, { key: "addIntersections", value: function(o, h, _) {
          for (var I = 0; I < o.getIntersectionNum(); I++) this.addIntersection(o, h, _, I);
        } }, { key: "interfaces_", get: function() {
          return [Wr];
        } }], [{ key: "constructor_", value: function() {
          this._nodeList = new Sc(this), this._pts = null, this._data = null;
          var o = arguments[0], h = arguments[1];
          this._pts = o, this._data = h;
        } }, { key: "getNodedSubstrings", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0], h = new ze();
            return y.getNodedSubstrings(o, h), h;
          }
          if (arguments.length === 2) for (var _ = arguments[1], I = arguments[0].iterator(); I.hasNext(); )
            I.next().getNodeList().addSplitEdges(_);
        } }]);
      })(), bi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "minX", value: function() {
          return Math.min(this.p0.x, this.p1.x);
        } }, { key: "orientationIndex", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0], h = ye.index(this.p0, this.p1, o.p0), _ = ye.index(this.p0, this.p1, o.p1);
            return h >= 0 && _ >= 0 || h <= 0 && _ <= 0 ? Math.max(h, _) : 0;
          }
          if (arguments[0] instanceof Ze) {
            var I = arguments[0];
            return ye.index(this.p0, this.p1, I);
          }
        } }, { key: "toGeometry", value: function(o) {
          return o.createLineString([this.p0, this.p1]);
        } }, { key: "isVertical", value: function() {
          return this.p0.x === this.p1.x;
        } }, { key: "equals", value: function(o) {
          if (!(o instanceof y)) return !1;
          var h = o;
          return this.p0.equals(h.p0) && this.p1.equals(h.p1);
        } }, { key: "intersection", value: function(o) {
          var h = new Yi();
          return h.computeIntersection(this.p0, this.p1, o.p0, o.p1), h.hasIntersection() ? h.getIntersection(0) : null;
        } }, { key: "project", value: function() {
          if (arguments[0] instanceof Ze) {
            var o = arguments[0];
            if (o.equals(this.p0) || o.equals(this.p1)) return new Ze(o);
            var h = this.projectionFactor(o), _ = new Ze();
            return _.x = this.p0.x + h * (this.p1.x - this.p0.x), _.y = this.p0.y + h * (this.p1.y - this.p0.y), _;
          }
          if (arguments[0] instanceof y) {
            var I = arguments[0], D = this.projectionFactor(I.p0), B = this.projectionFactor(I.p1);
            if (D >= 1 && B >= 1 || D <= 0 && B <= 0) return null;
            var H = this.project(I.p0);
            D < 0 && (H = this.p0), D > 1 && (H = this.p1);
            var se = this.project(I.p1);
            return B < 0 && (se = this.p0), B > 1 && (se = this.p1), new y(H, se);
          }
        } }, { key: "normalize", value: function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        } }, { key: "angle", value: function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        } }, { key: "getCoordinate", value: function(o) {
          return o === 0 ? this.p0 : this.p1;
        } }, { key: "distancePerpendicular", value: function(o) {
          return cr.pointToLinePerpendicular(o, this.p0, this.p1);
        } }, { key: "minY", value: function() {
          return Math.min(this.p0.y, this.p1.y);
        } }, { key: "midPoint", value: function() {
          return y.midPoint(this.p0, this.p1);
        } }, { key: "projectionFactor", value: function(o) {
          if (o.equals(this.p0)) return 0;
          if (o.equals(this.p1)) return 1;
          var h = this.p1.x - this.p0.x, _ = this.p1.y - this.p0.y, I = h * h + _ * _;
          return I <= 0 ? dt.NaN : ((o.x - this.p0.x) * h + (o.y - this.p0.y) * _) / I;
        } }, { key: "closestPoints", value: function(o) {
          var h = this.intersection(o);
          if (h !== null) return [h, h];
          var _ = new Array(2).fill(null), I = dt.MAX_VALUE, D = null, B = this.closestPoint(o.p0);
          I = B.distance(o.p0), _[0] = B, _[1] = o.p0;
          var H = this.closestPoint(o.p1);
          (D = H.distance(o.p1)) < I && (I = D, _[0] = H, _[1] = o.p1);
          var se = o.closestPoint(this.p0);
          (D = se.distance(this.p0)) < I && (I = D, _[0] = this.p0, _[1] = se);
          var de = o.closestPoint(this.p1);
          return (D = de.distance(this.p1)) < I && (I = D, _[0] = this.p1, _[1] = de), _;
        } }, { key: "closestPoint", value: function(o) {
          var h = this.projectionFactor(o);
          return h > 0 && h < 1 ? this.project(o) : this.p0.distance(o) < this.p1.distance(o) ? this.p0 : this.p1;
        } }, { key: "maxX", value: function() {
          return Math.max(this.p0.x, this.p1.x);
        } }, { key: "getLength", value: function() {
          return this.p0.distance(this.p1);
        } }, { key: "compareTo", value: function(o) {
          var h = o, _ = this.p0.compareTo(h.p0);
          return _ !== 0 ? _ : this.p1.compareTo(h.p1);
        } }, { key: "reverse", value: function() {
          var o = this.p0;
          this.p0 = this.p1, this.p1 = o;
        } }, { key: "equalsTopo", value: function(o) {
          return this.p0.equals(o.p0) && this.p1.equals(o.p1) || this.p0.equals(o.p1) && this.p1.equals(o.p0);
        } }, { key: "lineIntersection", value: function(o) {
          return Lt.intersection(this.p0, this.p1, o.p0, o.p1);
        } }, { key: "maxY", value: function() {
          return Math.max(this.p0.y, this.p1.y);
        } }, { key: "pointAlongOffset", value: function(o, h) {
          var _ = this.p0.x + o * (this.p1.x - this.p0.x), I = this.p0.y + o * (this.p1.y - this.p0.y), D = this.p1.x - this.p0.x, B = this.p1.y - this.p0.y, H = Math.sqrt(D * D + B * B), se = 0, de = 0;
          if (h !== 0) {
            if (H <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
            se = h * D / H, de = h * B / H;
          }
          return new Ze(_ - de, I + se);
        } }, { key: "setCoordinates", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            this.setCoordinates(o.p0, o.p1);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this.p0.x = h.x, this.p0.y = h.y, this.p1.x = _.x, this.p1.y = _.y;
          }
        } }, { key: "segmentFraction", value: function(o) {
          var h = this.projectionFactor(o);
          return h < 0 ? h = 0 : (h > 1 || dt.isNaN(h)) && (h = 1), h;
        } }, { key: "toString", value: function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        } }, { key: "isHorizontal", value: function() {
          return this.p0.y === this.p1.y;
        } }, { key: "reflect", value: function(o) {
          var h = this.p1.getY() - this.p0.getY(), _ = this.p0.getX() - this.p1.getX(), I = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), D = h * h + _ * _, B = h * h - _ * _, H = o.getX(), se = o.getY();
          return new Ze((-B * H - 2 * h * _ * se - 2 * h * I) / D, (B * se - 2 * h * _ * H - 2 * _ * I) / D);
        } }, { key: "distance", value: function() {
          if (arguments[0] instanceof y) {
            var o = arguments[0];
            return cr.segmentToSegment(this.p0, this.p1, o.p0, o.p1);
          }
          if (arguments[0] instanceof Ze) {
            var h = arguments[0];
            return cr.pointToSegment(h, this.p0, this.p1);
          }
        } }, { key: "pointAlong", value: function(o) {
          var h = new Ze();
          return h.x = this.p0.x + o * (this.p1.x - this.p0.x), h.y = this.p0.y + o * (this.p1.y - this.p0.y), h;
        } }, { key: "hashCode", value: function() {
          var o = dt.doubleToLongBits(this.p0.x);
          o ^= 31 * dt.doubleToLongBits(this.p0.y);
          var h = Math.trunc(o) ^ Math.trunc(o >> 32), _ = dt.doubleToLongBits(this.p1.x);
          return _ ^= 31 * dt.doubleToLongBits(this.p1.y), h ^ (Math.trunc(_) ^ Math.trunc(_ >> 32));
        } }, { key: "interfaces_", get: function() {
          return [ot, ie];
        } }], [{ key: "constructor_", value: function() {
          if (this.p0 = null, this.p1 = null, arguments.length === 0) y.constructor_.call(this, new Ze(), new Ze());
          else if (arguments.length === 1) {
            var o = arguments[0];
            y.constructor_.call(this, o.p0, o.p1);
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this.p0 = h, this.p1 = _;
          } else if (arguments.length === 4) {
            var I = arguments[0], D = arguments[1], B = arguments[2], H = arguments[3];
            y.constructor_.call(this, new Ze(I, D), new Ze(B, H));
          }
        } }, { key: "midPoint", value: function(o, h) {
          return new Ze((o.x + h.x) / 2, (o.y + h.y) / 2);
        } }]);
      })(), Fo = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "overlap", value: function() {
          if (arguments.length !== 2 && arguments.length === 4) {
            var y = arguments[1], o = arguments[2], h = arguments[3];
            arguments[0].getLineSegment(y, this._overlapSeg1), o.getLineSegment(h, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        } }], [{ key: "constructor_", value: function() {
          this._overlapSeg1 = new bi(), this._overlapSeg2 = new bi();
        } }]);
      })(), nn = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getLineSegment", value: function(y, o) {
          o.p0 = this._pts[y], o.p1 = this._pts[y + 1];
        } }, { key: "computeSelect", value: function(y, o, h, _) {
          var I = this._pts[o], D = this._pts[h];
          if (h - o == 1) return _.select(this, o), null;
          if (!y.intersects(I, D)) return null;
          var B = Math.trunc((o + h) / 2);
          o < B && this.computeSelect(y, o, B, _), B < h && this.computeSelect(y, B, h, _);
        } }, { key: "getCoordinates", value: function() {
          for (var y = new Array(this._end - this._start + 1).fill(null), o = 0, h = this._start; h <= this._end; h++) y[o++] = this._pts[h];
          return y;
        } }, { key: "computeOverlaps", value: function() {
          if (arguments.length === 2) {
            var y = arguments[0], o = arguments[1];
            this.computeOverlaps(this._start, this._end, y, y._start, y._end, o);
          } else if (arguments.length === 6) {
            var h = arguments[0], _ = arguments[1], I = arguments[2], D = arguments[3], B = arguments[4], H = arguments[5];
            if (_ - h == 1 && B - D == 1) return H.overlap(this, h, I, D), null;
            if (!this.overlaps(h, _, I, D, B)) return null;
            var se = Math.trunc((h + _) / 2), de = Math.trunc((D + B) / 2);
            h < se && (D < de && this.computeOverlaps(h, se, I, D, de, H), de < B && this.computeOverlaps(h, se, I, de, B, H)), se < _ && (D < de && this.computeOverlaps(se, _, I, D, de, H), de < B && this.computeOverlaps(se, _, I, de, B, H));
          }
        } }, { key: "setId", value: function(y) {
          this._id = y;
        } }, { key: "select", value: function(y, o) {
          this.computeSelect(y, this._start, this._end, o);
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            var y = this._pts[this._start], o = this._pts[this._end];
            this._env = new lr(y, o);
          }
          return this._env;
        } }, { key: "overlaps", value: function(y, o, h, _, I) {
          return lr.intersects(this._pts[y], this._pts[o], h._pts[_], h._pts[I]);
        } }, { key: "getEndIndex", value: function() {
          return this._end;
        } }, { key: "getStartIndex", value: function() {
          return this._start;
        } }, { key: "getContext", value: function() {
          return this._context;
        } }, { key: "getId", value: function() {
          return this._id;
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var y = arguments[0], o = arguments[1], h = arguments[2], _ = arguments[3];
          this._pts = y, this._start = o, this._end = h, this._context = _;
        } }]);
      })(), kc = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "findChainEnd", value: function(o, h) {
          for (var _ = h; _ < o.length - 1 && o[_].equals2D(o[_ + 1]); ) _++;
          if (_ >= o.length - 1) return o.length - 1;
          for (var I = rn.quadrant(o[_], o[_ + 1]), D = h + 1; D < o.length && !(!o[D - 1].equals2D(o[D]) && rn.quadrant(o[D - 1], o[D]) !== I); )
            D++;
          return D - 1;
        } }, { key: "getChains", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return y.getChains(o, null);
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1], I = new ze(), D = 0;
            do {
              var B = y.findChainEnd(h, D), H = new nn(h, D, B, _);
              I.add(H), D = B;
            } while (D < h.length - 1);
            return I;
          }
        } }]);
      })(), No = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "computeNodes", value: function(y) {
        } }, { key: "getNodedSubstrings", value: function() {
        } }]);
      })(), gu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "setSegmentIntersector", value: function(y) {
          this._segInt = y;
        } }, { key: "interfaces_", get: function() {
          return [No];
        } }], [{ key: "constructor_", value: function() {
          if (this._segInt = null, arguments.length !== 0 && arguments.length === 1) {
            var y = arguments[0];
            this.setSegmentIntersector(y);
          }
        } }]);
      })(), mu = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getMonotoneChains", value: function() {
          return this._monoChains;
        } }, { key: "getNodedSubstrings", value: function() {
          return Gi.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "getIndex", value: function() {
          return this._index;
        } }, { key: "add", value: function(h) {
          for (var _ = kc.getChains(h.getCoordinates(), h).iterator(); _.hasNext(); ) {
            var I = _.next();
            I.setId(this._idCounter++), this._index.insert(I.getEnvelope(), I), this._monoChains.add(I);
          }
        } }, { key: "computeNodes", value: function(h) {
          this._nodedSegStrings = h;
          for (var _ = h.iterator(); _.hasNext(); ) this.add(_.next());
          this.intersectChains();
        } }, { key: "intersectChains", value: function() {
          for (var h = new Ta(this._segInt), _ = this._monoChains.iterator(); _.hasNext(); ) for (var I = _.next(), D = this._index.query(I.getEnvelope()).iterator(); D.hasNext(); ) {
            var B = D.next();
            if (B.getId() > I.getId() && (I.computeOverlaps(B, h), this._nOverlaps++), this._segInt.isDone()) return null;
          }
        } }], [{ key: "constructor_", value: function() {
          if (this._monoChains = new ze(), this._index = new Jn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, arguments.length !== 0 && arguments.length === 1) {
            var h = arguments[0];
            gu.constructor_.call(this, h);
          }
        } }]);
      })(gu), Ta = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "overlap", value: function() {
          if (arguments.length !== 4) return ce(o, "overlap", this, 1).apply(this, arguments);
          var h = arguments[1], _ = arguments[2], I = arguments[3], D = arguments[0].getContext(), B = _.getContext();
          this._si.processIntersections(D, h, B, I);
        } }], [{ key: "constructor_", value: function() {
          this._si = null;
          var h = arguments[0];
          this._si = h;
        } }]);
      })(Fo);
      mu.SegmentOverlapAction = Ta;
      var ki = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "isDeletable", value: function(o, h, _, I) {
          var D = this._inputLine[o], B = this._inputLine[h], H = this._inputLine[_];
          return !!this.isConcave(D, B, H) && !!this.isShallow(D, B, H, I) && this.isShallowSampled(D, B, o, _, I);
        } }, { key: "deleteShallowConcavities", value: function() {
          for (var o = 1, h = this.findNextNonDeletedIndex(o), _ = this.findNextNonDeletedIndex(h), I = !1; _ < this._inputLine.length; ) {
            var D = !1;
            this.isDeletable(o, h, _, this._distanceTol) && (this._isDeleted[h] = y.DELETE, D = !0, I = !0), o = D ? _ : h, h = this.findNextNonDeletedIndex(o), _ = this.findNextNonDeletedIndex(h);
          }
          return I;
        } }, { key: "isShallowConcavity", value: function(o, h, _, I) {
          return ye.index(o, h, _) === this._angleOrientation && cr.pointToSegment(h, o, _) < I;
        } }, { key: "isShallowSampled", value: function(o, h, _, I, D) {
          var B = Math.trunc((I - _) / y.NUM_PTS_TO_CHECK);
          B <= 0 && (B = 1);
          for (var H = _; H < I; H += B) if (!this.isShallow(o, h, this._inputLine[H], D)) return !1;
          return !0;
        } }, { key: "isConcave", value: function(o, h, _) {
          var I = ye.index(o, h, _) === this._angleOrientation;
          return I;
        } }, { key: "simplify", value: function(o) {
          this._distanceTol = Math.abs(o), o < 0 && (this._angleOrientation = ye.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var h = !1;
          do
            h = this.deleteShallowConcavities();
          while (h);
          return this.collapseLine();
        } }, { key: "findNextNonDeletedIndex", value: function(o) {
          for (var h = o + 1; h < this._inputLine.length && this._isDeleted[h] === y.DELETE; ) h++;
          return h;
        } }, { key: "isShallow", value: function(o, h, _, I) {
          return cr.pointToSegment(h, o, _) < I;
        } }, { key: "collapseLine", value: function() {
          for (var o = new zt(), h = 0; h < this._inputLine.length; h++) this._isDeleted[h] !== y.DELETE && o.add(this._inputLine[h]);
          return o.toCoordinateArray();
        } }], [{ key: "constructor_", value: function() {
          this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ye.COUNTERCLOCKWISE;
          var o = arguments[0];
          this._inputLine = o;
        } }, { key: "simplify", value: function(o, h) {
          return new y(o).simplify(h);
        } }]);
      })();
      ki.INIT = 0, ki.DELETE = 1, ki.KEEP = 1, ki.NUM_PTS_TO_CHECK = 10;
      var Sa = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getCoordinates", value: function() {
          return this._ptList.toArray(y.COORDINATE_ARRAY_TYPE);
        } }, { key: "setPrecisionModel", value: function(o) {
          this._precisionModel = o;
        } }, { key: "addPt", value: function(o) {
          var h = new Ze(o);
          if (this._precisionModel.makePrecise(h), this.isRedundant(h)) return null;
          this._ptList.add(h);
        } }, { key: "reverse", value: function() {
        } }, { key: "addPts", value: function(o, h) {
          if (h) for (var _ = 0; _ < o.length; _++) this.addPt(o[_]);
          else for (var I = o.length - 1; I >= 0; I--) this.addPt(o[I]);
        } }, { key: "isRedundant", value: function(o) {
          if (this._ptList.size() < 1) return !1;
          var h = this._ptList.get(this._ptList.size() - 1);
          return o.distance(h) < this._minimimVertexDistance;
        } }, { key: "toString", value: function() {
          return new ni().createLineString(this.getCoordinates()).toString();
        } }, { key: "closeRing", value: function() {
          if (this._ptList.size() < 1) return null;
          var o = new Ze(this._ptList.get(0)), h = this._ptList.get(this._ptList.size() - 1);
          if (o.equals(h)) return null;
          this._ptList.add(o);
        } }, { key: "setMinimumVertexDistance", value: function(o) {
          this._minimimVertexDistance = o;
        } }], [{ key: "constructor_", value: function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new ze();
        } }]);
      })();
      Sa.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
      var wi = (function() {
        function y() {
          x(this, y);
        }
        return u(y, null, [{ key: "toDegrees", value: function(o) {
          return 180 * o / Math.PI;
        } }, { key: "normalize", value: function(o) {
          for (; o > Math.PI; ) o -= y.PI_TIMES_2;
          for (; o <= -Math.PI; ) o += y.PI_TIMES_2;
          return o;
        } }, { key: "angle", value: function() {
          if (arguments.length === 1) {
            var o = arguments[0];
            return Math.atan2(o.y, o.x);
          }
          if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1], I = _.x - h.x, D = _.y - h.y;
            return Math.atan2(D, I);
          }
        } }, { key: "isAcute", value: function(o, h, _) {
          var I = o.x - h.x, D = o.y - h.y;
          return I * (_.x - h.x) + D * (_.y - h.y) > 0;
        } }, { key: "isObtuse", value: function(o, h, _) {
          var I = o.x - h.x, D = o.y - h.y;
          return I * (_.x - h.x) + D * (_.y - h.y) < 0;
        } }, { key: "interiorAngle", value: function(o, h, _) {
          var I = y.angle(h, o), D = y.angle(h, _);
          return Math.abs(D - I);
        } }, { key: "normalizePositive", value: function(o) {
          if (o < 0) {
            for (; o < 0; ) o += y.PI_TIMES_2;
            o >= y.PI_TIMES_2 && (o = 0);
          } else {
            for (; o >= y.PI_TIMES_2; ) o -= y.PI_TIMES_2;
            o < 0 && (o = 0);
          }
          return o;
        } }, { key: "angleBetween", value: function(o, h, _) {
          var I = y.angle(h, o), D = y.angle(h, _);
          return y.diff(I, D);
        } }, { key: "diff", value: function(o, h) {
          var _ = null;
          return (_ = o < h ? h - o : o - h) > Math.PI && (_ = 2 * Math.PI - _), _;
        } }, { key: "toRadians", value: function(o) {
          return o * Math.PI / 180;
        } }, { key: "getTurn", value: function(o, h) {
          var _ = Math.sin(h - o);
          return _ > 0 ? y.COUNTERCLOCKWISE : _ < 0 ? y.CLOCKWISE : y.NONE;
        } }, { key: "angleBetweenOriented", value: function(o, h, _) {
          var I = y.angle(h, o), D = y.angle(h, _) - I;
          return D <= -Math.PI ? D + y.PI_TIMES_2 : D > Math.PI ? D - y.PI_TIMES_2 : D;
        } }]);
      })();
      wi.PI_TIMES_2 = 2 * Math.PI, wi.PI_OVER_2 = Math.PI / 2, wi.PI_OVER_4 = Math.PI / 4, wi.COUNTERCLOCKWISE = ye.COUNTERCLOCKWISE, wi.CLOCKWISE = ye.CLOCKWISE, wi.NONE = ye.COLLINEAR;
      var Ns = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "addNextSegment", value: function(o, h) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = o, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
          var _ = ye.index(this._s0, this._s1, this._s2), I = _ === ye.CLOCKWISE && this._side === St.LEFT || _ === ye.COUNTERCLOCKWISE && this._side === St.RIGHT;
          _ === 0 ? this.addCollinear(h) : I ? this.addOutsideTurn(_, h) : this.addInsideTurn(_, h);
        } }, { key: "addLineEndCap", value: function(o, h) {
          var _ = new bi(o, h), I = new bi();
          this.computeOffsetSegment(_, St.LEFT, this._distance, I);
          var D = new bi();
          this.computeOffsetSegment(_, St.RIGHT, this._distance, D);
          var B = h.x - o.x, H = h.y - o.y, se = Math.atan2(H, B);
          switch (this._bufParams.getEndCapStyle()) {
            case je.CAP_ROUND:
              this._segList.addPt(I.p1), this.addDirectedFillet(h, se + Math.PI / 2, se - Math.PI / 2, ye.CLOCKWISE, this._distance), this._segList.addPt(D.p1);
              break;
            case je.CAP_FLAT:
              this._segList.addPt(I.p1), this._segList.addPt(D.p1);
              break;
            case je.CAP_SQUARE:
              var de = new Ze();
              de.x = Math.abs(this._distance) * Math.cos(se), de.y = Math.abs(this._distance) * Math.sin(se);
              var $e = new Ze(I.p1.x + de.x, I.p1.y + de.y), rt = new Ze(D.p1.x + de.x, D.p1.y + de.y);
              this._segList.addPt($e), this._segList.addPt(rt);
          }
        } }, { key: "getCoordinates", value: function() {
          return this._segList.getCoordinates();
        } }, { key: "addMitreJoin", value: function(o, h, _, I) {
          var D = Lt.intersection(h.p0, h.p1, _.p0, _.p1);
          if (D !== null && (I <= 0 ? 1 : D.distance(o) / Math.abs(I)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(D), null;
          this.addLimitedMitreJoin(h, _, I, this._bufParams.getMitreLimit());
        } }, { key: "addOutsideTurn", value: function(o, h) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * y.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === je.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === je.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (h && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, o, this._distance), this._segList.addPt(this._offset1.p0));
        } }, { key: "createSquare", value: function(o) {
          this._segList.addPt(new Ze(o.x + this._distance, o.y + this._distance)), this._segList.addPt(new Ze(o.x + this._distance, o.y - this._distance)), this._segList.addPt(new Ze(o.x - this._distance, o.y - this._distance)), this._segList.addPt(new Ze(o.x - this._distance, o.y + this._distance)), this._segList.closeRing();
        } }, { key: "addSegments", value: function(o, h) {
          this._segList.addPts(o, h);
        } }, { key: "addFirstSegment", value: function() {
          this._segList.addPt(this._offset1.p0);
        } }, { key: "addCornerFillet", value: function(o, h, _, I, D) {
          var B = h.x - o.x, H = h.y - o.y, se = Math.atan2(H, B), de = _.x - o.x, $e = _.y - o.y, rt = Math.atan2($e, de);
          I === ye.CLOCKWISE ? se <= rt && (se += 2 * Math.PI) : se >= rt && (se -= 2 * Math.PI), this._segList.addPt(h), this.addDirectedFillet(o, se, rt, I, D), this._segList.addPt(_);
        } }, { key: "addLastSegment", value: function() {
          this._segList.addPt(this._offset1.p1);
        } }, { key: "initSideSegments", value: function(o, h, _) {
          this._s1 = o, this._s2 = h, this._side = _, this._seg1.setCoordinates(o, h), this.computeOffsetSegment(this._seg1, _, this._distance, this._offset1);
        } }, { key: "addLimitedMitreJoin", value: function(o, h, _, I) {
          var D = this._seg0.p1, B = wi.angle(D, this._seg0.p0), H = wi.angleBetweenOriented(this._seg0.p0, D, this._seg1.p1) / 2, se = wi.normalize(B + H), de = wi.normalize(se + Math.PI), $e = I * _, rt = _ - $e * Math.abs(Math.sin(H)), vt = D.x + $e * Math.cos(de), Gt = D.y + $e * Math.sin(de), $t = new Ze(vt, Gt), Xt = new bi(D, $t), _r = Xt.pointAlongOffset(1, rt), or = Xt.pointAlongOffset(1, -rt);
          this._side === St.LEFT ? (this._segList.addPt(_r), this._segList.addPt(or)) : (this._segList.addPt(or), this._segList.addPt(_r));
        } }, { key: "addDirectedFillet", value: function(o, h, _, I, D) {
          var B = I === ye.CLOCKWISE ? -1 : 1, H = Math.abs(h - _), se = Math.trunc(H / this._filletAngleQuantum + 0.5);
          if (se < 1) return null;
          for (var de = H / se, $e = new Ze(), rt = 0; rt < se; rt++) {
            var vt = h + B * rt * de;
            $e.x = o.x + D * Math.cos(vt), $e.y = o.y + D * Math.sin(vt), this._segList.addPt($e);
          }
        } }, { key: "computeOffsetSegment", value: function(o, h, _, I) {
          var D = h === St.LEFT ? 1 : -1, B = o.p1.x - o.p0.x, H = o.p1.y - o.p0.y, se = Math.sqrt(B * B + H * H), de = D * _ * B / se, $e = D * _ * H / se;
          I.p0.x = o.p0.x - $e, I.p0.y = o.p0.y + de, I.p1.x = o.p1.x - $e, I.p1.y = o.p1.y + de;
        } }, { key: "addInsideTurn", value: function(o, h) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * y.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var _ = new Ze((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(_);
              var I = new Ze((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(I);
            } else this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        } }, { key: "createCircle", value: function(o) {
          var h = new Ze(o.x + this._distance, o.y);
          this._segList.addPt(h), this.addDirectedFillet(o, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        } }, { key: "addBevelJoin", value: function(o, h) {
          this._segList.addPt(o.p1), this._segList.addPt(h.p0);
        } }, { key: "init", value: function(o) {
          this._distance = o, this._maxCurveSegmentError = o * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Sa(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(o * y.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        } }, { key: "addCollinear", value: function(o) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === je.JOIN_BEVEL || this._bufParams.getJoinStyle() === je.JOIN_MITRE ? (o && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ye.CLOCKWISE, this._distance));
        } }, { key: "closeRing", value: function() {
          this._segList.closeRing();
        } }, { key: "hasNarrowConcaveAngle", value: function() {
          return this._hasNarrowConcaveAngle;
        } }], [{ key: "constructor_", value: function() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new bi(), this._seg1 = new bi(), this._offset0 = new bi(), this._offset1 = new bi(), this._side = 0, this._hasNarrowConcaveAngle = !1;
          var o = arguments[0], h = arguments[1], _ = arguments[2];
          this._precisionModel = o, this._bufParams = h, this._li = new Yi(), this._filletAngleQuantum = Math.PI / 2 / h.getQuadrantSegments(), h.getQuadrantSegments() >= 8 && h.getJoinStyle() === je.JOIN_ROUND && (this._closingSegLengthFactor = y.MAX_CLOSING_SEG_LEN_FACTOR), this.init(_);
        } }]);
      })();
      Ns.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, Ns.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, Ns.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Ns.MAX_CLOSING_SEG_LEN_FACTOR = 80;
      var no = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getOffsetCurve", value: function(o, h) {
          if (this._distance = h, h === 0) return null;
          var _ = h < 0, I = Math.abs(h), D = this.getSegGen(I);
          o.length <= 1 ? this.computePointCurve(o[0], D) : this.computeOffsetCurve(o, _, D);
          var B = D.getCoordinates();
          return _ && bt.reverse(B), B;
        } }, { key: "computeSingleSidedBufferCurve", value: function(o, h, _) {
          var I = this.simplifyTolerance(this._distance);
          if (h) {
            _.addSegments(o, !0);
            var D = ki.simplify(o, -I), B = D.length - 1;
            _.initSideSegments(D[B], D[B - 1], St.LEFT), _.addFirstSegment();
            for (var H = B - 2; H >= 0; H--) _.addNextSegment(D[H], !0);
          } else {
            _.addSegments(o, !1);
            var se = ki.simplify(o, I), de = se.length - 1;
            _.initSideSegments(se[0], se[1], St.LEFT), _.addFirstSegment();
            for (var $e = 2; $e <= de; $e++) _.addNextSegment(se[$e], !0);
          }
          _.addLastSegment(), _.closeRing();
        } }, { key: "computeRingBufferCurve", value: function(o, h, _) {
          var I = this.simplifyTolerance(this._distance);
          h === St.RIGHT && (I = -I);
          var D = ki.simplify(o, I), B = D.length - 1;
          _.initSideSegments(D[B - 1], D[0], h);
          for (var H = 1; H <= B; H++) {
            var se = H !== 1;
            _.addNextSegment(D[H], se);
          }
          _.closeRing();
        } }, { key: "computeLineBufferCurve", value: function(o, h) {
          var _ = this.simplifyTolerance(this._distance), I = ki.simplify(o, _), D = I.length - 1;
          h.initSideSegments(I[0], I[1], St.LEFT);
          for (var B = 2; B <= D; B++) h.addNextSegment(I[B], !0);
          h.addLastSegment(), h.addLineEndCap(I[D - 1], I[D]);
          var H = ki.simplify(o, -_), se = H.length - 1;
          h.initSideSegments(H[se], H[se - 1], St.LEFT);
          for (var de = se - 2; de >= 0; de--) h.addNextSegment(H[de], !0);
          h.addLastSegment(), h.addLineEndCap(H[1], H[0]), h.closeRing();
        } }, { key: "computePointCurve", value: function(o, h) {
          switch (this._bufParams.getEndCapStyle()) {
            case je.CAP_ROUND:
              h.createCircle(o);
              break;
            case je.CAP_SQUARE:
              h.createSquare(o);
          }
        } }, { key: "getLineCurve", value: function(o, h) {
          if (this._distance = h, this.isLineOffsetEmpty(h)) return null;
          var _ = Math.abs(h), I = this.getSegGen(_);
          if (o.length <= 1) this.computePointCurve(o[0], I);
          else if (this._bufParams.isSingleSided()) {
            var D = h < 0;
            this.computeSingleSidedBufferCurve(o, D, I);
          } else this.computeLineBufferCurve(o, I);
          return I.getCoordinates();
        } }, { key: "getBufferParameters", value: function() {
          return this._bufParams;
        } }, { key: "simplifyTolerance", value: function(o) {
          return o * this._bufParams.getSimplifyFactor();
        } }, { key: "getRingCurve", value: function(o, h, _) {
          if (this._distance = _, o.length <= 2) return this.getLineCurve(o, _);
          if (_ === 0) return y.copyCoordinates(o);
          var I = this.getSegGen(_);
          return this.computeRingBufferCurve(o, h, I), I.getCoordinates();
        } }, { key: "computeOffsetCurve", value: function(o, h, _) {
          var I = this.simplifyTolerance(this._distance);
          if (h) {
            var D = ki.simplify(o, -I), B = D.length - 1;
            _.initSideSegments(D[B], D[B - 1], St.LEFT), _.addFirstSegment();
            for (var H = B - 2; H >= 0; H--) _.addNextSegment(D[H], !0);
          } else {
            var se = ki.simplify(o, I), de = se.length - 1;
            _.initSideSegments(se[0], se[1], St.LEFT), _.addFirstSegment();
            for (var $e = 2; $e <= de; $e++) _.addNextSegment(se[$e], !0);
          }
          _.addLastSegment();
        } }, { key: "isLineOffsetEmpty", value: function(o) {
          return o === 0 || o < 0 && !this._bufParams.isSingleSided();
        } }, { key: "getSegGen", value: function(o) {
          return new Ns(this._precisionModel, this._bufParams, o);
        } }], [{ key: "constructor_", value: function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var o = arguments[0], h = arguments[1];
          this._precisionModel = o, this._bufParams = h;
        } }, { key: "copyCoordinates", value: function(o) {
          for (var h = new Array(o.length).fill(null), _ = 0; _ < h.length; _++) h[_] = new Ze(o[_]);
          return h;
        } }]);
      })(), ka = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "findStabbedSegments", value: function() {
          if (arguments.length === 1) {
            for (var y = arguments[0], o = new ze(), h = this._subgraphs.iterator(); h.hasNext(); ) {
              var _ = h.next(), I = _.getEnvelope();
              y.y < I.getMinY() || y.y > I.getMaxY() || this.findStabbedSegments(y, _.getDirectedEdges(), o);
            }
            return o;
          }
          if (arguments.length === 3) {
            if (er(arguments[2], In) && arguments[0] instanceof Ze && arguments[1] instanceof ai) {
              for (var D = arguments[0], B = arguments[1], H = arguments[2], se = B.getEdge().getCoordinates(), de = 0; de < se.length - 1; de++)
                if (this._seg.p0 = se[de], this._seg.p1 = se[de + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < D.x || this._seg.isHorizontal() || D.y < this._seg.p0.y || D.y > this._seg.p1.y || ye.index(this._seg.p0, this._seg.p1, D) === ye.RIGHT)) {
                  var $e = B.getDepth(St.LEFT);
                  this._seg.p0.equals(se[de]) || ($e = B.getDepth(St.RIGHT));
                  var rt = new wn(this._seg, $e);
                  H.add(rt);
                }
            } else if (er(arguments[2], In) && arguments[0] instanceof Ze && er(arguments[1], In)) for (var vt = arguments[0], Gt = arguments[2], $t = arguments[1].iterator(); $t.hasNext(); ) {
              var Xt = $t.next();
              Xt.isForward() && this.findStabbedSegments(vt, Xt, Gt);
            }
          }
        } }, { key: "getDepth", value: function(y) {
          var o = this.findStabbedSegments(y);
          return o.size() === 0 ? 0 : nr.min(o)._leftDepth;
        } }], [{ key: "constructor_", value: function() {
          this._subgraphs = null, this._seg = new bi();
          var y = arguments[0];
          this._subgraphs = y;
        } }]);
      })(), wn = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "compareTo", value: function(y) {
          var o = y;
          if (this._upwardSeg.minX() >= o._upwardSeg.maxX()) return 1;
          if (this._upwardSeg.maxX() <= o._upwardSeg.minX()) return -1;
          var h = this._upwardSeg.orientationIndex(o._upwardSeg);
          return h !== 0 || (h = -1 * o._upwardSeg.orientationIndex(this._upwardSeg)) !== 0 ? h : this._upwardSeg.compareTo(o._upwardSeg);
        } }, { key: "compareX", value: function(y, o) {
          var h = y.p0.compareTo(o.p0);
          return h !== 0 ? h : y.p1.compareTo(o.p1);
        } }, { key: "toString", value: function() {
          return this._upwardSeg.toString();
        } }, { key: "interfaces_", get: function() {
          return [ot];
        } }], [{ key: "constructor_", value: function() {
          this._upwardSeg = null, this._leftDepth = null;
          var y = arguments[0], o = arguments[1];
          this._upwardSeg = new bi(y), this._leftDepth = o;
        } }]);
      })();
      ka.DepthSegment = wn;
      var _u = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, null, [{ key: "constructor_", value: function() {
          Qe.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
        } }]);
      })(Qe), sa = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getY", value: function() {
          var o = this.y / this.w;
          if (dt.isNaN(o) || dt.isInfinite(o)) throw new _u();
          return o;
        } }, { key: "getX", value: function() {
          var o = this.x / this.w;
          if (dt.isNaN(o) || dt.isInfinite(o)) throw new _u();
          return o;
        } }, { key: "getCoordinate", value: function() {
          var o = new Ze();
          return o.x = this.getX(), o.y = this.getY(), o;
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1;
          else if (arguments.length === 1) {
            var o = arguments[0];
            this.x = o.x, this.y = o.y, this.w = 1;
          } else if (arguments.length === 2) {
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var h = arguments[0], _ = arguments[1];
              this.x = h, this.y = _, this.w = 1;
            } else if (arguments[0] instanceof y && arguments[1] instanceof y) {
              var I = arguments[0], D = arguments[1];
              this.x = I.y * D.w - D.y * I.w, this.y = D.x * I.w - I.x * D.w, this.w = I.x * D.y - D.x * I.y;
            } else if (arguments[0] instanceof Ze && arguments[1] instanceof Ze) {
              var B = arguments[0], H = arguments[1];
              this.x = B.y - H.y, this.y = H.x - B.x, this.w = B.x * H.y - H.x * B.y;
            }
          } else if (arguments.length === 3) {
            var se = arguments[0], de = arguments[1], $e = arguments[2];
            this.x = se, this.y = de, this.w = $e;
          } else if (arguments.length === 4) {
            var rt = arguments[0], vt = arguments[1], Gt = arguments[2], $t = arguments[3], Xt = rt.y - vt.y, _r = vt.x - rt.x, or = rt.x * vt.y - vt.x * rt.y, Gr = Gt.y - $t.y, qn = $t.x - Gt.x, $n = Gt.x * $t.y - $t.x * Gt.y;
            this.x = _r * $n - qn * or, this.y = Gr * or - Xt * $n, this.w = Xt * qn - Gr * _r;
          }
        } }]);
      })(), Oo = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "area", value: function() {
          return y.area(this.p0, this.p1, this.p2);
        } }, { key: "signedArea", value: function() {
          return y.signedArea(this.p0, this.p1, this.p2);
        } }, { key: "interpolateZ", value: function(o) {
          if (o === null) throw new et("Supplied point is null.");
          return y.interpolateZ(o, this.p0, this.p1, this.p2);
        } }, { key: "longestSideLength", value: function() {
          return y.longestSideLength(this.p0, this.p1, this.p2);
        } }, { key: "isAcute", value: function() {
          return y.isAcute(this.p0, this.p1, this.p2);
        } }, { key: "circumcentre", value: function() {
          return y.circumcentre(this.p0, this.p1, this.p2);
        } }, { key: "area3D", value: function() {
          return y.area3D(this.p0, this.p1, this.p2);
        } }, { key: "centroid", value: function() {
          return y.centroid(this.p0, this.p1, this.p2);
        } }, { key: "inCentre", value: function() {
          return y.inCentre(this.p0, this.p1, this.p2);
        } }], [{ key: "constructor_", value: function() {
          this.p0 = null, this.p1 = null, this.p2 = null;
          var o = arguments[0], h = arguments[1], _ = arguments[2];
          this.p0 = o, this.p1 = h, this.p2 = _;
        } }, { key: "area", value: function(o, h, _) {
          return Math.abs(((_.x - o.x) * (h.y - o.y) - (h.x - o.x) * (_.y - o.y)) / 2);
        } }, { key: "signedArea", value: function(o, h, _) {
          return ((_.x - o.x) * (h.y - o.y) - (h.x - o.x) * (_.y - o.y)) / 2;
        } }, { key: "det", value: function(o, h, _, I) {
          return o * I - h * _;
        } }, { key: "interpolateZ", value: function(o, h, _, I) {
          var D = h.x, B = h.y, H = _.x - D, se = I.x - D, de = _.y - B, $e = I.y - B, rt = H * $e - se * de, vt = o.x - D, Gt = o.y - B, $t = ($e * vt - se * Gt) / rt, Xt = (-de * vt + H * Gt) / rt;
          return h.getZ() + $t * (_.getZ() - h.getZ()) + Xt * (I.getZ() - h.getZ());
        } }, { key: "longestSideLength", value: function(o, h, _) {
          var I = o.distance(h), D = h.distance(_), B = _.distance(o), H = I;
          return D > H && (H = D), B > H && (H = B), H;
        } }, { key: "circumcentreDD", value: function(o, h, _) {
          var I = J.valueOf(o.x).subtract(_.x), D = J.valueOf(o.y).subtract(_.y), B = J.valueOf(h.x).subtract(_.x), H = J.valueOf(h.y).subtract(_.y), se = J.determinant(I, D, B, H).multiply(2), de = I.sqr().add(D.sqr()), $e = B.sqr().add(H.sqr()), rt = J.determinant(D, de, H, $e), vt = J.determinant(I, de, B, $e), Gt = J.valueOf(_.x).subtract(rt.divide(se)).doubleValue(), $t = J.valueOf(_.y).add(vt.divide(se)).doubleValue();
          return new Ze(Gt, $t);
        } }, { key: "isAcute", value: function(o, h, _) {
          return !!wi.isAcute(o, h, _) && !!wi.isAcute(h, _, o) && !!wi.isAcute(_, o, h);
        } }, { key: "circumcentre", value: function(o, h, _) {
          var I = _.x, D = _.y, B = o.x - I, H = o.y - D, se = h.x - I, de = h.y - D, $e = 2 * y.det(B, H, se, de), rt = y.det(H, B * B + H * H, de, se * se + de * de), vt = y.det(B, B * B + H * H, se, se * se + de * de);
          return new Ze(I - rt / $e, D + vt / $e);
        } }, { key: "perpendicularBisector", value: function(o, h) {
          var _ = h.x - o.x, I = h.y - o.y, D = new sa(o.x + _ / 2, o.y + I / 2, 1), B = new sa(o.x - I + _ / 2, o.y + _ + I / 2, 1);
          return new sa(D, B);
        } }, { key: "angleBisector", value: function(o, h, _) {
          var I = h.distance(o), D = I / (I + h.distance(_)), B = _.x - o.x, H = _.y - o.y;
          return new Ze(o.x + D * B, o.y + D * H);
        } }, { key: "area3D", value: function(o, h, _) {
          var I = h.x - o.x, D = h.y - o.y, B = h.getZ() - o.getZ(), H = _.x - o.x, se = _.y - o.y, de = _.getZ() - o.getZ(), $e = D * de - B * se, rt = B * H - I * de, vt = I * se - D * H, Gt = $e * $e + rt * rt + vt * vt, $t = Math.sqrt(Gt) / 2;
          return $t;
        } }, { key: "centroid", value: function(o, h, _) {
          var I = (o.x + h.x + _.x) / 3, D = (o.y + h.y + _.y) / 3;
          return new Ze(I, D);
        } }, { key: "inCentre", value: function(o, h, _) {
          var I = h.distance(_), D = o.distance(_), B = o.distance(h), H = I + D + B, se = (I * o.x + D * h.x + B * _.x) / H, de = (I * o.y + D * h.y + B * _.y) / H;
          return new Ze(se, de);
        } }]);
      })(), Ia = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "addRingSide", value: function(y, o, h, _, I) {
          if (o === 0 && y.length < rr.MINIMUM_VALID_SIZE) return null;
          var D = _, B = I;
          y.length >= rr.MINIMUM_VALID_SIZE && ye.isCCW(y) && (D = I, B = _, h = St.opposite(h));
          var H = this._curveBuilder.getRingCurve(y, h, o);
          this.addCurve(H, D, B);
        } }, { key: "addRingBothSides", value: function(y, o) {
          this.addRingSide(y, o, St.LEFT, Me.EXTERIOR, Me.INTERIOR), this.addRingSide(y, o, St.RIGHT, Me.INTERIOR, Me.EXTERIOR);
        } }, { key: "addPoint", value: function(y) {
          if (this._distance <= 0) return null;
          var o = y.getCoordinates(), h = this._curveBuilder.getLineCurve(o, this._distance);
          this.addCurve(h, Me.EXTERIOR, Me.INTERIOR);
        } }, { key: "addPolygon", value: function(y) {
          var o = this._distance, h = St.LEFT;
          this._distance < 0 && (o = -this._distance, h = St.RIGHT);
          var _ = y.getExteriorRing(), I = bt.removeRepeatedPoints(_.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(_, this._distance) || this._distance <= 0 && I.length < 3) return null;
          this.addRingSide(I, o, h, Me.EXTERIOR, Me.INTERIOR);
          for (var D = 0; D < y.getNumInteriorRing(); D++) {
            var B = y.getInteriorRingN(D), H = bt.removeRepeatedPoints(B.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(B, -this._distance) || this.addRingSide(H, o, St.opposite(h), Me.INTERIOR, Me.EXTERIOR);
          }
        } }, { key: "isTriangleErodedCompletely", value: function(y, o) {
          var h = new Oo(y[0], y[1], y[2]), _ = h.inCentre();
          return cr.pointToSegment(_, h.p0, h.p1) < Math.abs(o);
        } }, { key: "addLineString", value: function(y) {
          if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
          var o = bt.removeRepeatedPoints(y.getCoordinates());
          if (bt.isRing(o) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(o, this._distance);
          else {
            var h = this._curveBuilder.getLineCurve(o, this._distance);
            this.addCurve(h, Me.EXTERIOR, Me.INTERIOR);
          }
        } }, { key: "addCurve", value: function(y, o, h) {
          if (y === null || y.length < 2) return null;
          var _ = new Gi(y, new Si(0, Me.BOUNDARY, o, h));
          this._curveList.add(_);
        } }, { key: "getCurves", value: function() {
          return this.add(this._inputGeom), this._curveList;
        } }, { key: "add", value: function(y) {
          if (y.isEmpty()) return null;
          if (y instanceof bn) this.addPolygon(y);
          else if (y instanceof Pr) this.addLineString(y);
          else if (y instanceof Yr) this.addPoint(y);
          else if (y instanceof ir) this.addCollection(y);
          else if (y instanceof As) this.addCollection(y);
          else if (y instanceof Or) this.addCollection(y);
          else {
            if (!(y instanceof xt)) throw new tr(y.getGeometryType());
            this.addCollection(y);
          }
        } }, { key: "isErodedCompletely", value: function(y, o) {
          var h = y.getCoordinates();
          if (h.length < 4) return o < 0;
          if (h.length === 4) return this.isTriangleErodedCompletely(h, o);
          var _ = y.getEnvelopeInternal(), I = Math.min(_.getHeight(), _.getWidth());
          return o < 0 && 2 * Math.abs(o) > I;
        } }, { key: "addCollection", value: function(y) {
          for (var o = 0; o < y.getNumGeometries(); o++) {
            var h = y.getGeometryN(o);
            this.add(h);
          }
        } }], [{ key: "constructor_", value: function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new ze();
          var y = arguments[0], o = arguments[1], h = arguments[2];
          this._inputGeom = y, this._distance = o, this._curveBuilder = h;
        } }]);
      })(), Qh = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "locate", value: function(y) {
        } }]);
      })(), bl = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "next", value: function() {
          if (this._atStart) return this._atStart = !1, y.isAtomic(this._parent) && this._index++, this._parent;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max) throw new ur();
          var o = this._parent.getGeometryN(this._index++);
          return o instanceof xt ? (this._subcollectionIterator = new y(o), this._subcollectionIterator.next()) : o;
        } }, { key: "remove", value: function() {
          throw new tr(this.getClass().getName());
        } }, { key: "hasNext", value: function() {
          if (this._atStart) return !0;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return !0;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        } }, { key: "interfaces_", get: function() {
          return [Kh];
        } }], [{ key: "constructor_", value: function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var o = arguments[0];
          this._parent = o, this._atStart = !0, this._index = 0, this._max = o.getNumGeometries();
        } }, { key: "isAtomic", value: function(o) {
          return !(o instanceof xt);
        } }]);
      })(), ed = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "locate", value: function(o) {
          return y.locate(o, this._geom);
        } }, { key: "interfaces_", get: function() {
          return [Qh];
        } }], [{ key: "constructor_", value: function() {
          this._geom = null;
          var o = arguments[0];
          this._geom = o;
        } }, { key: "locatePointInPolygon", value: function(o, h) {
          if (h.isEmpty()) return Me.EXTERIOR;
          var _ = h.getExteriorRing(), I = y.locatePointInRing(o, _);
          if (I !== Me.INTERIOR) return I;
          for (var D = 0; D < h.getNumInteriorRing(); D++) {
            var B = h.getInteriorRingN(D), H = y.locatePointInRing(o, B);
            if (H === Me.BOUNDARY) return Me.BOUNDARY;
            if (H === Me.INTERIOR) return Me.EXTERIOR;
          }
          return Me.INTERIOR;
        } }, { key: "locatePointInRing", value: function(o, h) {
          return h.getEnvelopeInternal().intersects(o) ? Lo.locateInRing(o, h.getCoordinates()) : Me.EXTERIOR;
        } }, { key: "containsPointInPolygon", value: function(o, h) {
          return Me.EXTERIOR !== y.locatePointInPolygon(o, h);
        } }, { key: "locateInGeometry", value: function(o, h) {
          if (h instanceof bn) return y.locatePointInPolygon(o, h);
          if (h instanceof xt) for (var _ = new bl(h); _.hasNext(); ) {
            var I = _.next();
            if (I !== h) {
              var D = y.locateInGeometry(o, I);
              if (D !== Me.EXTERIOR) return D;
            }
          }
          return Me.EXTERIOR;
        } }, { key: "isContained", value: function(o, h) {
          return Me.EXTERIOR !== y.locate(o, h);
        } }, { key: "locate", value: function(o, h) {
          return h.isEmpty() ? Me.EXTERIOR : h.getEnvelopeInternal().intersects(o) ? y.locateInGeometry(o, h) : Me.EXTERIOR;
        } }]);
      })(), io = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getNextCW", value: function(y) {
          this.getEdges();
          var o = this._edgeList.indexOf(y), h = o - 1;
          return o === 0 && (h = this._edgeList.size() - 1), this._edgeList.get(h);
        } }, { key: "propagateSideLabels", value: function(y) {
          for (var o = Me.NONE, h = this.iterator(); h.hasNext(); ) {
            var _ = h.next().getLabel();
            _.isArea(y) && _.getLocation(y, St.LEFT) !== Me.NONE && (o = _.getLocation(y, St.LEFT));
          }
          if (o === Me.NONE) return null;
          for (var I = o, D = this.iterator(); D.hasNext(); ) {
            var B = D.next(), H = B.getLabel();
            if (H.getLocation(y, St.ON) === Me.NONE && H.setLocation(y, St.ON, I), H.isArea(y)) {
              var se = H.getLocation(y, St.LEFT), de = H.getLocation(y, St.RIGHT);
              if (de !== Me.NONE) {
                if (de !== I) throw new qe("side location conflict", B.getCoordinate());
                se === Me.NONE && Pt.shouldNeverReachHere("found single null side (at " + B.getCoordinate() + ")"), I = se;
              } else Pt.isTrue(H.getLocation(y, St.LEFT) === Me.NONE, "found single null side"), H.setLocation(y, St.RIGHT, I), H.setLocation(y, St.LEFT, I);
            }
          }
        } }, { key: "getCoordinate", value: function() {
          var y = this.iterator();
          return y.hasNext() ? y.next().getCoordinate() : null;
        } }, { key: "print", value: function(y) {
          Nt.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var o = this.iterator(); o.hasNext(); )
            o.next().print(y);
        } }, { key: "isAreaLabelsConsistent", value: function(y) {
          return this.computeEdgeEndLabels(y.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        } }, { key: "checkAreaLabelsConsistent", value: function(y) {
          var o = this.getEdges();
          if (o.size() <= 0) return !0;
          var h = o.size() - 1, _ = o.get(h).getLabel().getLocation(y, St.LEFT);
          Pt.isTrue(_ !== Me.NONE, "Found unlabelled area edge");
          for (var I = _, D = this.iterator(); D.hasNext(); ) {
            var B = D.next().getLabel();
            Pt.isTrue(B.isArea(y), "Found non-area edge");
            var H = B.getLocation(y, St.LEFT), se = B.getLocation(y, St.RIGHT);
            if (H === se || se !== I) return !1;
            I = H;
          }
          return !0;
        } }, { key: "findIndex", value: function(y) {
          this.iterator();
          for (var o = 0; o < this._edgeList.size(); o++)
            if (this._edgeList.get(o) === y) return o;
          return -1;
        } }, { key: "iterator", value: function() {
          return this.getEdges().iterator();
        } }, { key: "getEdges", value: function() {
          return this._edgeList === null && (this._edgeList = new ze(this._edgeMap.values())), this._edgeList;
        } }, { key: "getLocation", value: function(y, o, h) {
          return this._ptInAreaLocation[y] === Me.NONE && (this._ptInAreaLocation[y] = ed.locate(o, h[y].getGeometry())), this._ptInAreaLocation[y];
        } }, { key: "toString", value: function() {
          var y = new Kr();
          y.append("EdgeEndStar:   " + this.getCoordinate()), y.append(`
`);
          for (var o = this.iterator(); o.hasNext(); ) {
            var h = o.next();
            y.append(h), y.append(`
`);
          }
          return y.toString();
        } }, { key: "computeEdgeEndLabels", value: function(y) {
          for (var o = this.iterator(); o.hasNext(); )
            o.next().computeLabel(y);
        } }, { key: "computeLabelling", value: function(y) {
          this.computeEdgeEndLabels(y[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var o = [!1, !1], h = this.iterator(); h.hasNext(); ) for (var _ = h.next().getLabel(), I = 0; I < 2; I++) _.isLine(I) && _.getLocation(I) === Me.BOUNDARY && (o[I] = !0);
          for (var D = this.iterator(); D.hasNext(); ) for (var B = D.next(), H = B.getLabel(), se = 0; se < 2; se++) if (H.isAnyNull(se)) {
            var de = Me.NONE;
            if (o[se]) de = Me.EXTERIOR;
            else {
              var $e = B.getCoordinate();
              de = this.getLocation(se, $e, y);
            }
            H.setAllLocationsIfNull(se, de);
          }
        } }, { key: "getDegree", value: function() {
          return this._edgeMap.size();
        } }, { key: "insertEdgeEnd", value: function(y, o) {
          this._edgeMap.put(y, o), this._edgeList = null;
        } }], [{ key: "constructor_", value: function() {
          this._edgeMap = new Ur(), this._edgeList = null, this._ptInAreaLocation = [Me.NONE, Me.NONE];
        } }]);
      })(), wl = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "linkResultDirectedEdges", value: function() {
          this.getResultAreaEdges();
          for (var h = null, _ = null, I = this._SCANNING_FOR_INCOMING, D = 0; D < this._resultAreaEdgeList.size(); D++) {
            var B = this._resultAreaEdgeList.get(D), H = B.getSym();
            if (B.getLabel().isArea()) switch (h === null && B.isInResult() && (h = B), I) {
              case this._SCANNING_FOR_INCOMING:
                if (!H.isInResult()) continue;
                _ = H, I = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (!B.isInResult()) continue;
                _.setNext(B), I = this._SCANNING_FOR_INCOMING;
            }
          }
          if (I === this._LINKING_TO_OUTGOING) {
            if (h === null) throw new qe("no outgoing dirEdge found", this.getCoordinate());
            Pt.isTrue(h.isInResult(), "unable to link last incoming dirEdge"), _.setNext(h);
          }
        } }, { key: "insert", value: function(h) {
          var _ = h;
          this.insertEdgeEnd(_, _);
        } }, { key: "getRightmostEdge", value: function() {
          var h = this.getEdges(), _ = h.size();
          if (_ < 1) return null;
          var I = h.get(0);
          if (_ === 1) return I;
          var D = h.get(_ - 1), B = I.getQuadrant(), H = D.getQuadrant();
          return rn.isNorthern(B) && rn.isNorthern(H) ? I : rn.isNorthern(B) || rn.isNorthern(H) ? I.getDy() !== 0 ? I : D.getDy() !== 0 ? D : (Pt.shouldNeverReachHere("found two horizontal edges incident on node"), null) : D;
        } }, { key: "print", value: function(h) {
          Nt.out.println("DirectedEdgeStar: " + this.getCoordinate());
          for (var _ = this.iterator(); _.hasNext(); ) {
            var I = _.next();
            h.print("out "), I.print(h), h.println(), h.print("in "), I.getSym().print(h), h.println();
          }
        } }, { key: "getResultAreaEdges", value: function() {
          if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
          this._resultAreaEdgeList = new ze();
          for (var h = this.iterator(); h.hasNext(); ) {
            var _ = h.next();
            (_.isInResult() || _.getSym().isInResult()) && this._resultAreaEdgeList.add(_);
          }
          return this._resultAreaEdgeList;
        } }, { key: "updateLabelling", value: function(h) {
          for (var _ = this.iterator(); _.hasNext(); ) {
            var I = _.next().getLabel();
            I.setAllLocationsIfNull(0, h.getLocation(0)), I.setAllLocationsIfNull(1, h.getLocation(1));
          }
        } }, { key: "linkAllDirectedEdges", value: function() {
          this.getEdges();
          for (var h = null, _ = null, I = this._edgeList.size() - 1; I >= 0; I--) {
            var D = this._edgeList.get(I), B = D.getSym();
            _ === null && (_ = B), h !== null && B.setNext(h), h = D;
          }
          _.setNext(h);
        } }, { key: "computeDepths", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0], _ = this.findIndex(h), I = h.getDepth(St.LEFT), D = h.getDepth(St.RIGHT), B = this.computeDepths(_ + 1, this._edgeList.size(), I);
            if (this.computeDepths(0, _, B) !== D) throw new qe("depth mismatch at " + h.getCoordinate());
          } else if (arguments.length === 3) {
            for (var H = arguments[1], se = arguments[2], de = arguments[0]; de < H; de++) {
              var $e = this._edgeList.get(de);
              $e.setEdgeDepths(St.RIGHT, se), se = $e.getDepth(St.LEFT);
            }
            return se;
          }
        } }, { key: "mergeSymLabels", value: function() {
          for (var h = this.iterator(); h.hasNext(); ) {
            var _ = h.next();
            _.getLabel().merge(_.getSym().getLabel());
          }
        } }, { key: "linkMinimalDirectedEdges", value: function(h) {
          for (var _ = null, I = null, D = this._SCANNING_FOR_INCOMING, B = this._resultAreaEdgeList.size() - 1; B >= 0; B--) {
            var H = this._resultAreaEdgeList.get(B), se = H.getSym();
            switch (_ === null && H.getEdgeRing() === h && (_ = H), D) {
              case this._SCANNING_FOR_INCOMING:
                if (se.getEdgeRing() !== h) continue;
                I = se, D = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (H.getEdgeRing() !== h) continue;
                I.setNextMin(H), D = this._SCANNING_FOR_INCOMING;
            }
          }
          D === this._LINKING_TO_OUTGOING && (Pt.isTrue(_ !== null, "found null for first outgoing dirEdge"), Pt.isTrue(_.getEdgeRing() === h, "unable to link last incoming dirEdge"), I.setNextMin(_));
        } }, { key: "getOutgoingDegree", value: function() {
          if (arguments.length === 0) {
            for (var h = 0, _ = this.iterator(); _.hasNext(); )
              _.next().isInResult() && h++;
            return h;
          }
          if (arguments.length === 1) {
            for (var I = arguments[0], D = 0, B = this.iterator(); B.hasNext(); )
              B.next().getEdgeRing() === I && D++;
            return D;
          }
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "findCoveredLineEdges", value: function() {
          for (var h = Me.NONE, _ = this.iterator(); _.hasNext(); ) {
            var I = _.next(), D = I.getSym();
            if (!I.isLineEdge()) {
              if (I.isInResult()) {
                h = Me.INTERIOR;
                break;
              }
              if (D.isInResult()) {
                h = Me.EXTERIOR;
                break;
              }
            }
          }
          if (h === Me.NONE) return null;
          for (var B = h, H = this.iterator(); H.hasNext(); ) {
            var se = H.next(), de = se.getSym();
            se.isLineEdge() ? se.getEdge().setCovered(B === Me.INTERIOR) : (se.isInResult() && (B = Me.EXTERIOR), de.isInResult() && (B = Me.INTERIOR));
          }
        } }, { key: "computeLabelling", value: function(h) {
          ce(o, "computeLabelling", this, 1).call(this, h), this._label = new Si(Me.NONE);
          for (var _ = this.iterator(); _.hasNext(); ) for (var I = _.next().getEdge().getLabel(), D = 0; D < 2; D++) {
            var B = I.getLocation(D);
            B !== Me.INTERIOR && B !== Me.BOUNDARY || this._label.setLocation(D, Me.INTERIOR);
          }
        } }], [{ key: "constructor_", value: function() {
          this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
        } }]);
      })(io), Ic = (function(y) {
        function o() {
          return x(this, o), p(this, o);
        }
        return $(o, y), u(o, [{ key: "createNode", value: function(h) {
          return new Lr(h, new wl());
        } }]);
      })(ia), yu = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "compareTo", value: function(o) {
          var h = o;
          return y.compareOriented(this._pts, this._orientation, h._pts, h._orientation);
        } }, { key: "interfaces_", get: function() {
          return [ot];
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._orientation = null;
          var o = arguments[0];
          this._pts = o, this._orientation = y.orientation(o);
        } }, { key: "orientation", value: function(o) {
          return bt.increasingDirection(o) === 1;
        } }, { key: "compareOriented", value: function(o, h, _, I) {
          for (var D = h ? 1 : -1, B = I ? 1 : -1, H = h ? o.length : -1, se = I ? _.length : -1, de = h ? 0 : o.length - 1, $e = I ? 0 : _.length - 1; ; ) {
            var rt = o[de].compareTo(_[$e]);
            if (rt !== 0) return rt;
            var vt = (de += D) === H, Gt = ($e += B) === se;
            if (vt && !Gt) return -1;
            if (!vt && Gt) return 1;
            if (vt && Gt) return 0;
          }
        } }]);
      })(), vu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "print", value: function(y) {
          y.print("MULTILINESTRING ( ");
          for (var o = 0; o < this._edges.size(); o++) {
            var h = this._edges.get(o);
            o > 0 && y.print(","), y.print("(");
            for (var _ = h.getCoordinates(), I = 0; I < _.length; I++) I > 0 && y.print(","), y.print(_[I].x + " " + _[I].y);
            y.println(")");
          }
          y.print(")  ");
        } }, { key: "addAll", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); ) this.add(o.next());
        } }, { key: "findEdgeIndex", value: function(y) {
          for (var o = 0; o < this._edges.size(); o++) if (this._edges.get(o).equals(y)) return o;
          return -1;
        } }, { key: "iterator", value: function() {
          return this._edges.iterator();
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "get", value: function(y) {
          return this._edges.get(y);
        } }, { key: "findEqualEdge", value: function(y) {
          var o = new yu(y.getCoordinates());
          return this._ocaMap.get(o);
        } }, { key: "add", value: function(y) {
          this._edges.add(y);
          var o = new yu(y.getCoordinates());
          this._ocaMap.put(o, y);
        } }], [{ key: "constructor_", value: function() {
          this._edges = new ze(), this._ocaMap = new Ur();
        } }]);
      })(), El = (function() {
        return u((function y() {
          x(this, y);
        }), [{ key: "processIntersections", value: function(y, o, h, _) {
        } }, { key: "isDone", value: function() {
        } }]);
      })(), xu = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "isTrivialIntersection", value: function(o, h, _, I) {
          if (o === _ && this._li.getIntersectionNum() === 1) {
            if (y.isAdjacentSegments(h, I)) return !0;
            if (o.isClosed()) {
              var D = o.size() - 1;
              if (h === 0 && I === D || I === 0 && h === D) return !0;
            }
          }
          return !1;
        } }, { key: "getProperIntersectionPoint", value: function() {
          return this._properIntersectionPoint;
        } }, { key: "hasProperInteriorIntersection", value: function() {
          return this._hasProperInterior;
        } }, { key: "getLineIntersector", value: function() {
          return this._li;
        } }, { key: "hasProperIntersection", value: function() {
          return this._hasProper;
        } }, { key: "processIntersections", value: function(o, h, _, I) {
          if (o === _ && h === I) return null;
          this.numTests++;
          var D = o.getCoordinates()[h], B = o.getCoordinates()[h + 1], H = _.getCoordinates()[I], se = _.getCoordinates()[I + 1];
          this._li.computeIntersection(D, B, H, se), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(o, h, _, I) || (this._hasIntersection = !0, o.addIntersections(this._li, h, 0), _.addIntersections(this._li, I, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
        } }, { key: "hasIntersection", value: function() {
          return this._hasIntersection;
        } }, { key: "isDone", value: function() {
          return !1;
        } }, { key: "hasInteriorIntersection", value: function() {
          return this._hasInterior;
        } }, { key: "interfaces_", get: function() {
          return [El];
        } }], [{ key: "constructor_", value: function() {
          this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var o = arguments[0];
          this._li = o;
        } }, { key: "isAdjacentSegments", value: function(o, h) {
          return Math.abs(o - h) === 1;
        } }]);
      })(), Mc = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getSegmentIndex", value: function() {
          return this.segmentIndex;
        } }, { key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(y) {
          y.print(this.coord), y.print(" seg # = " + this.segmentIndex), y.println(" dist = " + this.dist);
        } }, { key: "compareTo", value: function(y) {
          var o = y;
          return this.compare(o.segmentIndex, o.dist);
        } }, { key: "isEndPoint", value: function(y) {
          return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === y;
        } }, { key: "toString", value: function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        } }, { key: "getDistance", value: function() {
          return this.dist;
        } }, { key: "compare", value: function(y, o) {
          return this.segmentIndex < y ? -1 : this.segmentIndex > y ? 1 : this.dist < o ? -1 : this.dist > o ? 1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [ot];
        } }], [{ key: "constructor_", value: function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var y = arguments[0], o = arguments[1], h = arguments[2];
          this.coord = new Ze(y), this.segmentIndex = o, this.dist = h;
        } }]);
      })(), Cc = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "print", value: function(y) {
          y.println("Intersections:");
          for (var o = this.iterator(); o.hasNext(); )
            o.next().print(y);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(y) {
          this.addEndpoints();
          for (var o = this.iterator(), h = o.next(); o.hasNext(); ) {
            var _ = o.next(), I = this.createSplitEdge(h, _);
            y.add(I), h = _;
          }
        } }, { key: "addEndpoints", value: function() {
          var y = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[y], y, 0);
        } }, { key: "createSplitEdge", value: function(y, o) {
          var h = o.segmentIndex - y.segmentIndex + 2, _ = this.edge.pts[o.segmentIndex], I = o.dist > 0 || !o.coord.equals2D(_);
          I || h--;
          var D = new Array(h).fill(null), B = 0;
          D[B++] = new Ze(y.coord);
          for (var H = y.segmentIndex + 1; H <= o.segmentIndex; H++) D[B++] = this.edge.pts[H];
          return I && (D[B] = o.coord), new wu(D, new Si(this.edge._label));
        } }, { key: "add", value: function(y, o, h) {
          var _ = new Mc(y, o, h), I = this._nodeMap.get(_);
          return I !== null ? I : (this._nodeMap.put(_, _), _);
        } }, { key: "isIntersection", value: function(y) {
          for (var o = this.iterator(); o.hasNext(); )
            if (o.next().coord.equals(y)) return !0;
          return !1;
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new Ur(), this.edge = null;
          var y = arguments[0];
          this.edge = y;
        } }]);
      })(), Pc = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "isIntersects", value: function() {
          return !this.isDisjoint();
        } }, { key: "isCovers", value: function() {
          return (y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) || y.isTrue(this._matrix[Me.INTERIOR][Me.BOUNDARY]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.INTERIOR]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.BOUNDARY])) && this._matrix[Me.EXTERIOR][Me.INTERIOR] === mt.FALSE && this._matrix[Me.EXTERIOR][Me.BOUNDARY] === mt.FALSE;
        } }, { key: "isCoveredBy", value: function() {
          return (y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) || y.isTrue(this._matrix[Me.INTERIOR][Me.BOUNDARY]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.INTERIOR]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.BOUNDARY])) && this._matrix[Me.INTERIOR][Me.EXTERIOR] === mt.FALSE && this._matrix[Me.BOUNDARY][Me.EXTERIOR] === mt.FALSE;
        } }, { key: "set", value: function() {
          if (arguments.length === 1) for (var o = arguments[0], h = 0; h < o.length; h++) {
            var _ = Math.trunc(h / 3), I = h % 3;
            this._matrix[_][I] = mt.toDimensionValue(o.charAt(h));
          }
          else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], H = arguments[2];
            this._matrix[D][B] = H;
          }
        } }, { key: "isContains", value: function() {
          return y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && this._matrix[Me.EXTERIOR][Me.INTERIOR] === mt.FALSE && this._matrix[Me.EXTERIOR][Me.BOUNDARY] === mt.FALSE;
        } }, { key: "setAtLeast", value: function() {
          if (arguments.length === 1) for (var o = arguments[0], h = 0; h < o.length; h++) {
            var _ = Math.trunc(h / 3), I = h % 3;
            this.setAtLeast(_, I, mt.toDimensionValue(o.charAt(h)));
          }
          else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1], H = arguments[2];
            this._matrix[D][B] < H && (this._matrix[D][B] = H);
          }
        } }, { key: "setAtLeastIfValid", value: function(o, h, _) {
          o >= 0 && h >= 0 && this.setAtLeast(o, h, _);
        } }, { key: "isWithin", value: function() {
          return y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && this._matrix[Me.INTERIOR][Me.EXTERIOR] === mt.FALSE && this._matrix[Me.BOUNDARY][Me.EXTERIOR] === mt.FALSE;
        } }, { key: "isTouches", value: function(o, h) {
          return o > h ? this.isTouches(h, o) : (o === mt.A && h === mt.A || o === mt.L && h === mt.L || o === mt.L && h === mt.A || o === mt.P && h === mt.A || o === mt.P && h === mt.L) && this._matrix[Me.INTERIOR][Me.INTERIOR] === mt.FALSE && (y.isTrue(this._matrix[Me.INTERIOR][Me.BOUNDARY]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.INTERIOR]) || y.isTrue(this._matrix[Me.BOUNDARY][Me.BOUNDARY]));
        } }, { key: "isOverlaps", value: function(o, h) {
          return o === mt.P && h === mt.P || o === mt.A && h === mt.A ? y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && y.isTrue(this._matrix[Me.INTERIOR][Me.EXTERIOR]) && y.isTrue(this._matrix[Me.EXTERIOR][Me.INTERIOR]) : o === mt.L && h === mt.L && this._matrix[Me.INTERIOR][Me.INTERIOR] === 1 && y.isTrue(this._matrix[Me.INTERIOR][Me.EXTERIOR]) && y.isTrue(this._matrix[Me.EXTERIOR][Me.INTERIOR]);
        } }, { key: "isEquals", value: function(o, h) {
          return o === h && y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && this._matrix[Me.INTERIOR][Me.EXTERIOR] === mt.FALSE && this._matrix[Me.BOUNDARY][Me.EXTERIOR] === mt.FALSE && this._matrix[Me.EXTERIOR][Me.INTERIOR] === mt.FALSE && this._matrix[Me.EXTERIOR][Me.BOUNDARY] === mt.FALSE;
        } }, { key: "toString", value: function() {
          for (var o = new Cr("123456789"), h = 0; h < 3; h++) for (var _ = 0; _ < 3; _++) o.setCharAt(3 * h + _, mt.toDimensionSymbol(this._matrix[h][_]));
          return o.toString();
        } }, { key: "setAll", value: function(o) {
          for (var h = 0; h < 3; h++) for (var _ = 0; _ < 3; _++) this._matrix[h][_] = o;
        } }, { key: "get", value: function(o, h) {
          return this._matrix[o][h];
        } }, { key: "transpose", value: function() {
          var o = this._matrix[1][0];
          return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = o, o = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = o, o = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = o, this;
        } }, { key: "matches", value: function(o) {
          if (o.length !== 9) throw new et("Should be length 9: " + o);
          for (var h = 0; h < 3; h++) for (var _ = 0; _ < 3; _++) if (!y.matches(this._matrix[h][_], o.charAt(3 * h + _))) return !1;
          return !0;
        } }, { key: "add", value: function(o) {
          for (var h = 0; h < 3; h++) for (var _ = 0; _ < 3; _++) this.setAtLeast(h, _, o.get(h, _));
        } }, { key: "isDisjoint", value: function() {
          return this._matrix[Me.INTERIOR][Me.INTERIOR] === mt.FALSE && this._matrix[Me.INTERIOR][Me.BOUNDARY] === mt.FALSE && this._matrix[Me.BOUNDARY][Me.INTERIOR] === mt.FALSE && this._matrix[Me.BOUNDARY][Me.BOUNDARY] === mt.FALSE;
        } }, { key: "isCrosses", value: function(o, h) {
          return o === mt.P && h === mt.L || o === mt.P && h === mt.A || o === mt.L && h === mt.A ? y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && y.isTrue(this._matrix[Me.INTERIOR][Me.EXTERIOR]) : o === mt.L && h === mt.P || o === mt.A && h === mt.P || o === mt.A && h === mt.L ? y.isTrue(this._matrix[Me.INTERIOR][Me.INTERIOR]) && y.isTrue(this._matrix[Me.EXTERIOR][Me.INTERIOR]) : o === mt.L && h === mt.L && this._matrix[Me.INTERIOR][Me.INTERIOR] === 0;
        } }, { key: "interfaces_", get: function() {
          return [Q];
        } }], [{ key: "constructor_", value: function() {
          if (this._matrix = null, arguments.length === 0) this._matrix = Array(3).fill().map((function() {
            return Array(3);
          })), this.setAll(mt.FALSE);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "string") {
              var o = arguments[0];
              y.constructor_.call(this), this.set(o);
            } else if (arguments[0] instanceof y) {
              var h = arguments[0];
              y.constructor_.call(this), this._matrix[Me.INTERIOR][Me.INTERIOR] = h._matrix[Me.INTERIOR][Me.INTERIOR], this._matrix[Me.INTERIOR][Me.BOUNDARY] = h._matrix[Me.INTERIOR][Me.BOUNDARY], this._matrix[Me.INTERIOR][Me.EXTERIOR] = h._matrix[Me.INTERIOR][Me.EXTERIOR], this._matrix[Me.BOUNDARY][Me.INTERIOR] = h._matrix[Me.BOUNDARY][Me.INTERIOR], this._matrix[Me.BOUNDARY][Me.BOUNDARY] = h._matrix[Me.BOUNDARY][Me.BOUNDARY], this._matrix[Me.BOUNDARY][Me.EXTERIOR] = h._matrix[Me.BOUNDARY][Me.EXTERIOR], this._matrix[Me.EXTERIOR][Me.INTERIOR] = h._matrix[Me.EXTERIOR][Me.INTERIOR], this._matrix[Me.EXTERIOR][Me.BOUNDARY] = h._matrix[Me.EXTERIOR][Me.BOUNDARY], this._matrix[Me.EXTERIOR][Me.EXTERIOR] = h._matrix[Me.EXTERIOR][Me.EXTERIOR];
            }
          }
        } }, { key: "matches", value: function() {
          if (Number.isInteger(arguments[0]) && typeof arguments[1] == "string") {
            var o = arguments[0], h = arguments[1];
            return h === mt.SYM_DONTCARE || h === mt.SYM_TRUE && (o >= 0 || o === mt.TRUE) || h === mt.SYM_FALSE && o === mt.FALSE || h === mt.SYM_P && o === mt.P || h === mt.SYM_L && o === mt.L || h === mt.SYM_A && o === mt.A;
          }
          if (typeof arguments[0] == "string" && typeof arguments[1] == "string") {
            var _ = arguments[1];
            return new y(arguments[0]).matches(_);
          }
        } }, { key: "isTrue", value: function(o) {
          return o >= 0 || o === mt.TRUE;
        } }]);
      })(), Ma = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "size", value: function() {
          return this._size;
        } }, { key: "addAll", value: function(o) {
          return o === null || o.length === 0 ? null : (this.ensureCapacity(this._size + o.length), Nt.arraycopy(o, 0, this._data, this._size, o.length), void (this._size += o.length));
        } }, { key: "ensureCapacity", value: function(o) {
          if (o <= this._data.length) return null;
          var h = Math.max(o, 2 * this._data.length);
          this._data = Rn.copyOf(this._data, h);
        } }, { key: "toArray", value: function() {
          var o = new Array(this._size).fill(null);
          return Nt.arraycopy(this._data, 0, o, 0, this._size), o;
        } }, { key: "add", value: function(o) {
          this.ensureCapacity(this._size + 1), this._data[this._size] = o, ++this._size;
        } }], [{ key: "constructor_", value: function() {
          if (this._data = null, this._size = 0, arguments.length === 0) y.constructor_.call(this, 10);
          else if (arguments.length === 1) {
            var o = arguments[0];
            this._data = new Array(o).fill(null);
          }
        } }]);
      })(), Ac = (function() {
        function y() {
          x(this, y);
        }
        return u(y, [{ key: "getChainStartIndices", value: function(o) {
          var h = 0, _ = new Ma(Math.trunc(o.length / 2));
          _.add(h);
          do {
            var I = this.findChainEnd(o, h);
            _.add(I), h = I;
          } while (h < o.length - 1);
          return _.toArray();
        } }, { key: "findChainEnd", value: function(o, h) {
          for (var _ = rn.quadrant(o[h], o[h + 1]), I = h + 1; I < o.length && rn.quadrant(o[I - 1], o[I]) === _; )
            I++;
          return I - 1;
        } }, { key: "OLDgetChainStartIndices", value: function(o) {
          var h = 0, _ = new ze();
          _.add(h);
          do {
            var I = this.findChainEnd(o, h);
            _.add(I), h = I;
          } while (h < o.length - 1);
          return y.toIntArray(_);
        } }], [{ key: "toIntArray", value: function(o) {
          for (var h = new Array(o.size()).fill(null), _ = 0; _ < h.length; _++) h[_] = o.get(_).intValue();
          return h;
        } }]);
      })(), bu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "getMaxX", value: function(y) {
          var o = this.pts[this.startIndex[y]].x, h = this.pts[this.startIndex[y + 1]].x;
          return o > h ? o : h;
        } }, { key: "getMinX", value: function(y) {
          var o = this.pts[this.startIndex[y]].x, h = this.pts[this.startIndex[y + 1]].x;
          return o < h ? o : h;
        } }, { key: "computeIntersectsForChain", value: function() {
          if (arguments.length === 4) {
            var y = arguments[0], o = arguments[1], h = arguments[2], _ = arguments[3];
            this.computeIntersectsForChain(this.startIndex[y], this.startIndex[y + 1], o, o.startIndex[h], o.startIndex[h + 1], _);
          } else if (arguments.length === 6) {
            var I = arguments[0], D = arguments[1], B = arguments[2], H = arguments[3], se = arguments[4], de = arguments[5];
            if (D - I == 1 && se - H == 1) return de.addIntersections(this.e, I, B.e, H), null;
            if (!this.overlaps(I, D, B, H, se)) return null;
            var $e = Math.trunc((I + D) / 2), rt = Math.trunc((H + se) / 2);
            I < $e && (H < rt && this.computeIntersectsForChain(I, $e, B, H, rt, de), rt < se && this.computeIntersectsForChain(I, $e, B, rt, se, de)), $e < D && (H < rt && this.computeIntersectsForChain($e, D, B, H, rt, de), rt < se && this.computeIntersectsForChain($e, D, B, rt, se, de));
          }
        } }, { key: "overlaps", value: function(y, o, h, _, I) {
          return lr.intersects(this.pts[y], this.pts[o], h.pts[_], h.pts[I]);
        } }, { key: "getStartIndexes", value: function() {
          return this.startIndex;
        } }, { key: "computeIntersects", value: function(y, o) {
          for (var h = 0; h < this.startIndex.length - 1; h++) for (var _ = 0; _ < y.startIndex.length - 1; _++) this.computeIntersectsForChain(h, y, _, o);
        } }], [{ key: "constructor_", value: function() {
          this.e = null, this.pts = null, this.startIndex = null;
          var y = arguments[0];
          this.e = y, this.pts = y.getCoordinates();
          var o = new Ac();
          this.startIndex = o.getChainStartIndices(this.pts);
        } }]);
      })(), Ca = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "getDepth", value: function(o, h) {
          return this._depth[o][h];
        } }, { key: "setDepth", value: function(o, h, _) {
          this._depth[o][h] = _;
        } }, { key: "isNull", value: function() {
          if (arguments.length === 0) {
            for (var o = 0; o < 2; o++) for (var h = 0; h < 3; h++) if (this._depth[o][h] !== y.NULL_VALUE) return !1;
            return !0;
          }
          if (arguments.length === 1) {
            var _ = arguments[0];
            return this._depth[_][1] === y.NULL_VALUE;
          }
          if (arguments.length === 2) {
            var I = arguments[0], D = arguments[1];
            return this._depth[I][D] === y.NULL_VALUE;
          }
        } }, { key: "normalize", value: function() {
          for (var o = 0; o < 2; o++) if (!this.isNull(o)) {
            var h = this._depth[o][1];
            this._depth[o][2] < h && (h = this._depth[o][2]), h < 0 && (h = 0);
            for (var _ = 1; _ < 3; _++) {
              var I = 0;
              this._depth[o][_] > h && (I = 1), this._depth[o][_] = I;
            }
          }
        } }, { key: "getDelta", value: function(o) {
          return this._depth[o][St.RIGHT] - this._depth[o][St.LEFT];
        } }, { key: "getLocation", value: function(o, h) {
          return this._depth[o][h] <= 0 ? Me.EXTERIOR : Me.INTERIOR;
        } }, { key: "toString", value: function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        } }, { key: "add", value: function() {
          if (arguments.length === 1) for (var o = arguments[0], h = 0; h < 2; h++) for (var _ = 1; _ < 3; _++) {
            var I = o.getLocation(h, _);
            I !== Me.EXTERIOR && I !== Me.INTERIOR || (this.isNull(h, _) ? this._depth[h][_] = y.depthAtLocation(I) : this._depth[h][_] += y.depthAtLocation(I));
          }
          else if (arguments.length === 3) {
            var D = arguments[0], B = arguments[1];
            arguments[2] === Me.INTERIOR && this._depth[D][B]++;
          }
        } }], [{ key: "constructor_", value: function() {
          this._depth = Array(2).fill().map((function() {
            return Array(3);
          }));
          for (var o = 0; o < 2; o++) for (var h = 0; h < 3; h++) this._depth[o][h] = y.NULL_VALUE;
        } }, { key: "depthAtLocation", value: function(o) {
          return o === Me.EXTERIOR ? 0 : o === Me.INTERIOR ? 1 : y.NULL_VALUE;
        } }]);
      })();
      Ca.NULL_VALUE = -1;
      var wu = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "getDepth", value: function() {
          return this._depth;
        } }, { key: "getCollapsedEdge", value: function() {
          var h = new Array(2).fill(null);
          return h[0] = this.pts[0], h[1] = this.pts[1], new o(h, Si.toLineLabel(this._label));
        } }, { key: "isIsolated", value: function() {
          return this._isIsolated;
        } }, { key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "setIsolated", value: function(h) {
          this._isIsolated = h;
        } }, { key: "setName", value: function(h) {
          this._name = h;
        } }, { key: "equals", value: function(h) {
          if (!(h instanceof o)) return !1;
          var _ = h;
          if (this.pts.length !== _.pts.length) return !1;
          for (var I = !0, D = !0, B = this.pts.length, H = 0; H < this.pts.length; H++) if (this.pts[H].equals2D(_.pts[H]) || (I = !1), this.pts[H].equals2D(_.pts[--B]) || (D = !1), !I && !D) return !1;
          return !0;
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null;
          if (arguments.length === 1) {
            var h = arguments[0];
            return this.pts[h];
          }
        } }, { key: "print", value: function(h) {
          h.print("edge " + this._name + ": "), h.print("LINESTRING (");
          for (var _ = 0; _ < this.pts.length; _++) _ > 0 && h.print(","), h.print(this.pts[_].x + " " + this.pts[_].y);
          h.print(")  " + this._label + " " + this._depthDelta);
        } }, { key: "computeIM", value: function(h) {
          o.updateIM(this._label, h);
        } }, { key: "isCollapsed", value: function() {
          return !!this._label.isArea() && this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]);
        } }, { key: "isClosed", value: function() {
          return this.pts[0].equals(this.pts[this.pts.length - 1]);
        } }, { key: "getMaximumSegmentIndex", value: function() {
          return this.pts.length - 1;
        } }, { key: "getDepthDelta", value: function() {
          return this._depthDelta;
        } }, { key: "getNumPoints", value: function() {
          return this.pts.length;
        } }, { key: "printReverse", value: function(h) {
          h.print("edge " + this._name + ": ");
          for (var _ = this.pts.length - 1; _ >= 0; _--) h.print(this.pts[_] + " ");
          h.println("");
        } }, { key: "getMonotoneChainEdge", value: function() {
          return this._mce === null && (this._mce = new bu(this)), this._mce;
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            this._env = new lr();
            for (var h = 0; h < this.pts.length; h++) this._env.expandToInclude(this.pts[h]);
          }
          return this._env;
        } }, { key: "addIntersection", value: function(h, _, I, D) {
          var B = new Ze(h.getIntersection(D)), H = _, se = h.getEdgeDistance(I, D), de = H + 1;
          if (de < this.pts.length) {
            var $e = this.pts[de];
            B.equals2D($e) && (H = de, se = 0);
          }
          this.eiList.add(B, H, se);
        } }, { key: "toString", value: function() {
          var h = new Cr();
          h.append("edge " + this._name + ": "), h.append("LINESTRING (");
          for (var _ = 0; _ < this.pts.length; _++) _ > 0 && h.append(","), h.append(this.pts[_].x + " " + this.pts[_].y);
          return h.append(")  " + this._label + " " + this._depthDelta), h.toString();
        } }, { key: "isPointwiseEqual", value: function(h) {
          if (this.pts.length !== h.pts.length) return !1;
          for (var _ = 0; _ < this.pts.length; _++) if (!this.pts[_].equals2D(h.pts[_])) return !1;
          return !0;
        } }, { key: "setDepthDelta", value: function(h) {
          this._depthDelta = h;
        } }, { key: "getEdgeIntersectionList", value: function() {
          return this.eiList;
        } }, { key: "addIntersections", value: function(h, _, I) {
          for (var D = 0; D < h.getIntersectionNum(); D++) this.addIntersection(h, _, I, D);
        } }], [{ key: "constructor_", value: function() {
          if (this.pts = null, this._env = null, this.eiList = new Cc(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new Ca(), this._depthDelta = 0, arguments.length === 1) {
            var h = arguments[0];
            o.constructor_.call(this, h, null);
          } else if (arguments.length === 2) {
            var _ = arguments[0], I = arguments[1];
            this.pts = _, this._label = I;
          }
        } }, { key: "updateIM", value: function() {
          if (!(arguments.length === 2 && arguments[1] instanceof Pc && arguments[0] instanceof Si)) return ce(o, "updateIM", this).apply(this, arguments);
          var h = arguments[0], _ = arguments[1];
          _.setAtLeastIfValid(h.getLocation(0, St.ON), h.getLocation(1, St.ON), 1), h.isArea() && (_.setAtLeastIfValid(h.getLocation(0, St.LEFT), h.getLocation(1, St.LEFT), 2), _.setAtLeastIfValid(h.getLocation(0, St.RIGHT), h.getLocation(1, St.RIGHT), 2));
        } }]);
      })(Qt), zo = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "setWorkingPrecisionModel", value: function(o) {
          this._workingPrecisionModel = o;
        } }, { key: "insertUniqueEdge", value: function(o) {
          var h = this._edgeList.findEqualEdge(o);
          if (h !== null) {
            var _ = h.getLabel(), I = o.getLabel();
            h.isPointwiseEqual(o) || (I = new Si(o.getLabel())).flip(), _.merge(I);
            var D = y.depthDelta(I), B = h.getDepthDelta() + D;
            h.setDepthDelta(B);
          } else this._edgeList.add(o), o.setDepthDelta(y.depthDelta(o.getLabel()));
        } }, { key: "buildSubgraphs", value: function(o, h) {
          for (var _ = new ze(), I = o.iterator(); I.hasNext(); ) {
            var D = I.next(), B = D.getRightmostCoordinate(), H = new ka(_).getDepth(B);
            D.computeDepth(H), D.findResultEdges(), _.add(D), h.add(D.getDirectedEdges(), D.getNodes());
          }
        } }, { key: "createSubgraphs", value: function(o) {
          for (var h = new ze(), _ = o.getNodes().iterator(); _.hasNext(); ) {
            var I = _.next();
            if (!I.isVisited()) {
              var D = new ct();
              D.create(I), h.add(D);
            }
          }
          return nr.sort(h, nr.reverseOrder()), h;
        } }, { key: "createEmptyResultGeometry", value: function() {
          return this._geomFact.createPolygon();
        } }, { key: "getNoder", value: function(o) {
          if (this._workingNoder !== null) return this._workingNoder;
          var h = new mu(), _ = new Yi();
          return _.setPrecisionModel(o), h.setSegmentIntersector(new xu(_)), h;
        } }, { key: "buffer", value: function(o, h) {
          var _ = this._workingPrecisionModel;
          _ === null && (_ = o.getPrecisionModel()), this._geomFact = o.getFactory();
          var I = new no(_, this._bufParams), D = new Ia(o, h, I).getCurves();
          if (D.size() <= 0) return this.createEmptyResultGeometry();
          this.computeNodedEdges(D, _), this._graph = new xs(new Ic()), this._graph.addEdges(this._edgeList.getEdges());
          var B = this.createSubgraphs(this._graph), H = new Tc(this._geomFact);
          this.buildSubgraphs(B, H);
          var se = H.getPolygons();
          return se.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(se);
        } }, { key: "computeNodedEdges", value: function(o, h) {
          var _ = this.getNoder(h);
          _.computeNodes(o);
          for (var I = _.getNodedSubstrings().iterator(); I.hasNext(); ) {
            var D = I.next(), B = D.getCoordinates();
            if (B.length !== 2 || !B[0].equals2D(B[1])) {
              var H = D.getData(), se = new wu(D.getCoordinates(), new Si(H));
              this.insertUniqueEdge(se);
            }
          }
        } }, { key: "setNoder", value: function(o) {
          this._workingNoder = o;
        } }], [{ key: "constructor_", value: function() {
          this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new vu();
          var o = arguments[0];
          this._bufParams = o;
        } }, { key: "depthDelta", value: function(o) {
          var h = o.getLocation(0, St.LEFT), _ = o.getLocation(0, St.RIGHT);
          return h === Me.INTERIOR && _ === Me.EXTERIOR ? 1 : h === Me.EXTERIOR && _ === Me.INTERIOR ? -1 : 0;
        } }, { key: "convertSegStrings", value: function(o) {
          for (var h = new ni(), _ = new ze(); o.hasNext(); ) {
            var I = o.next(), D = h.createLineString(I.getCoordinates());
            _.add(D);
          }
          return h.buildGeometry(_);
        } }]);
      })(), td = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "rescale", value: function() {
          if (er(arguments[0], br)) for (var o = arguments[0].iterator(); o.hasNext(); ) {
            var h = o.next();
            this.rescale(h.getCoordinates());
          }
          else if (arguments[0] instanceof Array) {
            for (var _ = arguments[0], I = 0; I < _.length; I++) _[I].x = _[I].x / this._scaleFactor + this._offsetX, _[I].y = _[I].y / this._scaleFactor + this._offsetY;
            _.length === 2 && _[0].equals2D(_[1]) && Nt.out.println(_);
          }
        } }, { key: "scale", value: function() {
          if (er(arguments[0], br)) {
            for (var o = arguments[0], h = new ze(o.size()), _ = o.iterator(); _.hasNext(); ) {
              var I = _.next();
              h.add(new Gi(this.scale(I.getCoordinates()), I.getData()));
            }
            return h;
          }
          if (arguments[0] instanceof Array) {
            for (var D = arguments[0], B = new Array(D.length).fill(null), H = 0; H < D.length; H++) B[H] = new Ze(Math.round((D[H].x - this._offsetX) * this._scaleFactor), Math.round((D[H].y - this._offsetY) * this._scaleFactor), D[H].getZ());
            return bt.removeRepeatedPoints(B);
          }
        } }, { key: "isIntegerPrecision", value: function() {
          return this._scaleFactor === 1;
        } }, { key: "getNodedSubstrings", value: function() {
          var o = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(o), o;
        } }, { key: "computeNodes", value: function(o) {
          var h = o;
          this._isScaled && (h = this.scale(o)), this._noder.computeNodes(h);
        } }, { key: "interfaces_", get: function() {
          return [No];
        } }], [{ key: "constructor_", value: function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) {
            var o = arguments[0], h = arguments[1];
            y.constructor_.call(this, o, h, 0, 0);
          } else if (arguments.length === 4) {
            var _ = arguments[0], I = arguments[1];
            this._noder = _, this._scaleFactor = I, this._isScaled = !this.isIntegerPrecision();
          }
        } }]);
      })(), Lc = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "checkEndPtVertexIntersections", value: function() {
          if (arguments.length === 0) for (var o = this._segStrings.iterator(); o.hasNext(); ) {
            var h = o.next().getCoordinates();
            this.checkEndPtVertexIntersections(h[0], this._segStrings), this.checkEndPtVertexIntersections(h[h.length - 1], this._segStrings);
          }
          else if (arguments.length === 2) {
            for (var _ = arguments[0], I = arguments[1].iterator(); I.hasNext(); ) for (var D = I.next().getCoordinates(), B = 1; B < D.length - 1; B++) if (D[B].equals(_)) throw new Ht("found endpt/interior pt intersection at index " + B + " :pt " + _);
          }
        } }, { key: "checkInteriorIntersections", value: function() {
          if (arguments.length === 0) for (var o = this._segStrings.iterator(); o.hasNext(); ) for (var h = o.next(), _ = this._segStrings.iterator(); _.hasNext(); ) {
            var I = _.next();
            this.checkInteriorIntersections(h, I);
          }
          else if (arguments.length === 2) for (var D = arguments[0], B = arguments[1], H = D.getCoordinates(), se = B.getCoordinates(), de = 0; de < H.length - 1; de++) for (var $e = 0; $e < se.length - 1; $e++) this.checkInteriorIntersections(D, de, B, $e);
          else if (arguments.length === 4) {
            var rt = arguments[0], vt = arguments[1], Gt = arguments[2], $t = arguments[3];
            if (rt === Gt && vt === $t) return null;
            var Xt = rt.getCoordinates()[vt], _r = rt.getCoordinates()[vt + 1], or = Gt.getCoordinates()[$t], Gr = Gt.getCoordinates()[$t + 1];
            if (this._li.computeIntersection(Xt, _r, or, Gr), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, Xt, _r) || this.hasInteriorIntersection(this._li, or, Gr))) throw new Ht("found non-noded intersection at " + Xt + "-" + _r + " and " + or + "-" + Gr);
          }
        } }, { key: "checkValid", value: function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        } }, { key: "checkCollapses", value: function() {
          if (arguments.length === 0) for (var o = this._segStrings.iterator(); o.hasNext(); ) {
            var h = o.next();
            this.checkCollapses(h);
          }
          else if (arguments.length === 1) for (var _ = arguments[0].getCoordinates(), I = 0; I < _.length - 2; I++) this.checkCollapse(_[I], _[I + 1], _[I + 2]);
        } }, { key: "hasInteriorIntersection", value: function(o, h, _) {
          for (var I = 0; I < o.getIntersectionNum(); I++) {
            var D = o.getIntersection(I);
            if (!D.equals(h) && !D.equals(_)) return !0;
          }
          return !1;
        } }, { key: "checkCollapse", value: function(o, h, _) {
          if (o.equals(_)) throw new Ht("found non-noded collapse at " + y.fact.createLineString([o, h, _]));
        } }], [{ key: "constructor_", value: function() {
          this._li = new Yi(), this._segStrings = null;
          var o = arguments[0];
          this._segStrings = o;
        } }]);
      })();
      Lc.fact = new ni();
      var Tl = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "intersectsScaled", value: function(o, h) {
          var _ = Math.min(o.x, h.x), I = Math.max(o.x, h.x), D = Math.min(o.y, h.y), B = Math.max(o.y, h.y), H = this._maxx < _ || this._minx > I || this._maxy < D || this._miny > B;
          if (H) return !1;
          var se = this.intersectsToleranceSquare(o, h);
          return Pt.isTrue(!(H && se), "Found bad envelope test"), se;
        } }, { key: "initCorners", value: function(o) {
          var h = 0.5;
          this._minx = o.x - h, this._maxx = o.x + h, this._miny = o.y - h, this._maxy = o.y + h, this._corner[0] = new Ze(this._maxx, this._maxy), this._corner[1] = new Ze(this._minx, this._maxy), this._corner[2] = new Ze(this._minx, this._miny), this._corner[3] = new Ze(this._maxx, this._miny);
        } }, { key: "intersects", value: function(o, h) {
          return this._scaleFactor === 1 ? this.intersectsScaled(o, h) : (this.copyScaled(o, this._p0Scaled), this.copyScaled(h, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        } }, { key: "scale", value: function(o) {
          return Math.round(o * this._scaleFactor);
        } }, { key: "getCoordinate", value: function() {
          return this._originalPt;
        } }, { key: "copyScaled", value: function(o, h) {
          h.x = this.scale(o.x), h.y = this.scale(o.y);
        } }, { key: "getSafeEnvelope", value: function() {
          if (this._safeEnv === null) {
            var o = y.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new lr(this._originalPt.x - o, this._originalPt.x + o, this._originalPt.y - o, this._originalPt.y + o);
          }
          return this._safeEnv;
        } }, { key: "intersectsPixelClosure", value: function(o, h) {
          return this._li.computeIntersection(o, h, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(o, h, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(o, h, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(o, h, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        } }, { key: "intersectsToleranceSquare", value: function(o, h) {
          var _ = !1, I = !1;
          return this._li.computeIntersection(o, h, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(o, h, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (_ = !0), this._li.computeIntersection(o, h, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (I = !0), this._li.computeIntersection(o, h, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!_ || !I) || !!o.equals(this._pt) || !!h.equals(this._pt))));
        } }, { key: "addSnappedNode", value: function(o, h) {
          var _ = o.getCoordinate(h), I = o.getCoordinate(h + 1);
          return !!this.intersects(_, I) && (o.addIntersection(this.getCoordinate(), h), !0);
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var o = arguments[0], h = arguments[1], _ = arguments[2];
          if (this._originalPt = o, this._pt = o, this._scaleFactor = h, this._li = _, h <= 0) throw new et("Scale factor must be non-zero");
          h !== 1 && (this._pt = new Ze(this.scale(o.x), this.scale(o.y)), this._p0Scaled = new Ze(), this._p1Scaled = new Ze()), this.initCorners(this._pt);
        } }]);
      })();
      Tl.SAFE_ENV_EXPANSION_FACTOR = 0.75;
      var Bo = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "select", value: function() {
          if (arguments.length !== 1 && arguments.length === 2) {
            var y = arguments[1];
            arguments[0].getLineSegment(y, this.selectedSegment), this.select(this.selectedSegment);
          }
        } }], [{ key: "constructor_", value: function() {
          this.selectedSegment = new bi();
        } }]);
      })(), Eu = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "snap", value: function() {
          if (arguments.length === 1) {
            var y = arguments[0];
            return this.snap(y, null, -1);
          }
          if (arguments.length === 3) {
            var o = arguments[0], h = arguments[1], _ = arguments[2], I = o.getSafeEnvelope(), D = new Sl(o, h, _);
            return this._index.query(I, new ((function() {
              return u((function B() {
                x(this, B);
              }), [{ key: "interfaces_", get: function() {
                return [to];
              } }, { key: "visitItem", value: function(B) {
                B.select(I, D);
              } }]);
            })())()), D.isNodeAdded();
          }
        } }], [{ key: "constructor_", value: function() {
          this._index = null;
          var y = arguments[0];
          this._index = y;
        } }]);
      })(), Sl = (function(y) {
        function o() {
          var h;
          return x(this, o), h = p(this, o), o.constructor_.apply(h, arguments), h;
        }
        return $(o, y), u(o, [{ key: "isNodeAdded", value: function() {
          return this._isNodeAdded;
        } }, { key: "select", value: function() {
          if (!(arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof nn)) return ce(o, "select", this, 1).apply(this, arguments);
          var h = arguments[1], _ = arguments[0].getContext();
          if (this._parentEdge === _ && (h === this._hotPixelVertexIndex || h + 1 === this._hotPixelVertexIndex)) return null;
          this._isNodeAdded |= this._hotPixel.addSnappedNode(_, h);
        } }], [{ key: "constructor_", value: function() {
          this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
          var h = arguments[0], _ = arguments[1], I = arguments[2];
          this._hotPixel = h, this._parentEdge = _, this._hotPixelVertexIndex = I;
        } }]);
      })(Bo);
      Eu.HotPixelSnapAction = Sl;
      var Dc = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "processIntersections", value: function(y, o, h, _) {
          if (y === h && o === _) return null;
          var I = y.getCoordinates()[o], D = y.getCoordinates()[o + 1], B = h.getCoordinates()[_], H = h.getCoordinates()[_ + 1];
          if (this._li.computeIntersection(I, D, B, H), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var se = 0; se < this._li.getIntersectionNum(); se++) this._interiorIntersections.add(this._li.getIntersection(se));
            y.addIntersections(this._li, o, 0), h.addIntersections(this._li, _, 1);
          }
        } }, { key: "isDone", value: function() {
          return !1;
        } }, { key: "getInteriorIntersections", value: function() {
          return this._interiorIntersections;
        } }, { key: "interfaces_", get: function() {
          return [El];
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._interiorIntersections = null;
          var y = arguments[0];
          this._li = y, this._interiorIntersections = new ze();
        } }]);
      })(), kl = (function() {
        return u((function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }), [{ key: "checkCorrectness", value: function(y) {
          var o = Gi.getNodedSubstrings(y), h = new Lc(o);
          try {
            h.checkValid();
          } catch (_) {
            if (!(_ instanceof Qe)) throw _;
            _.printStackTrace();
          }
        } }, { key: "getNodedSubstrings", value: function() {
          return Gi.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "snapRound", value: function(y, o) {
          var h = this.findInteriorIntersections(y, o);
          this.computeIntersectionSnaps(h), this.computeVertexSnaps(y);
        } }, { key: "findInteriorIntersections", value: function(y, o) {
          var h = new Dc(o);
          return this._noder.setSegmentIntersector(h), this._noder.computeNodes(y), h.getInteriorIntersections();
        } }, { key: "computeVertexSnaps", value: function() {
          if (er(arguments[0], br)) for (var y = arguments[0].iterator(); y.hasNext(); ) {
            var o = y.next();
            this.computeVertexSnaps(o);
          }
          else if (arguments[0] instanceof Gi) for (var h = arguments[0], _ = h.getCoordinates(), I = 0; I < _.length; I++) {
            var D = new Tl(_[I], this._scaleFactor, this._li);
            this._pointSnapper.snap(D, h, I) && h.addIntersection(_[I], I);
          }
        } }, { key: "computeNodes", value: function(y) {
          this._nodedSegStrings = y, this._noder = new mu(), this._pointSnapper = new Eu(this._noder.getIndex()), this.snapRound(y, this._li);
        } }, { key: "computeIntersectionSnaps", value: function(y) {
          for (var o = y.iterator(); o.hasNext(); ) {
            var h = o.next(), _ = new Tl(h, this._scaleFactor, this._li);
            this._pointSnapper.snap(_);
          }
        } }, { key: "interfaces_", get: function() {
          return [No];
        } }], [{ key: "constructor_", value: function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var y = arguments[0];
          this._pm = y, this._li = new Yi(), this._li.setPrecisionModel(y), this._scaleFactor = y.getScale();
        } }]);
      })(), oi = (function() {
        function y() {
          x(this, y), y.constructor_.apply(this, arguments);
        }
        return u(y, [{ key: "bufferFixedPrecision", value: function(o) {
          var h = new td(new kl(new Nn(1)), o.getScale()), _ = new zo(this._bufParams);
          _.setWorkingPrecisionModel(o), _.setNoder(h), this._resultGeometry = _.buffer(this._argGeom, this._distance);
        } }, { key: "bufferReducedPrecision", value: function() {
          if (arguments.length === 0) {
            for (var o = y.MAX_PRECISION_DIGITS; o >= 0; o--) {
              try {
                this.bufferReducedPrecision(o);
              } catch (D) {
                if (!(D instanceof qe)) throw D;
                this._saveException = D;
              }
              if (this._resultGeometry !== null) return null;
            }
            throw this._saveException;
          }
          if (arguments.length === 1) {
            var h = arguments[0], _ = y.precisionScaleFactor(this._argGeom, this._distance, h), I = new Nn(_);
            this.bufferFixedPrecision(I);
          }
        } }, { key: "computeGeometry", value: function() {
          if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null;
          var o = this._argGeom.getFactory().getPrecisionModel();
          o.getType() === Nn.FIXED ? this.bufferFixedPrecision(o) : this.bufferReducedPrecision();
        } }, { key: "setQuadrantSegments", value: function(o) {
          this._bufParams.setQuadrantSegments(o);
        } }, { key: "bufferOriginalPrecision", value: function() {
          try {
            var o = new zo(this._bufParams);
            this._resultGeometry = o.buffer(this._argGeom, this._distance);
          } catch (h) {
            if (!(h instanceof Ht)) throw h;
            this._saveException = h;
          }
        } }, { key: "getResultGeometry", value: function(o) {
          return this._distance = o, this.computeGeometry(), this._resultGeometry;
        } }, { key: "setEndCapStyle", value: function(o) {
          this._bufParams.setEndCapStyle(o);
        } }], [{ key: "constructor_", value: function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new je(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
            var o = arguments[0];
            this._argGeom = o;
          } else if (arguments.length === 2) {
            var h = arguments[0], _ = arguments[1];
            this._argGeom = h, this._bufParams = _;
          }
        } }, { key: "bufferOp", value: function() {
          if (arguments.length === 2) {
            var o = arguments[1];
            return new y(arguments[0]).getResultGeometry(o);
          }
          if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Ut && typeof arguments[1] == "number") {
              var h = arguments[1], _ = arguments[2], I = new y(arguments[0]);
              return I.setQuadrantSegments(_), I.getResultGeometry(h);
            }
            if (arguments[2] instanceof je && arguments[0] instanceof Ut && typeof arguments[1] == "number") {
              var D = arguments[1];
              return new y(arguments[0], arguments[2]).getResultGeometry(D);
            }
          } else if (arguments.length === 4) {
            var B = arguments[1], H = arguments[2], se = arguments[3], de = new y(arguments[0]);
            return de.setQuadrantSegments(H), de.setEndCapStyle(se), de.getResultGeometry(B);
          }
        } }, { key: "precisionScaleFactor", value: function(o, h, _) {
          var I = o.getEnvelopeInternal(), D = Wt.max(Math.abs(I.getMaxX()), Math.abs(I.getMaxY()), Math.abs(I.getMinX()), Math.abs(I.getMinY())) + 2 * (h > 0 ? h : 0), B = _ - Math.trunc(Math.log(D) / Math.log(10) + 1);
          return Math.pow(10, B);
        } }]);
      })();
      oi.CAP_ROUND = je.CAP_ROUND, oi.CAP_BUTT = je.CAP_FLAT, oi.CAP_FLAT = je.CAP_FLAT, oi.CAP_SQUARE = je.CAP_SQUARE, oi.MAX_PRECISION_DIGITS = 12;
      var Il = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ml = (function() {
        return u((function y(o) {
          x(this, y), this.geometryFactory = o || new ni();
        }), [{ key: "read", value: function(y) {
          var o, h = (o = typeof y == "string" ? JSON.parse(y) : y).type;
          if (!Ii[h]) throw new Error("Unknown GeoJSON type: " + o.type);
          return Il.indexOf(h) !== -1 ? Ii[h].call(this, o.coordinates) : h === "GeometryCollection" ? Ii[h].call(this, o.geometries) : Ii[h].call(this, o);
        } }, { key: "write", value: function(y) {
          var o = y.getGeometryType();
          if (!Xi[o]) throw new Error("Geometry is not supported");
          return Xi[o].call(this, y);
        } }]);
      })(), Ii = { Feature: function(y) {
        var o = {};
        for (var h in y) o[h] = y[h];
        if (y.geometry) {
          var _ = y.geometry.type;
          if (!Ii[_]) throw new Error("Unknown GeoJSON type: " + y.type);
          o.geometry = this.read(y.geometry);
        }
        return y.bbox && (o.bbox = Ii.bbox.call(this, y.bbox)), o;
      }, FeatureCollection: function(y) {
        var o = {};
        if (y.features) {
          o.features = [];
          for (var h = 0; h < y.features.length; ++h) o.features.push(this.read(y.features[h]));
        }
        return y.bbox && (o.bbox = this.parse.bbox.call(this, y.bbox)), o;
      }, coordinates: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) {
          var _ = y[h];
          o.push(M(Ze, me(_)));
        }
        return o;
      }, bbox: function(y) {
        return this.geometryFactory.createLinearRing([new Ze(y[0], y[1]), new Ze(y[2], y[1]), new Ze(y[2], y[3]), new Ze(y[0], y[3]), new Ze(y[0], y[1])]);
      }, Point: function(y) {
        var o = M(Ze, me(y));
        return this.geometryFactory.createPoint(o);
      }, MultiPoint: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) o.push(Ii.Point.call(this, y[h]));
        return this.geometryFactory.createMultiPoint(o);
      }, LineString: function(y) {
        var o = Ii.coordinates.call(this, y);
        return this.geometryFactory.createLineString(o);
      }, MultiLineString: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) o.push(Ii.LineString.call(this, y[h]));
        return this.geometryFactory.createMultiLineString(o);
      }, Polygon: function(y) {
        for (var o = Ii.coordinates.call(this, y[0]), h = this.geometryFactory.createLinearRing(o), _ = [], I = 1; I < y.length; ++I) {
          var D = y[I], B = Ii.coordinates.call(this, D), H = this.geometryFactory.createLinearRing(B);
          _.push(H);
        }
        return this.geometryFactory.createPolygon(h, _);
      }, MultiPolygon: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) {
          var _ = y[h];
          o.push(Ii.Polygon.call(this, _));
        }
        return this.geometryFactory.createMultiPolygon(o);
      }, GeometryCollection: function(y) {
        for (var o = [], h = 0; h < y.length; ++h) {
          var _ = y[h];
          o.push(this.read(_));
        }
        return this.geometryFactory.createGeometryCollection(o);
      } }, Xi = { coordinate: function(y) {
        var o = [y.x, y.y];
        return y.z && o.push(y.z), y.m && o.push(y.m), o;
      }, Point: function(y) {
        return { type: "Point", coordinates: Xi.coordinate.call(this, y.getCoordinate()) };
      }, MultiPoint: function(y) {
        for (var o = [], h = 0; h < y._geometries.length; ++h) {
          var _ = y._geometries[h], I = Xi.Point.call(this, _);
          o.push(I.coordinates);
        }
        return { type: "MultiPoint", coordinates: o };
      }, LineString: function(y) {
        for (var o = [], h = y.getCoordinates(), _ = 0; _ < h.length; ++_) {
          var I = h[_];
          o.push(Xi.coordinate.call(this, I));
        }
        return { type: "LineString", coordinates: o };
      }, MultiLineString: function(y) {
        for (var o = [], h = 0; h < y._geometries.length; ++h) {
          var _ = y._geometries[h], I = Xi.LineString.call(this, _);
          o.push(I.coordinates);
        }
        return { type: "MultiLineString", coordinates: o };
      }, Polygon: function(y) {
        var o = [], h = Xi.LineString.call(this, y._shell);
        o.push(h.coordinates);
        for (var _ = 0; _ < y._holes.length; ++_) {
          var I = y._holes[_], D = Xi.LineString.call(this, I);
          o.push(D.coordinates);
        }
        return { type: "Polygon", coordinates: o };
      }, MultiPolygon: function(y) {
        for (var o = [], h = 0; h < y._geometries.length; ++h) {
          var _ = y._geometries[h], I = Xi.Polygon.call(this, _);
          o.push(I.coordinates);
        }
        return { type: "MultiPolygon", coordinates: o };
      }, GeometryCollection: function(y) {
        for (var o = [], h = 0; h < y._geometries.length; ++h) {
          var _ = y._geometries[h], I = _.getGeometryType();
          o.push(Xi[I].call(this, _));
        }
        return { type: "GeometryCollection", geometries: o };
      } };
      return { BufferOp: oi, GeoJSONReader: (function() {
        return u((function y(o) {
          x(this, y), this.parser = new Ml(o || new ni());
        }), [{ key: "read", value: function(y) {
          return this.parser.read(y);
        } }]);
      })(), GeoJSONWriter: (function() {
        return u((function y() {
          x(this, y), this.parser = new Ml(this.geometryFactory);
        }), [{ key: "write", value: function(y) {
          return this.parser.write(y);
        } }]);
      })() };
    }));
  })(wy)), wy.exports;
}
var eN = QF();
const tN = /* @__PURE__ */ bw(eN);
function iu() {
  return new Lg();
}
function Lg() {
  this.reset();
}
Lg.prototype = {
  constructor: Lg,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(a) {
    nb(eg, a, this.t), nb(this, eg.s, this.s), this.s ? this.t += eg.t : this.s = eg.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var eg = new Lg();
function nb(a, n, l) {
  var p = a.s = n + l, x = p - n, M = p - x;
  a.t = n - M + (l - x);
}
var xn = 1e-6, jr = Math.PI, Eo = jr / 2, ib = jr / 4, Co = jr * 2, ql = 180 / jr, ma = jr / 180, Oi = Math.abs, rN = Math.atan, jh = Math.atan2, jn = Math.cos, Vn = Math.sin, Jh = Math.sqrt;
function X2(a) {
  return a > 1 ? 0 : a < -1 ? jr : Math.acos(a);
}
function gc(a) {
  return a > 1 ? Eo : a < -1 ? -Eo : Math.asin(a);
}
function cf() {
}
function Dg(a, n) {
  a && ab.hasOwnProperty(a.type) && ab[a.type](a, n);
}
var sb = {
  Feature: function(a, n) {
    Dg(a.geometry, n);
  },
  FeatureCollection: function(a, n) {
    for (var l = a.features, p = -1, x = l.length; ++p < x; ) Dg(l[p].geometry, n);
  }
}, ab = {
  Sphere: function(a, n) {
    n.sphere();
  },
  Point: function(a, n) {
    a = a.coordinates, n.point(a[0], a[1], a[2]);
  },
  MultiPoint: function(a, n) {
    for (var l = a.coordinates, p = -1, x = l.length; ++p < x; ) a = l[p], n.point(a[0], a[1], a[2]);
  },
  LineString: function(a, n) {
    Ey(a.coordinates, n, 0);
  },
  MultiLineString: function(a, n) {
    for (var l = a.coordinates, p = -1, x = l.length; ++p < x; ) Ey(l[p], n, 0);
  },
  Polygon: function(a, n) {
    ob(a.coordinates, n);
  },
  MultiPolygon: function(a, n) {
    for (var l = a.coordinates, p = -1, x = l.length; ++p < x; ) ob(l[p], n);
  },
  GeometryCollection: function(a, n) {
    for (var l = a.geometries, p = -1, x = l.length; ++p < x; ) Dg(l[p], n);
  }
};
function Ey(a, n, l) {
  var p = -1, x = a.length - l, M;
  for (n.lineStart(); ++p < x; ) M = a[p], n.point(M[0], M[1], M[2]);
  n.lineEnd();
}
function ob(a, n) {
  var l = -1, p = a.length;
  for (n.polygonStart(); ++l < p; ) Ey(a[l], n, 1);
  n.polygonEnd();
}
function nN(a, n) {
  a && sb.hasOwnProperty(a.type) ? sb[a.type](a, n) : Dg(a, n);
}
iu();
iu();
function Ty(a) {
  return [jh(a[1], a[0]), gc(a[2])];
}
function Vh(a) {
  var n = a[0], l = a[1], p = jn(l);
  return [p * jn(n), p * Vn(n), Vn(l)];
}
function tg(a, n) {
  return a[0] * n[0] + a[1] * n[1] + a[2] * n[2];
}
function Rg(a, n) {
  return [a[1] * n[2] - a[2] * n[1], a[2] * n[0] - a[0] * n[2], a[0] * n[1] - a[1] * n[0]];
}
function z_(a, n) {
  a[0] += n[0], a[1] += n[1], a[2] += n[2];
}
function rg(a, n) {
  return [a[0] * n, a[1] * n, a[2] * n];
}
function Sy(a) {
  var n = Jh(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
  a[0] /= n, a[1] /= n, a[2] /= n;
}
iu();
function J2(a, n) {
  function l(p, x) {
    return p = a(p, x), n(p[0], p[1]);
  }
  return a.invert && n.invert && (l.invert = function(p, x) {
    return p = n.invert(p, x), p && a.invert(p[0], p[1]);
  }), l;
}
function ky(a, n) {
  return [a > jr ? a - Co : a < -jr ? a + Co : a, n];
}
ky.invert = ky;
function iN(a, n, l) {
  return (a %= Co) ? n || l ? J2(ub(a), cb(n, l)) : ub(a) : n || l ? cb(n, l) : ky;
}
function lb(a) {
  return function(n, l) {
    return n += a, [n > jr ? n - Co : n < -jr ? n + Co : n, l];
  };
}
function ub(a) {
  var n = lb(a);
  return n.invert = lb(-a), n;
}
function cb(a, n) {
  var l = jn(a), p = Vn(a), x = jn(n), M = Vn(n);
  function T(u, R) {
    var z = jn(R), U = jn(u) * z, $ = Vn(u) * z, ee = Vn(R), oe = ee * l + U * p;
    return [
      jh($ * x - oe * M, U * l - ee * p),
      gc(oe * x + $ * M)
    ];
  }
  return T.invert = function(u, R) {
    var z = jn(R), U = jn(u) * z, $ = Vn(u) * z, ee = Vn(R), oe = ee * x - $ * M;
    return [
      jh($ * x + ee * M, U * l + oe * p),
      gc(oe * l - U * p)
    ];
  }, T;
}
function sN(a, n, l, p, x, M) {
  if (l) {
    var T = jn(n), u = Vn(n), R = p * l;
    x == null ? (x = n + p * Co, M = n - R / 2) : (x = hb(T, x), M = hb(T, M), (p > 0 ? x < M : x > M) && (x += p * Co));
    for (var z, U = x; p > 0 ? U > M : U < M; U -= R)
      z = Ty([T, -u * jn(U), -u * Vn(U)]), a.point(z[0], z[1]);
  }
}
function hb(a, n) {
  n = Vh(n), n[0] -= a, Sy(n);
  var l = X2(-n[1]);
  return ((-n[2] < 0 ? -l : l) + Co - xn) % Co;
}
function K2() {
  var a = [], n;
  return {
    point: function(l, p) {
      n.push([l, p]);
    },
    lineStart: function() {
      a.push(n = []);
    },
    lineEnd: cf,
    rejoin: function() {
      a.length > 1 && a.push(a.pop().concat(a.shift()));
    },
    result: function() {
      var l = a;
      return a = [], n = null, l;
    }
  };
}
function aN(a, n, l, p, x, M) {
  var T = a[0], u = a[1], R = n[0], z = n[1], U = 0, $ = 1, ee = R - T, oe = z - u, ce;
  if (ce = l - T, !(!ee && ce > 0)) {
    if (ce /= ee, ee < 0) {
      if (ce < U) return;
      ce < $ && ($ = ce);
    } else if (ee > 0) {
      if (ce > $) return;
      ce > U && (U = ce);
    }
    if (ce = x - T, !(!ee && ce < 0)) {
      if (ce /= ee, ee < 0) {
        if (ce > $) return;
        ce > U && (U = ce);
      } else if (ee > 0) {
        if (ce < U) return;
        ce < $ && ($ = ce);
      }
      if (ce = p - u, !(!oe && ce > 0)) {
        if (ce /= oe, oe < 0) {
          if (ce < U) return;
          ce < $ && ($ = ce);
        } else if (oe > 0) {
          if (ce > $) return;
          ce > U && (U = ce);
        }
        if (ce = M - u, !(!oe && ce < 0)) {
          if (ce /= oe, oe < 0) {
            if (ce > $) return;
            ce > U && (U = ce);
          } else if (oe > 0) {
            if (ce < U) return;
            ce < $ && ($ = ce);
          }
          return U > 0 && (a[0] = T + U * ee, a[1] = u + U * oe), $ < 1 && (n[0] = T + $ * ee, n[1] = u + $ * oe), !0;
        }
      }
    }
  }
}
function _g(a, n) {
  return Oi(a[0] - n[0]) < xn && Oi(a[1] - n[1]) < xn;
}
function ng(a, n, l, p) {
  this.x = a, this.z = n, this.o = l, this.e = p, this.v = !1, this.n = this.p = null;
}
function Q2(a, n, l, p, x) {
  var M = [], T = [], u, R;
  if (a.forEach(function(ce) {
    if (!((me = ce.length - 1) <= 0)) {
      var me, re = ce[0], Pe = ce[me], _e;
      if (_g(re, Pe)) {
        for (x.lineStart(), u = 0; u < me; ++u) x.point((re = ce[u])[0], re[1]);
        x.lineEnd();
        return;
      }
      M.push(_e = new ng(re, ce, null, !0)), T.push(_e.o = new ng(re, null, _e, !1)), M.push(_e = new ng(Pe, ce, null, !1)), T.push(_e.o = new ng(Pe, null, _e, !0));
    }
  }), !!M.length) {
    for (T.sort(n), db(M), db(T), u = 0, R = T.length; u < R; ++u)
      T[u].e = l = !l;
    for (var z = M[0], U, $; ; ) {
      for (var ee = z, oe = !0; ee.v; ) if ((ee = ee.n) === z) return;
      U = ee.z, x.lineStart();
      do {
        if (ee.v = ee.o.v = !0, ee.e) {
          if (oe)
            for (u = 0, R = U.length; u < R; ++u) x.point(($ = U[u])[0], $[1]);
          else
            p(ee.x, ee.n.x, 1, x);
          ee = ee.n;
        } else {
          if (oe)
            for (U = ee.p.z, u = U.length - 1; u >= 0; --u) x.point(($ = U[u])[0], $[1]);
          else
            p(ee.x, ee.p.x, -1, x);
          ee = ee.p;
        }
        ee = ee.o, U = ee.z, oe = !oe;
      } while (!ee.v);
      x.lineEnd();
    }
  }
}
function db(a) {
  if (n = a.length) {
    for (var n, l = 0, p = a[0], x; ++l < n; )
      p.n = x = a[l], x.p = p, p = x;
    p.n = x = a[0], x.p = p;
  }
}
function eE(a, n) {
  return a < n ? -1 : a > n ? 1 : a >= n ? 0 : NaN;
}
function oN(a) {
  return a.length === 1 && (a = lN(a)), {
    left: function(n, l, p, x) {
      for (p == null && (p = 0), x == null && (x = n.length); p < x; ) {
        var M = p + x >>> 1;
        a(n[M], l) < 0 ? p = M + 1 : x = M;
      }
      return p;
    },
    right: function(n, l, p, x) {
      for (p == null && (p = 0), x == null && (x = n.length); p < x; ) {
        var M = p + x >>> 1;
        a(n[M], l) > 0 ? x = M : p = M + 1;
      }
      return p;
    }
  };
}
function lN(a) {
  return function(n, l) {
    return eE(a(n), l);
  };
}
oN(eE);
function tE(a) {
  for (var n = a.length, l, p = -1, x = 0, M, T; ++p < n; ) x += a[p].length;
  for (M = new Array(x); --n >= 0; )
    for (T = a[n], l = T.length; --l >= 0; )
      M[--x] = T[l];
  return M;
}
var hf = 1e9, ig = -hf;
function uN(a, n, l, p) {
  function x(z, U) {
    return a <= z && z <= l && n <= U && U <= p;
  }
  function M(z, U, $, ee) {
    var oe = 0, ce = 0;
    if (z == null || (oe = T(z, $)) !== (ce = T(U, $)) || R(z, U) < 0 ^ $ > 0)
      do
        ee.point(oe === 0 || oe === 3 ? a : l, oe > 1 ? p : n);
      while ((oe = (oe + $ + 4) % 4) !== ce);
    else
      ee.point(U[0], U[1]);
  }
  function T(z, U) {
    return Oi(z[0] - a) < xn ? U > 0 ? 0 : 3 : Oi(z[0] - l) < xn ? U > 0 ? 2 : 1 : Oi(z[1] - n) < xn ? U > 0 ? 1 : 0 : U > 0 ? 3 : 2;
  }
  function u(z, U) {
    return R(z.x, U.x);
  }
  function R(z, U) {
    var $ = T(z, 1), ee = T(U, 1);
    return $ !== ee ? $ - ee : $ === 0 ? U[1] - z[1] : $ === 1 ? z[0] - U[0] : $ === 2 ? z[1] - U[1] : U[0] - z[0];
  }
  return function(z) {
    var U = z, $ = K2(), ee, oe, ce, me, re, Pe, _e, je, Qe, et, Ye, ot = {
      point: Q,
      lineStart: Ie,
      lineEnd: Oe,
      polygonStart: ge,
      polygonEnd: Se
    };
    function Q(De, Fe) {
      x(De, Fe) && U.point(De, Fe);
    }
    function ie() {
      for (var De = 0, Fe = 0, Ue = oe.length; Fe < Ue; ++Fe)
        for (var Ve = oe[Fe], We = 1, dt = Ve.length, Tt = Ve[0], Ht, Ot, Pt = Tt[0], Mt = Tt[1]; We < dt; ++We)
          Ht = Pt, Ot = Mt, Tt = Ve[We], Pt = Tt[0], Mt = Tt[1], Ot <= p ? Mt > p && (Pt - Ht) * (p - Ot) > (Mt - Ot) * (a - Ht) && ++De : Mt <= p && (Pt - Ht) * (p - Ot) < (Mt - Ot) * (a - Ht) && --De;
      return De;
    }
    function ge() {
      U = $, ee = [], oe = [], Ye = !0;
    }
    function Se() {
      var De = ie(), Fe = Ye && De, Ue = (ee = tE(ee)).length;
      (Fe || Ue) && (z.polygonStart(), Fe && (z.lineStart(), M(null, null, 1, z), z.lineEnd()), Ue && Q2(ee, u, De, M, z), z.polygonEnd()), U = z, ee = oe = ce = null;
    }
    function Ie() {
      ot.point = Re, oe && oe.push(ce = []), et = !0, Qe = !1, _e = je = NaN;
    }
    function Oe() {
      ee && (Re(me, re), Pe && Qe && $.rejoin(), ee.push($.result())), ot.point = Q, Qe && U.lineEnd();
    }
    function Re(De, Fe) {
      var Ue = x(De, Fe);
      if (oe && ce.push([De, Fe]), et)
        me = De, re = Fe, Pe = Ue, et = !1, Ue && (U.lineStart(), U.point(De, Fe));
      else if (Ue && Qe) U.point(De, Fe);
      else {
        var Ve = [_e = Math.max(ig, Math.min(hf, _e)), je = Math.max(ig, Math.min(hf, je))], We = [De = Math.max(ig, Math.min(hf, De)), Fe = Math.max(ig, Math.min(hf, Fe))];
        aN(Ve, We, a, n, l, p) ? (Qe || (U.lineStart(), U.point(Ve[0], Ve[1])), U.point(We[0], We[1]), Ue || U.lineEnd(), Ye = !1) : Ue && (U.lineStart(), U.point(De, Fe), Ye = !1);
      }
      _e = De, je = Fe, Qe = Ue;
    }
    return ot;
  };
}
var B_ = iu();
function cN(a, n) {
  var l = n[0], p = n[1], x = [Vn(l), -jn(l), 0], M = 0, T = 0;
  B_.reset();
  for (var u = 0, R = a.length; u < R; ++u)
    if (U = (z = a[u]).length)
      for (var z, U, $ = z[U - 1], ee = $[0], oe = $[1] / 2 + ib, ce = Vn(oe), me = jn(oe), re = 0; re < U; ++re, ee = _e, ce = Qe, me = et, $ = Pe) {
        var Pe = z[re], _e = Pe[0], je = Pe[1] / 2 + ib, Qe = Vn(je), et = jn(je), Ye = _e - ee, ot = Ye >= 0 ? 1 : -1, Q = ot * Ye, ie = Q > jr, ge = ce * Qe;
        if (B_.add(jh(ge * ot * Vn(Q), me * et + ge * jn(Q))), M += ie ? Ye + ot * Co : Ye, ie ^ ee >= l ^ _e >= l) {
          var Se = Rg(Vh($), Vh(Pe));
          Sy(Se);
          var Ie = Rg(x, Se);
          Sy(Ie);
          var Oe = (ie ^ Ye >= 0 ? -1 : 1) * gc(Ie[2]);
          (p > Oe || p === Oe && (Se[0] || Se[1])) && (T += ie ^ Ye >= 0 ? 1 : -1);
        }
      }
  return (M < -xn || M < xn && B_ < -xn) ^ T & 1;
}
iu();
function fb(a) {
  return a;
}
iu();
iu();
var Uh = 1 / 0, Fg = Uh, Lf = -Uh, Ng = Lf, pb = {
  point: hN,
  lineStart: cf,
  lineEnd: cf,
  polygonStart: cf,
  polygonEnd: cf,
  result: function() {
    var a = [[Uh, Fg], [Lf, Ng]];
    return Lf = Ng = -(Fg = Uh = 1 / 0), a;
  }
};
function hN(a, n) {
  a < Uh && (Uh = a), a > Lf && (Lf = a), n < Fg && (Fg = n), n > Ng && (Ng = n);
}
iu();
function rE(a, n, l, p) {
  return function(x, M) {
    var T = n(M), u = x.invert(p[0], p[1]), R = K2(), z = n(R), U = !1, $, ee, oe, ce = {
      point: me,
      lineStart: Pe,
      lineEnd: _e,
      polygonStart: function() {
        ce.point = je, ce.lineStart = Qe, ce.lineEnd = et, ee = [], $ = [];
      },
      polygonEnd: function() {
        ce.point = me, ce.lineStart = Pe, ce.lineEnd = _e, ee = tE(ee);
        var Ye = cN($, u);
        ee.length ? (U || (M.polygonStart(), U = !0), Q2(ee, fN, Ye, l, M)) : Ye && (U || (M.polygonStart(), U = !0), M.lineStart(), l(null, null, 1, M), M.lineEnd()), U && (M.polygonEnd(), U = !1), ee = $ = null;
      },
      sphere: function() {
        M.polygonStart(), M.lineStart(), l(null, null, 1, M), M.lineEnd(), M.polygonEnd();
      }
    };
    function me(Ye, ot) {
      var Q = x(Ye, ot);
      a(Ye = Q[0], ot = Q[1]) && M.point(Ye, ot);
    }
    function re(Ye, ot) {
      var Q = x(Ye, ot);
      T.point(Q[0], Q[1]);
    }
    function Pe() {
      ce.point = re, T.lineStart();
    }
    function _e() {
      ce.point = me, T.lineEnd();
    }
    function je(Ye, ot) {
      oe.push([Ye, ot]);
      var Q = x(Ye, ot);
      z.point(Q[0], Q[1]);
    }
    function Qe() {
      z.lineStart(), oe = [];
    }
    function et() {
      je(oe[0][0], oe[0][1]), z.lineEnd();
      var Ye = z.clean(), ot = R.result(), Q, ie = ot.length, ge, Se, Ie;
      if (oe.pop(), $.push(oe), oe = null, !!ie) {
        if (Ye & 1) {
          if (Se = ot[0], (ge = Se.length - 1) > 0) {
            for (U || (M.polygonStart(), U = !0), M.lineStart(), Q = 0; Q < ge; ++Q) M.point((Ie = Se[Q])[0], Ie[1]);
            M.lineEnd();
          }
          return;
        }
        ie > 1 && Ye & 2 && ot.push(ot.pop().concat(ot.shift())), ee.push(ot.filter(dN));
      }
    }
    return ce;
  };
}
function dN(a) {
  return a.length > 1;
}
function fN(a, n) {
  return ((a = a.x)[0] < 0 ? a[1] - Eo - xn : Eo - a[1]) - ((n = n.x)[0] < 0 ? n[1] - Eo - xn : Eo - n[1]);
}
const gb = rE(
  function() {
    return !0;
  },
  pN,
  mN,
  [-jr, -Eo]
);
function pN(a) {
  var n = NaN, l = NaN, p = NaN, x;
  return {
    lineStart: function() {
      a.lineStart(), x = 1;
    },
    point: function(M, T) {
      var u = M > 0 ? jr : -jr, R = Oi(M - n);
      Oi(R - jr) < xn ? (a.point(n, l = (l + T) / 2 > 0 ? Eo : -Eo), a.point(p, l), a.lineEnd(), a.lineStart(), a.point(u, l), a.point(M, l), x = 0) : p !== u && R >= jr && (Oi(n - p) < xn && (n -= p * xn), Oi(M - u) < xn && (M -= u * xn), l = gN(n, l, M, T), a.point(p, l), a.lineEnd(), a.lineStart(), a.point(u, l), x = 0), a.point(n = M, l = T), p = u;
    },
    lineEnd: function() {
      a.lineEnd(), n = l = NaN;
    },
    clean: function() {
      return 2 - x;
    }
  };
}
function gN(a, n, l, p) {
  var x, M, T = Vn(a - l);
  return Oi(T) > xn ? rN((Vn(n) * (M = jn(p)) * Vn(l) - Vn(p) * (x = jn(n)) * Vn(a)) / (x * M * T)) : (n + p) / 2;
}
function mN(a, n, l, p) {
  var x;
  if (a == null)
    x = l * Eo, p.point(-jr, x), p.point(0, x), p.point(jr, x), p.point(jr, 0), p.point(jr, -x), p.point(0, -x), p.point(-jr, -x), p.point(-jr, 0), p.point(-jr, x);
  else if (Oi(a[0] - n[0]) > xn) {
    var M = a[0] < n[0] ? jr : -jr;
    x = l * M / 2, p.point(-M, x), p.point(0, x), p.point(M, x);
  } else
    p.point(n[0], n[1]);
}
function _N(a, n) {
  var l = jn(a), p = l > 0, x = Oi(l) > xn;
  function M(U, $, ee, oe) {
    sN(oe, a, n, ee, U, $);
  }
  function T(U, $) {
    return jn(U) * jn($) > l;
  }
  function u(U) {
    var $, ee, oe, ce, me;
    return {
      lineStart: function() {
        ce = oe = !1, me = 1;
      },
      point: function(re, Pe) {
        var _e = [re, Pe], je, Qe = T(re, Pe), et = p ? Qe ? 0 : z(re, Pe) : Qe ? z(re + (re < 0 ? jr : -jr), Pe) : 0;
        if (!$ && (ce = oe = Qe) && U.lineStart(), Qe !== oe && (je = R($, _e), (!je || _g($, je) || _g(_e, je)) && (_e[0] += xn, _e[1] += xn, Qe = T(_e[0], _e[1]))), Qe !== oe)
          me = 0, Qe ? (U.lineStart(), je = R(_e, $), U.point(je[0], je[1])) : (je = R($, _e), U.point(je[0], je[1]), U.lineEnd()), $ = je;
        else if (x && $ && p ^ Qe) {
          var Ye;
          !(et & ee) && (Ye = R(_e, $, !0)) && (me = 0, p ? (U.lineStart(), U.point(Ye[0][0], Ye[0][1]), U.point(Ye[1][0], Ye[1][1]), U.lineEnd()) : (U.point(Ye[1][0], Ye[1][1]), U.lineEnd(), U.lineStart(), U.point(Ye[0][0], Ye[0][1])));
        }
        Qe && (!$ || !_g($, _e)) && U.point(_e[0], _e[1]), $ = _e, oe = Qe, ee = et;
      },
      lineEnd: function() {
        oe && U.lineEnd(), $ = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return me | (ce && oe) << 1;
      }
    };
  }
  function R(U, $, ee) {
    var oe = Vh(U), ce = Vh($), me = [1, 0, 0], re = Rg(oe, ce), Pe = tg(re, re), _e = re[0], je = Pe - _e * _e;
    if (!je) return !ee && U;
    var Qe = l * Pe / je, et = -l * _e / je, Ye = Rg(me, re), ot = rg(me, Qe), Q = rg(re, et);
    z_(ot, Q);
    var ie = Ye, ge = tg(ot, ie), Se = tg(ie, ie), Ie = ge * ge - Se * (tg(ot, ot) - 1);
    if (!(Ie < 0)) {
      var Oe = Jh(Ie), Re = rg(ie, (-ge - Oe) / Se);
      if (z_(Re, ot), Re = Ty(Re), !ee) return Re;
      var De = U[0], Fe = $[0], Ue = U[1], Ve = $[1], We;
      Fe < De && (We = De, De = Fe, Fe = We);
      var dt = Fe - De, Tt = Oi(dt - jr) < xn, Ht = Tt || dt < xn;
      if (!Tt && Ve < Ue && (We = Ue, Ue = Ve, Ve = We), Ht ? Tt ? Ue + Ve > 0 ^ Re[1] < (Oi(Re[0] - De) < xn ? Ue : Ve) : Ue <= Re[1] && Re[1] <= Ve : dt > jr ^ (De <= Re[0] && Re[0] <= Fe)) {
        var Ot = rg(ie, (-ge + Oe) / Se);
        return z_(Ot, ot), [Re, Ty(Ot)];
      }
    }
  }
  function z(U, $) {
    var ee = p ? a : jr - a, oe = 0;
    return U < -ee ? oe |= 1 : U > ee && (oe |= 2), $ < -ee ? oe |= 4 : $ > ee && (oe |= 8), oe;
  }
  return rE(T, u, M, p ? [0, -a] : [-jr, a - jr]);
}
function nE(a) {
  return function(n) {
    var l = new Iy();
    for (var p in a) l[p] = a[p];
    return l.stream = n, l;
  };
}
function Iy() {
}
Iy.prototype = {
  constructor: Iy,
  point: function(a, n) {
    this.stream.point(a, n);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function iE(a, n, l) {
  var p = n[1][0] - n[0][0], x = n[1][1] - n[0][1], M = a.clipExtent && a.clipExtent();
  a.scale(150).translate([0, 0]), M != null && a.clipExtent(null), nN(l, a.stream(pb));
  var T = pb.result(), u = Math.min(p / (T[1][0] - T[0][0]), x / (T[1][1] - T[0][1])), R = +n[0][0] + (p - u * (T[1][0] + T[0][0])) / 2, z = +n[0][1] + (x - u * (T[1][1] + T[0][1])) / 2;
  return M != null && a.clipExtent(M), a.scale(u * 150).translate([R, z]);
}
function yN(a, n, l) {
  return iE(a, [[0, 0], n], l);
}
var mb = 16, vN = jn(30 * ma);
function _b(a, n) {
  return +n ? bN(a, n) : xN(a);
}
function xN(a) {
  return nE({
    point: function(n, l) {
      n = a(n, l), this.stream.point(n[0], n[1]);
    }
  });
}
function bN(a, n) {
  function l(p, x, M, T, u, R, z, U, $, ee, oe, ce, me, re) {
    var Pe = z - p, _e = U - x, je = Pe * Pe + _e * _e;
    if (je > 4 * n && me--) {
      var Qe = T + ee, et = u + oe, Ye = R + ce, ot = Jh(Qe * Qe + et * et + Ye * Ye), Q = gc(Ye /= ot), ie = Oi(Oi(Ye) - 1) < xn || Oi(M - $) < xn ? (M + $) / 2 : jh(et, Qe), ge = a(ie, Q), Se = ge[0], Ie = ge[1], Oe = Se - p, Re = Ie - x, De = _e * Oe - Pe * Re;
      (De * De / je > n || Oi((Pe * Oe + _e * Re) / je - 0.5) > 0.3 || T * ee + u * oe + R * ce < vN) && (l(p, x, M, T, u, R, Se, Ie, ie, Qe /= ot, et /= ot, Ye, me, re), re.point(Se, Ie), l(Se, Ie, ie, Qe, et, Ye, z, U, $, ee, oe, ce, me, re));
    }
  }
  return function(p) {
    var x, M, T, u, R, z, U, $, ee, oe, ce, me, re = {
      point: Pe,
      lineStart: _e,
      lineEnd: Qe,
      polygonStart: function() {
        p.polygonStart(), re.lineStart = et;
      },
      polygonEnd: function() {
        p.polygonEnd(), re.lineStart = _e;
      }
    };
    function Pe(Q, ie) {
      Q = a(Q, ie), p.point(Q[0], Q[1]);
    }
    function _e() {
      $ = NaN, re.point = je, p.lineStart();
    }
    function je(Q, ie) {
      var ge = Vh([Q, ie]), Se = a(Q, ie);
      l($, ee, U, oe, ce, me, $ = Se[0], ee = Se[1], U = Q, oe = ge[0], ce = ge[1], me = ge[2], mb, p), p.point($, ee);
    }
    function Qe() {
      re.point = Pe, p.lineEnd();
    }
    function et() {
      _e(), re.point = Ye, re.lineEnd = ot;
    }
    function Ye(Q, ie) {
      je(x = Q, ie), M = $, T = ee, u = oe, R = ce, z = me, re.point = je;
    }
    function ot() {
      l($, ee, U, oe, ce, me, M, T, x, u, R, z, mb, p), re.lineEnd = Qe, Qe();
    }
    return re;
  };
}
var wN = nE({
  point: function(a, n) {
    this.stream.point(a * ma, n * ma);
  }
});
function EN(a) {
  return TN(function() {
    return a;
  })();
}
function TN(a) {
  var n, l = 150, p = 480, x = 250, M, T, u = 0, R = 0, z = 0, U = 0, $ = 0, ee, oe, ce = null, me = gb, re = null, Pe, _e, je, Qe = fb, et = 0.5, Ye = _b(Se, et), ot, Q;
  function ie(Re) {
    return Re = oe(Re[0] * ma, Re[1] * ma), [Re[0] * l + M, T - Re[1] * l];
  }
  function ge(Re) {
    return Re = oe.invert((Re[0] - M) / l, (T - Re[1]) / l), Re && [Re[0] * ql, Re[1] * ql];
  }
  function Se(Re, De) {
    return Re = n(Re, De), [Re[0] * l + M, T - Re[1] * l];
  }
  ie.stream = function(Re) {
    return ot && Q === Re ? ot : ot = wN(me(ee, Ye(Qe(Q = Re))));
  }, ie.clipAngle = function(Re) {
    return arguments.length ? (me = +Re ? _N(ce = Re * ma, 6 * ma) : (ce = null, gb), Oe()) : ce * ql;
  }, ie.clipExtent = function(Re) {
    return arguments.length ? (Qe = Re == null ? (re = Pe = _e = je = null, fb) : uN(re = +Re[0][0], Pe = +Re[0][1], _e = +Re[1][0], je = +Re[1][1]), Oe()) : re == null ? null : [[re, Pe], [_e, je]];
  }, ie.scale = function(Re) {
    return arguments.length ? (l = +Re, Ie()) : l;
  }, ie.translate = function(Re) {
    return arguments.length ? (p = +Re[0], x = +Re[1], Ie()) : [p, x];
  }, ie.center = function(Re) {
    return arguments.length ? (u = Re[0] % 360 * ma, R = Re[1] % 360 * ma, Ie()) : [u * ql, R * ql];
  }, ie.rotate = function(Re) {
    return arguments.length ? (z = Re[0] % 360 * ma, U = Re[1] % 360 * ma, $ = Re.length > 2 ? Re[2] % 360 * ma : 0, Ie()) : [z * ql, U * ql, $ * ql];
  }, ie.precision = function(Re) {
    return arguments.length ? (Ye = _b(Se, et = Re * Re), Oe()) : Jh(et);
  }, ie.fitExtent = function(Re, De) {
    return iE(ie, Re, De);
  }, ie.fitSize = function(Re, De) {
    return yN(ie, Re, De);
  };
  function Ie() {
    oe = J2(ee = iN(z, U, $), n);
    var Re = n(u, R);
    return M = p - Re[0] * l, T = x + Re[1] * l, Oe();
  }
  function Oe() {
    return ot = Q = null, ie;
  }
  return function() {
    return n = a.apply(this, arguments), ie.invert = n.invert && ge, Ie();
  };
}
function sE(a) {
  return function(n, l) {
    var p = jn(n), x = jn(l), M = a(p * x);
    return [
      M * x * Vn(n),
      M * Vn(l)
    ];
  };
}
function aE(a) {
  return function(n, l) {
    var p = Jh(n * n + l * l), x = a(p), M = Vn(x), T = jn(x);
    return [
      jh(n * M, p * T),
      gc(p && l * M / p)
    ];
  };
}
var SN = sE(function(a) {
  return Jh(2 / (1 + a));
});
SN.invert = aE(function(a) {
  return 2 * gc(a / 2);
});
var oE = sE(function(a) {
  return (a = X2(a)) && a / Vn(a);
});
oE.invert = aE(function(a) {
  return a;
});
function kN() {
  return EN(oE).scale(79.4188).clipAngle(180 - 1e-3);
}
function yb(a, n) {
  return [a, n];
}
yb.invert = yb;
var { BufferOp: IN, GeoJSONReader: MN, GeoJSONWriter: CN } = tN;
function PN(a, n, l) {
  l = l || {};
  var p = l.units || "kilometers", x = l.steps || 8;
  if (!a) throw new Error("geojson is required");
  if (typeof l != "object") throw new Error("options must be an object");
  if (typeof x != "number") throw new Error("steps must be an number");
  if (n === void 0) throw new Error("radius is required");
  if (x <= 0) throw new Error("steps must be greater than 0");
  var M = [];
  switch (a.type) {
    case "GeometryCollection":
      return xc(a, function(T) {
        var u = yg(T, n, p, x);
        u && M.push(u);
      }), gi(M);
    case "FeatureCollection":
      return Mo(a, function(T) {
        var u = yg(T, n, p, x);
        u && Mo(u, function(R) {
          R && M.push(R);
        });
      }), gi(M);
  }
  return yg(a, n, p, x);
}
function yg(a, n, l, p) {
  var x = a.properties || {}, M = a.type === "Feature" ? a.geometry : a;
  if (M.type === "GeometryCollection") {
    var T = [];
    return xc(a, function(me) {
      var re = yg(me, n, l, p);
      re && T.push(re);
    }), gi(T);
  }
  var u = AN(M), R = {
    type: M.type,
    coordinates: uE(M.coordinates, u)
  }, z = new MN(), U = z.read(R), $ = uv(cv(n, l), "meters"), ee = IN.bufferOp(U, $, p), oe = new CN();
  if (ee = oe.write(ee), !lE(ee.coordinates)) {
    var ce = {
      type: ee.type,
      coordinates: cE(ee.coordinates, u)
    };
    return Ja(ce, x);
  }
}
function lE(a) {
  return Array.isArray(a[0]) ? lE(a[0]) : isNaN(a[0]);
}
function uE(a, n) {
  return typeof a[0] != "object" ? n(a) : a.map(function(l) {
    return uE(l, n);
  });
}
function cE(a, n) {
  return typeof a[0] != "object" ? n.invert(a) : a.map(function(l) {
    return cE(l, n);
  });
}
function AN(a) {
  var n = JF(a).geometry.coordinates, l = [-n[0], -n[1]];
  return kN().rotate(l).scale(Ri);
}
var LN = PN;
class hE {
  constructor(n = [], l = DN) {
    if (this.data = n, this.length = this.data.length, this.compare = l, this.length > 0)
      for (let p = (this.length >> 1) - 1; p >= 0; p--) this._down(p);
  }
  push(n) {
    this.data.push(n), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    const n = this.data[0], l = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = l, this._down(0)), n;
  }
  peek() {
    return this.data[0];
  }
  _up(n) {
    const { data: l, compare: p } = this, x = l[n];
    for (; n > 0; ) {
      const M = n - 1 >> 1, T = l[M];
      if (p(x, T) >= 0) break;
      l[n] = T, n = M;
    }
    l[n] = x;
  }
  _down(n) {
    const { data: l, compare: p } = this, x = this.length >> 1, M = l[n];
    for (; n < x; ) {
      let T = (n << 1) + 1, u = l[T];
      const R = T + 1;
      if (R < this.length && p(l[R], u) < 0 && (T = R, u = l[R]), p(u, M) >= 0) break;
      l[n] = u, n = T;
    }
    l[n] = M;
  }
}
function DN(a, n) {
  return a < n ? -1 : a > n ? 1 : 0;
}
function dE(a, n) {
  return a.p.x > n.p.x ? 1 : a.p.x < n.p.x ? -1 : a.p.y !== n.p.y ? a.p.y > n.p.y ? 1 : -1 : 1;
}
function RN(a, n) {
  return a.rightSweepEvent.p.x > n.rightSweepEvent.p.x ? 1 : a.rightSweepEvent.p.x < n.rightSweepEvent.p.x ? -1 : a.rightSweepEvent.p.y !== n.rightSweepEvent.p.y ? a.rightSweepEvent.p.y < n.rightSweepEvent.p.y ? 1 : -1 : 1;
}
class vb {
  constructor(n, l, p, x) {
    this.p = {
      x: n[0],
      y: n[1]
    }, this.featureId = l, this.ringId = p, this.eventId = x, this.otherEvent = null, this.isLeftEndpoint = null;
  }
  isSamePoint(n) {
    return this.p.x === n.p.x && this.p.y === n.p.y;
  }
}
function FN(a, n) {
  if (a.type === "FeatureCollection") {
    const l = a.features;
    for (let p = 0; p < l.length; p++)
      xb(l[p], n);
  } else
    xb(a, n);
}
let sg = 0, ag = 0, og = 0;
function xb(a, n) {
  const l = a.type === "Feature" ? a.geometry : a;
  let p = l.coordinates;
  (l.type === "Polygon" || l.type === "MultiLineString") && (p = [p]), l.type === "LineString" && (p = [[p]]);
  for (let x = 0; x < p.length; x++)
    for (let M = 0; M < p[x].length; M++) {
      let T = p[x][M][0], u = null;
      ag = ag + 1;
      for (let R = 0; R < p[x][M].length - 1; R++) {
        u = p[x][M][R + 1];
        const z = new vb(T, sg, ag, og), U = new vb(u, sg, ag, og + 1);
        z.otherEvent = U, U.otherEvent = z, dE(z, U) > 0 ? (U.isLeftEndpoint = !0, z.isLeftEndpoint = !1) : (z.isLeftEndpoint = !0, U.isLeftEndpoint = !1), n.push(z), n.push(U), T = u, og = og + 1;
      }
    }
  sg = sg + 1;
}
let NN = class {
  constructor(a) {
    this.leftSweepEvent = a, this.rightSweepEvent = a.otherEvent;
  }
};
function ON(a, n) {
  if (a === null || n === null || a.leftSweepEvent.ringId === n.leftSweepEvent.ringId && (a.rightSweepEvent.isSamePoint(n.leftSweepEvent) || a.rightSweepEvent.isSamePoint(n.leftSweepEvent) || a.rightSweepEvent.isSamePoint(n.rightSweepEvent) || a.leftSweepEvent.isSamePoint(n.leftSweepEvent) || a.leftSweepEvent.isSamePoint(n.rightSweepEvent))) return !1;
  const l = a.leftSweepEvent.p.x, p = a.leftSweepEvent.p.y, x = a.rightSweepEvent.p.x, M = a.rightSweepEvent.p.y, T = n.leftSweepEvent.p.x, u = n.leftSweepEvent.p.y, R = n.rightSweepEvent.p.x, z = n.rightSweepEvent.p.y, U = (z - u) * (x - l) - (R - T) * (M - p), $ = (R - T) * (p - u) - (z - u) * (l - T), ee = (x - l) * (p - u) - (M - p) * (l - T);
  if (U === 0)
    return !1;
  const oe = $ / U, ce = ee / U;
  if (oe >= 0 && oe <= 1 && ce >= 0 && ce <= 1) {
    const me = l + oe * (x - l), re = p + oe * (M - p);
    return [me, re];
  }
  return !1;
}
function zN(a, n) {
  n = n || !1;
  const l = [], p = new hE([], RN);
  for (; a.length; ) {
    const x = a.pop();
    if (x.isLeftEndpoint) {
      const M = new NN(x);
      for (let T = 0; T < p.data.length; T++) {
        const u = p.data[T];
        if (n && u.leftSweepEvent.featureId === x.featureId)
          continue;
        const R = ON(M, u);
        R !== !1 && l.push(R);
      }
      p.push(M);
    } else x.isLeftEndpoint === !1 && p.pop();
  }
  return l;
}
function BN(a, n) {
  const l = new hE([], dE);
  return FN(a, l), zN(l, n);
}
var GN = BN;
function $f(a, n, l = {}) {
  const { removeDuplicates: p = !0, ignoreSelfIntersections: x = !0 } = l;
  let M = [];
  a.type === "FeatureCollection" ? M = M.concat(a.features) : a.type === "Feature" ? M.push(a) : (a.type === "LineString" || a.type === "Polygon" || a.type === "MultiLineString" || a.type === "MultiPolygon") && M.push(Ja(a)), n.type === "FeatureCollection" ? M = M.concat(n.features) : n.type === "Feature" ? M.push(n) : (n.type === "LineString" || n.type === "Polygon" || n.type === "MultiLineString" || n.type === "MultiPolygon") && M.push(Ja(n));
  const T = GN(
    gi(M),
    x
  );
  let u = [];
  if (p) {
    const R = {};
    T.forEach((z) => {
      const U = z.join(",");
      R[U] || (R[U] = !0, u.push(z));
    });
  } else
    u = T;
  return gi(u.map((R) => Ha(R)));
}
var jN = $f;
function My(a) {
  const n = Ws(a);
  let l = 0, p = 1, x, M;
  for (; p < n.length; )
    x = M || n[0], M = n[p], l += (M[0] - x[0]) * (M[1] + x[1]), p++;
  return l > 0;
}
function VN(a, n = {}) {
  var l, p;
  if (n = n || {}, !Qg(n)) throw new Error("options is invalid");
  const x = (l = n.mutate) != null ? l : !1, M = (p = n.reverse) != null ? p : !1;
  if (!a) throw new Error("<geojson> is required");
  if (typeof M != "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof x != "boolean")
    throw new Error("<mutate> must be a boolean");
  !x && a.type !== "Point" && a.type !== "MultiPoint" && (a = em(a));
  const T = [];
  switch (a.type) {
    case "GeometryCollection":
      return xc(a, function(u) {
        vg(u, M);
      }), a;
    case "FeatureCollection":
      return Mo(a, function(u) {
        const R = vg(u, M);
        Mo(R, function(z) {
          T.push(z);
        });
      }), gi(T);
  }
  return vg(a, M);
}
function vg(a, n) {
  switch (a.type === "Feature" ? a.geometry.type : a.type) {
    case "GeometryCollection":
      return xc(a, function(l) {
        vg(l, n);
      }), a;
    case "LineString":
      return bb(Ws(a), n), a;
    case "Polygon":
      return wb(Ws(a), n), a;
    case "MultiLineString":
      return Ws(a).forEach(function(l) {
        bb(l, n);
      }), a;
    case "MultiPolygon":
      return Ws(a).forEach(function(l) {
        wb(l, n);
      }), a;
    case "Point":
    case "MultiPoint":
      return a;
  }
}
function bb(a, n) {
  My(a) === n && a.reverse();
}
function wb(a, n) {
  My(a[0]) !== n && a[0].reverse();
  for (let l = 1; l < a.length; l++)
    My(a[l]) === n && a[l].reverse();
}
var UN = VN;
const qN = ["Point", "MultiPoint"], $N = [
  "LineString",
  "MultiLineString",
  "Polygon",
  "MultiPolygon"
], fE = (a) => qN.includes(a.geometry.type), Cy = (a) => $N.includes(a.geometry.type), ZN = (a, n) => (Vf(a, (l) => {
  const p = l.coordinate;
  p[0] += n.lng, p[1] += n.lat;
}), a), HN = (a, n) => {
  const l = a.getBounds(), p = B2(l[0], l[1], { units: "meters" });
  return LN(n, p * 1e-4, { units: "meters" }) || null;
}, YN = (a, n) => {
  const l = Js(a.getGeoJson());
  return ZN(l, n), l;
}, WN = (a, n) => {
  try {
    Vf(a, (l) => {
      if (!pc(l.coordinate, n))
        throw new Error("stop");
    });
  } catch {
    return !1;
  }
  return !0;
}, lg = (a, n) => {
  const l = WN(a, n);
  return fE(a) ? l : l && Cy(a) ? !jN(a, n, { ignoreSelfIntersections: !0 }).features.length : !1;
}, bv = (a) => {
  const n = a.getGeoJson();
  return typeof n != "object" ? null : $2(n);
}, XN = (a) => {
  if (Cy(a)) {
    const n = UN(a, { mutate: !1 });
    if (n.type === "Feature" && Cy(n))
      return {
        ...n,
        properties: a.properties || {}
      };
  }
  return fE(a) ? a : null;
}, JN = (a, n) => {
  const l = a.properties?.[n];
  return typeof l == "string" || typeof l == "number" ? l : null;
};
class wv extends qf {
  mode = "drag";
  previousLngLat = null;
  pointBasedShapes = ["marker", "circle_marker", "text_marker"];
  throttledMethods = bc(
    {
      onMouseMove: this.onMouseMove
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  eventHandlers = {
    [`${Ft}:edit`]: this.handleGmEdit.bind(this),
    mousedown: this.onMouseDown.bind(this),
    touchstart: this.onMouseDown.bind(this),
    mousemove: this.throttledMethods.onMouseMove.bind(this),
    touchmove: this.throttledMethods.onMouseMove.bind(this),
    mouseup: this.onMouseUp.bind(this),
    touchend: this.onMouseUp.bind(this)
  };
  getUpdatedGeoJsonHandlers = {
    marker: this.moveSource.bind(this),
    ellipse: this.moveEllipse.bind(this),
    circle: this.moveCircle.bind(this),
    circle_marker: this.moveSource.bind(this),
    text_marker: this.moveSource.bind(this),
    line: this.moveSource.bind(this),
    rectangle: this.moveSource.bind(this),
    polygon: this.moveSource.bind(this)
  };
  onMouseDown(n) {
    if (!Yn(n))
      return { next: !0 };
    const l = this.getFeatureByMouseEvent({ event: n, sourceNames: [wt.main] });
    return l && this.getUpdatedGeoJsonHandlers[l.shape] ? (this.featureData = l, this.featureData.changeSource({ sourceName: wt.temporary, atomic: !0 }), this.gm.mapAdapter.setDragPan(!1), this.snappingHelper?.addExcludedFeature(this.featureData), this.fireFeatureEditStartEvent({ feature: this.featureData, forceMode: "drag" }), this.flags.actionInProgress = !0, this.isPointBasedShape() && this.alignShapeCenterWithControlMarker(this.featureData, n), { next: !1 }) : { next: !0 };
  }
  onMouseUp(n) {
    return !this.featureData || !Yn(n, { warning: !0 }) ? { next: !0 } : (this.snappingHelper?.clearExcludedFeatures(), this.featureData.changeSource({ sourceName: wt.main, atomic: !0 }), this.previousLngLat = null, this.gm.mapAdapter.setDragPan(!0), this.fireFeatureEditEndEvent({ feature: this.featureData, forceMode: "drag" }), this.flags.actionInProgress = !1, this.featureData = null, { next: !0 });
  }
  onMouseMove(n) {
    if (!this.flags.actionInProgress || !Yn(n, { warning: !0 }))
      return { next: !0 };
    if (this.featureData) {
      const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
      this.moveFeature(this.featureData, l);
    }
    return { next: !1 };
  }
  isPointBasedShape() {
    return !!this.featureData && this.pointBasedShapes.includes(this.featureData.shape);
  }
  alignShapeCenterWithControlMarker(n, l) {
    const p = bv(n);
    p && (this.gm.markerPointer.marker?.setLngLat(p), this.onMouseMove(l));
  }
  moveFeature(n, l) {
    if (!this.flags.actionInProgress)
      return;
    if (!this.previousLngLat) {
      this.previousLngLat = l;
      return;
    }
    const p = this.getUpdatedGeoJsonHandlers[n.shape];
    if (p) {
      const x = p(n, this.previousLngLat, l);
      if (!x) {
        It.error("BaseDrag.moveFeature: invalid updatedGeoJson", n);
        return;
      }
      this.fireBeforeFeatureUpdate({
        features: [n],
        geoJsonFeatures: [x],
        forceMode: "drag"
      });
      const M = this.updateFeatureGeoJson({
        featureData: n,
        featureGeoJson: x,
        forceMode: "drag"
      });
      $h(n.getGeoJson().properties, x.properties) || n._updateAllProperties(x.properties), M && (this.previousLngLat = l);
    }
  }
  moveSource(n, l, p) {
    const x = L_(l, p);
    return YN(n, x);
  }
  moveEllipse(n, l, p) {
    if (n.shape !== "ellipse")
      return It.error("BaseDrag.moveCircle: invalid shape type", n), null;
    const x = n.getShapeProperty("center"), M = n.getShapeProperty("xSemiAxis"), T = n.getShapeProperty("ySemiAxis"), u = n.getShapeProperty("angle");
    if (!Array.isArray(x) || typeof M != "number" || typeof T != "number" || typeof u != "number")
      return It.error(
        "BaseDrag.moveEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        n
      ), null;
    const R = L_(l, p), z = [
      x[0] + R.lng,
      x[1] + R.lat
    ];
    return rm({
      center: z,
      xSemiAxis: M,
      ySemiAxis: T,
      angle: u
    });
  }
  moveCircle(n, l, p) {
    if (n.shape !== "circle")
      return It.error("BaseDrag.moveCircle: invalid shape type", n), null;
    const x = n.getShapeProperty("center");
    if (!Array.isArray(x))
      return It.error("BaseDrag.moveCircle: missing center in the featureData", n), null;
    const M = n.getGeoJson(), T = L_(l, p), u = $2(M);
    if (!u)
      return It.error("BaseDrag.moveCircle: missing center circleRimLngLat"), null;
    const R = [
      x[0] + T.lng,
      x[1] + T.lat
    ];
    n.setShapeProperty("center", R);
    const z = pv({
      center: R,
      radius: this.gm.mapAdapter.getDistance(x, u)
    });
    return {
      type: "Feature",
      properties: {
        shape: "circle"
      },
      geometry: z.geometry
    };
  }
}
const KN = (a, n) => (a % n + n) % n;
class QN extends wv {
  mode = "change";
  cutVertexShapeTypes = ["line", "polygon", "rectangle"];
  markerData = null;
  shapeUpdateHandlers = {
    marker: this.updateSingleVertex.bind(this),
    circle: this.updateCircle.bind(this),
    circle_marker: this.updateSingleVertex.bind(this),
    ellipse: this.updateEllipse.bind(this),
    text_marker: this.updateSingleVertex.bind(this),
    line: this.updateSingleVertex.bind(this),
    rectangle: this.updateRectangle.bind(this),
    polygon: this.updateSingleVertex.bind(this)
  };
  get snapGuidesInstance() {
    const n = this.gm.actionInstances.helper__snap_guides;
    return Y2(n) ? n : null;
  }
  onStartAction() {
  }
  onEndAction() {
    this.snapGuidesInstance?.removeSnapGuides();
  }
  handleGmEdit(n) {
    if (!Xh(n))
      return { next: !0 };
    if (n.action === "marker_move" && n.lngLatStart && n.markerData) {
      if (n.markerData.type === "vertex")
        return this.moveVertex(n), { next: !1 };
      if (n.lngLatEnd)
        return this.moveSource(n.featureData, n.lngLatStart, n.lngLatEnd), { next: !1 };
    }
    return n.action === "marker_right_click" ? (this.cutVertex(n), this.fireFeatureEditEndEvent({ feature: n.featureData })) : n.action === "edge_marker_click" ? this.insertVertex(n) : n.action === "marker_captured" ? (this.setCursorToPointer(), n.featureData.changeSource({ sourceName: wt.temporary, atomic: !0 }), this.flags.actionInProgress = !0, this.fireFeatureEditStartEvent({ feature: n.featureData })) : n.action === "marker_released" && (this.markerData = null, this.snapGuidesInstance?.removeSnapGuides(), n.featureData.changeSource({ sourceName: wt.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: n.featureData }), this.flags.actionInProgress = !1), { next: !0 };
  }
  moveVertex(n) {
    this.markerData || (this.markerData = n.markerData || null, this.snapGuidesInstance?.updateSnapGuides(n.featureData.getGeoJson(), n.lngLatStart));
    const l = n.featureData, p = l.shape, x = this.shapeUpdateHandlers[p]?.(n) || null;
    x ? (this.fireBeforeFeatureUpdate({
      features: [l],
      geoJsonFeatures: [x]
    }), this.updateFeatureGeoJson({ featureData: l, featureGeoJson: x })) : It.error("EditChange.moveVertex: invalid geojson", x, n);
  }
  cutVertex(n) {
    const l = n.featureData;
    if (n.markerData.type !== "vertex" || !this.cutVertexShapeTypes.includes(l.shape))
      return;
    let p = !1;
    const x = l.getGeoJson(), M = n.markerData.instance;
    if (j2(x)) {
      if (D_(x) <= 2) {
        this.gm.features.delete(l);
        return;
      }
    } else if (U2(x)) {
      if (D_(x) <= 3) {
        this.gm.features.delete(l);
        return;
      }
    } else if (V2(x) && D_(x) <= 3) {
      this.gm.features.delete(l);
      return;
    }
    const T = bv(M);
    T && (p = HR(x, T)), p ? (l.convertToPolygon(), l.updateGeoJsonGeometry(x.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [l],
      targetFeatures: [l],
      markerData: n.markerData
    })) : It.error("EditChange.cutVertex: feature not updated", n);
  }
  insertVertex(n) {
    if (n.markerData.type !== "edge")
      return;
    const l = n.featureData.getGeoJson(), p = n.markerData.segment.end.path, x = p.pop(), M = Nh(l, p);
    typeof x == "number" && (M.splice(x, 0, [...n.markerData.position.coordinate]), n.featureData.updateGeoJsonGeometry(l.geometry), n.featureData.convertToPolygon(), this.fireFeatureUpdatedEvent({
      sourceFeatures: [n.featureData],
      targetFeatures: [n.featureData],
      markerData: n.markerData
    }));
  }
  updateSingleVertex({ featureData: n, lngLatEnd: l, markerData: p }) {
    const x = Js(n.getGeoJson()), M = Js(p.position.path), T = M.pop(), u = Nh(x, M);
    return Array.isArray(u) && typeof T == "number" ? (u[T] = [...l], T === 0 && n.shape === "polygon" && (u[u.length - 1] = [...l])) : It.error("BaseDrag.moveSingleVertex: invalid coordinates", x, M), x;
  }
  updateCircle({ featureData: n, lngLatEnd: l }) {
    const p = n.getShapeProperty("center");
    if (n.shape !== "circle" || !p)
      return It.error("BaseDrag.moveCircle: invalid shape type / missing center", n), null;
    const x = pv({
      center: p,
      radius: this.gm.mapAdapter.getDistance(p, l)
    });
    return {
      type: "Feature",
      properties: {
        shape: "circle"
      },
      geometry: x.geometry
    };
  }
  updateEllipse(n) {
    const { featureData: l, lngLatEnd: p, markerData: x } = n;
    if (l.shape !== "ellipse")
      return It.error("EditChange.updateEllipse: invalid shape type", l), null;
    const M = l.getShapeProperty("center");
    let T = l.getShapeProperty("xSemiAxis"), u = l.getShapeProperty("ySemiAxis");
    const R = l.getShapeProperty("angle");
    if (!Array.isArray(M) || typeof T != "number" || typeof u != "number" || typeof R != "number")
      return It.error(
        "updateEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        l
      ), null;
    const z = this.gm.mapAdapter.getDistance(M, p), U = x.position.path[3], $ = Math.floor(U / Z2 * 4);
    return ($ === 0 || $ === 2 ? "x" : "y") == "x" ? T = z : u = z, rm({
      center: M,
      xSemiAxis: T,
      ySemiAxis: u,
      angle: R
    });
  }
  updateRectangle({ featureData: n, lngLatStart: l, lngLatEnd: p }) {
    const x = n.getGeoJson(), M = x.geometry.coordinates[0], { absCoordIndex: T } = tm(x, l);
    if (T === -1)
      return It.error("EditChange.updateRectangle: start vertex not found", n), null;
    const u = KN(T - 2, 4), R = M[u];
    return vy(p, R);
  }
}
function eO(a, n, {
  ignoreSelfIntersections: l = !0
} = { ignoreSelfIntersections: !0 }) {
  let p = !0;
  return tu(a, (x) => {
    tu(n, (M) => {
      if (p === !1)
        return !1;
      p = tO(
        x.geometry,
        M.geometry,
        l
      );
    });
  }), p;
}
function tO(a, n, l) {
  switch (a.type) {
    case "Point":
      switch (n.type) {
        case "Point":
          return !sO(a.coordinates, n.coordinates);
        case "LineString":
          return !Eb(n, a);
        case "Polygon":
          return !pc(a, n);
      }
      break;
    case "LineString":
      switch (n.type) {
        case "Point":
          return !Eb(a, n);
        case "LineString":
          return !rO(a, n, l);
        case "Polygon":
          return !Tb(n, a, l);
      }
      break;
    case "Polygon":
      switch (n.type) {
        case "Point":
          return !pc(n, a);
        case "LineString":
          return !Tb(a, n, l);
        case "Polygon":
          return !nO(n, a, l);
      }
  }
  return !1;
}
function Eb(a, n) {
  for (let l = 0; l < a.coordinates.length - 1; l++)
    if (iO(
      a.coordinates[l],
      a.coordinates[l + 1],
      n.coordinates
    ))
      return !0;
  return !1;
}
function rO(a, n, l) {
  return $f(a, n, {
    ignoreSelfIntersections: l
  }).features.length > 0;
}
function Tb(a, n, l) {
  for (const p of n.coordinates)
    if (pc(p, a))
      return !0;
  return $f(n, yy(a), {
    ignoreSelfIntersections: l
  }).features.length > 0;
}
function nO(a, n, l) {
  for (const p of a.coordinates[0])
    if (pc(p, n))
      return !0;
  for (const p of n.coordinates[0])
    if (pc(p, a))
      return !0;
  return $f(
    yy(a),
    yy(n),
    { ignoreSelfIntersections: l }
  ).features.length > 0;
}
function iO(a, n, l) {
  const p = l[0] - a[0], x = l[1] - a[1], M = n[0] - a[0], T = n[1] - a[1];
  return p * T - x * M !== 0 ? !1 : Math.abs(M) >= Math.abs(T) ? M > 0 ? a[0] <= l[0] && l[0] <= n[0] : n[0] <= l[0] && l[0] <= a[0] : T > 0 ? a[1] <= l[1] && l[1] <= n[1] : n[1] <= l[1] && l[1] <= a[1];
}
function sO(a, n) {
  return a[0] === n[0] && a[1] === n[1];
}
function aO(a, n, {
  ignoreSelfIntersections: l = !0
} = {}) {
  let p = !1;
  return tu(a, (x) => {
    tu(n, (M) => {
      if (p === !0)
        return !0;
      p = !eO(x.geometry, M.geometry, {
        ignoreSelfIntersections: l
      });
    });
  }), p;
}
var oO = aO, lO = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, G_ = Math.ceil, da = Math.floor, ks = "[BigNumber Error] ", Sb = ks + "Number primitive has more than 15 significant digits: ", Ba = 1e14, vr = 14, j_ = 9007199254740991, V_ = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], $l = 1e7, Li = 1e9;
function pE(a) {
  var n, l, p, x = _e.prototype = { constructor: _e, toString: null, valueOf: null }, M = new _e(1), T = 20, u = 4, R = -7, z = 21, U = -1e7, $ = 1e7, ee = !1, oe = 1, ce = 0, me = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, re = "0123456789abcdefghijklmnopqrstuvwxyz", Pe = !0;
  function _e(Q, ie) {
    var ge, Se, Ie, Oe, Re, De, Fe, Ue, Ve = this;
    if (!(Ve instanceof _e)) return new _e(Q, ie);
    if (ie == null) {
      if (Q && Q._isBigNumber === !0) {
        Ve.s = Q.s, !Q.c || Q.e > $ ? Ve.c = Ve.e = null : Q.e < U ? Ve.c = [Ve.e = 0] : (Ve.e = Q.e, Ve.c = Q.c.slice());
        return;
      }
      if ((De = typeof Q == "number") && Q * 0 == 0) {
        if (Ve.s = 1 / Q < 0 ? (Q = -Q, -1) : 1, Q === ~~Q) {
          for (Oe = 0, Re = Q; Re >= 10; Re /= 10, Oe++) ;
          Oe > $ ? Ve.c = Ve.e = null : (Ve.e = Oe, Ve.c = [Q]);
          return;
        }
        Ue = String(Q);
      } else {
        if (!lO.test(Ue = String(Q))) return p(Ve, Ue, De);
        Ve.s = Ue.charCodeAt(0) == 45 ? (Ue = Ue.slice(1), -1) : 1;
      }
      (Oe = Ue.indexOf(".")) > -1 && (Ue = Ue.replace(".", "")), (Re = Ue.search(/e/i)) > 0 ? (Oe < 0 && (Oe = Re), Oe += +Ue.slice(Re + 1), Ue = Ue.substring(0, Re)) : Oe < 0 && (Oe = Ue.length);
    } else {
      if (Bn(ie, 2, re.length, "Base"), ie == 10 && Pe)
        return Ve = new _e(Q), Ye(Ve, T + Ve.e + 1, u);
      if (Ue = String(Q), De = typeof Q == "number") {
        if (Q * 0 != 0) return p(Ve, Ue, De, ie);
        if (Ve.s = 1 / Q < 0 ? (Ue = Ue.slice(1), -1) : 1, _e.DEBUG && Ue.replace(/^0\.0*|\./, "").length > 15)
          throw Error(Sb + Q);
      } else
        Ve.s = Ue.charCodeAt(0) === 45 ? (Ue = Ue.slice(1), -1) : 1;
      for (ge = re.slice(0, ie), Oe = Re = 0, Fe = Ue.length; Re < Fe; Re++)
        if (ge.indexOf(Se = Ue.charAt(Re)) < 0) {
          if (Se == ".") {
            if (Re > Oe) {
              Oe = Fe;
              continue;
            }
          } else if (!Ie && (Ue == Ue.toUpperCase() && (Ue = Ue.toLowerCase()) || Ue == Ue.toLowerCase() && (Ue = Ue.toUpperCase()))) {
            Ie = !0, Re = -1, Oe = 0;
            continue;
          }
          return p(Ve, String(Q), De, ie);
        }
      De = !1, Ue = l(Ue, ie, 10, Ve.s), (Oe = Ue.indexOf(".")) > -1 ? Ue = Ue.replace(".", "") : Oe = Ue.length;
    }
    for (Re = 0; Ue.charCodeAt(Re) === 48; Re++) ;
    for (Fe = Ue.length; Ue.charCodeAt(--Fe) === 48; ) ;
    if (Ue = Ue.slice(Re, ++Fe)) {
      if (Fe -= Re, De && _e.DEBUG && Fe > 15 && (Q > j_ || Q !== da(Q)))
        throw Error(Sb + Ve.s * Q);
      if ((Oe = Oe - Re - 1) > $)
        Ve.c = Ve.e = null;
      else if (Oe < U)
        Ve.c = [Ve.e = 0];
      else {
        if (Ve.e = Oe, Ve.c = [], Re = (Oe + 1) % vr, Oe < 0 && (Re += vr), Re < Fe) {
          for (Re && Ve.c.push(+Ue.slice(0, Re)), Fe -= vr; Re < Fe; )
            Ve.c.push(+Ue.slice(Re, Re += vr));
          Re = vr - (Ue = Ue.slice(Re)).length;
        } else
          Re -= Fe;
        for (; Re--; Ue += "0") ;
        Ve.c.push(+Ue);
      }
    } else
      Ve.c = [Ve.e = 0];
  }
  _e.clone = pE, _e.ROUND_UP = 0, _e.ROUND_DOWN = 1, _e.ROUND_CEIL = 2, _e.ROUND_FLOOR = 3, _e.ROUND_HALF_UP = 4, _e.ROUND_HALF_DOWN = 5, _e.ROUND_HALF_EVEN = 6, _e.ROUND_HALF_CEIL = 7, _e.ROUND_HALF_FLOOR = 8, _e.EUCLID = 9, _e.config = _e.set = function(Q) {
    var ie, ge;
    if (Q != null)
      if (typeof Q == "object") {
        if (Q.hasOwnProperty(ie = "DECIMAL_PLACES") && (ge = Q[ie], Bn(ge, 0, Li, ie), T = ge), Q.hasOwnProperty(ie = "ROUNDING_MODE") && (ge = Q[ie], Bn(ge, 0, 8, ie), u = ge), Q.hasOwnProperty(ie = "EXPONENTIAL_AT") && (ge = Q[ie], ge && ge.pop ? (Bn(ge[0], -Li, 0, ie), Bn(ge[1], 0, Li, ie), R = ge[0], z = ge[1]) : (Bn(ge, -Li, Li, ie), R = -(z = ge < 0 ? -ge : ge))), Q.hasOwnProperty(ie = "RANGE"))
          if (ge = Q[ie], ge && ge.pop)
            Bn(ge[0], -Li, -1, ie), Bn(ge[1], 1, Li, ie), U = ge[0], $ = ge[1];
          else if (Bn(ge, -Li, Li, ie), ge)
            U = -($ = ge < 0 ? -ge : ge);
          else
            throw Error(ks + ie + " cannot be zero: " + ge);
        if (Q.hasOwnProperty(ie = "CRYPTO"))
          if (ge = Q[ie], ge === !!ge)
            if (ge)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                ee = ge;
              else
                throw ee = !ge, Error(ks + "crypto unavailable");
            else
              ee = ge;
          else
            throw Error(ks + ie + " not true or false: " + ge);
        if (Q.hasOwnProperty(ie = "MODULO_MODE") && (ge = Q[ie], Bn(ge, 0, 9, ie), oe = ge), Q.hasOwnProperty(ie = "POW_PRECISION") && (ge = Q[ie], Bn(ge, 0, Li, ie), ce = ge), Q.hasOwnProperty(ie = "FORMAT"))
          if (ge = Q[ie], typeof ge == "object") me = ge;
          else throw Error(ks + ie + " not an object: " + ge);
        if (Q.hasOwnProperty(ie = "ALPHABET"))
          if (ge = Q[ie], typeof ge == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(ge))
            Pe = ge.slice(0, 10) == "0123456789", re = ge;
          else
            throw Error(ks + ie + " invalid: " + ge);
      } else
        throw Error(ks + "Object expected: " + Q);
    return {
      DECIMAL_PLACES: T,
      ROUNDING_MODE: u,
      EXPONENTIAL_AT: [R, z],
      RANGE: [U, $],
      CRYPTO: ee,
      MODULO_MODE: oe,
      POW_PRECISION: ce,
      FORMAT: me,
      ALPHABET: re
    };
  }, _e.isBigNumber = function(Q) {
    if (!Q || Q._isBigNumber !== !0) return !1;
    if (!_e.DEBUG) return !0;
    var ie, ge, Se = Q.c, Ie = Q.e, Oe = Q.s;
    e: if ({}.toString.call(Se) == "[object Array]") {
      if ((Oe === 1 || Oe === -1) && Ie >= -Li && Ie <= Li && Ie === da(Ie)) {
        if (Se[0] === 0) {
          if (Ie === 0 && Se.length === 1) return !0;
          break e;
        }
        if (ie = (Ie + 1) % vr, ie < 1 && (ie += vr), String(Se[0]).length == ie) {
          for (ie = 0; ie < Se.length; ie++)
            if (ge = Se[ie], ge < 0 || ge >= Ba || ge !== da(ge)) break e;
          if (ge !== 0) return !0;
        }
      }
    } else if (Se === null && Ie === null && (Oe === null || Oe === 1 || Oe === -1))
      return !0;
    throw Error(ks + "Invalid BigNumber: " + Q);
  }, _e.maximum = _e.max = function() {
    return Qe(arguments, -1);
  }, _e.minimum = _e.min = function() {
    return Qe(arguments, 1);
  }, _e.random = (function() {
    var Q = 9007199254740992, ie = Math.random() * Q & 2097151 ? function() {
      return da(Math.random() * Q);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(ge) {
      var Se, Ie, Oe, Re, De, Fe = 0, Ue = [], Ve = new _e(M);
      if (ge == null ? ge = T : Bn(ge, 0, Li), Re = G_(ge / vr), ee)
        if (crypto.getRandomValues) {
          for (Se = crypto.getRandomValues(new Uint32Array(Re *= 2)); Fe < Re; )
            De = Se[Fe] * 131072 + (Se[Fe + 1] >>> 11), De >= 9e15 ? (Ie = crypto.getRandomValues(new Uint32Array(2)), Se[Fe] = Ie[0], Se[Fe + 1] = Ie[1]) : (Ue.push(De % 1e14), Fe += 2);
          Fe = Re / 2;
        } else if (crypto.randomBytes) {
          for (Se = crypto.randomBytes(Re *= 7); Fe < Re; )
            De = (Se[Fe] & 31) * 281474976710656 + Se[Fe + 1] * 1099511627776 + Se[Fe + 2] * 4294967296 + Se[Fe + 3] * 16777216 + (Se[Fe + 4] << 16) + (Se[Fe + 5] << 8) + Se[Fe + 6], De >= 9e15 ? crypto.randomBytes(7).copy(Se, Fe) : (Ue.push(De % 1e14), Fe += 7);
          Fe = Re / 7;
        } else
          throw ee = !1, Error(ks + "crypto unavailable");
      if (!ee)
        for (; Fe < Re; )
          De = ie(), De < 9e15 && (Ue[Fe++] = De % 1e14);
      for (Re = Ue[--Fe], ge %= vr, Re && ge && (De = V_[vr - ge], Ue[Fe] = da(Re / De) * De); Ue[Fe] === 0; Ue.pop(), Fe--) ;
      if (Fe < 0)
        Ue = [Oe = 0];
      else {
        for (Oe = -1; Ue[0] === 0; Ue.splice(0, 1), Oe -= vr) ;
        for (Fe = 1, De = Ue[0]; De >= 10; De /= 10, Fe++) ;
        Fe < vr && (Oe -= vr - Fe);
      }
      return Ve.e = Oe, Ve.c = Ue, Ve;
    };
  })(), _e.sum = function() {
    for (var Q = 1, ie = arguments, ge = new _e(ie[0]); Q < ie.length; ) ge = ge.plus(ie[Q++]);
    return ge;
  }, l = /* @__PURE__ */ (function() {
    var Q = "0123456789";
    function ie(ge, Se, Ie, Oe) {
      for (var Re, De = [0], Fe, Ue = 0, Ve = ge.length; Ue < Ve; ) {
        for (Fe = De.length; Fe--; De[Fe] *= Se) ;
        for (De[0] += Oe.indexOf(ge.charAt(Ue++)), Re = 0; Re < De.length; Re++)
          De[Re] > Ie - 1 && (De[Re + 1] == null && (De[Re + 1] = 0), De[Re + 1] += De[Re] / Ie | 0, De[Re] %= Ie);
      }
      return De.reverse();
    }
    return function(ge, Se, Ie, Oe, Re) {
      var De, Fe, Ue, Ve, We, dt, Tt, Ht, Ot = ge.indexOf("."), Pt = T, Mt = u;
      for (Ot >= 0 && (Ve = ce, ce = 0, ge = ge.replace(".", ""), Ht = new _e(Se), dt = Ht.pow(ge.length - Ot), ce = Ve, Ht.c = ie(
        rl(ha(dt.c), dt.e, "0"),
        10,
        Ie,
        Q
      ), Ht.e = Ht.c.length), Tt = ie(ge, Se, Ie, Re ? (De = re, Q) : (De = Q, re)), Ue = Ve = Tt.length; Tt[--Ve] == 0; Tt.pop()) ;
      if (!Tt[0]) return De.charAt(0);
      if (Ot < 0 ? --Ue : (dt.c = Tt, dt.e = Ue, dt.s = Oe, dt = n(dt, Ht, Pt, Mt, Ie), Tt = dt.c, We = dt.r, Ue = dt.e), Fe = Ue + Pt + 1, Ot = Tt[Fe], Ve = Ie / 2, We = We || Fe < 0 || Tt[Fe + 1] != null, We = Mt < 4 ? (Ot != null || We) && (Mt == 0 || Mt == (dt.s < 0 ? 3 : 2)) : Ot > Ve || Ot == Ve && (Mt == 4 || We || Mt == 6 && Tt[Fe - 1] & 1 || Mt == (dt.s < 0 ? 8 : 7)), Fe < 1 || !Tt[0])
        ge = We ? rl(De.charAt(1), -Pt, De.charAt(0)) : De.charAt(0);
      else {
        if (Tt.length = Fe, We)
          for (--Ie; ++Tt[--Fe] > Ie; )
            Tt[Fe] = 0, Fe || (++Ue, Tt = [1].concat(Tt));
        for (Ve = Tt.length; !Tt[--Ve]; ) ;
        for (Ot = 0, ge = ""; Ot <= Ve; ge += De.charAt(Tt[Ot++])) ;
        ge = rl(ge, Ue, De.charAt(0));
      }
      return ge;
    };
  })(), n = /* @__PURE__ */ (function() {
    function Q(Se, Ie, Oe) {
      var Re, De, Fe, Ue, Ve = 0, We = Se.length, dt = Ie % $l, Tt = Ie / $l | 0;
      for (Se = Se.slice(); We--; )
        Fe = Se[We] % $l, Ue = Se[We] / $l | 0, Re = Tt * Fe + Ue * dt, De = dt * Fe + Re % $l * $l + Ve, Ve = (De / Oe | 0) + (Re / $l | 0) + Tt * Ue, Se[We] = De % Oe;
      return Ve && (Se = [Ve].concat(Se)), Se;
    }
    function ie(Se, Ie, Oe, Re) {
      var De, Fe;
      if (Oe != Re)
        Fe = Oe > Re ? 1 : -1;
      else
        for (De = Fe = 0; De < Oe; De++)
          if (Se[De] != Ie[De]) {
            Fe = Se[De] > Ie[De] ? 1 : -1;
            break;
          }
      return Fe;
    }
    function ge(Se, Ie, Oe, Re) {
      for (var De = 0; Oe--; )
        Se[Oe] -= De, De = Se[Oe] < Ie[Oe] ? 1 : 0, Se[Oe] = De * Re + Se[Oe] - Ie[Oe];
      for (; !Se[0] && Se.length > 1; Se.splice(0, 1)) ;
    }
    return function(Se, Ie, Oe, Re, De) {
      var Fe, Ue, Ve, We, dt, Tt, Ht, Ot, Pt, Mt, Kt, gr, Ze, ri, lr, Ut, Me, br = Se.s == Ie.s ? 1 : -1, ur = Se.c, tr = Ie.c;
      if (!ur || !ur[0] || !tr || !tr[0])
        return new _e(
          // Return NaN if either NaN, or both Infinity or 0.
          !Se.s || !Ie.s || (ur ? tr && ur[0] == tr[0] : !tr) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            ur && ur[0] == 0 || !tr ? br * 0 : br / 0
          )
        );
      for (Ot = new _e(br), Pt = Ot.c = [], Ue = Se.e - Ie.e, br = Oe + Ue + 1, De || (De = Ba, Ue = fa(Se.e / vr) - fa(Ie.e / vr), br = br / vr | 0), Ve = 0; tr[Ve] == (ur[Ve] || 0); Ve++) ;
      if (tr[Ve] > (ur[Ve] || 0) && Ue--, br < 0)
        Pt.push(1), We = !0;
      else {
        for (ri = ur.length, Ut = tr.length, Ve = 0, br += 2, dt = da(De / (tr[0] + 1)), dt > 1 && (tr = Q(tr, dt, De), ur = Q(ur, dt, De), Ut = tr.length, ri = ur.length), Ze = Ut, Mt = ur.slice(0, Ut), Kt = Mt.length; Kt < Ut; Mt[Kt++] = 0) ;
        Me = tr.slice(), Me = [0].concat(Me), lr = tr[0], tr[1] >= De / 2 && lr++;
        do {
          if (dt = 0, Fe = ie(tr, Mt, Ut, Kt), Fe < 0) {
            if (gr = Mt[0], Ut != Kt && (gr = gr * De + (Mt[1] || 0)), dt = da(gr / lr), dt > 1)
              for (dt >= De && (dt = De - 1), Tt = Q(tr, dt, De), Ht = Tt.length, Kt = Mt.length; ie(Tt, Mt, Ht, Kt) == 1; )
                dt--, ge(Tt, Ut < Ht ? Me : tr, Ht, De), Ht = Tt.length, Fe = 1;
            else
              dt == 0 && (Fe = dt = 1), Tt = tr.slice(), Ht = Tt.length;
            if (Ht < Kt && (Tt = [0].concat(Tt)), ge(Mt, Tt, Kt, De), Kt = Mt.length, Fe == -1)
              for (; ie(tr, Mt, Ut, Kt) < 1; )
                dt++, ge(Mt, Ut < Kt ? Me : tr, Kt, De), Kt = Mt.length;
          } else Fe === 0 && (dt++, Mt = [0]);
          Pt[Ve++] = dt, Mt[0] ? Mt[Kt++] = ur[Ze] || 0 : (Mt = [ur[Ze]], Kt = 1);
        } while ((Ze++ < ri || Mt[0] != null) && br--);
        We = Mt[0] != null, Pt[0] || Pt.splice(0, 1);
      }
      if (De == Ba) {
        for (Ve = 1, br = Pt[0]; br >= 10; br /= 10, Ve++) ;
        Ye(Ot, Oe + (Ot.e = Ve + Ue * vr - 1) + 1, Re, We);
      } else
        Ot.e = Ue, Ot.r = +We;
      return Ot;
    };
  })();
  function je(Q, ie, ge, Se) {
    var Ie, Oe, Re, De, Fe;
    if (ge == null ? ge = u : Bn(ge, 0, 8), !Q.c) return Q.toString();
    if (Ie = Q.c[0], Re = Q.e, ie == null)
      Fe = ha(Q.c), Fe = Se == 1 || Se == 2 && (Re <= R || Re >= z) ? cg(Fe, Re) : rl(Fe, Re, "0");
    else if (Q = Ye(new _e(Q), ie, ge), Oe = Q.e, Fe = ha(Q.c), De = Fe.length, Se == 1 || Se == 2 && (ie <= Oe || Oe <= R)) {
      for (; De < ie; Fe += "0", De++) ;
      Fe = cg(Fe, Oe);
    } else if (ie -= Re + (Se === 2 && Oe > Re), Fe = rl(Fe, Oe, "0"), Oe + 1 > De) {
      if (--ie > 0) for (Fe += "."; ie--; Fe += "0") ;
    } else if (ie += Oe - De, ie > 0)
      for (Oe + 1 == De && (Fe += "."); ie--; Fe += "0") ;
    return Q.s < 0 && Ie ? "-" + Fe : Fe;
  }
  function Qe(Q, ie) {
    for (var ge, Se, Ie = 1, Oe = new _e(Q[0]); Ie < Q.length; Ie++)
      Se = new _e(Q[Ie]), (!Se.s || (ge = nc(Oe, Se)) === ie || ge === 0 && Oe.s === ie) && (Oe = Se);
    return Oe;
  }
  function et(Q, ie, ge) {
    for (var Se = 1, Ie = ie.length; !ie[--Ie]; ie.pop()) ;
    for (Ie = ie[0]; Ie >= 10; Ie /= 10, Se++) ;
    return (ge = Se + ge * vr - 1) > $ ? Q.c = Q.e = null : ge < U ? Q.c = [Q.e = 0] : (Q.e = ge, Q.c = ie), Q;
  }
  p = /* @__PURE__ */ (function() {
    var Q = /^(-?)0([xbo])(?=\w[\w.]*$)/i, ie = /^([^.]+)\.$/, ge = /^\.([^.]+)$/, Se = /^-?(Infinity|NaN)$/, Ie = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(Oe, Re, De, Fe) {
      var Ue, Ve = De ? Re : Re.replace(Ie, "");
      if (Se.test(Ve))
        Oe.s = isNaN(Ve) ? null : Ve < 0 ? -1 : 1;
      else {
        if (!De && (Ve = Ve.replace(Q, function(We, dt, Tt) {
          return Ue = (Tt = Tt.toLowerCase()) == "x" ? 16 : Tt == "b" ? 2 : 8, !Fe || Fe == Ue ? dt : We;
        }), Fe && (Ue = Fe, Ve = Ve.replace(ie, "$1").replace(ge, "0.$1")), Re != Ve))
          return new _e(Ve, Ue);
        if (_e.DEBUG)
          throw Error(ks + "Not a" + (Fe ? " base " + Fe : "") + " number: " + Re);
        Oe.s = null;
      }
      Oe.c = Oe.e = null;
    };
  })();
  function Ye(Q, ie, ge, Se) {
    var Ie, Oe, Re, De, Fe, Ue, Ve, We = Q.c, dt = V_;
    if (We) {
      e: {
        for (Ie = 1, De = We[0]; De >= 10; De /= 10, Ie++) ;
        if (Oe = ie - Ie, Oe < 0)
          Oe += vr, Re = ie, Fe = We[Ue = 0], Ve = da(Fe / dt[Ie - Re - 1] % 10);
        else if (Ue = G_((Oe + 1) / vr), Ue >= We.length)
          if (Se) {
            for (; We.length <= Ue; We.push(0)) ;
            Fe = Ve = 0, Ie = 1, Oe %= vr, Re = Oe - vr + 1;
          } else
            break e;
        else {
          for (Fe = De = We[Ue], Ie = 1; De >= 10; De /= 10, Ie++) ;
          Oe %= vr, Re = Oe - vr + Ie, Ve = Re < 0 ? 0 : da(Fe / dt[Ie - Re - 1] % 10);
        }
        if (Se = Se || ie < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        We[Ue + 1] != null || (Re < 0 ? Fe : Fe % dt[Ie - Re - 1]), Se = ge < 4 ? (Ve || Se) && (ge == 0 || ge == (Q.s < 0 ? 3 : 2)) : Ve > 5 || Ve == 5 && (ge == 4 || Se || ge == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (Oe > 0 ? Re > 0 ? Fe / dt[Ie - Re] : 0 : We[Ue - 1]) % 10 & 1 || ge == (Q.s < 0 ? 8 : 7)), ie < 1 || !We[0])
          return We.length = 0, Se ? (ie -= Q.e + 1, We[0] = dt[(vr - ie % vr) % vr], Q.e = -ie || 0) : We[0] = Q.e = 0, Q;
        if (Oe == 0 ? (We.length = Ue, De = 1, Ue--) : (We.length = Ue + 1, De = dt[vr - Oe], We[Ue] = Re > 0 ? da(Fe / dt[Ie - Re] % dt[Re]) * De : 0), Se)
          for (; ; )
            if (Ue == 0) {
              for (Oe = 1, Re = We[0]; Re >= 10; Re /= 10, Oe++) ;
              for (Re = We[0] += De, De = 1; Re >= 10; Re /= 10, De++) ;
              Oe != De && (Q.e++, We[0] == Ba && (We[0] = 1));
              break;
            } else {
              if (We[Ue] += De, We[Ue] != Ba) break;
              We[Ue--] = 0, De = 1;
            }
        for (Oe = We.length; We[--Oe] === 0; We.pop()) ;
      }
      Q.e > $ ? Q.c = Q.e = null : Q.e < U && (Q.c = [Q.e = 0]);
    }
    return Q;
  }
  function ot(Q) {
    var ie, ge = Q.e;
    return ge === null ? Q.toString() : (ie = ha(Q.c), ie = ge <= R || ge >= z ? cg(ie, ge) : rl(ie, ge, "0"), Q.s < 0 ? "-" + ie : ie);
  }
  return x.absoluteValue = x.abs = function() {
    var Q = new _e(this);
    return Q.s < 0 && (Q.s = 1), Q;
  }, x.comparedTo = function(Q, ie) {
    return nc(this, new _e(Q, ie));
  }, x.decimalPlaces = x.dp = function(Q, ie) {
    var ge, Se, Ie, Oe = this;
    if (Q != null)
      return Bn(Q, 0, Li), ie == null ? ie = u : Bn(ie, 0, 8), Ye(new _e(Oe), Q + Oe.e + 1, ie);
    if (!(ge = Oe.c)) return null;
    if (Se = ((Ie = ge.length - 1) - fa(this.e / vr)) * vr, Ie = ge[Ie]) for (; Ie % 10 == 0; Ie /= 10, Se--) ;
    return Se < 0 && (Se = 0), Se;
  }, x.dividedBy = x.div = function(Q, ie) {
    return n(this, new _e(Q, ie), T, u);
  }, x.dividedToIntegerBy = x.idiv = function(Q, ie) {
    return n(this, new _e(Q, ie), 0, 1);
  }, x.exponentiatedBy = x.pow = function(Q, ie) {
    var ge, Se, Ie, Oe, Re, De, Fe, Ue, Ve, We = this;
    if (Q = new _e(Q), Q.c && !Q.isInteger())
      throw Error(ks + "Exponent not an integer: " + ot(Q));
    if (ie != null && (ie = new _e(ie)), De = Q.e > 14, !We.c || !We.c[0] || We.c[0] == 1 && !We.e && We.c.length == 1 || !Q.c || !Q.c[0])
      return Ve = new _e(Math.pow(+ot(We), De ? Q.s * (2 - ug(Q)) : +ot(Q))), ie ? Ve.mod(ie) : Ve;
    if (Fe = Q.s < 0, ie) {
      if (ie.c ? !ie.c[0] : !ie.s) return new _e(NaN);
      Se = !Fe && We.isInteger() && ie.isInteger(), Se && (We = We.mod(ie));
    } else {
      if (Q.e > 9 && (We.e > 0 || We.e < -1 || (We.e == 0 ? We.c[0] > 1 || De && We.c[1] >= 24e7 : We.c[0] < 8e13 || De && We.c[0] <= 9999975e7)))
        return Oe = We.s < 0 && ug(Q) ? -0 : 0, We.e > -1 && (Oe = 1 / Oe), new _e(Fe ? 1 / Oe : Oe);
      ce && (Oe = G_(ce / vr + 2));
    }
    for (De ? (ge = new _e(0.5), Fe && (Q.s = 1), Ue = ug(Q)) : (Ie = Math.abs(+ot(Q)), Ue = Ie % 2), Ve = new _e(M); ; ) {
      if (Ue) {
        if (Ve = Ve.times(We), !Ve.c) break;
        Oe ? Ve.c.length > Oe && (Ve.c.length = Oe) : Se && (Ve = Ve.mod(ie));
      }
      if (Ie) {
        if (Ie = da(Ie / 2), Ie === 0) break;
        Ue = Ie % 2;
      } else if (Q = Q.times(ge), Ye(Q, Q.e + 1, 1), Q.e > 14)
        Ue = ug(Q);
      else {
        if (Ie = +ot(Q), Ie === 0) break;
        Ue = Ie % 2;
      }
      We = We.times(We), Oe ? We.c && We.c.length > Oe && (We.c.length = Oe) : Se && (We = We.mod(ie));
    }
    return Se ? Ve : (Fe && (Ve = M.div(Ve)), ie ? Ve.mod(ie) : Oe ? Ye(Ve, ce, u, Re) : Ve);
  }, x.integerValue = function(Q) {
    var ie = new _e(this);
    return Q == null ? Q = u : Bn(Q, 0, 8), Ye(ie, ie.e + 1, Q);
  }, x.isEqualTo = x.eq = function(Q, ie) {
    return nc(this, new _e(Q, ie)) === 0;
  }, x.isFinite = function() {
    return !!this.c;
  }, x.isGreaterThan = x.gt = function(Q, ie) {
    return nc(this, new _e(Q, ie)) > 0;
  }, x.isGreaterThanOrEqualTo = x.gte = function(Q, ie) {
    return (ie = nc(this, new _e(Q, ie))) === 1 || ie === 0;
  }, x.isInteger = function() {
    return !!this.c && fa(this.e / vr) > this.c.length - 2;
  }, x.isLessThan = x.lt = function(Q, ie) {
    return nc(this, new _e(Q, ie)) < 0;
  }, x.isLessThanOrEqualTo = x.lte = function(Q, ie) {
    return (ie = nc(this, new _e(Q, ie))) === -1 || ie === 0;
  }, x.isNaN = function() {
    return !this.s;
  }, x.isNegative = function() {
    return this.s < 0;
  }, x.isPositive = function() {
    return this.s > 0;
  }, x.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, x.minus = function(Q, ie) {
    var ge, Se, Ie, Oe, Re = this, De = Re.s;
    if (Q = new _e(Q, ie), ie = Q.s, !De || !ie) return new _e(NaN);
    if (De != ie)
      return Q.s = -ie, Re.plus(Q);
    var Fe = Re.e / vr, Ue = Q.e / vr, Ve = Re.c, We = Q.c;
    if (!Fe || !Ue) {
      if (!Ve || !We) return Ve ? (Q.s = -ie, Q) : new _e(We ? Re : NaN);
      if (!Ve[0] || !We[0])
        return We[0] ? (Q.s = -ie, Q) : new _e(Ve[0] ? Re : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          u == 3 ? -0 : 0
        ));
    }
    if (Fe = fa(Fe), Ue = fa(Ue), Ve = Ve.slice(), De = Fe - Ue) {
      for ((Oe = De < 0) ? (De = -De, Ie = Ve) : (Ue = Fe, Ie = We), Ie.reverse(), ie = De; ie--; Ie.push(0)) ;
      Ie.reverse();
    } else
      for (Se = (Oe = (De = Ve.length) < (ie = We.length)) ? De : ie, De = ie = 0; ie < Se; ie++)
        if (Ve[ie] != We[ie]) {
          Oe = Ve[ie] < We[ie];
          break;
        }
    if (Oe && (Ie = Ve, Ve = We, We = Ie, Q.s = -Q.s), ie = (Se = We.length) - (ge = Ve.length), ie > 0) for (; ie--; Ve[ge++] = 0) ;
    for (ie = Ba - 1; Se > De; ) {
      if (Ve[--Se] < We[Se]) {
        for (ge = Se; ge && !Ve[--ge]; Ve[ge] = ie) ;
        --Ve[ge], Ve[Se] += Ba;
      }
      Ve[Se] -= We[Se];
    }
    for (; Ve[0] == 0; Ve.splice(0, 1), --Ue) ;
    return Ve[0] ? et(Q, Ve, Ue) : (Q.s = u == 3 ? -1 : 1, Q.c = [Q.e = 0], Q);
  }, x.modulo = x.mod = function(Q, ie) {
    var ge, Se, Ie = this;
    return Q = new _e(Q, ie), !Ie.c || !Q.s || Q.c && !Q.c[0] ? new _e(NaN) : !Q.c || Ie.c && !Ie.c[0] ? new _e(Ie) : (oe == 9 ? (Se = Q.s, Q.s = 1, ge = n(Ie, Q, 0, 3), Q.s = Se, ge.s *= Se) : ge = n(Ie, Q, 0, oe), Q = Ie.minus(ge.times(Q)), !Q.c[0] && oe == 1 && (Q.s = Ie.s), Q);
  }, x.multipliedBy = x.times = function(Q, ie) {
    var ge, Se, Ie, Oe, Re, De, Fe, Ue, Ve, We, dt, Tt, Ht, Ot, Pt, Mt = this, Kt = Mt.c, gr = (Q = new _e(Q, ie)).c;
    if (!Kt || !gr || !Kt[0] || !gr[0])
      return !Mt.s || !Q.s || Kt && !Kt[0] && !gr || gr && !gr[0] && !Kt ? Q.c = Q.e = Q.s = null : (Q.s *= Mt.s, !Kt || !gr ? Q.c = Q.e = null : (Q.c = [0], Q.e = 0)), Q;
    for (Se = fa(Mt.e / vr) + fa(Q.e / vr), Q.s *= Mt.s, Fe = Kt.length, We = gr.length, Fe < We && (Ht = Kt, Kt = gr, gr = Ht, Ie = Fe, Fe = We, We = Ie), Ie = Fe + We, Ht = []; Ie--; Ht.push(0)) ;
    for (Ot = Ba, Pt = $l, Ie = We; --Ie >= 0; ) {
      for (ge = 0, dt = gr[Ie] % Pt, Tt = gr[Ie] / Pt | 0, Re = Fe, Oe = Ie + Re; Oe > Ie; )
        Ue = Kt[--Re] % Pt, Ve = Kt[Re] / Pt | 0, De = Tt * Ue + Ve * dt, Ue = dt * Ue + De % Pt * Pt + Ht[Oe] + ge, ge = (Ue / Ot | 0) + (De / Pt | 0) + Tt * Ve, Ht[Oe--] = Ue % Ot;
      Ht[Oe] = ge;
    }
    return ge ? ++Se : Ht.splice(0, 1), et(Q, Ht, Se);
  }, x.negated = function() {
    var Q = new _e(this);
    return Q.s = -Q.s || null, Q;
  }, x.plus = function(Q, ie) {
    var ge, Se = this, Ie = Se.s;
    if (Q = new _e(Q, ie), ie = Q.s, !Ie || !ie) return new _e(NaN);
    if (Ie != ie)
      return Q.s = -ie, Se.minus(Q);
    var Oe = Se.e / vr, Re = Q.e / vr, De = Se.c, Fe = Q.c;
    if (!Oe || !Re) {
      if (!De || !Fe) return new _e(Ie / 0);
      if (!De[0] || !Fe[0]) return Fe[0] ? Q : new _e(De[0] ? Se : Ie * 0);
    }
    if (Oe = fa(Oe), Re = fa(Re), De = De.slice(), Ie = Oe - Re) {
      for (Ie > 0 ? (Re = Oe, ge = Fe) : (Ie = -Ie, ge = De), ge.reverse(); Ie--; ge.push(0)) ;
      ge.reverse();
    }
    for (Ie = De.length, ie = Fe.length, Ie - ie < 0 && (ge = Fe, Fe = De, De = ge, ie = Ie), Ie = 0; ie; )
      Ie = (De[--ie] = De[ie] + Fe[ie] + Ie) / Ba | 0, De[ie] = Ba === De[ie] ? 0 : De[ie] % Ba;
    return Ie && (De = [Ie].concat(De), ++Re), et(Q, De, Re);
  }, x.precision = x.sd = function(Q, ie) {
    var ge, Se, Ie, Oe = this;
    if (Q != null && Q !== !!Q)
      return Bn(Q, 1, Li), ie == null ? ie = u : Bn(ie, 0, 8), Ye(new _e(Oe), Q, ie);
    if (!(ge = Oe.c)) return null;
    if (Ie = ge.length - 1, Se = Ie * vr + 1, Ie = ge[Ie]) {
      for (; Ie % 10 == 0; Ie /= 10, Se--) ;
      for (Ie = ge[0]; Ie >= 10; Ie /= 10, Se++) ;
    }
    return Q && Oe.e + 1 > Se && (Se = Oe.e + 1), Se;
  }, x.shiftedBy = function(Q) {
    return Bn(Q, -j_, j_), this.times("1e" + Q);
  }, x.squareRoot = x.sqrt = function() {
    var Q, ie, ge, Se, Ie, Oe = this, Re = Oe.c, De = Oe.s, Fe = Oe.e, Ue = T + 4, Ve = new _e("0.5");
    if (De !== 1 || !Re || !Re[0])
      return new _e(!De || De < 0 && (!Re || Re[0]) ? NaN : Re ? Oe : 1 / 0);
    if (De = Math.sqrt(+ot(Oe)), De == 0 || De == 1 / 0 ? (ie = ha(Re), (ie.length + Fe) % 2 == 0 && (ie += "0"), De = Math.sqrt(+ie), Fe = fa((Fe + 1) / 2) - (Fe < 0 || Fe % 2), De == 1 / 0 ? ie = "5e" + Fe : (ie = De.toExponential(), ie = ie.slice(0, ie.indexOf("e") + 1) + Fe), ge = new _e(ie)) : ge = new _e(De + ""), ge.c[0]) {
      for (Fe = ge.e, De = Fe + Ue, De < 3 && (De = 0); ; )
        if (Ie = ge, ge = Ve.times(Ie.plus(n(Oe, Ie, Ue, 1))), ha(Ie.c).slice(0, De) === (ie = ha(ge.c)).slice(0, De))
          if (ge.e < Fe && --De, ie = ie.slice(De - 3, De + 1), ie == "9999" || !Se && ie == "4999") {
            if (!Se && (Ye(Ie, Ie.e + T + 2, 0), Ie.times(Ie).eq(Oe))) {
              ge = Ie;
              break;
            }
            Ue += 4, De += 4, Se = 1;
          } else {
            (!+ie || !+ie.slice(1) && ie.charAt(0) == "5") && (Ye(ge, ge.e + T + 2, 1), Q = !ge.times(ge).eq(Oe));
            break;
          }
    }
    return Ye(ge, ge.e + T + 1, u, Q);
  }, x.toExponential = function(Q, ie) {
    return Q != null && (Bn(Q, 0, Li), Q++), je(this, Q, ie, 1);
  }, x.toFixed = function(Q, ie) {
    return Q != null && (Bn(Q, 0, Li), Q = Q + this.e + 1), je(this, Q, ie);
  }, x.toFormat = function(Q, ie, ge) {
    var Se, Ie = this;
    if (ge == null)
      Q != null && ie && typeof ie == "object" ? (ge = ie, ie = null) : Q && typeof Q == "object" ? (ge = Q, Q = ie = null) : ge = me;
    else if (typeof ge != "object")
      throw Error(ks + "Argument not an object: " + ge);
    if (Se = Ie.toFixed(Q, ie), Ie.c) {
      var Oe, Re = Se.split("."), De = +ge.groupSize, Fe = +ge.secondaryGroupSize, Ue = ge.groupSeparator || "", Ve = Re[0], We = Re[1], dt = Ie.s < 0, Tt = dt ? Ve.slice(1) : Ve, Ht = Tt.length;
      if (Fe && (Oe = De, De = Fe, Fe = Oe, Ht -= Oe), De > 0 && Ht > 0) {
        for (Oe = Ht % De || De, Ve = Tt.substr(0, Oe); Oe < Ht; Oe += De) Ve += Ue + Tt.substr(Oe, De);
        Fe > 0 && (Ve += Ue + Tt.slice(Oe)), dt && (Ve = "-" + Ve);
      }
      Se = We ? Ve + (ge.decimalSeparator || "") + ((Fe = +ge.fractionGroupSize) ? We.replace(
        new RegExp("\\d{" + Fe + "}\\B", "g"),
        "$&" + (ge.fractionGroupSeparator || "")
      ) : We) : Ve;
    }
    return (ge.prefix || "") + Se + (ge.suffix || "");
  }, x.toFraction = function(Q) {
    var ie, ge, Se, Ie, Oe, Re, De, Fe, Ue, Ve, We, dt, Tt = this, Ht = Tt.c;
    if (Q != null && (De = new _e(Q), !De.isInteger() && (De.c || De.s !== 1) || De.lt(M)))
      throw Error(ks + "Argument " + (De.isInteger() ? "out of range: " : "not an integer: ") + ot(De));
    if (!Ht) return new _e(Tt);
    for (ie = new _e(M), Ue = ge = new _e(M), Se = Fe = new _e(M), dt = ha(Ht), Oe = ie.e = dt.length - Tt.e - 1, ie.c[0] = V_[(Re = Oe % vr) < 0 ? vr + Re : Re], Q = !Q || De.comparedTo(ie) > 0 ? Oe > 0 ? ie : Ue : De, Re = $, $ = 1 / 0, De = new _e(dt), Fe.c[0] = 0; Ve = n(De, ie, 0, 1), Ie = ge.plus(Ve.times(Se)), Ie.comparedTo(Q) != 1; )
      ge = Se, Se = Ie, Ue = Fe.plus(Ve.times(Ie = Ue)), Fe = Ie, ie = De.minus(Ve.times(Ie = ie)), De = Ie;
    return Ie = n(Q.minus(ge), Se, 0, 1), Fe = Fe.plus(Ie.times(Ue)), ge = ge.plus(Ie.times(Se)), Fe.s = Ue.s = Tt.s, Oe = Oe * 2, We = n(Ue, Se, Oe, u).minus(Tt).abs().comparedTo(
      n(Fe, ge, Oe, u).minus(Tt).abs()
    ) < 1 ? [Ue, Se] : [Fe, ge], $ = Re, We;
  }, x.toNumber = function() {
    return +ot(this);
  }, x.toPrecision = function(Q, ie) {
    return Q != null && Bn(Q, 1, Li), je(this, Q, ie, 2);
  }, x.toString = function(Q) {
    var ie, ge = this, Se = ge.s, Ie = ge.e;
    return Ie === null ? Se ? (ie = "Infinity", Se < 0 && (ie = "-" + ie)) : ie = "NaN" : (Q == null ? ie = Ie <= R || Ie >= z ? cg(ha(ge.c), Ie) : rl(ha(ge.c), Ie, "0") : Q === 10 && Pe ? (ge = Ye(new _e(ge), T + Ie + 1, u), ie = rl(ha(ge.c), ge.e, "0")) : (Bn(Q, 2, re.length, "Base"), ie = l(rl(ha(ge.c), Ie, "0"), 10, Q, Se, !0)), Se < 0 && ge.c[0] && (ie = "-" + ie)), ie;
  }, x.valueOf = x.toJSON = function() {
    return ot(this);
  }, x._isBigNumber = !0, x[Symbol.toStringTag] = "BigNumber", x[Symbol.for("nodejs.util.inspect.custom")] = x.valueOf, a != null && _e.set(a), _e;
}
function fa(a) {
  var n = a | 0;
  return a > 0 || a === n ? n : n - 1;
}
function ha(a) {
  for (var n, l, p = 1, x = a.length, M = a[0] + ""; p < x; ) {
    for (n = a[p++] + "", l = vr - n.length; l--; n = "0" + n) ;
    M += n;
  }
  for (x = M.length; M.charCodeAt(--x) === 48; ) ;
  return M.slice(0, x + 1 || 1);
}
function nc(a, n) {
  var l, p, x = a.c, M = n.c, T = a.s, u = n.s, R = a.e, z = n.e;
  if (!T || !u) return null;
  if (l = x && !x[0], p = M && !M[0], l || p) return l ? p ? 0 : -u : T;
  if (T != u) return T;
  if (l = T < 0, p = R == z, !x || !M) return p ? 0 : !x ^ l ? 1 : -1;
  if (!p) return R > z ^ l ? 1 : -1;
  for (u = (R = x.length) < (z = M.length) ? R : z, T = 0; T < u; T++) if (x[T] != M[T]) return x[T] > M[T] ^ l ? 1 : -1;
  return R == z ? 0 : R > z ^ l ? 1 : -1;
}
function Bn(a, n, l, p) {
  if (a < n || a > l || a !== da(a))
    throw Error(ks + (p || "Argument") + (typeof a == "number" ? a < n || a > l ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(a));
}
function ug(a) {
  var n = a.c.length - 1;
  return fa(a.e / vr) == n && a.c[n] % 2 != 0;
}
function cg(a, n) {
  return (a.length > 1 ? a.charAt(0) + "." + a.slice(1) : a) + (n < 0 ? "e" : "e+") + n;
}
function rl(a, n, l) {
  var p, x;
  if (n < 0) {
    for (x = l + "."; ++n; x += l) ;
    a = x + a;
  } else if (p = a.length, ++n > p) {
    for (x = l, n -= p; --n; x += l) ;
    a += x;
  } else n < p && (a = a.slice(0, n) + "." + a.slice(n));
  return a;
}
var To = pE(), uO = class {
  key;
  left = null;
  right = null;
  constructor(a) {
    this.key = a;
  }
}, ef = class extends uO {
  constructor(a) {
    super(a);
  }
}, cO = class {
  size = 0;
  modificationCount = 0;
  splayCount = 0;
  splay(a) {
    const n = this.root;
    if (n == null)
      return this.compare(a, a), -1;
    let l = null, p = null, x = null, M = null, T = n;
    const u = this.compare;
    let R;
    for (; ; )
      if (R = u(T.key, a), R > 0) {
        let z = T.left;
        if (z == null || (R = u(z.key, a), R > 0 && (T.left = z.right, z.right = T, T = z, z = T.left, z == null)))
          break;
        l == null ? p = T : l.left = T, l = T, T = z;
      } else if (R < 0) {
        let z = T.right;
        if (z == null || (R = u(z.key, a), R < 0 && (T.right = z.left, z.left = T, T = z, z = T.right, z == null)))
          break;
        x == null ? M = T : x.right = T, x = T, T = z;
      } else
        break;
    return x != null && (x.right = T.left, T.left = M), l != null && (l.left = T.right, T.right = p), this.root !== T && (this.root = T, this.splayCount++), R;
  }
  splayMin(a) {
    let n = a, l = n.left;
    for (; l != null; ) {
      const p = l;
      n.left = p.right, p.right = n, n = p, l = n.left;
    }
    return n;
  }
  splayMax(a) {
    let n = a, l = n.right;
    for (; l != null; ) {
      const p = l;
      n.right = p.left, p.left = n, n = p, l = n.right;
    }
    return n;
  }
  _delete(a) {
    if (this.root == null || this.splay(a) != 0) return null;
    let n = this.root;
    const l = n, p = n.left;
    if (this.size--, p == null)
      this.root = n.right;
    else {
      const x = n.right;
      n = this.splayMax(p), n.right = x, this.root = n;
    }
    return this.modificationCount++, l;
  }
  addNewRoot(a, n) {
    this.size++, this.modificationCount++;
    const l = this.root;
    if (l == null) {
      this.root = a;
      return;
    }
    n < 0 ? (a.left = l, a.right = l.right, l.right = null) : (a.right = l, a.left = l.left, l.left = null), this.root = a;
  }
  _first() {
    const a = this.root;
    return a == null ? null : (this.root = this.splayMin(a), this.root);
  }
  _last() {
    const a = this.root;
    return a == null ? null : (this.root = this.splayMax(a), this.root);
  }
  clear() {
    this.root = null, this.size = 0, this.modificationCount++;
  }
  has(a) {
    return this.validKey(a) && this.splay(a) == 0;
  }
  defaultCompare() {
    return (a, n) => a < n ? -1 : a > n ? 1 : 0;
  }
  wrap() {
    return {
      getRoot: () => this.root,
      setRoot: (a) => {
        this.root = a;
      },
      getSize: () => this.size,
      getModificationCount: () => this.modificationCount,
      getSplayCount: () => this.splayCount,
      setSplayCount: (a) => {
        this.splayCount = a;
      },
      splay: (a) => this.splay(a),
      has: (a) => this.has(a)
    };
  }
}, Og = class df extends cO {
  root = null;
  compare;
  validKey;
  constructor(n, l) {
    super(), this.compare = n ?? this.defaultCompare(), this.validKey = l ?? ((p) => p != null && p != null);
  }
  delete(n) {
    return this.validKey(n) ? this._delete(n) != null : !1;
  }
  deleteAll(n) {
    for (const l of n)
      this.delete(l);
  }
  forEach(n) {
    const l = this[Symbol.iterator]();
    let p;
    for (; p = l.next(), !p.done; )
      n(p.value, p.value, this);
  }
  add(n) {
    const l = this.splay(n);
    return l != 0 && this.addNewRoot(new ef(n), l), this;
  }
  addAndReturn(n) {
    const l = this.splay(n);
    return l != 0 && this.addNewRoot(new ef(n), l), this.root.key;
  }
  addAll(n) {
    for (const l of n)
      this.add(l);
  }
  isEmpty() {
    return this.root == null;
  }
  isNotEmpty() {
    return this.root != null;
  }
  single() {
    if (this.size == 0) throw "Bad state: No element";
    if (this.size > 1) throw "Bad state: Too many element";
    return this.root.key;
  }
  first() {
    if (this.size == 0) throw "Bad state: No element";
    return this._first().key;
  }
  last() {
    if (this.size == 0) throw "Bad state: No element";
    return this._last().key;
  }
  lastBefore(n) {
    if (n == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(n) < 0) return this.root.key;
    let l = this.root.left;
    if (l == null) return null;
    let p = l.right;
    for (; p != null; )
      l = p, p = l.right;
    return l.key;
  }
  firstAfter(n) {
    if (n == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(n) > 0) return this.root.key;
    let l = this.root.right;
    if (l == null) return null;
    let p = l.left;
    for (; p != null; )
      l = p, p = l.left;
    return l.key;
  }
  retainAll(n) {
    const l = new df(this.compare, this.validKey), p = this.modificationCount;
    for (const x of n) {
      if (p != this.modificationCount)
        throw "Concurrent modification during iteration.";
      this.validKey(x) && this.splay(x) == 0 && l.add(this.root.key);
    }
    l.size != this.size && (this.root = l.root, this.size = l.size, this.modificationCount++);
  }
  lookup(n) {
    return !this.validKey(n) || this.splay(n) != 0 ? null : this.root.key;
  }
  intersection(n) {
    const l = new df(this.compare, this.validKey);
    for (const p of this)
      n.has(p) && l.add(p);
    return l;
  }
  difference(n) {
    const l = new df(this.compare, this.validKey);
    for (const p of this)
      n.has(p) || l.add(p);
    return l;
  }
  union(n) {
    const l = this.clone();
    return l.addAll(n), l;
  }
  clone() {
    const n = new df(this.compare, this.validKey);
    return n.size = this.size, n.root = this.copyNode(this.root), n;
  }
  copyNode(n) {
    if (n == null) return null;
    function l(x, M) {
      let T, u;
      do {
        if (T = x.left, u = x.right, T != null) {
          const R = new ef(T.key);
          M.left = R, l(T, R);
        }
        if (u != null) {
          const R = new ef(u.key);
          M.right = R, x = u, M = R;
        }
      } while (u != null);
    }
    const p = new ef(n.key);
    return l(n, p), p;
  }
  toSet() {
    return this.clone();
  }
  entries() {
    return new dO(this.wrap());
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return new hO(this.wrap());
  }
  [Symbol.toStringTag] = "[object Set]";
}, gE = class {
  tree;
  path = new Array();
  modificationCount = null;
  splayCount;
  constructor(a) {
    this.tree = a, this.splayCount = a.getSplayCount();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    return this.moveNext() ? { done: !1, value: this.current() } : { done: !0, value: null };
  }
  current() {
    if (!this.path.length) return null;
    const a = this.path[this.path.length - 1];
    return this.getValue(a);
  }
  rebuildPath(a) {
    this.path.splice(0, this.path.length), this.tree.splay(a), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
  }
  findLeftMostDescendent(a) {
    for (; a != null; )
      this.path.push(a), a = a.left;
  }
  moveNext() {
    if (this.modificationCount != this.tree.getModificationCount()) {
      if (this.modificationCount == null) {
        this.modificationCount = this.tree.getModificationCount();
        let l = this.tree.getRoot();
        for (; l != null; )
          this.path.push(l), l = l.left;
        return this.path.length > 0;
      }
      throw "Concurrent modification during iteration.";
    }
    if (!this.path.length) return !1;
    this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
    let a = this.path[this.path.length - 1], n = a.right;
    if (n != null) {
      for (; n != null; )
        this.path.push(n), n = n.left;
      return !0;
    }
    for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === a; )
      a = this.path.pop();
    return this.path.length > 0;
  }
}, hO = class extends gE {
  getValue(a) {
    return a.key;
  }
}, dO = class extends gE {
  getValue(a) {
    return [a.key, a.key];
  }
}, mE = (a) => () => a, Py = (a) => {
  const n = a ? (l, p) => p.minus(l).abs().isLessThanOrEqualTo(a) : mE(!1);
  return (l, p) => n(l, p) ? 0 : l.comparedTo(p);
};
function fO(a) {
  const n = a ? (l, p, x, M, T) => l.exponentiatedBy(2).isLessThanOrEqualTo(
    M.minus(p).exponentiatedBy(2).plus(T.minus(x).exponentiatedBy(2)).times(a)
  ) : mE(!1);
  return (l, p, x) => {
    const M = l.x, T = l.y, u = x.x, R = x.y, z = T.minus(R).times(p.x.minus(u)).minus(M.minus(u).times(p.y.minus(R)));
    return n(z, M, T, u, R) ? 0 : z.comparedTo(0);
  };
}
var pO = (a) => a, gO = (a) => {
  if (a) {
    const n = new Og(Py(a)), l = new Og(Py(a)), p = (M, T) => T.addAndReturn(M), x = (M) => ({
      x: p(M.x, n),
      y: p(M.y, l)
    });
    return x({ x: new To(0), y: new To(0) }), x;
  }
  return pO;
}, Ay = (a) => ({
  set: (n) => {
    dl = Ay(n);
  },
  reset: () => Ay(a),
  compare: Py(a),
  snap: gO(a),
  orient: fO(a)
}), dl = Ay(), tf = (a, n) => a.ll.x.isLessThanOrEqualTo(n.x) && n.x.isLessThanOrEqualTo(a.ur.x) && a.ll.y.isLessThanOrEqualTo(n.y) && n.y.isLessThanOrEqualTo(a.ur.y), Ly = (a, n) => {
  if (n.ur.x.isLessThan(a.ll.x) || a.ur.x.isLessThan(n.ll.x) || n.ur.y.isLessThan(a.ll.y) || a.ur.y.isLessThan(n.ll.y))
    return null;
  const l = a.ll.x.isLessThan(n.ll.x) ? n.ll.x : a.ll.x, p = a.ur.x.isLessThan(n.ur.x) ? a.ur.x : n.ur.x, x = a.ll.y.isLessThan(n.ll.y) ? n.ll.y : a.ll.y, M = a.ur.y.isLessThan(n.ur.y) ? a.ur.y : n.ur.y;
  return { ll: { x: l, y: x }, ur: { x: p, y: M } };
}, xg = (a, n) => a.x.times(n.y).minus(a.y.times(n.x)), _E = (a, n) => a.x.times(n.x).plus(a.y.times(n.y)), zg = (a) => _E(a, a).sqrt(), mO = (a, n, l) => {
  const p = { x: n.x.minus(a.x), y: n.y.minus(a.y) }, x = { x: l.x.minus(a.x), y: l.y.minus(a.y) };
  return xg(x, p).div(zg(x)).div(zg(p));
}, _O = (a, n, l) => {
  const p = { x: n.x.minus(a.x), y: n.y.minus(a.y) }, x = { x: l.x.minus(a.x), y: l.y.minus(a.y) };
  return _E(x, p).div(zg(x)).div(zg(p));
}, kb = (a, n, l) => n.y.isZero() ? null : { x: a.x.plus(n.x.div(n.y).times(l.minus(a.y))), y: l }, Ib = (a, n, l) => n.x.isZero() ? null : { x: l, y: a.y.plus(n.y.div(n.x).times(l.minus(a.x))) }, yO = (a, n, l, p) => {
  if (n.x.isZero()) return Ib(l, p, a.x);
  if (p.x.isZero()) return Ib(a, n, l.x);
  if (n.y.isZero()) return kb(l, p, a.y);
  if (p.y.isZero()) return kb(a, n, l.y);
  const x = xg(n, p);
  if (x.isZero()) return null;
  const M = { x: l.x.minus(a.x), y: l.y.minus(a.y) }, T = xg(M, n).div(x), u = xg(M, p).div(x), R = a.x.plus(u.times(n.x)), z = l.x.plus(T.times(p.x)), U = a.y.plus(u.times(n.y)), $ = l.y.plus(T.times(p.y)), ee = R.plus(z).div(2), oe = U.plus($).div(2);
  return { x: ee, y: oe };
}, xo = class yE {
  point;
  isLeft;
  segment;
  otherSE;
  consumedBy;
  // for ordering sweep events in the sweep event queue
  static compare(n, l) {
    const p = yE.comparePoints(n.point, l.point);
    return p !== 0 ? p : (n.point !== l.point && n.link(l), n.isLeft !== l.isLeft ? n.isLeft ? 1 : -1 : Bg.compare(n.segment, l.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(n, l) {
    return n.x.isLessThan(l.x) ? -1 : n.x.isGreaterThan(l.x) ? 1 : n.y.isLessThan(l.y) ? -1 : n.y.isGreaterThan(l.y) ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(n, l) {
    n.events === void 0 ? n.events = [this] : n.events.push(this), this.point = n, this.isLeft = l;
  }
  link(n) {
    if (n.point === this.point)
      throw new Error("Tried to link already linked events");
    const l = n.point.events;
    for (let p = 0, x = l.length; p < x; p++) {
      const M = l[p];
      this.point.events.push(M), M.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const n = this.point.events.length;
    for (let l = 0; l < n; l++) {
      const p = this.point.events[l];
      if (p.segment.consumedBy === void 0)
        for (let x = l + 1; x < n; x++) {
          const M = this.point.events[x];
          M.consumedBy === void 0 && p.otherSE.point.events === M.otherSE.point.events && p.segment.consume(M.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const n = [];
    for (let l = 0, p = this.point.events.length; l < p; l++) {
      const x = this.point.events[l];
      x !== this && !x.segment.ringOut && x.segment.isInResult() && n.push(x);
    }
    return n;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(n) {
    const l = /* @__PURE__ */ new Map(), p = (x) => {
      const M = x.otherSE;
      l.set(x, {
        sine: mO(this.point, n.point, M.point),
        cosine: _O(this.point, n.point, M.point)
      });
    };
    return (x, M) => {
      l.has(x) || p(x), l.has(M) || p(M);
      const { sine: T, cosine: u } = l.get(x), { sine: R, cosine: z } = l.get(M);
      return T.isGreaterThanOrEqualTo(0) && R.isGreaterThanOrEqualTo(0) ? u.isLessThan(z) ? 1 : u.isGreaterThan(z) ? -1 : 0 : T.isLessThan(0) && R.isLessThan(0) ? u.isLessThan(z) ? -1 : u.isGreaterThan(z) ? 1 : 0 : R.isLessThan(T) ? -1 : R.isGreaterThan(T) ? 1 : 0;
    };
  }
}, vO = class Dy {
  events;
  poly;
  _isExteriorRing;
  _enclosingRing;
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(n) {
    const l = [];
    for (let p = 0, x = n.length; p < x; p++) {
      const M = n[p];
      if (!M.isInResult() || M.ringOut) continue;
      let T = null, u = M.leftSE, R = M.rightSE;
      const z = [u], U = u.point, $ = [];
      for (; T = u, u = R, z.push(u), u.point !== U; )
        for (; ; ) {
          const ee = u.getAvailableLinkedEvents();
          if (ee.length === 0) {
            const me = z[0].point, re = z[z.length - 1].point;
            throw new Error(
              `Unable to complete output ring starting at [${me.x}, ${me.y}]. Last matching segment found ends at [${re.x}, ${re.y}].`
            );
          }
          if (ee.length === 1) {
            R = ee[0].otherSE;
            break;
          }
          let oe = null;
          for (let me = 0, re = $.length; me < re; me++)
            if ($[me].point === u.point) {
              oe = me;
              break;
            }
          if (oe !== null) {
            const me = $.splice(oe)[0], re = z.splice(me.index);
            re.unshift(re[0].otherSE), l.push(new Dy(re.reverse()));
            continue;
          }
          $.push({
            index: z.length,
            point: u.point
          });
          const ce = u.getLeftmostComparator(T);
          R = ee.sort(ce)[0].otherSE;
          break;
        }
      l.push(new Dy(z));
    }
    return l;
  }
  constructor(n) {
    this.events = n;
    for (let l = 0, p = n.length; l < p; l++)
      n[l].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let n = this.events[0].point;
    const l = [n];
    for (let z = 1, U = this.events.length - 1; z < U; z++) {
      const $ = this.events[z].point, ee = this.events[z + 1].point;
      dl.orient($, n, ee) !== 0 && (l.push($), n = $);
    }
    if (l.length === 1) return null;
    const p = l[0], x = l[1];
    dl.orient(p, n, x) === 0 && l.shift(), l.push(l[0]);
    const M = this.isExteriorRing() ? 1 : -1, T = this.isExteriorRing() ? 0 : l.length - 1, u = this.isExteriorRing() ? l.length : -1, R = [];
    for (let z = T; z != u; z += M)
      R.push([l[z].x.toNumber(), l[z].y.toNumber()]);
    return R;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const n = this.enclosingRing();
      this._isExteriorRing = n ? !n.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let n = this.events[0];
    for (let x = 1, M = this.events.length; x < M; x++) {
      const T = this.events[x];
      xo.compare(n, T) > 0 && (n = T);
    }
    let l = n.segment.prevInResult(), p = l ? l.prevInResult() : null;
    for (; ; ) {
      if (!l) return null;
      if (!p) return l.ringOut;
      if (p.ringOut !== l.ringOut)
        return p.ringOut?.enclosingRing() !== l.ringOut ? l.ringOut : l.ringOut?.enclosingRing();
      l = p.prevInResult(), p = l ? l.prevInResult() : null;
    }
  }
}, Mb = class {
  exteriorRing;
  interiorRings;
  constructor(a) {
    this.exteriorRing = a, a.poly = this, this.interiorRings = [];
  }
  addInterior(a) {
    this.interiorRings.push(a), a.poly = this;
  }
  getGeom() {
    const a = this.exteriorRing.getGeom();
    if (a === null) return null;
    const n = [a];
    for (let l = 0, p = this.interiorRings.length; l < p; l++) {
      const x = this.interiorRings[l].getGeom();
      x !== null && n.push(x);
    }
    return n;
  }
}, xO = class {
  rings;
  polys;
  constructor(a) {
    this.rings = a, this.polys = this._composePolys(a);
  }
  getGeom() {
    const a = [];
    for (let n = 0, l = this.polys.length; n < l; n++) {
      const p = this.polys[n].getGeom();
      p !== null && a.push(p);
    }
    return a;
  }
  _composePolys(a) {
    const n = [];
    for (let l = 0, p = a.length; l < p; l++) {
      const x = a[l];
      if (!x.poly)
        if (x.isExteriorRing()) n.push(new Mb(x));
        else {
          const M = x.enclosingRing();
          M?.poly || n.push(new Mb(M)), M?.poly?.addInterior(x);
        }
    }
    return n;
  }
}, bO = class {
  queue;
  tree;
  segments;
  constructor(a, n = Bg.compare) {
    this.queue = a, this.tree = new Og(n), this.segments = [];
  }
  process(a) {
    const n = a.segment, l = [];
    if (a.consumedBy)
      return a.isLeft ? this.queue.delete(a.otherSE) : this.tree.delete(n), l;
    a.isLeft && this.tree.add(n);
    let p = n, x = n;
    do
      p = this.tree.lastBefore(p);
    while (p != null && p.consumedBy != null);
    do
      x = this.tree.firstAfter(x);
    while (x != null && x.consumedBy != null);
    if (a.isLeft) {
      let M = null;
      if (p) {
        const u = p.getIntersection(n);
        if (u !== null && (n.isAnEndpoint(u) || (M = u), !p.isAnEndpoint(u))) {
          const R = this._splitSafely(p, u);
          for (let z = 0, U = R.length; z < U; z++)
            l.push(R[z]);
        }
      }
      let T = null;
      if (x) {
        const u = x.getIntersection(n);
        if (u !== null && (n.isAnEndpoint(u) || (T = u), !x.isAnEndpoint(u))) {
          const R = this._splitSafely(x, u);
          for (let z = 0, U = R.length; z < U; z++)
            l.push(R[z]);
        }
      }
      if (M !== null || T !== null) {
        let u = null;
        M === null ? u = T : T === null ? u = M : u = xo.comparePoints(
          M,
          T
        ) <= 0 ? M : T, this.queue.delete(n.rightSE), l.push(n.rightSE);
        const R = n.split(u);
        for (let z = 0, U = R.length; z < U; z++)
          l.push(R[z]);
      }
      l.length > 0 ? (this.tree.delete(n), l.push(a)) : (this.segments.push(n), n.prev = p);
    } else {
      if (p && x) {
        const M = p.getIntersection(x);
        if (M !== null) {
          if (!p.isAnEndpoint(M)) {
            const T = this._splitSafely(p, M);
            for (let u = 0, R = T.length; u < R; u++)
              l.push(T[u]);
          }
          if (!x.isAnEndpoint(M)) {
            const T = this._splitSafely(x, M);
            for (let u = 0, R = T.length; u < R; u++)
              l.push(T[u]);
          }
        }
      }
      this.tree.delete(n);
    }
    return l;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(a, n) {
    this.tree.delete(a);
    const l = a.rightSE;
    this.queue.delete(l);
    const p = a.split(n);
    return p.push(l), a.consumedBy === void 0 && this.tree.add(a), p;
  }
}, wO = class {
  type;
  numMultiPolys;
  run(a, n, l) {
    ff.type = a;
    const p = [new Pb(n, !0)];
    for (let R = 0, z = l.length; R < z; R++)
      p.push(new Pb(l[R], !1));
    if (ff.numMultiPolys = p.length, ff.type === "difference") {
      const R = p[0];
      let z = 1;
      for (; z < p.length; )
        Ly(p[z].bbox, R.bbox) !== null ? z++ : p.splice(z, 1);
    }
    if (ff.type === "intersection")
      for (let R = 0, z = p.length; R < z; R++) {
        const U = p[R];
        for (let $ = R + 1, ee = p.length; $ < ee; $++)
          if (Ly(U.bbox, p[$].bbox) === null) return [];
      }
    const x = new Og(xo.compare);
    for (let R = 0, z = p.length; R < z; R++) {
      const U = p[R].getSweepEvents();
      for (let $ = 0, ee = U.length; $ < ee; $++)
        x.add(U[$]);
    }
    const M = new bO(x);
    let T = null;
    for (x.size != 0 && (T = x.first(), x.delete(T)); T; ) {
      const R = M.process(T);
      for (let z = 0, U = R.length; z < U; z++) {
        const $ = R[z];
        $.consumedBy === void 0 && x.add($);
      }
      x.size != 0 ? (T = x.first(), x.delete(T)) : T = null;
    }
    dl.reset();
    const u = vO.factory(M.segments);
    return new xO(u).getGeom();
  }
}, ff = new wO(), Ry = ff, EO = 0, Bg = class bg {
  id;
  leftSE;
  rightSE;
  rings;
  windings;
  ringOut;
  consumedBy;
  prev;
  _prevInResult;
  _beforeState;
  _afterState;
  _isInResult;
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(n, l) {
    const p = n.leftSE.point.x, x = l.leftSE.point.x, M = n.rightSE.point.x, T = l.rightSE.point.x;
    if (T.isLessThan(p)) return 1;
    if (M.isLessThan(x)) return -1;
    const u = n.leftSE.point.y, R = l.leftSE.point.y, z = n.rightSE.point.y, U = l.rightSE.point.y;
    if (p.isLessThan(x)) {
      if (R.isLessThan(u) && R.isLessThan(z)) return 1;
      if (R.isGreaterThan(u) && R.isGreaterThan(z)) return -1;
      const $ = n.comparePoint(l.leftSE.point);
      if ($ < 0) return 1;
      if ($ > 0) return -1;
      const ee = l.comparePoint(n.rightSE.point);
      return ee !== 0 ? ee : -1;
    }
    if (p.isGreaterThan(x)) {
      if (u.isLessThan(R) && u.isLessThan(U)) return -1;
      if (u.isGreaterThan(R) && u.isGreaterThan(U)) return 1;
      const $ = l.comparePoint(n.leftSE.point);
      if ($ !== 0) return $;
      const ee = n.comparePoint(l.rightSE.point);
      return ee < 0 ? 1 : ee > 0 ? -1 : 1;
    }
    if (u.isLessThan(R)) return -1;
    if (u.isGreaterThan(R)) return 1;
    if (M.isLessThan(T)) {
      const $ = l.comparePoint(n.rightSE.point);
      if ($ !== 0) return $;
    }
    if (M.isGreaterThan(T)) {
      const $ = n.comparePoint(l.rightSE.point);
      if ($ < 0) return 1;
      if ($ > 0) return -1;
    }
    if (!M.eq(T)) {
      const $ = z.minus(u), ee = M.minus(p), oe = U.minus(R), ce = T.minus(x);
      if ($.isGreaterThan(ee) && oe.isLessThan(ce)) return 1;
      if ($.isLessThan(ee) && oe.isGreaterThan(ce)) return -1;
    }
    return M.isGreaterThan(T) ? 1 : M.isLessThan(T) || z.isLessThan(U) ? -1 : z.isGreaterThan(U) ? 1 : n.id < l.id ? -1 : n.id > l.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(n, l, p, x) {
    this.id = ++EO, this.leftSE = n, n.segment = this, n.otherSE = l, this.rightSE = l, l.segment = this, l.otherSE = n, this.rings = p, this.windings = x;
  }
  static fromRing(n, l, p) {
    let x, M, T;
    const u = xo.comparePoints(n, l);
    if (u < 0)
      x = n, M = l, T = 1;
    else if (u > 0)
      x = l, M = n, T = -1;
    else
      throw new Error(
        `Tried to create degenerate segment at [${n.x}, ${n.y}]`
      );
    const R = new xo(x, !0), z = new xo(M, !1);
    return new bg(R, z, [p], [T]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(n) {
    this.rightSE = n, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const n = this.leftSE.point.y, l = this.rightSE.point.y;
    return {
      ll: { x: this.leftSE.point.x, y: n.isLessThan(l) ? n : l },
      ur: { x: this.rightSE.point.x, y: n.isGreaterThan(l) ? n : l }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x.minus(this.leftSE.point.x),
      y: this.rightSE.point.y.minus(this.leftSE.point.y)
    };
  }
  isAnEndpoint(n) {
    return n.x.eq(this.leftSE.point.x) && n.y.eq(this.leftSE.point.y) || n.x.eq(this.rightSE.point.x) && n.y.eq(this.rightSE.point.y);
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(n) {
    return dl.orient(this.leftSE.point, n, this.rightSE.point);
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(n) {
    const l = this.bbox(), p = n.bbox(), x = Ly(l, p);
    if (x === null) return null;
    const M = this.leftSE.point, T = this.rightSE.point, u = n.leftSE.point, R = n.rightSE.point, z = tf(l, u) && this.comparePoint(u) === 0, U = tf(p, M) && n.comparePoint(M) === 0, $ = tf(l, R) && this.comparePoint(R) === 0, ee = tf(p, T) && n.comparePoint(T) === 0;
    if (U && z)
      return ee && !$ ? T : !ee && $ ? R : null;
    if (U)
      return $ && M.x.eq(R.x) && M.y.eq(R.y) ? null : M;
    if (z)
      return ee && T.x.eq(u.x) && T.y.eq(u.y) ? null : u;
    if (ee && $) return null;
    if (ee) return T;
    if ($) return R;
    const oe = yO(M, this.vector(), u, n.vector());
    return oe === null || !tf(x, oe) ? null : dl.snap(oe);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(n) {
    const l = [], p = n.events !== void 0, x = new xo(n, !0), M = new xo(n, !1), T = this.rightSE;
    this.replaceRightSE(M), l.push(M), l.push(x);
    const u = new bg(
      x,
      T,
      this.rings.slice(),
      this.windings.slice()
    );
    return xo.comparePoints(u.leftSE.point, u.rightSE.point) > 0 && u.swapEvents(), xo.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), p && (x.checkForConsuming(), M.checkForConsuming()), l;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const n = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = n, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let l = 0, p = this.windings.length; l < p; l++)
      this.windings[l] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(n) {
    let l = this, p = n;
    for (; l.consumedBy; ) l = l.consumedBy;
    for (; p.consumedBy; ) p = p.consumedBy;
    const x = bg.compare(l, p);
    if (x !== 0) {
      if (x > 0) {
        const M = l;
        l = p, p = M;
      }
      if (l.prev === p) {
        const M = l;
        l = p, p = M;
      }
      for (let M = 0, T = p.rings.length; M < T; M++) {
        const u = p.rings[M], R = p.windings[M], z = l.rings.indexOf(u);
        z === -1 ? (l.rings.push(u), l.windings.push(R)) : l.windings[z] += R;
      }
      p.rings = null, p.windings = null, p.consumedBy = l, p.leftSE.consumedBy = l.leftSE, p.rightSE.consumedBy = l.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const n = this.prev.consumedBy || this.prev;
      this._beforeState = n.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const n = this.beforeState();
    this._afterState = {
      rings: n.rings.slice(0),
      windings: n.windings.slice(0),
      multiPolys: []
    };
    const l = this._afterState.rings, p = this._afterState.windings, x = this._afterState.multiPolys;
    for (let u = 0, R = this.rings.length; u < R; u++) {
      const z = this.rings[u], U = this.windings[u], $ = l.indexOf(z);
      $ === -1 ? (l.push(z), p.push(U)) : p[$] += U;
    }
    const M = [], T = [];
    for (let u = 0, R = l.length; u < R; u++) {
      if (p[u] === 0) continue;
      const z = l[u], U = z.poly;
      if (T.indexOf(U) === -1)
        if (z.isExterior) M.push(U);
        else {
          T.indexOf(U) === -1 && T.push(U);
          const $ = M.indexOf(z.poly);
          $ !== -1 && M.splice($, 1);
        }
    }
    for (let u = 0, R = M.length; u < R; u++) {
      const z = M[u].multiPoly;
      x.indexOf(z) === -1 && x.push(z);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const n = this.beforeState().multiPolys, l = this.afterState().multiPolys;
    switch (Ry.type) {
      case "union": {
        const p = n.length === 0, x = l.length === 0;
        this._isInResult = p !== x;
        break;
      }
      case "intersection": {
        let p, x;
        n.length < l.length ? (p = n.length, x = l.length) : (p = l.length, x = n.length), this._isInResult = x === Ry.numMultiPolys && p < x;
        break;
      }
      case "xor": {
        const p = Math.abs(n.length - l.length);
        this._isInResult = p % 2 === 1;
        break;
      }
      case "difference": {
        const p = (x) => x.length === 1 && x[0].isSubject;
        this._isInResult = p(n) !== p(l);
        break;
      }
    }
    return this._isInResult;
  }
}, Cb = class {
  poly;
  isExterior;
  segments;
  bbox;
  constructor(a, n, l) {
    if (!Array.isArray(a) || a.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = n, this.isExterior = l, this.segments = [], typeof a[0][0] != "number" || typeof a[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const p = dl.snap({ x: new To(a[0][0]), y: new To(a[0][1]) });
    this.bbox = {
      ll: { x: p.x, y: p.y },
      ur: { x: p.x, y: p.y }
    };
    let x = p;
    for (let M = 1, T = a.length; M < T; M++) {
      if (typeof a[M][0] != "number" || typeof a[M][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      const u = dl.snap({ x: new To(a[M][0]), y: new To(a[M][1]) });
      u.x.eq(x.x) && u.y.eq(x.y) || (this.segments.push(Bg.fromRing(x, u, this)), u.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = u.x), u.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = u.y), u.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = u.x), u.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = u.y), x = u);
    }
    (!p.x.eq(x.x) || !p.y.eq(x.y)) && this.segments.push(Bg.fromRing(x, p, this));
  }
  getSweepEvents() {
    const a = [];
    for (let n = 0, l = this.segments.length; n < l; n++) {
      const p = this.segments[n];
      a.push(p.leftSE), a.push(p.rightSE);
    }
    return a;
  }
}, TO = class {
  multiPoly;
  exteriorRing;
  interiorRings;
  bbox;
  constructor(a, n) {
    if (!Array.isArray(a))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new Cb(a[0], this, !0), this.bbox = {
      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
    }, this.interiorRings = [];
    for (let l = 1, p = a.length; l < p; l++) {
      const x = new Cb(a[l], this, !1);
      x.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = x.bbox.ll.x), x.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = x.bbox.ll.y), x.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = x.bbox.ur.x), x.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = x.bbox.ur.y), this.interiorRings.push(x);
    }
    this.multiPoly = n;
  }
  getSweepEvents() {
    const a = this.exteriorRing.getSweepEvents();
    for (let n = 0, l = this.interiorRings.length; n < l; n++) {
      const p = this.interiorRings[n].getSweepEvents();
      for (let x = 0, M = p.length; x < M; x++)
        a.push(p[x]);
    }
    return a;
  }
}, Pb = class {
  isSubject;
  polys;
  bbox;
  constructor(a, n) {
    if (!Array.isArray(a))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof a[0][0][0] == "number" && (a = [a]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: { x: new To(Number.POSITIVE_INFINITY), y: new To(Number.POSITIVE_INFINITY) },
      ur: { x: new To(Number.NEGATIVE_INFINITY), y: new To(Number.NEGATIVE_INFINITY) }
    };
    for (let l = 0, p = a.length; l < p; l++) {
      const x = new TO(a[l], this);
      x.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = x.bbox.ll.x), x.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = x.bbox.ll.y), x.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = x.bbox.ur.x), x.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = x.bbox.ur.y), this.polys.push(x);
    }
    this.isSubject = n;
  }
  getSweepEvents() {
    const a = [];
    for (let n = 0, l = this.polys.length; n < l; n++) {
      const p = this.polys[n].getSweepEvents();
      for (let x = 0, M = p.length; x < M; x++)
        a.push(p[x]);
    }
    return a;
  }
}, SO = (a, ...n) => Ry.run("difference", a, n);
dl.set;
function kO(a) {
  const n = [];
  if (xc(a, (x) => {
    n.push(x.coordinates);
  }), n.length < 2)
    throw new Error("Must have at least two features");
  const l = a.features[0].properties || {}, p = SO(n[0], ...n.slice(1));
  return p.length === 0 ? null : p.length === 1 ? Ql(p[0], l) : C2(p, l);
}
var IO = kO;
function vE(a) {
  var n = new pa(a);
  return n.insert = function(l) {
    if (l.type !== "Feature") throw new Error("invalid feature");
    return l.bbox = l.bbox ? l.bbox : il(l), pa.prototype.insert.call(this, l);
  }, n.load = function(l) {
    var p = [];
    return Array.isArray(l) ? l.forEach(function(x) {
      if (x.type !== "Feature") throw new Error("invalid features");
      x.bbox = x.bbox ? x.bbox : il(x), p.push(x);
    }) : Mo(l, function(x) {
      if (x.type !== "Feature") throw new Error("invalid features");
      x.bbox = x.bbox ? x.bbox : il(x), p.push(x);
    }), pa.prototype.load.call(this, p);
  }, n.remove = function(l, p) {
    if (l.type !== "Feature") throw new Error("invalid feature");
    return l.bbox = l.bbox ? l.bbox : il(l), pa.prototype.remove.call(this, l, p);
  }, n.clear = function() {
    return pa.prototype.clear.call(this);
  }, n.search = function(l) {
    var p = pa.prototype.search.call(this, this.toBBox(l));
    return gi(p);
  }, n.collides = function(l) {
    return pa.prototype.collides.call(this, this.toBBox(l));
  }, n.all = function() {
    var l = pa.prototype.all.call(this);
    return gi(l);
  }, n.toJSON = function() {
    return pa.prototype.toJSON.call(this);
  }, n.fromJSON = function(l) {
    return pa.prototype.fromJSON.call(this, l);
  }, n.toBBox = function(l) {
    var p;
    if (l.bbox) p = l.bbox;
    else if (Array.isArray(l) && l.length === 4) p = l;
    else if (Array.isArray(l) && l.length === 6)
      p = [l[0], l[1], l[3], l[4]];
    else if (l.type === "Feature") p = il(l);
    else if (l.type === "FeatureCollection") p = il(l);
    else throw new Error("invalid geojson");
    return {
      minX: p[0],
      minY: p[1],
      maxX: p[2],
      maxY: p[3]
    };
  }, n;
}
function MO(a, n) {
  if (n = n ?? {}, !Qg(n)) throw new Error("options is invalid");
  var l = n.precision, p = n.coordinates, x = n.mutate;
  if (l = l == null || isNaN(l) ? 6 : l, p = p == null || isNaN(p) ? 3 : p, !a) throw new Error("<geojson> is required");
  if (typeof l != "number")
    throw new Error("<precision> must be a number");
  if (typeof p != "number")
    throw new Error("<coordinates> must be a number");
  (x === !1 || x === void 0) && (a = JSON.parse(JSON.stringify(a)));
  var M = Math.pow(10, l);
  return ru(a, function(T) {
    CO(T, M, p);
  }), a;
}
function CO(a, n, l) {
  a.length > l && a.splice(l, a.length);
  for (var p = 0; p < a.length; p++)
    a[p] = Math.round(a[p] * n) / n;
  return a;
}
function PO(a) {
  if (!a)
    throw new Error("geojson is required");
  const n = [];
  return tu(a, (l) => {
    AO(l, n);
  }), gi(n);
}
function AO(a, n) {
  let l = [];
  const p = a.geometry;
  if (p !== null) {
    switch (p.type) {
      case "Polygon":
        l = Ws(p);
        break;
      case "LineString":
        l = [Ws(p)];
    }
    l.forEach((x) => {
      LO(x, a.properties).forEach((M) => {
        M.id = n.length, n.push(M);
      });
    });
  }
}
function LO(a, n) {
  const l = [];
  return a.reduce((p, x) => {
    const M = eu([p, x], n);
    return M.bbox = DO(p, x), l.push(M), x;
  }), l;
}
function DO(a, n) {
  const l = a[0], p = a[1], x = n[0], M = n[1], T = l < x ? l : x, u = p < M ? p : M, R = l > x ? l : x, z = p > M ? p : M;
  return [T, u, R, z];
}
var RO = Object.defineProperty, FO = Object.defineProperties, NO = Object.getOwnPropertyDescriptors, Ab = Object.getOwnPropertySymbols, OO = Object.prototype.hasOwnProperty, zO = Object.prototype.propertyIsEnumerable, Lb = (a, n, l) => n in a ? RO(a, n, { enumerable: !0, configurable: !0, writable: !0, value: l }) : a[n] = l, Db = (a, n) => {
  for (var l in n || (n = {}))
    OO.call(n, l) && Lb(a, l, n[l]);
  if (Ab)
    for (var l of Ab(n))
      zO.call(n, l) && Lb(a, l, n[l]);
  return a;
}, Rb = (a, n) => FO(a, NO(n));
function BO(a, n, l = {}) {
  if (!a || !n)
    throw new Error("lines and pt are required arguments");
  const p = ti(n);
  let x = Ha([1 / 0, 1 / 0], {
    dist: 1 / 0,
    index: -1,
    multiFeatureIndex: -1,
    location: -1
  }), M = 0;
  return tu(
    a,
    function(T, u, R) {
      const z = Ws(T);
      for (let U = 0; U < z.length - 1; U++) {
        const $ = Ha(z[U]), ee = ti($), oe = Ha(z[U + 1]), ce = ti(oe), me = Dh($, oe, l);
        let re, Pe;
        ce[0] === p[0] && ce[1] === p[1] ? [re, Pe] = [ce, !0] : ee[0] === p[0] && ee[1] === p[1] ? [re, Pe] = [ee, !1] : [re, Pe] = VO(
          ee,
          ce,
          p
        );
        const _e = Ha(re, {
          dist: Dh(n, re, l),
          multiFeatureIndex: R,
          location: M + Dh($, re, l)
        });
        _e.properties.dist < x.properties.dist && (x = Rb(Db({}, _e), {
          properties: Rb(Db({}, _e.properties), {
            // Legacy behaviour where index progresses to next segment # if we
            // went with the end point this iteration.
            index: Pe ? U + 1 : U
          })
        })), M += me;
      }
    }
  ), x;
}
function ic(a, n) {
  const [l, p, x] = a, [M, T, u] = n;
  return l * M + p * T + x * u;
}
function rf(a, n) {
  const [l, p, x] = a, [M, T, u] = n;
  return [p * u - x * T, x * M - l * u, l * T - p * M];
}
function GO(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2));
}
function Fb(a) {
  const n = GO(a);
  return [a[0] / n, a[1] / n, a[2] / n];
}
function U_(a) {
  const n = Ni(a[1]), l = Ni(a[0]);
  return [
    Math.cos(n) * Math.cos(l),
    Math.cos(n) * Math.sin(l),
    Math.sin(n)
  ];
}
function jO(a) {
  const [n, l, p] = a, x = Math.min(Math.max(p, -1), 1), M = fc(Math.asin(x));
  return [fc(Math.atan2(l, n)), M];
}
function VO(a, n, l) {
  const p = U_(a), x = U_(n), M = U_(l), T = rf(p, x);
  if (T[0] === 0 && T[1] === 0 && T[2] === 0)
    return ic(p, x) > 0 ? [[...n], !0] : [[...l], !1];
  const u = rf(T, M);
  if (u[0] === 0 && u[1] === 0 && u[2] === 0)
    return [[...n], !0];
  const R = rf(u, T), z = Fb(R), U = [-z[0], -z[1], -z[2]], $ = ic(M, z) > ic(M, U) ? z : U, ee = Fb(T), oe = ic(rf(p, $), ee), ce = ic(rf($, x), ee);
  return oe >= 0 && ce >= 0 ? [jO($), !1] : ic(p, M) > ic(x, M) ? [[...a], !1] : [[...n], !0];
}
function UO(a, n) {
  if (!a) throw new Error("line is required");
  if (!n) throw new Error("splitter is required");
  var l = G1(a), p = G1(n);
  if (l !== "LineString") throw new Error("line must be LineString");
  if (p === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (p === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var x = MO(n, { precision: 7 });
  switch (p) {
    case "Point":
      return Fy(a, x);
    case "MultiPoint":
      return Nb(a, x);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return Nb(
        a,
        $f(a, x, {
          ignoreSelfIntersections: !0
        })
      );
  }
}
function Nb(a, n) {
  var l = [], p = vE();
  return tu(n, function(x) {
    if (l.forEach(function(u, R) {
      u.id = R;
    }), !l.length)
      l = Fy(a, x).features, p.load(gi(l));
    else {
      var M = p.search(x);
      if (M.features.length) {
        var T = xE(x, M);
        l = l.filter(function(u) {
          return u.id !== T.id;
        }), p.remove(T), Mo(Fy(T, x), function(u) {
          l.push(u), p.insert(u);
        });
      }
    }
  }), gi(l);
}
function Fy(a, n) {
  var l = [], p = Ws(a)[0], x = Ws(a)[a.geometry.coordinates.length - 1];
  if (q_(p, ti(n)) || q_(x, ti(n)))
    return gi([a]);
  var M = vE(), T = PO(a);
  M.load(T);
  var u = M.search(n);
  if (!u.features.length) return gi([a]);
  var R = xE(n, u), z = [p], U = kR(
    T,
    function($, ee, oe) {
      var ce = Ws(ee)[1], me = ti(n);
      return oe === R.id ? ($.push(me), l.push(eu($)), q_(me, ce) ? [me] : [me, ce]) : ($.push(ce), $);
    },
    z
  );
  return U.length > 1 && l.push(eu(U)), gi(l);
}
function xE(a, n) {
  if (!n.features.length) throw new Error("lines must contain features");
  if (n.features.length === 1) return n.features[0];
  var l, p = 1 / 0;
  return Mo(n, function(x) {
    var M = BO(x, a), T = M.properties.dist;
    T < p && (l = x, p = T);
  }), l;
}
function q_(a, n) {
  return a[0] === n[0] && a[1] === n[1];
}
var Ob = UO;
class qO extends qf {
  mode = "cut";
  lineDrawer = new xv(this.gm, { snappingMarkers: "first", targetShape: "polygon" });
  cutShapesAllowed = ["circle", "ellipse", "line", "rectangle", "polygon"];
  eventHandlers = {
    [`${Ft}:draw`]: this.forwardLineDrawerEvent.bind(this),
    mousemove: this.onMouseMove.bind(this)
  };
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("firstMarkerClick", this.cutPolygonFinished.bind(this));
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onMouseMove(n) {
    return Yn(n) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  cutPolygonFinished(n) {
    this.lineDrawer.endShape();
    const l = vv(n.geoJson), p = this.getBBoxFeaturesByPolygon(l);
    this.cutFeaturesByPolygon(p, l);
  }
  getBBoxFeaturesByPolygon(n) {
    const l = dv(n), p = this.gm.mapAdapter.coordBoundsToScreenBounds(l);
    return this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: p,
      sourceNames: [wt.main]
    });
  }
  cutFeaturesByPolygon(n, l) {
    n.forEach((p) => {
      if (p.getShapeProperty("disableEdit") !== !0) {
        if (lg(p.getGeoJson(), l)) {
          this.gm.features.delete(p), this.fireFeatureRemovedEvent(p);
          return;
        }
        if (oO(p.getGeoJson(), l) && this.cutShapesAllowed.includes(p.shape)) {
          if (p.shape === "line") {
            this.cutLineFeatureByPolygon(p, l);
            return;
          }
          this.cutPolygonFeatureByPolygon(p.id, l);
        }
      }
    });
  }
  cutLineFeatureByPolygon(n, l) {
    const p = n.getGeoJson(), x = HN(this.gm.mapAdapter, l);
    let M = !1, T = [];
    if (x) {
      if (p.geometry.type === "MultiLineString")
        p.geometry.coordinates.forEach((u) => {
          if (lg(eu(u), l))
            return;
          const R = Ob(eu(u), l);
          if (R.features.length === 0) {
            T.push(u);
            return;
          }
          R.features.filter((z) => !lg(z, x)).forEach((z) => {
            M = !0, T.push(z.geometry.coordinates);
          });
        });
      else if (p.geometry.type === "LineString") {
        const u = Ob(p, l);
        T = u.features.filter(
          (R) => !lg(R, x) && R.geometry.type === "LineString"
        ).map((R) => R.geometry.coordinates), u.features.length > 0 && (M = !0);
      }
      M && T.length && (T.length === 1 ? n.updateGeoJsonGeometry({ type: "LineString", coordinates: T[0] }) : n.updateGeoJsonGeometry({ type: "MultiLineString", coordinates: T }), this.fireFeatureUpdatedEvent({
        sourceFeatures: [n],
        targetFeatures: [n]
      }));
    }
  }
  cutPolygonFeatureByPolygon(n, l) {
    const p = this.gm.features.get(wt.main, n);
    if (!p) {
      It.warn("cutPolygonFeatureByPolygon: featureData not found", n);
      return;
    }
    p.convertToPolygon();
    const x = p.getGeoJson(), M = this.getGeoJsonDifference(x, l);
    M && (p.updateGeoJsonGeometry(M.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [p],
      targetFeatures: [p]
    }));
  }
  getGeoJsonDifference(n, l) {
    const p = gi([n, l]), x = IO(p);
    return x ? x.type === "Feature" ? x : (x.type === "FeatureCollection" && It.error("getGeoJsonDifference: FeatureCollection detected (not supported)", x), null) : null;
  }
}
class $O extends qf {
  mode = "delete";
  allowedShapes = [...ol];
  eventHandlers = {
    click: this.onMouseClick.bind(this)
  };
  onStartAction() {
    this.gm.markerPointer.enable({ invisibleMarker: !0 }), this.gm.markerPointer.pauseSnapping();
  }
  onEndAction() {
    this.gm.markerPointer.resumeSnapping(), this.gm.markerPointer.disable();
  }
  onMouseClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !1 };
    const l = this.getFeatureByMouseEvent({ event: n, sourceNames: [wt.main] });
    return l && this.allowedShapes.includes(l.shape) && (this.gm.features.delete(l), this.fireFeatureRemovedEvent(l)), { next: !1 };
  }
}
class ZO extends wv {
  mode = "drag";
  onStartAction() {
  }
  onEndAction() {
  }
  handleGmEdit(n) {
    return Xh(n) ? n.action === "marker_move" && n.lngLatStart && n.lngLatEnd ? (this.previousLngLat || (this.previousLngLat = n.lngLatStart), this.moveFeature(n.featureData, n.lngLatEnd), { next: !1 }) : (n.action === "marker_captured" ? (n.featureData.changeSource({ sourceName: wt.temporary, atomic: !0 }), this.flags.actionInProgress = !0, this.fireFeatureEditStartEvent({ feature: n.featureData }), this.setCursorToPointer()) : n.action === "marker_released" && (this.previousLngLat = null, n.featureData.changeSource({ sourceName: wt.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: n.featureData }), this.flags.actionInProgress = !1), { next: !0 }) : (It.error("EditDrag.handleGmEdit: not an edit event", n), { next: !0 });
  }
}
class HO extends wv {
  mode = "rotate";
  allowedShapes = ["line", "rectangle", "polygon", "ellipse"];
  convertFeaturesTypes = ["rectangle"];
  shapeRotateHandlers = {
    marker: this.rotateFeature.bind(this),
    circle: this.rotateFeature.bind(this),
    circle_marker: this.rotateFeature.bind(this),
    text_marker: this.rotateFeature.bind(this),
    line: this.rotateFeature.bind(this),
    rectangle: this.rotateFeature.bind(this),
    polygon: this.rotateFeature.bind(this),
    ellipse: this.rotateEllipse.bind(this)
  };
  onStartAction() {
  }
  onEndAction() {
  }
  handleGmEdit(n) {
    return Xh(n) ? this.isFeatureAllowed(n) ? { next: !0 } : n.action === "marker_move" && n.lngLatStart && n.lngLatEnd ? (n.markerData?.type === "vertex" ? this.moveVertex(n) : this.moveSource(n.featureData, n.lngLatStart, n.lngLatEnd), { next: !1 }) : (n.action === "marker_captured" ? (n.featureData.changeSource({ sourceName: wt.temporary, atomic: !0 }), this.setCursorToPointer(), this.flags.actionInProgress = !0, this.fireFeatureEditStartEvent({ feature: n.featureData })) : n.action === "marker_released" && (n.featureData.changeSource({ sourceName: wt.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: n.featureData }), this.flags.actionInProgress = !1), { next: !0 }) : (It.error("EditChange.handleGmEdit: not an edit event", n), { next: !1 });
  }
  isFeatureAllowed(n) {
    return "featureData" in n && !this.allowedShapes.includes(n.featureData.shape);
  }
  moveVertex(n) {
    const l = n.featureData, p = this.shapeRotateHandlers[l.shape]?.(n) || null;
    p ? (this.fireBeforeFeatureUpdate({
      features: [l],
      geoJsonFeatures: [p]
    }), this.updateFeatureGeoJson({ featureData: l, featureGeoJson: p }) && this.convertFeaturesTypes.includes(l.shape) && l.convertToPolygon()) : It.error("EditRotate.moveVertex: invalid geojson", p, n);
  }
  rotateEllipse(n) {
    const { featureData: l } = n;
    if (l.shape !== "ellipse")
      return It.error("EditRotate.rotateEllipse: invalid shape type", l), null;
    const p = l.getShapeProperty("center"), x = l.getShapeProperty("xSemiAxis"), M = l.getShapeProperty("ySemiAxis"), T = l.getShapeProperty("angle");
    if (!Array.isArray(p) || typeof x != "number" || typeof M != "number" || typeof T != "number")
      return It.error(
        "rotateEllipse: missing center, xSemiAxis, ySemiAxis or angle in the featureData",
        l
      ), null;
    const u = this.calculateRotationAngle(
      p,
      n.lngLatStart,
      n.lngLatEnd,
      !1
    );
    return rm({
      center: p,
      xSemiAxis: x,
      ySemiAxis: M,
      angle: T + u
    });
  }
  rotateFeature(n) {
    const l = n.featureData, p = Js(l.getGeoJson()), x = xy(_y(p)), M = this.calculateRotationAngle(x, n.lngLatStart, n.lngLatEnd);
    return p.geometry = OR(p, M, { pivot: x }).geometry, p;
  }
  calculateRotationAngle(n, l, p, x = !0) {
    const M = Pg(n, l), T = Pg(n, p) - M;
    return x ? (T + 360) % 360 : T;
  }
}
const Ny = {
  drag: ZO,
  change: QN,
  rotate: HO,
  scale: null,
  copy: null,
  cut: qO,
  split: null,
  union: null,
  difference: null,
  line_simplification: null,
  lasso: null,
  delete: $O
}, YO = (a, n) => Ny[n] ? new Ny[n](a) : (It.error(`Edit "${n}" is not available`), null);
class WO extends Kg {
  eventHandlers = {
    [`${Ft}:edit`]: this.handleEditEvent.bind(this)
  };
  constructor(n, l) {
    super(n), l.attachEvents(this.eventHandlers);
  }
  handleEditEvent(n) {
    if (!Xh(n))
      return { next: !0 };
    const l = `${n.actionType}__${n.mode}`;
    return n.action === "mode_start" ? (this.trackExclusiveModes(n), this.start(l, n), this.trackRelatedModes(n)) : n.action === "mode_end" && (this.trackRelatedModes(n), this.end(l)), { next: !0 };
  }
  start(n, l) {
    if (l.action !== "mode_start")
      return;
    const p = YO(this.gm, l.mode);
    p && (n in this.gm.actionInstances && It.error(`Action instance "${n}" already exists`), this.gm.actionInstances[n] = p, p.startAction());
  }
  end(n) {
    const l = this.gm.actionInstances[n];
    l instanceof qf ? (l.endAction(), delete this.gm.actionInstances[n]) : console.error(
      `Wrong action instance for edit event "${n}": `,
      l
    );
  }
}
class XO extends nu {
  mode = "shape_markers";
  pinEnabled = this.gm.options.controls.helper.pin?.active || !1;
  previousPosition = null;
  activeMarker = null;
  activeFeatureData = null;
  sharedMarkers = [];
  allowedShapes = ["circle", "line", "rectangle", "polygon", "ellipse"];
  edgeMarkersAllowed = !1;
  edgeMarkerAllowedShapes = ["line", "rectangle", "polygon"];
  shapeMarkerAllowedModes = ["drag", "change", "cut", "split"];
  eventHandlers = {
    [`${Ft}:draw`]: this.handleGmDraw.bind(this),
    [`${Ft}:edit`]: this.handleGmEdit.bind(this),
    mousedown: this.onMouseDown.bind(this),
    touchstart: this.onMouseDown.bind(this),
    mouseup: this.onMouseUp.bind(this),
    touchend: this.onMouseUp.bind(this),
    mousemove: this.onMouseMove.bind(this),
    touchmove: this.onMouseMove.bind(this),
    contextmenu: this.onMouseRightButtonClick.bind(this)
  };
  throttledMethods = bc(
    {
      sendMarkerMoveEvent: this.sendMarkerMoveEvent,
      sendMarkerRightClickEvent: this.sendMarkerRightClickEvent
    },
    this,
    this.gm.options.settings.throttlingDelay
  );
  debouncedMethods = eF(
    {
      refreshMarkers: this.refreshMarkers
    },
    this,
    this.gm.options.settings.throttlingDelay * 10
  );
  get pinHelperInstance() {
    return this.pinEnabled && Object.values(this.gm.actionInstances).find(oF) || null;
  }
  onStartAction() {
    this.isShapeMarkerAllowed() && this.gm.markerPointer.enable({ invisibleMarker: !0 }), this.edgeMarkersAllowed = this.gm.getActiveEditModes().includes("change"), this.addMarkers();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.removeMarkers();
  }
  setPin(n) {
    this.pinEnabled = n;
  }
  onMouseDown(n) {
    const l = ["mousedown", "touchstart"];
    if (!Yn(n, { warning: !0 }) || !l.includes(n.type) || nF(n))
      return { next: !0 };
    if (n.type === "mousedown" && n.originalEvent.button !== 0)
      return { next: !0 };
    const p = this.getFeatureMarkerByMouseEvent(n);
    return this.activeMarker = p || null, this.activeFeatureData = p?.instance.parent || null, this.activeMarker && this.activeFeatureData ? (this.previousPosition = bv(this.activeMarker.instance), this.gm.mapAdapter.setDragPan(!1), this.activeMarker.type === "edge" && this.sendMarkerEvent("edge_marker_click", this.activeFeatureData, this.activeMarker), this.pinEnabled && this.pinHelperInstance ? (this.sharedMarkers = this.pinHelperInstance.getSharedMarkers(
      this.activeMarker.position.coordinate
    ), this.sharedMarkers.forEach(
      (x) => this.snappingHelper?.addExcludedFeature(x.featureData)
    )) : this.snappingHelper?.addExcludedFeature(this.activeFeatureData), this.sendMarkerEvent("marker_captured", this.activeFeatureData, this.activeMarker), { next: !1 }) : { next: !0 };
  }
  onMouseUp() {
    if (!this.activeMarker)
      return { next: !0 };
    const n = {
      featureData: this.activeFeatureData,
      markerData: this.activeMarker
    };
    return this.activeMarker = null, this.activeFeatureData = null, this.sharedMarkers = [], this.snappingHelper?.clearExcludedFeatures(), this.previousPosition = null, this.gm.mapAdapter.setDragPan(!0), n.featureData && n.markerData ? (this.sendMarkerEvent("marker_released", n.featureData, n.markerData), { next: !1 }) : (It.debug("ShapeMarkersHelper.onMouseUp: no active marker or featureData", n), { next: !0 });
  }
  onMouseMove(n) {
    return !this.activeMarker || !Yn(n, { warning: !0 }) ? { next: !0 } : (this.throttledMethods.sendMarkerMoveEvent(n), { next: !1 });
  }
  onMouseRightButtonClick(n) {
    if (!Yn(n, { warning: !0 }))
      return { next: !0 };
    const l = this.getFeatureMarkerByMouseEvent(n);
    return l && l.instance.parent ? (this.throttledMethods.sendMarkerRightClickEvent(
      l.instance.parent,
      l
    ), { next: !1 }) : { next: !0 };
  }
  isShapeMarkerAllowed() {
    return MA(this.shapeMarkerAllowedModes, this.gm.getActiveEditModes()).length > 0;
  }
  convertToVertexMarker(n) {
    if (n.type === "edge" && n.instance.parent) {
      const l = n.position, p = n.instance.parent;
      this.removeMarker(n);
      const x = this.createMarker({
        type: "vertex",
        positionData: l,
        parentFeature: p
      }), M = p.getGeoJson(), T = jR(M, l.coordinate);
      if (T) {
        const u = T.path.join("."), R = p.markers.get(u);
        return R && this.removeMarker(R), p.markers.set(u, x), x;
      }
    }
    return It.error("ShapeMarkersHelper.convertToVertexMarker: invalid marker type", n), n;
  }
  getFeatureMarkerByMouseEvent(n) {
    const l = this.gm.features.getFeatureByMouseEvent({
      event: n,
      sourceNames: [wt.main]
    });
    if (l?.parent?.markers) {
      const p = $A(
        l.parent.markers,
        (x) => x.instance === l
      );
      if (p?.type !== "dom")
        return p;
    }
    return null;
  }
  addMarkers() {
    this.gm.features.forEach((n) => {
      if (!n || !this.allowedShapes.includes(n.shape) || n.getShapeProperty("disableEdit") === !0)
        return;
      this.addCenterMarker(n);
      const l = this.getAllShapeSegments(n), p = this.getEndMarkerIndexes(n);
      l.forEach((x, M) => {
        if (this.isMarkerIndexAllowed(
          n.shape,
          M,
          l.length
        )) {
          const T = this.createOrUpdateVertexMarker(x.segment.start, n);
          if (n.markers.set(T.markerKey, T.markerData), p.has(M)) {
            const u = this.createOrUpdateVertexMarker(
              x.segment.end,
              n
            );
            n.markers.set(u.markerKey, u.markerData);
          }
        }
        if (this.isEdgeMarkerAllowed(n)) {
          const T = this.createOrUpdateEdgeMarker(x, n);
          n.markers.set(T.markerKey, T.markerData);
        }
      });
    });
  }
  addCenterMarker(n) {
    const l = n.getShapeProperty("center");
    if (l) {
      const p = this.createMarker({
        type: "center",
        positionData: {
          path: [],
          coordinate: l
        },
        parentFeature: n
      });
      n.markers.set("center", p);
    }
  }
  getAllShapeSegments(n) {
    const l = n.getGeoJson(), p = [];
    return q2(l, (x, M) => {
      p.push({
        segment: x,
        middle: this.getSegmentMiddlePosition(x),
        edgeMarkerKey: this.getEdgeMarkerKey(M)
      });
    }), p;
  }
  isEdgeMarkerAllowed(n) {
    return this.edgeMarkersAllowed && this.edgeMarkerAllowedShapes.includes(n.shape);
  }
  isMarkerIndexAllowed(n, l, p) {
    const x = Math.floor(p / 4);
    return n === "circle" ? (l + x / 2) % x === 0 : n === "ellipse" ? l % x === 0 : !0;
  }
  getEdgeMarkerKey(n) {
    return `edge.${n}`;
  }
  getEndMarkerIndexes(n) {
    const l = n.getGeoJson().geometry;
    return n.shape !== "line" || !["LineString", "MultiLineString"].includes(l.type) ? /* @__PURE__ */ new Set() : l.type === "MultiLineString" ? l.coordinates.reduce(
      (p, x) => (p.indexes.add(p.sum + x.length - 2), p.sum += x.length - 1, p),
      { sum: 0, indexes: /* @__PURE__ */ new Set() }
    ).indexes : /* @__PURE__ */ new Set([l.coordinates.length - 2]);
  }
  getSegmentMiddlePosition(n) {
    const l = this.gm.mapAdapter.project(n.start.coordinate), p = this.gm.mapAdapter.project(n.end.coordinate), x = [
      (l[0] + p[0]) / 2,
      (l[1] + p[1]) / 2
    ], M = n.start.path.slice(0, n.start.path.length - 1).concat([-1]);
    return {
      coordinate: this.gm.mapAdapter.unproject(x),
      path: M
    };
  }
  removeMarkers() {
    this.gm.features.forEach((n, l) => {
      const p = this.gm.features.get(wt.main, l);
      p && (p.markers.forEach((x) => {
        x.type !== "dom" ? this.gm.features.delete(x.instance) : It.error("Non a FeatureData marker", x);
      }), p.markers = /* @__PURE__ */ new Map());
    });
  }
  removeMarker(n) {
    if (n.type === "dom") {
      It.error("Wrong marker type", n);
      return;
    }
    const l = n.instance.parent;
    if (!l) {
      It.error("Missing parent feature data", n);
      return;
    }
    try {
      l.markers.forEach((p, x) => {
        if (p === n)
          throw this.gm.features.delete(p.instance), l.markers.delete(x), new Error("break");
      });
    } catch {
    }
  }
  handleGmDraw(n) {
    return _v(n) ? (["feature_created", "mode_start"].includes(n.action) && this.debouncedMethods.refreshMarkers(), { next: !0 }) : (It.error("ShapeMarkersHelper.handleGmDraw: not a draw event", n), { next: !0 });
  }
  refreshMarkers() {
    this.gm.options.isModeEnabled("helper", "shape_markers") && (this.removeMarkers(), this.addMarkers());
  }
  handleGmEdit(n) {
    return Xh(n) ? (n.action === "feature_updated" && this.handleShapeUpdate(n), { next: !0 }) : (It.error("ShapeMarkersHelper.handleGmEdit: not an edit event", n), { next: !0 });
  }
  handleShapeUpdate(n) {
    const l = n.targetFeatures[0];
    if (!l) {
      It.error("ShapeMarkersHelper.handleShapeUpdate: no featureData", n);
      return;
    }
    this.activeMarker?.type === "edge" && (this.activeMarker = this.convertToVertexMarker(this.activeMarker));
    const p = this.getAllShapeSegments(l), x = new Set(l.markers.keys()), M = this.getEndMarkerIndexes(l);
    p.forEach((T, u) => {
      if (this.isMarkerIndexAllowed(
        l.shape,
        u,
        p.length
      )) {
        const R = this.createOrUpdateVertexMarker(T.segment.start, l);
        if (x.delete(R.markerKey), M.has(u)) {
          const z = this.createOrUpdateVertexMarker(
            T.segment.end,
            l
          );
          x.delete(z.markerKey);
        }
      }
      if (this.isEdgeMarkerAllowed(l)) {
        const R = this.createOrUpdateEdgeMarker(T, l);
        x.delete(R.markerKey);
      }
    }), this.updateCenterMarkerPosition(l), x.delete("center"), x.forEach((T) => {
      const u = l.markers.get(T);
      u && u.type !== "dom" ? this.gm.features.delete(u.instance) : It.error("Non a FeatureData marker"), l.markers.delete(T);
    });
  }
  createOrUpdateVertexMarker(n, l) {
    const p = n.path.join(".");
    let x = l.markers.get(p) || null;
    if (x && x?.type !== "vertex")
      throw new Error(`Invalid marker type "${x?.type}" for edge marker`);
    return x ? (U1(x.position.coordinate, n.coordinate) || this.gm.features.updateMarkerFeaturePosition(x.instance, n.coordinate), x.position = n) : (x = this.createMarker({
      type: "vertex",
      positionData: n,
      parentFeature: l
    }), l.markers.set(p, x)), { markerKey: p, markerData: x };
  }
  createOrUpdateEdgeMarker(n, l) {
    let p = l.markers.get(n.edgeMarkerKey) || null;
    if (p && p?.type !== "edge")
      throw new Error(`Invalid marker type "${p?.type}" for edge marker`);
    return p ? (U1(p.position.coordinate, n.middle.coordinate) || p.instance.updateGeoJsonGeometry({
      type: "Point",
      coordinates: n.middle.coordinate
    }), p.position = n.middle, p.segment = n.segment) : (p = this.createMarker({
      type: "edge",
      positionData: n.middle,
      segment: n.segment,
      parentFeature: l
    }), l.markers.set(n.edgeMarkerKey, p)), { markerKey: n.edgeMarkerKey, markerData: p };
  }
  updateCenterMarkerPosition(n) {
    const l = n.markers.get("center") || null, p = n.getShapeProperty("center");
    l && l.type !== "dom" && p && (l.instance.updateGeoJsonGeometry({
      type: "Point",
      coordinates: p
    }), l.position.coordinate = p);
  }
  sendMarkerEvent(n, l, p) {
    const x = {
      name: `${Ft}:edit:marker`,
      level: "system",
      actionType: "edit",
      mode: "change",
      action: n,
      featureData: l,
      markerData: p
    };
    this.gm.events.fire(`${Ft}:edit`, x);
  }
  sendMarkerRightClickEvent(n, l) {
    const p = {
      name: `${Ft}:edit:marker`,
      level: "system",
      actionType: "edit",
      mode: "change",
      action: "marker_right_click",
      featureData: n,
      markerData: l
    };
    this.gm.events.fire(`${Ft}:edit`, p);
  }
  sendMarkerMoveEvent(n) {
    const l = this.gm.markerPointer.marker?.getLngLat() || n.lngLat.toArray();
    this.activeMarker && this.activeFeatureData && (this.pinEnabled ? this.sharedMarkers : [
      {
        markerData: this.activeMarker,
        featureData: this.activeFeatureData
      }
    ]).forEach((p) => {
      if (this.previousPosition) {
        const x = {
          name: `${Ft}:edit:marker_move`,
          level: "system",
          actionType: "edit",
          mode: "drag",
          action: "marker_move",
          featureData: p.featureData,
          markerData: p.markerData,
          lngLatStart: this.previousPosition,
          lngLatEnd: l
        };
        this.gm.events.fire(`${Ft}:edit`, x);
      }
    }), this.previousPosition = l;
  }
  createMarker({
    type: n,
    segment: l,
    positionData: p,
    parentFeature: x
  }) {
    const M = p.coordinate, T = this.gm.features.createMarkerFeature({
      sourceName: x.sourceName,
      parentFeature: x,
      type: n,
      coordinate: M
    });
    if (!T)
      throw new Error(`Missine feature data for the "${n}" marker`);
    if (n === "edge" && l)
      return {
        type: n,
        instance: T,
        position: Js(p),
        segment: l
      };
    if (n === "vertex" || n === "center")
      return {
        type: n,
        instance: T,
        position: Js(p)
      };
    throw new Error(`Invalid marker type "${n}" with segment: ${l}`);
  }
}
class JO extends nu {
  mode = "snapping";
  tolerance = 18;
  lineSnappingShapes = [
    "circle",
    "line",
    "rectangle",
    "polygon",
    "snap_guide"
  ];
  eventHandlers = {};
  shapeSnappingHandlers = {
    marker: this.getPointsSnapping.bind(this),
    circle: this.getLineSnapping.bind(this),
    circle_marker: this.getPointsSnapping.bind(this),
    text_marker: this.getPointsSnapping.bind(this),
    line: this.getLineSnapping.bind(this),
    rectangle: this.getLineSnapping.bind(this),
    polygon: this.getLineSnapping.bind(this),
    snap_guide: this.getLineSnapping.bind(this)
  };
  excludedFeature = /* @__PURE__ */ new Set();
  customSnappingLngLats = /* @__PURE__ */ new Map();
  customSnappingFeatures = /* @__PURE__ */ new Set();
  onStartAction() {
    this.gm.markerPointer.setSnapping(!0);
  }
  onEndAction() {
    this.gm.markerPointer.setSnapping(!1);
  }
  addExcludedFeature(n) {
    this.excludedFeature.add(n);
  }
  clearExcludedFeatures() {
    this.excludedFeature.clear();
  }
  addCustomSnappingFeature(n) {
    this.customSnappingFeatures.add(n);
  }
  removeCustomSnappingFeature(n) {
    this.customSnappingFeatures.delete(n);
  }
  clearCustomSnappingFeature() {
    this.customSnappingFeatures.clear();
  }
  setCustomSnappingCoordinates(n, l) {
    this.customSnappingLngLats.set(n, l);
  }
  clearCustomSnappingCoordinates(n) {
    this.customSnappingLngLats.delete(n);
  }
  getSnappedLngLat(n, l) {
    let p = this.getCustomLngLatsSnapping(l);
    if (p)
      return p;
    const x = this.getFeaturesInPointBounds(l).filter(
      (M) => !this.excludedFeature.has(M)
    );
    return p = this.getFeaturePointsSnapping(x, n, l), p || (p = this.getFeatureLinesSnapping(x, n, l), p) ? p : n;
  }
  getCustomLngLatsSnapping(n) {
    const l = {
      distance: 1 / 0,
      lngLat: null
    };
    return this.customSnappingLngLats.forEach((p) => {
      p.forEach((x) => {
        const M = this.gm.mapAdapter.project(x), T = gg(n, M);
        T < this.tolerance && T < l.distance && (l.distance = T, l.lngLat = x);
      });
    }), l.lngLat;
  }
  getFeaturePointsSnapping(n, l, p) {
    let x = n.map((M) => ({
      shape: M.shape,
      ...this.getPointsSnapping(M, l, p)
    })).filter((M) => M.distance < this.tolerance);
    return x.length ? (x = f1(x, ["distance"]), x[0].lngLat) : null;
  }
  getFeatureLinesSnapping(n, l, p) {
    let x = n.filter((M) => this.lineSnappingShapes.includes(M.shape)).map((M) => {
      const T = this.shapeSnappingHandlers[M.shape];
      return T ? {
        shape: M.shape,
        ...T(M, l, p)
      } : null;
    }).filter((M) => M !== null && M.distance < this.tolerance);
    return x.length ? (x = f1(x, ["distance"]), x[0].lngLat) : null;
  }
  getFeaturesInPointBounds(n) {
    const l = [
      [n[0] - this.tolerance, n[1] - this.tolerance],
      [n[0] + this.tolerance, n[1] + this.tolerance]
    ];
    return this.gm.features.getFeaturesByScreenBounds({ bounds: l, sourceNames: [wt.main, wt.temporary] }).filter((p) => p.temporary ? this.customSnappingFeatures.has(p) : !0) || [];
  }
  getPointsSnapping(n, l, p) {
    const x = n.getGeoJson(), M = {
      distance: 1 / 0,
      coord: null
      // lngLat coords
    };
    return Vf(
      x,
      (T) => {
        const u = this.gm.mapAdapter.project(T.coordinate), R = gg(p, u);
        R < this.tolerance && R < M.distance && (M.distance = R, M.coord = T.coordinate);
      },
      !0
    ), {
      lngLat: M.coord ? M.coord : l,
      distance: M.distance
    };
  }
  getLineSnapping(n, l, p) {
    const x = n.getGeoJson();
    return this.getNearestLinePointData(x, l, p);
  }
  getNearestLinePointData(n, l, p) {
    const x = {
      lngLat: l,
      distance: 1 / 0
    }, M = this.gm.mapAdapter.getEuclideanNearestLngLat(n, l), T = this.gm.mapAdapter.project(M);
    return x.distance = gg(T, p), x.distance < this.tolerance && (x.lngLat = M), x;
  }
}
class KO extends nu {
  mode = "zoom_to_features";
  eventHandlers = {};
  onStartAction() {
    this.fitMapToFeatures(), setTimeout(() => {
      this.gm.options.disableMode("helper", "zoom_to_features");
    });
  }
  onEndAction() {
  }
  fitMapToFeatures() {
    const n = this.gm.features.asGeoJsonFeatureCollection({
      sourceNames: [wt.main, ...Di ? [wt.standby] : []]
    }), l = A2(n), p = [
      [l[0], l[1]],
      [l[2], l[3]]
    ];
    try {
      this.gm.mapAdapter.fitBounds(p, { padding: 20 });
    } catch {
      It.warn("Wrong bounds for zooming to features", p, n);
    }
  }
}
const Oy = {
  shape_markers: XO,
  pin: null,
  snapping: JO,
  snap_guides: null,
  measurements: null,
  auto_trace: null,
  geofencing: null,
  zoom_to_features: KO,
  click_to_edit: null
}, QO = (a, n) => Oy[n] ? new Oy[n](a) : (It.error(`Helper "${n}" is not available`), null);
class ez extends Kg {
  eventHandlers = {
    [`${Ft}:helper`]: this.handleHelperEvent.bind(this)
  };
  constructor(n, l) {
    super(n), l.attachEvents(this.eventHandlers);
  }
  handleHelperEvent(n) {
    if (!gv(n))
      return { next: !0 };
    const l = `${n.actionType}__${n.mode}`;
    return n.action === "mode_start" ? (this.trackExclusiveModes(n), this.start(l, n), this.trackRelatedModes(n)) : n.action === "mode_end" && (this.trackRelatedModes(n), this.end(l)), { next: !0 };
  }
  start(n, l) {
    const p = QO(this.gm, l.mode);
    p && (n in this.gm.actionInstances && It.error(`Action instance "${n}" already exists`), this.gm.actionInstances[n] = p, p.startAction());
  }
  end(n) {
    const l = this.gm.actionInstances[n];
    l instanceof nu ? (l.endAction(), delete this.gm.actionInstances[n]) : console.error(`Wrong action instance for edit event "${n}":`, l);
  }
}
class tz {
  gm;
  bus;
  listeners = {};
  constructor(n) {
    this.gm = n, this.bus = new vR(this.gm), this.listeners = {
      draw: new XF(this.gm, this.bus),
      edit: new WO(this.gm, this.bus),
      helper: new ez(this.gm, this.bus),
      control: new xR(this.gm, this.bus)
    };
  }
  fire(n, l) {
    this.listeners[l.actionType] || It.error(`Can't find event listener for "${l.actionType}" event type`), this.bus.fireEvent(n, l);
  }
}
const zb = 5e3;
class rz {
  gm;
  updateStorage;
  autoUpdatesEnabled = !0;
  delayedSourceUpdateMethods;
  // Track pending update promises per source to allow waiting for MapLibre to commit data
  // Using an array to track multiple concurrent promises (prevents overwriting if rapid updates occur)
  pendingUpdatePromises;
  constructor(n) {
    this.gm = n, this.updateStorage = Object.fromEntries(my(wt).map((l) => [l, []])), this.pendingUpdatePromises = {}, this.delayedSourceUpdateMethods = Object.fromEntries(
      my(wt).map((l) => [
        l,
        xw(
          () => this.updateSourceActual(l),
          this.gm.options.settings.throttlingDelay
        )
      ])
    );
  }
  updatesPending(n) {
    return !!this.updateStorage[n]?.length || !!(this.pendingUpdatePromises[n]?.length ?? 0);
  }
  getFeatureId(n) {
    const l = n.properties?.[Hs] ?? n.id;
    return l == null && console.warn("Feature id is null or undefined", n), l;
  }
  updateSource({
    sourceName: n,
    diff: l
  }) {
    l && this.updateStorage[n].push(l), this.delayedSourceUpdateMethods[n]();
  }
  updateSourceActual(n) {
    const l = this.gm.features.sources[n];
    if (this.autoUpdatesEnabled && l) {
      if (!l.loaded) {
        setTimeout(() => {
          this.updateSourceActual(n);
        }, this.gm.options.settings.throttlingDelay);
        return;
      }
      const p = this.getCombinedDiff(n);
      if (p) {
        const x = l.updateData(p);
        this.addPendingPromise(n, x);
      }
      this.updateStorage[n].length > 0 && setTimeout(
        () => this.updateSourceActual(n),
        this.gm.options.settings.throttlingDelay
      );
    }
  }
  /**
   * Add a pending promise to the tracking array for a source.
   * Automatically removes the promise from the array when it resolves.
   */
  addPendingPromise(n, l) {
    this.pendingUpdatePromises[n] || (this.pendingUpdatePromises[n] = []), this.pendingUpdatePromises[n].push(l), l.finally(() => {
      const p = this.pendingUpdatePromises[n];
      if (p) {
        const x = p.indexOf(l);
        x !== -1 && p.splice(x, 1), p.length === 0 && delete this.pendingUpdatePromises[n];
      }
    });
  }
  /**
   * Wait for any pending MapLibre source updates to complete.
   * This ensures data is committed before events are fired.
   *
   * When there are queued updates in updateStorage that haven't been processed yet
   * (due to throttling), this method flushes them immediately and waits for completion.
   *
   * Note: We call updateData() directly here rather than going through updateSourceActual()
   * because updateSourceActual() checks `!source.loaded` and may delay processing.
   * When waiting for pending updates (e.g., for event handlers), we need immediate processing.
   *
   * This is safe and won't cause duplicates because getCombinedDiff() atomically drains
   * the storage - whoever calls it first gets the diffs, subsequent calls get null.
   *
   * IMPORTANT: MapLibre's _updateWorkerData() has a guard that returns early if already
   * updating (`if (this._isUpdatingWorker) return`). This means updateData() can return
   * a promise that resolves before the data is actually committed to serialize().
   * To handle this, we loop until both storage and pending promises are empty, with
   * a microtask yield between iterations to allow MapLibre's recursive updates to run.
   */
  async waitForPendingUpdates(n) {
    const l = this.gm.features.sources[n];
    if (l) {
      for (; this.updateStorage[n]?.length || this.pendingUpdatePromises[n]?.length; ) {
        if (this.updateStorage[n]?.length) {
          const x = this.getCombinedDiff(n);
          if (x) {
            const M = l.updateData(x);
            this.addPendingPromise(n, M);
          }
        }
        const p = this.pendingUpdatePromises[n];
        p?.length && await Promise.all(p), await new Promise((x) => setTimeout(x, 0));
      }
      await new Promise((p) => requestAnimationFrame(p));
    }
  }
  withAtomicSourcesUpdate(n) {
    try {
      return this.autoUpdatesEnabled = !1, n();
    } finally {
      ei(this.gm.features.sources).forEach((l) => {
        this.updateSource({ sourceName: l });
      }), this.autoUpdatesEnabled = !0;
    }
  }
  getCombinedDiff(n) {
    let l = {
      remove: [],
      add: [],
      update: []
    };
    for (let p = 0; p < zb && this.updateStorage[n][p] !== void 0; p += 1)
      l = this.mergeGeoJsonDiff(l, this.updateStorage[n][p]);
    return this.updateStorage[n] = this.updateStorage[n].slice(zb), Object.values(l).find((p) => p.length) ? l : null;
  }
  mergeGeoJsonDiff(n, l) {
    const p = n ?? { add: [], update: [], remove: [] }, x = l ?? { add: [], update: [], remove: [] }, M = new Set(x.remove), T = p.add?.filter((z) => !M.has(this.getFeatureId(z))) || [], u = p.update?.filter((z) => !M.has(this.getFeatureId(z))) || [], R = [];
    return x.update?.forEach((z) => {
      const U = T.findIndex(
        (ee) => this.getFeatureId(ee) === this.getFeatureId(z)
      ), $ = u.findIndex(
        (ee) => this.getFeatureId(ee) === this.getFeatureId(z)
      );
      if (U === -1 && $ === -1) {
        R.push(z);
        return;
      }
      U !== -1 && (T[U] = z), $ !== -1 && (u[$] = z);
    }), {
      add: [...T, ...x.add || []],
      update: [...u, ...R],
      remove: [...p.remove || [], ...x.remove || []]
    };
  }
}
class nz {
  isInstanceAvailable() {
    return this.sourceInstance ? !0 : (It.error("Source instance is not available"), !1);
  }
}
class iz {
  gm;
  featureCounter = 0;
  featureStore = /* @__PURE__ */ new Map();
  featureStoreAllowedSources = [wt.main, wt.temporary];
  sources;
  defaultSourceName = wt.main;
  updateManager;
  layers;
  constructor(n) {
    this.gm = n, this.updateManager = new rz(n), this.sources = Object.fromEntries(
      my(wt).map((l) => [l, null])
    ), this.layers = [];
  }
  get forEach() {
    return this.filteredForEach((n) => !n.temporary);
  }
  get tmpForEach() {
    return this.filteredForEach((n) => n.temporary);
  }
  init() {
    if (Object.values(this.sources).some((n) => n !== null)) {
      It.warn("features.init(): features are already initialized");
      return;
    }
    ei(this.sources).forEach((n) => {
      this.sources[n] = this.createSource(n);
    }), this.hydrateFromExistingSources(), this.gm.options.settings.useDefaultLayers && (this.layers = this.createLayers());
  }
  /**
   * Hydrates the feature store from existing sources and syncs the ID counter.
   * This is called during init to restore state when remounting on preserved sources.
   */
  hydrateFromExistingSources() {
    let n = 0;
    ei(this.sources).forEach((l) => {
      const p = this.sources[l];
      if (p)
        try {
          const x = p.getGeoJson();
          if (x && "features" in x)
            for (const M of x.features) {
              const T = M.properties?.[Hs];
              if (!T) continue;
              if (typeof T == "string" && T.startsWith("feature-")) {
                const z = parseInt(T.replace("feature-", ""), 10);
                !isNaN(z) && z > n && (n = z);
              }
              if (this.featureStore.has(T)) continue;
              const u = M, R = new xf({
                gm: this.gm,
                id: T,
                parent: null,
                source: p,
                geoJsonShapeFeature: Js(u),
                skipSourceUpdate: !0
              });
              this.featureStore.set(T, R);
            }
        } catch {
        }
    }), n > this.featureCounter && (this.featureCounter = n);
  }
  getNewFeatureId(n) {
    if (this.featureCounter += 1, this.gm.options.settings.idGenerator)
      return this.gm.options.settings.idGenerator(n);
    let l = `feature-${this.featureCounter}`;
    for (; this.featureStore.has(l); )
      this.featureCounter += 1, l = `feature-${this.featureCounter}`;
    return l;
  }
  filteredForEach(n) {
    return (l) => {
      this.featureStore.forEach((p, x, M) => {
        n(p) && l(p, x, M);
      });
    };
  }
  has(n, l) {
    const p = this.featureStore.get(l);
    return !!p && p?.source === this.sources[n];
  }
  get(n, l) {
    const p = this.featureStore.get(l) || null;
    return p?.source === this.sources[n] ? p : null;
  }
  add(n) {
    if (this.featureStore.has(n.id)) {
      It.error(`features.add: feature with the id "${n.id}" already exists`);
      return;
    }
    this.featureStoreAllowedSources.includes(n.source.id) && this.featureStore.set(n.id, n);
  }
  setDefaultSourceName(n) {
    this.defaultSourceName = n;
  }
  createSource(n) {
    const l = this.gm.mapAdapter.addSource(n, {
      type: "FeatureCollection",
      features: []
    });
    if (l)
      return l;
    throw new Error(`Features: failed to create the source: "${n}"`);
  }
  delete(n) {
    let l;
    n instanceof xf ? l = n : l = this.featureStore.get(n) || null, l ? (this.featureStore.delete(l.id), l.delete()) : It.error(`features.delete: feature "${n}" not found`);
  }
  deleteAll() {
    this.featureStore.forEach((n) => {
      n.delete();
    }), this.featureStore.clear();
  }
  getFeatureByMouseEvent({
    event: n,
    sourceNames: l
  }) {
    if (!Yn(n, { warning: !0 }))
      return null;
    const p = [n.point.x, n.point.y], x = this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: p,
      sourceNames: l
    });
    return x.length ? x[0] : null;
  }
  getFeaturesByGeoJsonBounds({
    geoJson: n,
    sourceNames: l
  }) {
    const p = dv(n), x = this.gm.mapAdapter.coordBoundsToScreenBounds(p);
    return this.getFeaturesByScreenBounds({ bounds: x, sourceNames: l });
  }
  getFeaturesByScreenBounds({
    bounds: n,
    sourceNames: l
  }) {
    return this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: n,
      sourceNames: l
    });
  }
  createFeature({
    featureId: n,
    shapeGeoJson: l,
    parent: p,
    sourceName: x,
    imported: M
  }) {
    const T = this.sources[x];
    if (!T)
      return It.error("Features.createFeature Missing source for feature creation"), null;
    const u = n ?? l.properties[Hs] ?? this.getNewFeatureId(l);
    if (this.featureStore.get(u))
      return It.error(
        `Features.createFeature: feature with the id "${u}" already exists`,
        this.featureStore.get(u)
      ), null;
    const R = new xf({
      gm: this.gm,
      id: u,
      parent: p || null,
      source: T,
      geoJsonShapeFeature: Js(l)
    });
    return this.add(R), !R.temporary && !M && this.fireFeatureCreatedEvent(R), this.featureCounter += 1, R;
  }
  importGeoJson(n, l) {
    const p = l ?? {}, x = "features" in n ? n.features : [n], M = {
      stats: {
        total: 0,
        success: 0,
        failed: 0,
        overwritten: 0
      },
      addedFeatures: []
    };
    return x.forEach((T) => {
      let u = null;
      M.stats.total += 1;
      const R = XN(T);
      if (R) {
        if (p.idPropertyName) {
          const z = JN(R, p.idPropertyName);
          z && (R.id = z);
        }
        if (p.overwrite) {
          const z = R.id ?? R.properties?.[Hs];
          z && this.featureStore.has(z) && (this.delete(z), M.stats.overwritten += 1);
        }
        u = this.importGeoJsonFeature(R);
      }
      u ? (M.addedFeatures.push(u), M.stats.success += 1) : M.stats.failed += 1;
    }), M;
  }
  importGeoJsonFeature(n) {
    const l = this.defaultSourceName, p = this.getFeatureShapeByGeoJson(n);
    return p ? this.createFeature({
      featureId: n.id,
      shapeGeoJson: n,
      sourceName: l,
      imported: !0
    }) : (It.error("features.addGeoJsonFeature: unknown shape", p), null);
  }
  getAll() {
    return this.exportGeoJson();
  }
  /**
   * Exports GeoJSON from Geoman's internal state.
   *
   * This is the recommended method for most use cases as it always returns the latest
   * feature data, even during event handlers before MapLibre has committed changes.
   *
   * @param options - Export options
   * @param options.allowedShapes - Filter to only include specific shape types
   * @param options.idPropertyName - Property name to use for feature IDs (default: 'gm_id')
   * @returns GeoJSON FeatureCollection with all features
   *
   * @example
   * // Export all features
   * const geoJson = geoman.features.exportGeoJson();
   *
   * // Export only polygons and circles
   * const shapes = geoman.features.exportGeoJson({ allowedShapes: ['polygon', 'circle'] });
   */
  exportGeoJson({
    allowedShapes: n,
    idPropertyName: l
  } = { allowedShapes: void 0 }) {
    return this.asGeoJsonFeatureCollection({
      sourceNames: [wt.main, ...Di ? [wt.standby] : []],
      shapeTypes: n || [...ol],
      idPropertyName: l,
      useMapLibreSource: !1
    });
  }
  /**
   * Exports GeoJSON directly from MapLibre's underlying source data.
   *
   * This method reads from MapLibre's serialized source state, which may lag slightly
   * behind Geoman's internal state during rapid updates or in event handlers.
   *
   * Use this method when you specifically need to verify what MapLibre has committed
   * to its source, for debugging, or for synchronization with external systems that
   * read directly from MapLibre sources.
   *
   * For most use cases, prefer `exportGeoJson()` which uses Geoman's internal state
   * and is always up-to-date.
   *
   * @param options - Export options
   * @param options.allowedShapes - Filter to only include specific shape types
   * @param options.idPropertyName - Property name to use for feature IDs (default: 'gm_id')
   * @returns GeoJSON FeatureCollection from MapLibre's source
   *
   * @example
   * // Export features as stored in MapLibre source
   * const geoJson = geoman.features.exportGeoJsonFromSource();
   *
   * // Verify MapLibre has committed the data
   * await geoman.features.waitForPendingUpdates();
   * const committed = geoman.features.exportGeoJsonFromSource();
   */
  exportGeoJsonFromSource({
    allowedShapes: n,
    idPropertyName: l
  } = { allowedShapes: void 0 }) {
    return this.asGeoJsonFeatureCollection({
      sourceNames: [wt.main, ...Di ? [wt.standby] : []],
      shapeTypes: n || [...ol],
      idPropertyName: l,
      useMapLibreSource: !0
    });
  }
  asGeoJsonFeatureCollection({
    shapeTypes: n,
    sourceNames: l,
    idPropertyName: p,
    useMapLibreSource: x = !1
  }) {
    const M = {
      type: "FeatureCollection",
      features: []
    };
    return p ??= Hs, l.forEach((T) => {
      const u = this.sources[T];
      u && (x ? u.getGeoJson() : u.getGmGeoJson()).features.filter((R) => !!R).forEach((R) => {
        const z = this.get(T, R.id);
        if (!z)
          return;
        const U = R.properties[Hs];
        p !== Hs && (R.properties[p] = U, delete R.properties[Hs]), (n === void 0 || n.includes(z.shape)) && M.features.push({ ...R, id: U });
      });
    }), M;
  }
  convertSourceToGm(n) {
    const l = [], p = n.getGeoJson(), x = "features" in p ? p.features : [p];
    return this.gm.mapAdapter.getSource(n.id).remove(), x.forEach((M) => {
      const T = this.addGeoJsonFeature({
        shapeGeoJson: M,
        defaultSource: !0
      });
      T && l.push(T);
    }), l;
  }
  addGeoJsonFeature({
    shapeGeoJson: n,
    sourceName: l,
    defaultSource: p
  }) {
    let x;
    if (p ? (x = this.defaultSourceName, l && It.warn("features.addGeoJsonFeature: default source is set, sourceName is ignored")) : x = l || null, !x)
      return It.error("features.addGeoJsonFeature: missing sourceName"), null;
    const M = this.getFeatureShapeByGeoJson(n);
    return M ? this.createFeature({
      featureId: n.id,
      shapeGeoJson: {
        ...n,
        properties: { ...n.properties, shape: M }
      },
      sourceName: x
    }) : (It.error("features.addGeoJsonFeature: unknown shape", M), null);
  }
  createLayers() {
    const n = [];
    return ei(this.sources).forEach((l) => {
      ei(this.gm.options.layerStyles).forEach((p) => {
        this.gm.options.layerStyles[p][l].forEach((x) => {
          const M = this.createGenericLayer({
            sourceName: l,
            shapeNames: [p],
            partialStyle: x
          });
          M && n.push(M);
        });
      });
    }), n;
  }
  createGenericLayer({
    sourceName: n,
    shapeNames: l,
    partialStyle: p
  }) {
    const x = this.getGenericLayerName({ sourceName: n, shapeNames: l, partialStyle: p });
    if (!x)
      throw new Error(`Can't create a layer, for ${{ sourceName: n, shapeNames: l, partialStyle: p }}`);
    const M = {
      ...p,
      id: x,
      source: n,
      filter: ["in", ["get", `${rs}shape`], ["literal", l]]
    };
    return this.gm.mapAdapter.addLayer(M);
  }
  getGenericLayerName({
    sourceName: n,
    shapeNames: l,
    partialStyle: p
  }) {
    const x = l.length === 1 ? l[0] : "mixed", M = (u) => `${n}-${x}__${p.type}-layer-${u}`;
    let T = null;
    for (let u = 0; u < 100; u += 1) {
      const R = M(u);
      if (!this.gm.mapAdapter.getLayer(R))
        return T = R, T;
    }
    return null;
  }
  getFeatureShapeByGeoJson(n) {
    const l = {
      Point: "marker",
      LineString: "line",
      MultiLineString: "line",
      Polygon: "polygon",
      MultiPolygon: "polygon"
    }, p = n.properties;
    return p?.shape && ol.includes(p?.shape) ? p?.shape : l[n.geometry.type] || null;
  }
  createMarkerFeature({
    parentFeature: n,
    coordinate: l,
    type: p,
    sourceName: x
  }) {
    return this.createFeature({
      sourceName: x,
      parent: n,
      shapeGeoJson: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: l
        },
        properties: {
          [`${rs}shape`]: `${p}_marker`
        }
      }
    });
  }
  updateMarkerFeaturePosition(n, l) {
    n.updateGeoJsonGeometry({
      type: "Point",
      coordinates: l
    });
  }
  fireFeatureCreatedEvent(n) {
    if (Kl(n.shape, ol)) {
      const l = {
        name: `${Ft}:draw:feature_created`,
        level: "system",
        actionType: "draw",
        mode: n.shape,
        action: "feature_created",
        featureData: n
      };
      this.gm.events.fire(`${Ft}:draw`, l);
    }
  }
}
class sz {
  getEuclideanNearestLngLat(n, l) {
    const p = this.project(l);
    let x = [0, 0], M = 1 / 0;
    return q2(n, (T) => {
      const u = this.project(T.start.coordinate), R = this.project(T.end.coordinate), z = UR(
        u,
        R,
        p
      ), U = gg(p, z);
      U < M && (M = U, x = [z[0], z[1]]);
    }), this.unproject(x);
  }
  getDistance(n, l) {
    return B2(n, l, { units: "meters" });
  }
}
class az {
  isInstanceAvailable() {
    return this.layerInstance ? !0 : (It.error("layerInstance is not available"), !1);
  }
}
class $_ extends az {
  gm;
  layerInstance = null;
  mapInstance;
  constructor({
    gm: n,
    layerId: l,
    options: p
  }) {
    super(), this.gm = n, this.mapInstance = this.gm.mapAdapter.mapInstance, p ? this.layerInstance = this.createLayer(p) : this.layerInstance = this.mapInstance.getLayer(l) || null;
  }
  get id() {
    if (!this.isInstanceAvailable())
      throw new Error("Layer instance is not available");
    return this.layerInstance.id;
  }
  get source() {
    if (!this.isInstanceAvailable())
      throw new Error("Layer instance is not available");
    return this.layerInstance.source;
  }
  createLayer(n) {
    let l = this.mapInstance.getLayer(n.id);
    return l ? It.warn(`Layer "${n.id}" already exists, skipping`) : (this.mapInstance.addLayer(n), l = this.mapInstance.getLayer(n.id)), l ?? null;
  }
  remove() {
    this.isInstanceAvailable() && this.mapInstance.removeLayer(this.id), this.layerInstance = null;
  }
}
class oz extends lv {
  markerInstance;
  constructor({
    mapInstance: n,
    options: l,
    lngLat: p
  }) {
    super(), this.markerInstance = new Gg.Marker(l).setLngLat(p).addTo(n);
  }
  getElement() {
    return this.isMarkerInstanceAvailable() && this.markerInstance?.getElement() || null;
  }
  setLngLat(n) {
    this.isMarkerInstanceAvailable() && this.markerInstance?.setLngLat(n);
  }
  getLngLat() {
    return this.isMarkerInstanceAvailable() ? this.markerInstance?.getLngLat().toArray() || [0, 0] : [0, 0];
  }
  remove() {
    this.markerInstance?.remove();
  }
}
class lz {
  isInstanceAvailable() {
    return this.popupInstance ? !0 : (It.error("Popup instance is not available"), !1);
  }
}
class uz extends lz {
  popupInstance;
  constructor({
    mapInstance: n,
    options: l,
    lngLat: p
  }) {
    super(), this.popupInstance = new Gg.Popup(l).addTo(n), p && this.setLngLat(p);
  }
  getLngLat() {
    return this.isInstanceAvailable() ? this.popupInstance.getLngLat().toArray() || [0, 0] : [0, 0];
  }
  setLngLat(n) {
    this.isInstanceAvailable() && this.popupInstance.setLngLat(n);
  }
  setHtml(n) {
    this.isInstanceAvailable() && this.popupInstance.setHTML(n);
  }
  remove() {
    this.isInstanceAvailable() && this.popupInstance.remove();
  }
}
class Bb extends nz {
  gm;
  mapInstance;
  sourceInstance;
  constructor({ gm: n, geoJson: l, sourceId: p }) {
    super(), this.gm = n, this.mapInstance = this.gm.mapAdapter.mapInstance, l ? this.sourceInstance = this.createSource({ geoJson: l, sourceId: p }) : this.sourceInstance = this.mapInstance.getSource(p) || null;
  }
  get id() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.id;
  }
  get loaded() {
    return this.mapInstance.isSourceLoaded(this.id);
  }
  createSource({ geoJson: n, sourceId: l }) {
    let p = this.mapInstance.getSource(l);
    return p ? It.warn(`Source "${p.id}" already exists, skipping`) : (this.mapInstance.addSource(l, {
      type: "geojson",
      data: n,
      promoteId: Hs
    }), p = this.mapInstance.getSource(l)), p ?? null;
  }
  getGeoJson() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.serialize().data;
  }
  getGmGeoJson() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    const n = {
      type: "FeatureCollection",
      features: []
    };
    return this.gm.features.filteredForEach(
      (l) => l.source.id === this.sourceInstance?.id
    )((l) => {
      ol.includes(l.shape) && n.features.push(l.getGeoJson());
    }), n;
  }
  async setData(n) {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    await this.sourceInstance.setData(n, !0);
  }
  async updateData(n) {
    if (!this.isInstanceAvailable())
      return;
    const l = this.convertUniversalDiffToMlDiff(n);
    await this.sourceInstance.updateData(l, !0);
  }
  convertUniversalDiffToMlDiff(n) {
    return {
      add: n.add?.map(this.sanitizeFeatureForAdd.bind(this)),
      update: n.update?.map(this.convertFeatureToMlUpdateDiff.bind(this)),
      remove: n.remove
    };
  }
  /**
   * Sanitize a feature for addition to the source by removing undefined property values.
   * MapLibre's protobuf encoding does not support undefined values (per MapBox vector tile spec).
   */
  sanitizeFeatureForAdd(n) {
    if (!n.properties)
      return n;
    const l = {};
    for (const [p, x] of Object.entries(n.properties))
      x !== void 0 && (l[p] = x);
    return {
      ...n,
      properties: l
    };
  }
  convertFeatureToMlUpdateDiff(n) {
    const l = [], p = [];
    return Object.entries(n.properties || {}).forEach(([x, M]) => {
      M === void 0 ? p.push(x) : l.push({ key: x, value: M });
    }), {
      id: n.properties?.[Hs],
      newGeometry: n.geometry,
      addOrUpdateProperties: l,
      removeProperties: p
    };
  }
  remove() {
    this.isInstanceAvailable() && (this.gm.mapAdapter.eachLayer((n) => {
      n.source === this.sourceInstance.id && this.gm.mapAdapter.removeLayer(n.id);
    }), this.mapInstance.removeSource(this.sourceInstance.id));
  }
}
const cz = [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchcancel"
], Z_ = (a) => cz.includes(a);
class hz extends sz {
  gm;
  mapType = "maplibre";
  mapInstance;
  constructor(n, l) {
    super(), this.gm = l, this.mapInstance = n;
  }
  getMapInstance() {
    return this.mapInstance;
  }
  isLoaded() {
    return this.mapInstance._loaded;
  }
  getContainer() {
    return this.mapInstance.getContainer();
  }
  getCanvas() {
    return this.mapInstance.getCanvas();
  }
  addControl(n) {
    this.mapInstance.addControl(n);
  }
  removeControl(n) {
    this.mapInstance.removeControl(n);
  }
  async loadImage({ id: n, image: l }) {
    if (!this.mapInstance.hasImage(n)) {
      const p = await this.mapInstance.loadImage(l);
      this.mapInstance.addImage(n, p.data);
    }
  }
  removeImage(n) {
    try {
      this.mapInstance.hasImage(n) && this.mapInstance.removeImage(n);
    } catch {
    }
  }
  getBounds() {
    return this.mapInstance.getBounds().toArray();
  }
  fitBounds(n, l) {
    this.mapInstance.fitBounds(n, l);
  }
  setCursor(n) {
    this.mapInstance.getCanvas().style.cursor = n;
  }
  disableMapInteractions(n) {
    n.forEach((l) => {
      this.mapInstance[l].disable();
    });
  }
  enableMapInteractions(n) {
    n.forEach((l) => {
      this.mapInstance[l].enable();
    });
  }
  setDragPan(n) {
    n ? this.mapInstance.dragPan.enable() : this.mapInstance.dragPan.disable();
  }
  queryFeaturesByScreenCoordinates({
    queryCoordinates: n = void 0,
    sourceNames: l
  }) {
    return p1(
      this.mapInstance.queryRenderedFeatures(n).map((p) => ({
        featureId: p.properties[Hs],
        featureSourceName: p.source
      })),
      $h
    ).map(({ featureId: p, featureSourceName: x }) => p === void 0 || !l.includes(x) ? null : this.gm.features.get(x, p) || null).filter((p) => !!p);
  }
  queryGeoJsonFeatures({
    queryCoordinates: n = void 0,
    sourceNames: l
  }) {
    const p = (x, M) => x?.id === M?.id;
    return p1(
      this.mapInstance.queryRenderedFeatures(n).map((x) => {
        const M = this.convertToGeoJsonImportFeature(x);
        return M ? {
          id: x.properties[Hs],
          sourceName: x.source,
          geoJson: M
        } : null;
      }),
      p
    ).filter((x) => !!x && x.id !== void 0 && x.geoJson && l.includes(x.sourceName));
  }
  convertToGeoJsonImportFeature(n) {
    const l = n.properties[Hs];
    return l === void 0 || n.geometry.type === "GeometryCollection" ? null : {
      id: l,
      type: "Feature",
      properties: n.properties,
      geometry: n.geometry
    };
  }
  addSource(n, l) {
    return new Bb({ gm: this.gm, sourceId: n, geoJson: l });
  }
  getSource(n) {
    return new Bb({ gm: this.gm, sourceId: n });
  }
  addLayer(n) {
    const l = n.id;
    return new $_({ gm: this.gm, layerId: l, options: n });
  }
  getLayer(n) {
    return this.mapInstance.getLayer(n) ? new $_({ gm: this.gm, layerId: n }) : null;
  }
  removeLayer(n) {
    const l = this.getLayer(n);
    l && l.remove();
  }
  eachLayer(n) {
    this.mapInstance.getStyle().layers.forEach((l) => {
      n(new $_({ gm: this.gm, layerId: l.id }));
    });
  }
  createDomMarker(n, l) {
    return new oz({
      mapInstance: this.mapInstance,
      options: n,
      lngLat: l
    });
  }
  createPopup(n, l) {
    return new uz({
      mapInstance: this.mapInstance,
      options: n,
      lngLat: l
    });
  }
  project(n) {
    const l = this.mapInstance.project(n);
    return [l.x, l.y];
  }
  unproject(n) {
    const l = this.mapInstance.unproject(n);
    return [l.lng, l.lat];
  }
  coordBoundsToScreenBounds(n) {
    const l = new Gg.LngLatBounds(n), p = this.project(l.getSouthWest().toArray()), x = this.project(l.getNorthEast().toArray());
    return [p, x];
  }
  fire(n, l) {
    this.mapInstance.fire(n, l);
  }
  on(n, l, p) {
    if (typeof l == "string" && p && Z_(n))
      this.mapInstance.on(n, l, p);
    else if (typeof l == "function")
      this.mapInstance.on(n, l);
    else
      throw new Error("Invalid arguments passed to 'on' method");
  }
  once(n, l, p) {
    if (typeof l == "string" && p && Z_(n))
      this.mapInstance.once(n, l, p);
    else if (typeof l == "function")
      this.mapInstance.once(n, l);
    else
      throw new Error("Invalid arguments passed to 'once' method.");
  }
  off(n, l, p) {
    if (typeof l == "string" && p && Z_(n))
      this.mapInstance.off(n, l, p);
    else if (typeof l == "function")
      this.mapInstance.off(n, l);
    else
      throw new Error("Invalid arguments passed to 'off' method");
  }
}
const dz = (a, n) => new hz(n, a), fz = (a, n) => {
  if (!Array.isArray(a) || !Array.isArray(n))
    return;
  if (n.some((x) => !iF(x))) {
    It.warn("Wrong partial layer detected for layer styles");
    return;
  }
  const l = CA(a, "type"), p = pA(n, "type");
  if (Object.values(p).some((x) => x > 1))
    throw new Error(
      'Multiple layers for the same shape are detected. Use "useDefaultLayers: false" and define layers manually.'
    );
  return n.forEach((x) => {
    l[x.type] ? PA(l[x.type], x) : l[x.type] = Js(x);
  }), TA(l);
};
class pz {
  gm;
  settings;
  controls;
  layerStyles;
  constructor(n, l) {
    this.gm = n;
    const p = this.getMergedOptions(l);
    this.settings = p.settings, this.controls = p.controls, this.layerStyles = p.layerStyles;
  }
  getMergedOptions(n = {}) {
    const l = ny();
    return typeof n.settings?.controlsUiEnabledByDefault == "boolean" && (l.settings.controlsUiEnabledByDefault = n.settings.controlsUiEnabledByDefault), ZA(l), xA(l, n, fz);
  }
  enableMode(n, l) {
    const p = this.isModeEnabled(n, l), x = this.isModeAvailable(n, l);
    if (x || It.warn(`Unable to enable mode, "${n}:${l}" is not available`), p || !x)
      return;
    const M = this.controls[n][l];
    M ? (M.active = !0, this.fireModeEvent(n, l, "mode_start"), this.fireControlEvent(n, l, "on"), this.fireModeEvent(n, l, "mode_started")) : It.error("Can't find control section for", n, l);
  }
  disableMode(n, l) {
    const p = this.isModeEnabled(n, l), x = this.isModeAvailable(n, l);
    if (!p || !x)
      return;
    const M = this.controls[n][l];
    M ? (M.active = !1, this.fireModeEvent(n, l, "mode_end"), this.fireControlEvent(n, l, "off"), this.fireModeEvent(n, l, "mode_ended")) : It.error("Can't find control section for", n, l);
  }
  syncModeState(n, l) {
    const p = this.controls[n][l], x = this.isModeAvailable(n, l);
    p && (x ? p.active ? this.enableMode(n, l) : this.disableMode(n, l) : (console.log(`Not available mode: ${n}:${l}`), p.active = !1, p.uiEnabled = !1));
  }
  toggleMode(n, l) {
    this.isModeEnabled(n, l) ? this.disableMode(n, l) : this.enableMode(n, l);
  }
  isModeEnabled(n, l) {
    return !!Object.entries(this.gm.actionInstances).find(([p, x]) => p === `${n}__${l}` && x);
  }
  isModeAvailable(n, l) {
    return n === "draw" && Kl(l, S2) ? !!this.gm.drawClassMap[l] : n === "edit" && Kl(l, I2) ? !!this.gm.editClassMap[l] : n === "helper" && Kl(l, k2) ? !!this.gm.helperClassMap[l] : !1;
  }
  getControlOptions({
    modeType: n,
    modeName: l
  }) {
    return n && l && this.controls[n][l] || null;
  }
  fireModeEvent(n, l, p) {
    const x = {
      name: `${Ft}:${l}:mode`,
      level: "system",
      actionType: n,
      mode: l,
      action: p
    };
    Ev(x) && (_v(x) ? this.gm.events.fire(`${Ft}:${n}`, x) : Xh(x) ? this.gm.events.fire(`${Ft}:${n}`, x) : gv(x) ? this.gm.events.fire(`${Ft}:${n}`, x) : It.warn("Unknown mode event: ", x));
  }
  fireControlEvent(n, l, p) {
    const x = {
      name: `${Ft}:control:switch`,
      level: "system",
      actionType: "control",
      section: n,
      mode: l,
      action: p
    };
    this.gm.events.fire(`${Ft}:control`, x);
  }
}
class gz {
  gm;
  marker = null;
  tmpMarker = null;
  snapping = !1;
  oldSnapping = void 0;
  constructor(n) {
    this.gm = n, this.initEventHandlers();
  }
  get snappingHelper() {
    return this.gm.actionInstances.helper__snapping || null;
  }
  initEventHandlers() {
    this.throttledMethods = bc(
      {
        onMouseMove: this.onMouseMove
      },
      this,
      this.gm.options.settings.throttlingDelay
    ), this.eventHandlers = {
      mousemove: this.throttledMethods.onMouseMove.bind(this)
    };
  }
  setSnapping(n) {
    if (n && !this.snappingHelper) {
      It.error("MarkerPointer: snapping is not available");
      return;
    }
    this.snapping = n;
  }
  pauseSnapping() {
    this.oldSnapping !== void 0 && It.error("MarkerPointer: snapping is already paused"), this.oldSnapping = this.snapping, this.setSnapping(!1);
  }
  resumeSnapping() {
    this.oldSnapping === void 0 ? (It.error("MarkerPointer: resumeSnapping is called before pauseSnapping"), this.setSnapping(!0)) : (this.setSnapping(this.oldSnapping), this.oldSnapping = void 0);
  }
  enable({ lngLat: n, customMarker: l, invisibleMarker: p } = {
    lngLat: [0, 0],
    customMarker: void 0,
    invisibleMarker: !1
  }) {
    if (!QR()) {
      if (l && p)
        throw new Error("MarkerPointer: customMarker and invisibleMarker can't be used together");
      if (this.marker)
        throw new Error("MarkerPointer: marker is already enabled");
      this.gm.events.bus.attachEvents(this.eventHandlers), p ? this.marker = this.createInvisibleMarker(n || [0, 0]) : this.marker = l || this.createMarker(n || [0, 0]), this.gm.getActiveDrawModes().length && this.gm.mapAdapter.setCursor("crosshair");
    }
  }
  disable() {
    this.marker && (this.gm.events.bus.detachEvents(this.eventHandlers), this.marker.remove(), this.marker = null), this.gm.mapAdapter.setCursor("");
  }
  createMarker(n = [0, 0]) {
    return this.gm.mapAdapter.createDomMarker(
      {
        anchor: "center",
        element: this.gm.createSvgMarkerElement("control", { pointerEvents: "none" })
      },
      n
    );
  }
  createInvisibleMarker(n = [0, 0]) {
    const l = document.createElement("div");
    return l.style.width = "0px", l.style.height = "0px", this.gm.mapAdapter.createDomMarker(
      {
        anchor: "center",
        element: l
      },
      n
    );
  }
  onMouseMove(n) {
    if (Yn(n, { warning: !0 }) && this.marker)
      if (this.snapping && this.snappingHelper) {
        const l = [n.point.x, n.point.y], p = this.snappingHelper.getSnappedLngLat(n.lngLat.toArray(), l);
        this.marker.setLngLat(p);
      } else
        this.marker.setLngLat(n.lngLat.toArray());
    return { next: !0 };
  }
  syncTmpMarker(n) {
    this.tmpMarker || (this.tmpMarker = this.createMarker(n)), this.tmpMarker.setLngLat(n);
  }
}
const mz = ["mode_start", "mode_started", "mode_end", "mode_ended"], Ev = (a) => hl(a) && Kl(a.action, mz);
class _z {
  mapAdapterInstance = null;
  globalLngLatBounds = this.getGlobalLngLatBounds();
  features;
  loaded = !1;
  destroyed = !1;
  options;
  events;
  control;
  actionInstances = {};
  markerPointer;
  constructor(n, l = {}) {
    this.options = this.initCoreOptions(l), this.events = this.initCoreEvents(), this.features = this.initCoreFeatures(), this.control = this.initCoreControls(), this.markerPointer = this.initMarkerPointer();
    const p = Object.assign(n, { gm: this });
    this.mapAdapterInstance = dz(this, p), this.waitForBaseMap().then(this.init.bind(this)).catch((x) => {
      It.error("Geoman initialization failed:", x), this.destroy();
    });
  }
  get drawClassMap() {
    return by;
  }
  get editClassMap() {
    return Ny;
  }
  get helperClassMap() {
    return Oy;
  }
  get mapAdapter() {
    if (this.mapAdapterInstance)
      return this.mapAdapterInstance;
    throw It.trace("Map adapter is not initialized"), new Error("Map adapter is not initialized");
  }
  initCoreOptions(n = {}) {
    return new pz(this, n);
  }
  initCoreEvents() {
    return new tz(this);
  }
  initCoreFeatures() {
    return new iz(this);
  }
  initCoreControls() {
    return new mR(this);
  }
  initMarkerPointer() {
    return new gz(this);
  }
  addControls(n = void 0) {
    return new Promise((l) => {
      (async () => {
        n ? this.control.createControls(n) : this.mapAdapter.addControl(this.control), await this.onMapLoad(), l();
      })().then();
    });
  }
  async waitForBaseMap() {
    const n = this.mapAdapter.mapInstance;
    if (!rF(n)) {
      It.error('Map instance does not have a "once" method', n);
      return;
    }
    return this.mapAdapter.isLoaded() || await $1(
      new Promise((l) => {
        const p = () => l(n);
        n.once("load", p), this.mapAdapter.isLoaded() && (n.off("load", p), l(n));
      }),
      "waitForBaseMap failed"
    ), n;
  }
  async waitForGeomanLoaded() {
    if (this.loaded)
      return this;
    if (this.destroyed)
      return;
    const n = await this.waitForBaseMap();
    if (!n) {
      It.error("Map instance is not available", n);
      return;
    }
    const l = `${Fi}:loaded`;
    return await $1(
      new Promise((p) => {
        const x = () => p(this);
        n.once(l, x), this.loaded && (n.off(l, x), p(this));
      }),
      "waitForGeomanLoaded failed"
    ), this;
  }
  async init() {
    this.destroyed || (this.features.init(), !this.destroyed && await this.addControls());
  }
  /**
   * Destroys the Geoman instance and cleans up resources.
   *
   * This method can be called at any point in the lifecycle:
   * - Before initialization completes: cancels pending init and cleans up synchronously
   * - After initialization completes: performs full cleanup including controls
   *
   * For React StrictMode compatibility, this method performs synchronous cleanup
   * of the `gm` reference on the map instance, allowing immediate re-initialization.
   */
  async destroy({ removeSources: n } = { removeSources: !1 }) {
    if (this.destroyed = !0, this.mapAdapterInstance && "gm" in this.mapAdapterInstance.mapInstance && delete this.mapAdapterInstance.mapInstance.gm, this.loaded ? (this.removeControls(), this.mapAdapter.removeImage("default-marker")) : this.events.bus.detachAllEvents(), n)
      for (const l of Object.values(this.features.sources))
        l && l.remove();
  }
  removeControls() {
    this.disableAllModes(), this.mapAdapter.removeControl(this.control);
  }
  async onMapLoad() {
    if (this.loaded || this.destroyed || (await this.mapAdapter.loadImage({
      id: "default-marker",
      image: JS
    }), this.destroyed))
      return;
    const n = {
      name: `${Ft}:control:load`,
      level: "system",
      actionType: "control",
      action: "loaded"
    };
    this.events.fire(`${Ft}:control`, n), this.loaded = !0;
  }
  disableAllModes() {
    ei(this.actionInstances).forEach((n) => {
      const [l, p] = n.split("__");
      $F(l) && WF(p) && this.options.disableMode(l, p);
    });
  }
  getActiveDrawModes() {
    return ei(this.actionInstances).map((n) => {
      const l = this.actionInstances[n];
      return l instanceof _l ? l.mode : null;
    }).filter((n) => n !== null);
  }
  getActiveEditModes() {
    return ei(this.actionInstances).map((n) => {
      const l = this.actionInstances[n];
      return l instanceof qf ? l.mode : null;
    }).filter((n) => n !== null);
  }
  getActiveHelperModes() {
    return ei(this.actionInstances).map((n) => {
      const l = this.actionInstances[n];
      return l instanceof nu ? l.mode : null;
    }).filter((n) => n !== null);
  }
  getGlobalLngLatBounds() {
    const n = 85.051129;
    return [
      [-179.99999, -n],
      [179.99999, n]
    ];
  }
  setGlobalEventsListener(n = null) {
    this.events.bus.forwarder.globalEventsListener = n;
  }
  createSvgMarkerElement(n, l = void 0) {
    const p = this.options.settings.markerIcons;
    p[n] || It.error(`createMarkerElement: marker type "${n}" not found`);
    const x = document.createElement("div");
    x.classList.add("marker-wrapper"), x.style.lineHeight = "0", x.innerHTML = p[n] || "NO_ICON";
    const M = x.firstChild;
    if (typeof M != "object")
      throw It.error(`createMarkerElement: no icon "${n}" found`), new Error(`No icon "${n}" found`);
    return l && Object.assign(M.style, l), x;
  }
  enableMode(n, l) {
    this.options.enableMode(n, l);
  }
  disableMode(n, l) {
    this.options.disableMode(n, l);
  }
  toggleMode(n, l) {
    this.options.toggleMode(n, l);
  }
  isModeEnabled(n, l) {
    return this.options.isModeEnabled(n, l);
  }
  // helper methods for compatibility with the old API
  // draw (draw:*)
  enableDraw(n) {
    this.options.enableMode("draw", n);
  }
  disableDraw() {
    this.getActiveDrawModes().forEach((n) => this.options.disableMode("draw", n));
  }
  toggleDraw(n) {
    this.options.toggleMode("draw", n);
  }
  drawEnabled(n) {
    return this.options.isModeEnabled("draw", n);
  }
  // drag(edit:drag)
  enableGlobalDragMode() {
    this.options.enableMode("edit", "drag");
  }
  disableGlobalDragMode() {
    this.options.disableMode("edit", "drag");
  }
  toggleGlobalDragMode() {
    this.options.toggleMode("edit", "drag");
  }
  globalDragModeEnabled() {
    return this.options.isModeEnabled("edit", "drag");
  }
  // edit (edit:change)
  enableGlobalEditMode() {
    this.options.enableMode("edit", "change");
  }
  disableGlobalEditMode() {
    this.options.disableMode("edit", "change");
  }
  toggleGlobalEditMode() {
    this.options.toggleMode("edit", "change");
  }
  globalEditModeEnabled() {
    return this.options.isModeEnabled("edit", "change");
  }
  // rotate (edit:rotate)
  enableGlobalRotateMode() {
    this.options.enableMode("edit", "rotate");
  }
  disableGlobalRotateMode() {
    this.options.disableMode("edit", "rotate");
  }
  toggleGlobalRotateMode() {
    this.options.toggleMode("edit", "rotate");
  }
  globalRotateModeEnabled() {
    return this.options.isModeEnabled("edit", "rotate");
  }
  // cut (edit:cut)
  enableGlobalCutMode() {
    this.options.enableMode("edit", "cut");
  }
  disableGlobalCutMode() {
    this.options.disableMode("edit", "cut");
  }
  toggleGlobalCutMode() {
    this.options.toggleMode("edit", "cut");
  }
  globalCutModeEnabled() {
    return this.options.isModeEnabled("edit", "cut");
  }
  // remove (edit:delete)
  enableGlobalRemovalMode() {
    this.options.enableMode("edit", "delete");
  }
  disableGlobalRemovalMode() {
    this.options.disableMode("edit", "delete");
  }
  toggleGlobalRemovalMode() {
    this.options.toggleMode("edit", "delete");
  }
  globalRemovalModeEnabled() {
    return this.options.isModeEnabled("edit", "delete");
  }
}
class yz extends HTMLElement {
  static observedAttributes = ["title", "zoom", "lat", "lng", "enableToggle"];
  el = null;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  map = null;
  // ml.Map or MapInstanceWithGeoman??
  geoman = null;
  mapLibreStyle = {
    version: 8,
    glyphs: "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
    sources: {
      "osm-tiles": {
        type: "raster",
        tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
        tileSize: 256,
        attribution: " OpenStreetMap contributors"
      }
    },
    layers: [
      {
        id: "osm-tiles-layer",
        type: "raster",
        source: "osm-tiles",
        minzoom: 0,
        maxzoom: 19
      }
    ]
  };
  connectedCallback() {
    this.#e(), this.#i(), this.#t();
  }
  #e() {
    this.innerHTML = `
      <style>
        .simple-map__top:has(#show-map:not(:checked)) ~ .simple-map__simple-map { display: none; }
        .simple-map__top:has(#show-map:checked) ~ .simple-map__simple-map { display: block; }
        .simple-map .simple-map__simple-map { width: 100%; }
        .simple-map .simple-map__map, .simple-map #map { border: 1px solid #000; width: 100%; height: 400px; }
      </style>
      <div class="simple-map">
        <div class="simple-map__top">
          <h2 class="govuk-heading-m">${this.getAttribute("title")}</h2>
          ${this.#r()}
        </div>
        <div class="simple-map__simple-map">
          <div id="map" class="simple-map__map"></div>
        </div>
      </div>
    `, this.el = this.querySelector(".simple-map");
  }
  #r() {
    return this.getAttribute("enableToggle") !== "true" ? "" : `
      <div class="simple-map__actions">
        <p class="govuk-body">
          <a href="${this.getAttribute("basePath")}/map" class="govuk-link govuk-link--no-visited-state" rel="noreferrer noopener" target="_blank">Open <span class="govuk-visually-hidden">map</span> in new window</a>
        </p>
        <fieldset class="govuk-fieldset">
          <legend class="govuk-fieldset__legend govuk-fieldset__legend--m govuk-visually-hidden">
            Show and hide map preview
          </legend>
          <div class="govuk-checkboxes govuk-checkboxes--small" data-module="govuk-checkboxes">
            <div class="govuk-checkboxes__item">
              <input class="govuk-checkboxes__input" id="show-map" name="show-map" type="checkbox" value="show-map" checked="checked">
              <label class="govuk-label govuk-checkboxes__label" for="show-map">
                Show map
              </label>
            </div>
          </div>
        </fieldset>
      </div>
    `;
  }
  #i() {
    if (!this.el) return;
    const n = this.el.querySelector("#map");
    this.map = new Gg.Map({
      container: n,
      // style: "http://localhost:8081/api/map-style-os",
      style: this.mapLibreStyle,
      center: [
        Number(this.getAttribute("lng")),
        Number(this.getAttribute("lat"))
      ],
      zoom: Number(this.getAttribute("zoom"))
    });
  }
  #t() {
    if (!this.map) return;
    const n = {
      settings: {
        controlsUiEnabledByDefault: !1
      }
    };
    this.geoman = new _z(this.map, n), this.map.on("gm:loaded", () => {
      console.log("Geoman fully loaded");
      const l = {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [
            Number(this.getAttribute("lng")),
            Number(this.getAttribute("lat"))
          ]
        },
        properties: {}
      };
      this.geoman?.features.importGeoJsonFeature(l);
    });
  }
  attributeChangedCallback(n, l, p) {
    console.log(
      `Attribute ${n} has changed from ${l} to ${p}.`
    );
  }
}
customElements.define("simple-map", yz);
class bf extends HTMLElement {
  // props
  static POLL_INTERVAL = 2e3;
  // ms
  static observedAttributes = ["job-id", "job-title", "api-path"];
  static jobStatusList = [
    "awaiting_start",
    "in_progress",
    "completed",
    "failed"
  ];
  #e = null;
  #r = null;
  #i = null;
  // elements
  #t = null;
  #n = null;
  // state
  #a = !1;
  #s = "unknown";
  #o = null;
  constructor() {
    super();
  }
  /**
   * Handle component being added to the DOM.
   */
  connectedCallback() {
    this.#l(), this.#c(), this.#e && this.#r && this.#i && (this.polling = !0);
  }
  /**
   * Handle component being removed from the DOM.
   */
  disconnectedCallback() {
    this.#h();
  }
  /**
   * Handle attribute changes.
   * @param name The name of the attribute that changed.
   * @param _oldValue The old value of the attribute.
   * @param newValue The new value of the attribute.
   */
  attributeChangedCallback(n, l, p) {
    n === "job-id" && (this.#e = p), n === "job-title" && (this.#r = p), n === "api-path" && (this.#i = p), this.#e && this.#r && this.#i && (this.#f(), this.#l(), this.#c(), this.polling = !0);
  }
  /**
   * Initialise the status checker component so that it
   * has the structure and elements it needs for the rest
   * of the component to function
   * @returns void
   */
  #l() {
    if (this.classList.add("status-checker"), this.#e && this.#r && this.#i) {
      this.#t = this.#y();
      const n = this.#t.textContent?.trim() ?? "unknown";
      this.#s = bf.jobStatusList.includes(
        n
      ) ? n : "unknown", this.querySelector(".status-checker__alert") ? this.#n = this.querySelector(
        ".status-checker__alert"
      ) : (this.#n = this.#g(), this.appendChild(this.#n)), this.#u();
    }
  }
  /**
   * Apply Govuk Tag styles to the status element based on current status.
   * @returns void
   */
  #u() {
    if (this.#t && this.#t.classList.contains("govuk-tag") !== !1)
      switch (this.#t.classList.remove(
        "govuk-tag--green",
        "govuk-tag--red",
        "govuk-tag--grey"
      ), this.#s) {
        case "completed":
          this.#t.classList.add("govuk-tag--green");
          break;
        case "failed":
          this.#t.classList.add("govuk-tag--red");
          break;
        default:
          this.#t.classList.add("govuk-tag--grey");
      }
  }
  /**
   * Reset the status checker to its initial state.
   * @returns void
   */
  #h() {
    this.classList.remove("status-checker"), this.#n && this.contains(this.#n) && this.removeChild(this.#n), this.#t = null, this.#n = null, this.#s = "unknown", this.#f();
  }
  /**
   * Update the status element and alert region with the current status.
   * @returns void
   */
  #c() {
    this.#s !== "unknown" && (this.#t && (this.#t.textContent = this.#s.trim(), this.#u()), this.#n && (this.#n.textContent = `${this.#r ?? "Job"} is ${this.#s.trim()}`));
  }
  /**
   * Get or set the polling state.
   */
  get polling() {
    return this.#a;
  }
  /**
   * Set the polling state.
   * @param value The new polling state.
   */
  set polling(n) {
    this.#a !== n && (this.#a = n, n ? this.#d() : this.#f());
  }
  /**
   * Start polling the backend for job status.
   * @returns void
   */
  async #d() {
    this.classList.add("status-checker--active"), this.#n && (this.#n.setAttribute("aria-busy", "true"), this.#n.textContent = "Checking status");
    const { status: n } = await this.#p();
    this.#n && this.#n.setAttribute("aria-busy", "false"), this.#s = n, this.#c(), n !== "completed" && n !== "failed" && n !== "unknown" ? this.#o = window.setTimeout(
      () => this.#d(),
      bf.POLL_INTERVAL
    ) : this.#o = null;
  }
  /**
   * Stop polling the backend for job status.
   * @returns void
   */
  #f() {
    this.classList.remove("status-checker--active"), this.#o !== null && (clearTimeout(this.#o), this.#o = null);
  }
  /**
   * Fetch the job status from the backend API.
   * @returns JobStatusResponse The job status response.
   */
  async #p() {
    const n = {
      id: this.#e ?? "",
      jobType: "",
      status: "unknown"
    }, l = `${this.#i?.replace(/\/$/, "")}/${this.#e}`;
    if (!l) return n;
    try {
      const p = await fetch(l);
      if (!p.ok) throw new Error("Network error");
      const x = await p.json(), M = bf.jobStatusList.includes(
        x.status
      ) ? x.status : "unknown";
      return await new Promise((T) => setTimeout(T, 5e3)), {
        id: x.id,
        jobType: x.job_type,
        status: M
      };
    } catch (p) {
      return console.error("Error fetching status:", p), n;
    }
  }
  /**
   * Create the alert region for screen readers.
   * @returns HTMLSpanElement The created alert region element.
   */
  #g() {
    const n = document.createElement("span");
    return n.className = "status-checker__alert", n.setAttribute("aria-live", "polite"), n.setAttribute("aria-busy", "false"), n.setAttribute("role", "alert"), n.textContent = `${this.#r ?? "Job"} is ${this.#s?.trim() ?? "unknown"}`, n;
  }
  /**
   * Returns the element that contains the status text, if its not wrapped already then it will wrap it in a span.
   * Also removes any existing text nodes and returns the status tag element.
   * @returns HTMLSpanElement The status tag element.
   */
  #y() {
    let n = this.querySelector(
      ":scope > *:not(.status-checker__alert)"
    );
    if (!n) {
      const l = this.textContent?.trim() ?? "";
      for (; this.firstChild; )
        this.removeChild(this.firstChild);
      n = document.createElement("span"), n.textContent = l, this.appendChild(n);
    }
    return n;
  }
}
customElements.define("status-checker", bf);
export {
  ZS as LoadingSpinner,
  $S as MyBox,
  yz as SimpleMap,
  bf as StatusChecker
};
